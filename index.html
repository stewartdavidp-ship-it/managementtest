<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Command Center</title>
    <meta name="version" content="8.69.6">
    <meta name="gs-app-id" content="command-center">
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-functions-compat.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/js-yaml/4.1.0/js-yaml.min.js"></script>
    <style>
        * { box-sizing: border-box; }
        body { margin: 0; font-family: system-ui, -apple-system, sans-serif; background: #0f172a; color: #e2e8f0; }
        .animate-spin { animation: spin 1s linear infinite; }
        @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
        .fade-in { animation: fadeIn 0.2s ease-out; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(-10px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes slideIn { from { transform: translateX(100%); } to { transform: translateX(0); } }
    </style>
</head>
<body>
    <div id="root"><div style="display:flex;align-items:center;justify-content:center;min-height:100vh;"><div style="text-align:center;"><div style="margin-bottom:20px;"><svg viewBox="0 0 100 100" width="64" height="64" xmlns="http://www.w3.org/2000/svg"><defs><linearGradient id="gsLoadGrad" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" style="stop-color:#667eea"/><stop offset="100%" style="stop-color:#764ba2"/></linearGradient></defs><rect x="5" y="5" width="90" height="90" rx="20" fill="url(#gsLoadGrad)"/><g transform="rotate(-12, 35, 50)"><rect x="15" y="28" width="28" height="36" rx="4" fill="white"/><circle cx="43" cy="46" r="6" fill="white"/><text x="29" y="54" font-family="Arial" font-size="20" font-weight="bold" fill="#667eea" text-anchor="middle">G</text></g><g transform="rotate(12, 65, 50)"><rect x="57" y="28" width="28" height="36" rx="4" fill="rgba(255,255,255,0.9)"/><circle cx="57" cy="46" r="6" fill="url(#gsLoadGrad)"/><text x="71" y="54" font-family="Arial" font-size="20" font-weight="bold" fill="#764ba2" text-anchor="middle">S</text></g></svg></div>Loading...</div></div></div>

    <script type="text/babel">
    console.log(`Command Center v${document.querySelector('meta[name="version"]')?.content || '?'} starting...`);

    // Test mode: swap real services with mocks when running under Playwright
    const IS_TEST_MODE = window.__CC_TEST_MODE === true;
    if (IS_TEST_MODE) console.log('[CC] Running in TEST MODE — using mock services');

    // =========================================================================
    // SATELLITE SECRETS BOOTSTRAP (v8.49.0)
    // Populate gs_* keys from existing cc_* keys for satellite app access.
    // Dual-write: all future writes go to both cc_* and gs_* keys.
    // =========================================================================
    
    (function bootstrapSatelliteKeys() {
        const migrations = [
            ['cc_token',         'gs_github_token'],
            ['cc_firebase_sa',   'gs_firebase_sa'],
            ['cc_firebase_uid',  'gs_firebase_uid'],
            ['cc_api_key',       'gs_api_key'],
            ['cc_token_expires', 'gs_token_expires'],
            ['commandCenterConfig', 'gs_config']
        ];
        let count = 0;
        for (const [oldKey, newKey] of migrations) {
            try {
                const val = localStorage.getItem(oldKey);
                if (val && !localStorage.getItem(newKey)) {
                    localStorage.setItem(newKey, val);
                    count++;
                }
            } catch {}
        }
        if (count > 0) console.log(`[Satellite Bootstrap] Migrated ${count} keys to gs_* namespace`);
    })();
    
    // =========================================================================
    // FIREBASE CONFIG
    // =========================================================================
    
    const FIREBASE_CONFIG = {
        apiKey: "AIzaSyBQVwn8vOrFTzLlm2MYIPBwgZV2xR9AuhM",
        authDomain: "word-boxing.firebaseapp.com",
        databaseURL: "https://word-boxing-default-rtdb.firebaseio.com",
        projectId: "word-boxing"
    };
    
    // Custom domain mapping for repos
    // Maps repo full names to their custom domains
    const CUSTOM_DOMAINS = {
        'stewartdavidp-ship-it/gameshelf': 'gameshelf.co',
        'stewartdavidp-ship-it/quote-info': 'quotle.info'
    };
    
    // Initialize Firebase (or use mocks in test mode)
    let firebaseApp = null;
    let firebaseAuth = null;
    let firebaseDb = null;

    if (IS_TEST_MODE && window.MockFirebaseDb) {
        firebaseDb = window.MockFirebaseDb;
        firebaseAuth = window.MockFirebaseAuth;
        console.log('[CC] Using mock Firebase services');
    } else {
        try {
            if (!firebase.apps.length) {
                firebaseApp = firebase.initializeApp(FIREBASE_CONFIG);
            } else {
                firebaseApp = firebase.apps[0];
            }
            firebaseAuth = firebase.auth();
            firebaseDb = firebase.database();
            console.log('Firebase initialized successfully');
        } catch (e) {
            console.error('Firebase init error:', e);
        }
    }
    
    // =========================================================================
    // FIREBASE ADMIN (v8.9.0 — Service Account Token Management)
    // =========================================================================
    
    class FirebaseAdmin {
        constructor() {
            this.serviceAccount = null;
            this.cachedToken = null;
            this.tokenExpiry = null;
            this.loadServiceAccount();
        }
        
        // Load service account JSON from localStorage
        loadServiceAccount() {
            try {
                const stored = localStorage.getItem('cc_firebase_sa');
                if (stored) {
                    this.serviceAccount = JSON.parse(stored);
                    console.log('Firebase SA loaded:', this.serviceAccount.client_email);
                }
            } catch (e) {
                console.error('Failed to load service account:', e);
                this.serviceAccount = null;
            }
        }
        
        // Save service account JSON to localStorage
        saveServiceAccount(saJson) {
            try {
                const sa = typeof saJson === 'string' ? JSON.parse(saJson) : saJson;
                // Validate required fields
                const required = ['type', 'project_id', 'private_key', 'client_email'];
                const missing = required.filter(f => !sa[f]);
                if (missing.length > 0) {
                    throw new Error(`Missing required fields: ${missing.join(', ')}`);
                }
                if (sa.type !== 'service_account') {
                    throw new Error(`Invalid type "${sa.type}" — expected "service_account"`);
                }
                // Validate private key format
                if (!sa.private_key.includes('BEGIN') || !sa.private_key.includes('PRIVATE KEY')) {
                    throw new Error('Invalid private key format');
                }
                this.serviceAccount = sa;
                localStorage.setItem('cc_firebase_sa', JSON.stringify(sa));
                localStorage.setItem('gs_firebase_sa', JSON.stringify(sa));
                this.cachedToken = null;
                this.tokenExpiry = null;
                console.log('Firebase SA saved:', sa.client_email);
                return { success: true, email: sa.client_email, project: sa.project_id };
            } catch (e) {
                console.error('Failed to save service account:', e);
                return { success: false, error: e.message };
            }
        }
        
        // Remove service account from localStorage
        clearServiceAccount() {
            this.serviceAccount = null;
            this.cachedToken = null;
            this.tokenExpiry = null;
            localStorage.removeItem('cc_firebase_sa');
            localStorage.removeItem('gs_firebase_sa');
            console.log('Firebase SA cleared');
        }
        
        // Check if configured
        isConfigured() {
            return this.serviceAccount !== null && !!this.serviceAccount.private_key;
        }
        
        // Get summary info (safe to display)
        getInfo() {
            if (!this.serviceAccount) return null;
            return {
                email: this.serviceAccount.client_email,
                projectId: this.serviceAccount.project_id,
                keyId: this.serviceAccount.private_key_id?.slice(0, 8) + '...',
                tokenCached: !!this.cachedToken,
                tokenExpiry: this.tokenExpiry ? new Date(this.tokenExpiry).toLocaleTimeString() : null,
                tokenValid: this.cachedToken && this.tokenExpiry && Date.now() < this.tokenExpiry
            };
        }
        
        // Parse PEM private key to CryptoKey for RS256 signing
        async importPrivateKey(pemKey) {
            // Strip PEM header/footer and whitespace
            const pemContents = pemKey
                .replace(/-----BEGIN (RSA )?PRIVATE KEY-----/, '')
                .replace(/-----END (RSA )?PRIVATE KEY-----/, '')
                .replace(/\s/g, '');
            
            // Decode base64 to ArrayBuffer
            const binaryStr = atob(pemContents);
            const bytes = new Uint8Array(binaryStr.length);
            for (let i = 0; i < binaryStr.length; i++) {
                bytes[i] = binaryStr.charCodeAt(i);
            }
            
            // Import as PKCS8 key
            return await crypto.subtle.importKey(
                'pkcs8',
                bytes.buffer,
                { name: 'RSASSA-PKCS1-v1_5', hash: 'SHA-256' },
                false,
                ['sign']
            );
        }
        
        // Base64url encode (no padding, URL-safe)
        base64url(data) {
            if (typeof data === 'string') {
                data = new TextEncoder().encode(data);
            }
            const bytes = new Uint8Array(data);
            let binary = '';
            for (let i = 0; i < bytes.length; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            const base64 = btoa(binary);
            return base64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
        }
        
        // Create and sign a JWT for Google OAuth2
        async createSignedJWT(scopes) {
            const sa = this.serviceAccount;
            if (!sa) throw new Error('No service account configured');
            
            const now = Math.floor(Date.now() / 1000);
            
            const header = { alg: 'RS256', typ: 'JWT' };
            if (sa.private_key_id) header.kid = sa.private_key_id;
            
            const payload = {
                iss: sa.client_email,
                scope: Array.isArray(scopes) ? scopes.join(' ') : scopes,
                aud: 'https://oauth2.googleapis.com/token',
                iat: now,
                exp: now + 3600 // 1 hour
            };
            
            const headerB64 = this.base64url(JSON.stringify(header));
            const payloadB64 = this.base64url(JSON.stringify(payload));
            const signingInput = `${headerB64}.${payloadB64}`;
            
            // Import key and sign
            const cryptoKey = await this.importPrivateKey(sa.private_key);
            const signature = await crypto.subtle.sign(
                'RSASSA-PKCS1-v1_5',
                cryptoKey,
                new TextEncoder().encode(signingInput)
            );
            
            const signatureB64 = this.base64url(signature);
            return `${signingInput}.${signatureB64}`;
        }
        
        // Exchange signed JWT for a Google OAuth2 access token
        async getAccessToken(scopes = [
            'https://www.googleapis.com/auth/userinfo.email',
            'https://www.googleapis.com/auth/firebase.database',
            'https://www.googleapis.com/auth/cloud-platform'
        ]) {
            // Return cached token if still valid (with 5 min buffer)
            if (this.cachedToken && this.tokenExpiry && Date.now() < (this.tokenExpiry - 300000)) {
                return this.cachedToken;
            }
            
            const jwt = await this.createSignedJWT(scopes);
            
            const response = await fetch('https://oauth2.googleapis.com/token', {
                method: 'POST',
                headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                body: new URLSearchParams({
                    grant_type: 'urn:ietf:params:oauth:grant-type:jwt-bearer',
                    assertion: jwt
                })
            });
            
            if (!response.ok) {
                const err = await response.json().catch(() => ({}));
                throw new Error(`Token exchange failed: ${err.error_description || err.error || response.status}`);
            }
            
            const data = await response.json();
            this.cachedToken = data.access_token;
            this.tokenExpiry = Date.now() + ((data.expires_in || 3600) * 1000);
            console.log('Firebase admin token obtained, expires:', new Date(this.tokenExpiry).toLocaleTimeString());
            return this.cachedToken;
        }
        
        // Invalidate cached token
        clearToken() {
            this.cachedToken = null;
            this.tokenExpiry = null;
        }
        
        // ---- RTDB Rules API ----
        
        // Get current RTDB security rules
        // Quick test — tries to read RTDB rules to verify admin access
        async testConnection() {
            const results = { token: false, errors: [] };
            
            try {
                await this.getAccessToken();
                results.token = true;
            } catch (e) {
                results.errors.push(`Token: ${e.message}`);
            }
            
            return results;
        }
    }
    
    // Global instance
    const firebaseAdmin = new FirebaseAdmin();
    
    // =========================================================================
    // FIREBASE CONFIG SYNC (v8.17.0 — Server-Side Config Storage)
    // =========================================================================
    // Syncs CC configuration data to Firebase RTDB as source of truth.
    // localStorage remains the instant-load cache; Firebase is the primary store.
    // Sensitive data (tokens, SA keys, API keys) stays in localStorage only.
    //
    // Firebase path: command-center/{dataKey}
    // Data sets synced: config, deploy-history, rules-history, session-log,
    //                   deletion-history, rollback-snapshots
    // =========================================================================
    
    const FirebaseConfigSync = {
        BASE_PATH: 'command-center',
        db: null,
        initialized: false,
        syncStatus: 'offline', // 'offline' | 'syncing' | 'synced' | 'error'
        statusListeners: new Set(),
        _recoveryTimer: null, // v8.61.1: Self-healing timer for error recovery
        
        // Data key → localStorage key mapping
        DATA_KEYS: {
            'config': 'commandCenterConfig',
            'deploy-history': 'cc_history_v2',
            'rules-history': 'cc_rulesHistory',
            'session-log': 'cc_session_log',
            'deletion-history': 'cc_deletion_history',
            'rollback-snapshots': 'cc_rollback_snapshots'
        },
        
        // Initialize with Firebase database reference
        init(database) {
            if (!database) {
                console.warn('[ConfigSync] No database provided, running in offline mode');
                return;
            }
            this.db = database;
            this.initialized = true;
            console.log('[ConfigSync] Initialized with Firebase RTDB');
        },
        
        // --- Status management ---
        
        _setStatus(status) {
            this.syncStatus = status;
            this.statusListeners.forEach(fn => fn(status));

            // v8.61.1: Self-healing — if status goes to 'error', schedule a recovery check.
            // A single failed push shouldn't keep the UI stuck on 'error' forever.
            if (status === 'error' && !this._recoveryTimer) {
                this._recoveryTimer = setTimeout(async () => {
                    this._recoveryTimer = null;
                    if (this.syncStatus !== 'error') return; // Already recovered
                    try {
                        // Lightweight connectivity check — just read a single key
                        await this.db.ref(`${this.BASE_PATH}/config/_updatedAt`).once('value');
                        // Connection works — clear the error
                        console.log('[ConfigSync] Recovery check passed, clearing error status');
                        this.syncStatus = 'synced';
                        this.statusListeners.forEach(fn => fn('synced'));
                    } catch {
                        // Still broken — leave as error
                        console.log('[ConfigSync] Recovery check failed, status remains error');
                    }
                }, 5000);
            }
        },
        
        onStatusChange(callback) {
            this.statusListeners.add(callback);
            return () => this.statusListeners.delete(callback);
        },
        
        // --- Write methods (fire-and-forget after localStorage save) ---
        
        // Debounce timers per data key (prevents rapid-fire writes during batch operations)
        _debounceTimers: {},
        DEBOUNCE_KEYS: new Set(['deploy-history', 'session-log', 'deletion-history']), // Keys that get debounced
        DEBOUNCE_MS: 2000, // 2-second debounce window
        
        async push(dataKey, data) {
            if (!this.initialized || !this.db) return;
            try {
                const payload = JSON.parse(JSON.stringify(data)); // Deep clone to strip undefined
                payload._updatedAt = Date.now();
                payload._updatedBy = 'local';
                await this.db.ref(`${this.BASE_PATH}/${dataKey}`).set(payload);
                this._setStatus('synced');
                console.log(`[ConfigSync] Pushed ${dataKey} to Firebase`);
            } catch (err) {
                console.warn(`[ConfigSync] Failed to push ${dataKey}:`, err.message);
                this._setStatus('error');
            }
        },
        
        // Debounced push — delays the write, resets timer on each call
        pushDebounced(dataKey, data) {
            if (!this.initialized || !this.db) return Promise.resolve();
            
            // Clear any existing timer for this key
            if (this._debounceTimers[dataKey]) {
                clearTimeout(this._debounceTimers[dataKey]);
            }
            
            this._setStatus('syncing');
            
            return new Promise((resolve) => {
                this._debounceTimers[dataKey] = setTimeout(() => {
                    delete this._debounceTimers[dataKey];
                    this.push(dataKey, data).then(resolve).catch(resolve);
                }, this.DEBOUNCE_MS);
            });
        },
        
        // Smart push — uses debounce for rapid-fire keys, immediate for others
        pushSmart(dataKey, data) {
            if (this.DEBOUNCE_KEYS.has(dataKey)) {
                return this.pushDebounced(dataKey, data);
            }
            return this.push(dataKey, data);
        },
        
        async pushConfig(config) {
            return this.push('config', config);
        },
        
        async pushDeployHistory(history) {
            return this.pushSmart('deploy-history', history);
        },
        
        async pushRulesHistory(history) {
            return this.push('rules-history', history);
        },
        
        async pushSessionLog(log) {
            return this.pushSmart('session-log', log);
        },
        
        async pushDeletionHistory(history) {
            return this.pushSmart('deletion-history', history);
        },
        
        async pushRollbackSnapshots(snapshots) {
            return this.push('rollback-snapshots', snapshots);
        },
        
        // --- Read methods (one-time fetch for startup overlay) ---
        
        async pull(dataKey) {
            if (!this.initialized || !this.db) return null;
            try {
                const snap = await this.db.ref(`${this.BASE_PATH}/${dataKey}`).once('value');
                return snap.val();
            } catch (err) {
                console.warn(`[ConfigSync] Failed to pull ${dataKey}:`, err.message);
                return null;
            }
        },
        
        async pullConfig() {
            return this.pull('config');
        },
        
        async pullDeployHistory() {
            const data = await this.pull('deploy-history');
            return data || [];
        },
        
        async pullRulesHistory() {
            const data = await this.pull('rules-history');
            return data || [];
        },
        
        async pullSessionLog() {
            const data = await this.pull('session-log');
            return data || { currentSession: null, sessions: [], issues: [], notes: '' };
        },
        
        async pullDeletionHistory() {
            const data = await this.pull('deletion-history');
            return data || [];
        },
        
        async pullRollbackSnapshots() {
            const data = await this.pull('rollback-snapshots');
            return data || {};
        },
        
        // --- Startup sync: pull all data from Firebase ---
        // Returns an object with all synced data sets, or null for sets not found.
        // The caller decides whether to overlay onto local state.
        
        async pullAll() {
            if (!this.initialized || !this.db) {
                this._setStatus('offline');
                return null;
            }
            
            this._setStatus('syncing');
            
            try {
                const [config, deployHistory, rulesHistory, sessionLog, deletionHistory, rollbackSnapshots] = await Promise.all([
                    this.pullConfig(),
                    this.pullDeployHistory(),
                    this.pullRulesHistory(),
                    this.pullSessionLog(),
                    this.pullDeletionHistory(),
                    this.pullRollbackSnapshots()
                ]);
                
                this._setStatus('synced');
                
                return {
                    config,
                    deployHistory,
                    rulesHistory,
                    sessionLog,
                    deletionHistory,
                    rollbackSnapshots,
                    _pulledAt: Date.now()
                };
            } catch (err) {
                console.warn('[ConfigSync] pullAll failed:', err.message);
                this._setStatus('error');
                return null;
            }
        },
        
        // --- Push all non-sensitive data to Firebase (initial seed or manual sync) ---
        
        async pushAll({ config, deployHistory, rulesHistory, sessionLog, deletionHistory, rollbackSnapshots }) {
            if (!this.initialized || !this.db) return false;
            
            this._setStatus('syncing');
            
            try {
                const promises = [];
                if (config) promises.push(this.pushConfig(config));
                if (deployHistory) promises.push(this.pushDeployHistory(deployHistory));
                if (rulesHistory) promises.push(this.pushRulesHistory(rulesHistory));
                if (sessionLog) promises.push(this.pushSessionLog(sessionLog));
                if (deletionHistory) promises.push(this.pushDeletionHistory(deletionHistory));
                if (rollbackSnapshots) promises.push(this.pushRollbackSnapshots(rollbackSnapshots));
                
                await Promise.all(promises);
                this._setStatus('synced');
                console.log('[ConfigSync] Pushed all data to Firebase');
                return true;
            } catch (err) {
                console.warn('[ConfigSync] pushAll failed:', err.message);
                this._setStatus('error');
                return false;
            }
        },
        
        // --- Determine if Firebase data is newer than local ---
        
        isNewer(firebaseData, localTimestamp) {
            if (!firebaseData || !firebaseData._updatedAt) return false;
            return firebaseData._updatedAt > (localTimestamp || 0);
        },
        
        // --- Clear all Command Center data from Firebase ---
        
        async clearAll() {
            if (!this.initialized || !this.db) return false;
            this._setStatus('syncing');
            try {
                await this.db.ref(this.BASE_PATH).remove();
                this._setStatus('synced');
                console.log('[ConfigSync] Cleared all Firebase data');
                return true;
            } catch (err) {
                console.warn('[ConfigSync] Failed to clear Firebase data:', err.message);
                this._setStatus('error');
                return false;
            }
        },
        
        // --- Get approximate data size in Firebase ---
        
        async getDataSize() {
            if (!this.initialized || !this.db) return null;
            try {
                const snap = await this.db.ref(this.BASE_PATH).once('value');
                const data = snap.val();
                if (!data) return { totalBytes: 0, keys: {} };
                const totalStr = JSON.stringify(data);
                const keys = {};
                for (const key of Object.keys(data)) {
                    keys[key] = JSON.stringify(data[key]).length;
                }
                return { totalBytes: totalStr.length, keys };
            } catch (err) {
                console.warn('[ConfigSync] Failed to get data size:', err.message);
                return null;
            }
        }
    };
    
    // Initialize ConfigSync with the database reference
    FirebaseConfigSync.init(firebaseDb);
    
    // =========================================================================
    // DATA SERVICE LAYER (v8.19.0)
    // Namespaced service objects that encapsulate CRUD for each entity type.
    // Pattern: localStorage (immediate) + Firebase (async, fire-and-forget).
    // These services wrap existing data access patterns into clean APIs.
    // Views continue to use React state for rendering; services handle persistence.
    // =========================================================================
    
    /**
     * DeployService — Deploy history CRUD
     * Wraps: localStorage 'cc_history_v2' + FirebaseConfigSync deploy-history
     * Used by: App() deployments state, HistoryView, DashboardView
     */
    const DeployService = {
        STORAGE_KEY: 'cc_history_v2',
        MAX_HISTORY: 100,
        
        // Load deploy history from localStorage
        load() {
            try {
                const s = localStorage.getItem(this.STORAGE_KEY);
                return s ? JSON.parse(s) : [];
            } catch {
                return [];
            }
        },
        
        // Save full deploy history (localStorage + Firebase)
        save(deployments) {
            try {
                const history = deployments.slice(0, this.MAX_HISTORY);
                StorageManager.safeSet(this.STORAGE_KEY, JSON.stringify(history));
                if (FirebaseConfigSync.initialized) {
                    FirebaseConfigSync.pushDeployHistory(history).catch(() => {});
                }
                return true;
            } catch (e) {
                console.error('[DeployService] Save failed:', e);
                return false;
            }
        },
        
        // Add a deployment record to the front of the list
        add(deployment, currentList) {
            const updated = [deployment, ...currentList].slice(0, this.MAX_HISTORY);
            this.save(updated);
            return updated;
        },
        
        // Update a specific deployment record by id
        update(deploymentId, updates, currentList) {
            const updated = currentList.map(d =>
                d.id === deploymentId ? { ...d, ...updates } : d
            );
            this.save(updated);
            return updated;
        },
        
        // Get deployments for a specific app
        getForApp(appId, currentList) {
            return currentList.filter(d => d.appId === appId);
        },
        
        // Get recent deployments (last N)
        getRecent(n, currentList) {
            return currentList.slice(0, n);
        },
        
        // Overlay from Firebase (used during startup sync)
        overlay(remoteData) {
            if (!remoteData) return null;
            const { _updatedAt, _updatedBy, ...clean } = remoteData;
            try {
                localStorage.setItem(this.STORAGE_KEY, JSON.stringify(clean));
            } catch {}
            return Array.isArray(clean) ? clean : Object.values(clean);
        }
    };
    
    /**
     * SessionLogService — Session log CRUD
     * Wraps: localStorage 'cc_session_log' + FirebaseConfigSync session-log
     * Used by: App() sessionLog state, FirebaseConfigSync
     */
    const SessionLogService = {
        STORAGE_KEY: 'cc_session_log',
        
        DEFAULT_STATE: {
            currentSession: null,
            sessions: [],
            issues: [],
            notes: '',
            recentEntries: []
        },
        
        // Load session log from localStorage
        load() {
            try {
                const s = localStorage.getItem(this.STORAGE_KEY);
                return s ? JSON.parse(s) : { ...this.DEFAULT_STATE };
            } catch {
                return { ...this.DEFAULT_STATE };
            }
        },
        
        // Save full session log (localStorage + Firebase)
        save(sessionLog) {
            try {
                StorageManager.safeSet(this.STORAGE_KEY, JSON.stringify(sessionLog));
                if (FirebaseConfigSync.initialized) {
                    FirebaseConfigSync.pushSessionLog(sessionLog).catch(() => {});
                }
                return true;
            } catch (e) {
                console.error('[SessionLogService] Save failed:', e);
                return false;
            }
        },
        
        // Add a recent entry to the session log
        addRecentEntry(entry, currentLog) {
            const updated = {
                ...currentLog,
                recentEntries: [...(currentLog.recentEntries || []), entry].slice(-20)
            };
            this.save(updated);
            return updated;
        },
        
        // Update session notes
        updateNotes(notes, currentLog) {
            const updated = { ...currentLog, notes };
            this.save(updated);
            return updated;
        },
        
        // Set current session
        setCurrentSession(session, currentLog) {
            const updated = { ...currentLog, currentSession: session };
            this.save(updated);
            return updated;
        },
        
        // Overlay from Firebase (used during startup sync)
        overlay(remoteData) {
            if (!remoteData || !remoteData._updatedAt) return null;
            const { _updatedAt, _updatedBy, ...clean } = remoteData;
            try {
                localStorage.setItem(this.STORAGE_KEY, JSON.stringify(clean));
            } catch {}
            return clean;
        }
    };
    
    
    /**
     * IssueService — Minimal issues interface (full UI in Quality satellite)
     * Retained methods: listen (for globalIssues), update, linkToVersion (for deploy flow)
     */
    const IssueService = {
        _ref(uid) {
            if (!firebaseDb || !uid) return null;
            return firebaseDb.ref(`command-center/${uid}/issues`);
        },
        
        listen(uid, callback) {
            const ref = this._ref(uid);
            if (!ref) return () => {};
            const handler = ref.on('value', (snap) => {
                const data = snap.val();
                callback(data ? Object.values(data) : []);
            });
            return () => ref.off('value', handler);
        },
        
        async update(uid, issueId, updates) {
            const ref = this._ref(uid);
            if (!ref) return;
            const snap = await ref.orderByChild('id').equalTo(issueId).once('value');
            const entries = snap.val();
            if (entries) {
                const key = Object.keys(entries)[0];
                await ref.child(key).update(updates);
            }
        },
        
        async linkToVersion(uid, issueIds, version, appId) {
            if (!issueIds || !issueIds.length) return;
            for (const issueId of issueIds) {
                await this.update(uid, issueId, {
                    status: 'fixed',
                    fixedAt: new Date().toISOString(),
                    fixedInVersion: version,
                    fixedInApp: appId
                });
            }
        }
    };
    /**
     * RollbackService — Rollback snapshot CRUD
     * Wraps: localStorage 'cc_rollback_snapshots' + FirebaseConfigSync rollback-snapshots
     * Used by: App() rollbackSnapshots state, DashboardView quick rollback
     */
    const RollbackService = {
        STORAGE_KEY: 'cc_rollback_snapshots',
        
        // Load from localStorage
        load() {
            try {
                const s = localStorage.getItem(this.STORAGE_KEY);
                return s ? JSON.parse(s) : {};
            } catch {
                return {};
            }
        },
        
        // Save (localStorage + Firebase)
        save(snapshots) {
            try {
                StorageManager.safeSet(this.STORAGE_KEY, JSON.stringify(snapshots));
                if (FirebaseConfigSync.initialized) {
                    FirebaseConfigSync.pushRollbackSnapshots(snapshots).catch(() => {});
                }
                return true;
            } catch (e) {
                console.error('[RollbackService] Save failed:', e);
                return false;
            }
        },
        
        // Get snapshot for an app/target
        get(appId, target, currentSnapshots) {
            return currentSnapshots[`${appId}:${target}`] || null;
        },
        
        // Save a snapshot
        set(appId, target, snapshot, currentSnapshots) {
            const key = `${appId}:${target}`;
            const updated = { ...currentSnapshots, [key]: snapshot };
            this.save(updated);
            return updated;
        },
        
        // Clear a snapshot
        clear(appId, target, currentSnapshots) {
            const key = `${appId}:${target}`;
            const updated = { ...currentSnapshots };
            delete updated[key];
            this.save(updated);
            return updated;
        }
    };
    
    // =========================================================================
    // STORAGE MANAGER — Intelligent localStorage cleanup
    // Monitors usage, auto-prunes when approaching quota, provides diagnostics
    // =========================================================================
    
    const StorageManager = {
        // Approximate localStorage limit (5MB for most browsers)
        QUOTA_LIMIT: 5 * 1024 * 1024,
        // Trigger cleanup when usage exceeds this percentage
        CLEANUP_THRESHOLD: 0.80,
        // After cleanup, try to get down to this percentage
        TARGET_AFTER_CLEANUP: 0.60,
        
        // Keys ordered by cleanup priority (first = safe to prune aggressively)
        PRUNABLE_KEYS: [
            { key: 'cc_rollback_snapshots', type: 'object', strategy: 'keep-latest', maxAge: 7 * 24 * 60 * 60 * 1000, label: 'Rollback Snapshots' },
            { key: 'cc_history_v2', type: 'array', strategy: 'trim', keepCount: 30, label: 'Deploy History' },
            { key: 'cc_session_log', type: 'object', strategy: 'trim-entries', keepCount: 10, label: 'Session Log' },
            { key: 'cc_deletion_history', type: 'array', strategy: 'trim', keepCount: 20, label: 'Deletion History' },
            { key: 'cc_rulesHistory', type: 'array', strategy: 'trim', keepCount: 10, label: 'Rules History' },
            { key: 'cc_tld_prices', type: 'object', strategy: 'clear', label: 'TLD Price Cache' },
            { key: 'cc_domain_health', type: 'object', strategy: 'clear', label: 'Domain Health Cache' },
        ],
        
        // Keys that should never be pruned
        PROTECTED_KEYS: ['cc_token', 'cc_token_expires', 'cc_apps_v6', 'commandCenterConfig', 'cc_firebase_sa', 'cc_firebase_uid', 'cc_collapsedProjects', 'cc_default_engine', 'cc_projectStates', 'cc_domain_config', 'cc_godaddy_config', 'cc_token_registry', 'cc_api_key', 'cc_anthropic_api_key', 'cc_repo_health_last', 'githubRepoAssignments', 'gs_github_token', 'gs_firebase_sa', 'gs_firebase_uid', 'gs_config', 'gs_api_key', 'gs_token_expires'],
        
        // Get current storage usage in bytes
        getUsage() {
            let total = 0;
            const breakdown = {};
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                const value = localStorage.getItem(key);
                const size = (key.length + value.length) * 2; // UTF-16
                total += size;
                breakdown[key] = size;
            }
            return { total, breakdown, percent: (total / this.QUOTA_LIMIT * 100).toFixed(1) };
        },
        
        // Get human-readable diagnostics
        getDiagnostics() {
            const { total, breakdown, percent } = this.getUsage();
            const sorted = Object.entries(breakdown).sort((a, b) => b[1] - a[1]);
            return {
                totalBytes: total,
                totalFormatted: this._formatBytes(total),
                percent: parseFloat(percent),
                quotaFormatted: this._formatBytes(this.QUOTA_LIMIT),
                entries: sorted.map(([key, size]) => ({
                    key,
                    size,
                    sizeFormatted: this._formatBytes(size),
                    percent: (size / total * 100).toFixed(1),
                    protected: this.PROTECTED_KEYS.includes(key)
                }))
            };
        },
        
        // Intelligent cleanup — called automatically on QuotaExceededError or manually
        cleanup(aggressive = false) {
            const before = this.getUsage();
            const target = this.QUOTA_LIMIT * (aggressive ? 0.40 : this.TARGET_AFTER_CLEANUP);
            let freed = 0;
            const actions = [];
            
            console.log(`[StorageManager] Cleanup started. Usage: ${this._formatBytes(before.total)} (${before.percent}%)`);
            
            for (const rule of this.PRUNABLE_KEYS) {
                if (before.total - freed <= target) break;
                
                try {
                    const raw = localStorage.getItem(rule.key);
                    if (!raw) continue;
                    const sizeBefore = (rule.key.length + raw.length) * 2;
                    
                    if (rule.strategy === 'clear') {
                        localStorage.removeItem(rule.key);
                        freed += sizeBefore;
                        actions.push({ key: rule.key, action: 'cleared', freed: sizeBefore });
                        continue;
                    }
                    
                    const data = JSON.parse(raw);
                    
                    if (rule.strategy === 'keep-latest' && typeof data === 'object' && !Array.isArray(data)) {
                        // Rollback snapshots: remove entries older than maxAge, keep only most recent per app
                        const now = Date.now();
                        const maxAge = aggressive ? 24 * 60 * 60 * 1000 : rule.maxAge;
                        const pruned = {};
                        for (const [k, v] of Object.entries(data)) {
                            const savedAt = v.savedAt ? new Date(v.savedAt).getTime() : 0;
                            if (now - savedAt < maxAge) {
                                pruned[k] = v;
                            }
                        }
                        // If still too big, strip content from oldest snapshots (keep metadata)
                        if (aggressive) {
                            const entries = Object.entries(pruned).sort((a, b) => 
                                new Date(b[1].savedAt || 0) - new Date(a[1].savedAt || 0));
                            // Keep only the 3 most recent with content
                            entries.slice(3).forEach(([k, v]) => {
                                pruned[k] = { ...v, content: '[pruned]', prunedAt: new Date().toISOString() };
                            });
                        }
                        const newRaw = JSON.stringify(pruned);
                        localStorage.setItem(rule.key, newRaw);
                        const sizeAfter = (rule.key.length + newRaw.length) * 2;
                        freed += sizeBefore - sizeAfter;
                        actions.push({ key: rule.key, action: `pruned ${Object.keys(data).length - Object.keys(pruned).length} snapshots`, freed: sizeBefore - sizeAfter });
                    }
                    
                    if (rule.strategy === 'trim' && Array.isArray(data)) {
                        const keepCount = aggressive ? Math.floor(rule.keepCount / 2) : rule.keepCount;
                        if (data.length > keepCount) {
                            const trimmed = data.slice(0, keepCount);
                            const newRaw = JSON.stringify(trimmed);
                            localStorage.setItem(rule.key, newRaw);
                            const sizeAfter = (rule.key.length + newRaw.length) * 2;
                            freed += sizeBefore - sizeAfter;
                            actions.push({ key: rule.key, action: `trimmed ${data.length} → ${keepCount}`, freed: sizeBefore - sizeAfter });
                        }
                    }
                    
                    if (rule.strategy === 'trim-entries' && typeof data === 'object') {
                        // Session log: trim sessions and recentEntries arrays
                        const keepCount = aggressive ? 5 : rule.keepCount;
                        const pruned = { ...data };
                        if (Array.isArray(pruned.sessions)) pruned.sessions = pruned.sessions.slice(-keepCount);
                        if (Array.isArray(pruned.recentEntries)) pruned.recentEntries = pruned.recentEntries.slice(-keepCount);
                        const newRaw = JSON.stringify(pruned);
                        localStorage.setItem(rule.key, newRaw);
                        const sizeAfter = (rule.key.length + newRaw.length) * 2;
                        freed += sizeBefore - sizeAfter;
                        actions.push({ key: rule.key, action: 'trimmed entries', freed: sizeBefore - sizeAfter });
                    }
                } catch (e) {
                    console.warn(`[StorageManager] Error pruning ${rule.key}:`, e);
                }
            }
            
            // Remove any orphan cc_ keys not in protected or prunable lists
            if (aggressive) {
                const knownKeys = new Set([
                    ...this.PROTECTED_KEYS,
                    ...this.PRUNABLE_KEYS.map(r => r.key)
                ]);
                for (let i = localStorage.length - 1; i >= 0; i--) {
                    const key = localStorage.key(i);
                    if (key?.startsWith('cc_') && !knownKeys.has(key)) {
                        const size = (key.length + localStorage.getItem(key).length) * 2;
                        localStorage.removeItem(key);
                        freed += size;
                        actions.push({ key, action: 'removed orphan', freed: size });
                    }
                }
            }
            
            const after = this.getUsage();
            console.log(`[StorageManager] Cleanup complete. Freed: ${this._formatBytes(freed)}. Usage: ${this._formatBytes(after.total)} (${after.percent}%)`);
            
            return { before: before.total, after: after.total, freed, actions };
        },
        
        // Wrap a localStorage.setItem call with auto-cleanup on quota error
        safeSet(key, value) {
            try {
                localStorage.setItem(key, value);
                return true;
            } catch (e) {
                if (e.name === 'QuotaExceededError') {
                    console.warn(`[StorageManager] Quota exceeded on ${key}, running cleanup...`);
                    this.cleanup(false);
                    try {
                        localStorage.setItem(key, value);
                        return true;
                    } catch {
                        console.warn(`[StorageManager] Still full after cleanup, running aggressive cleanup...`);
                        this.cleanup(true);
                        try {
                            localStorage.setItem(key, value);
                            return true;
                        } catch {
                            console.error(`[StorageManager] Cannot save ${key} even after aggressive cleanup`);
                            return false;
                        }
                    }
                }
                throw e;
            }
        },
        
        _formatBytes(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
            return (bytes / (1024 * 1024)).toFixed(2) + ' MB';
        },

        // Auto-cleanup on app load — runs once per session if usage exceeds threshold
        autoCleanup() {
            try {
                const { total, percent } = this.getUsage();
                const pct = parseFloat(percent);
                if (pct >= this.CLEANUP_THRESHOLD * 100) {
                    console.log(`[StorageManager] Auto-cleanup: usage at ${percent}% (threshold: ${this.CLEANUP_THRESHOLD * 100}%), running cleanup...`);
                    const result = this.cleanup(false);
                    // If still above target after normal cleanup, go aggressive
                    const after = this.getUsage();
                    if (parseFloat(after.percent) >= this.CLEANUP_THRESHOLD * 100) {
                        console.log(`[StorageManager] Still at ${after.percent}% after normal cleanup, running aggressive...`);
                        this.cleanup(true);
                    }
                    return result;
                } else {
                    console.log(`[StorageManager] Storage healthy: ${this._formatBytes(total)} (${percent}%)`);
                }
            } catch (e) {
                console.warn('[StorageManager] Auto-cleanup error:', e.message);
            }
            return null;
        }
    };

    // Run storage auto-cleanup on app load
    StorageManager.autoCleanup();

    // =========================================================================
    // PHASE 0.2 DATA SERVICES — Orchestrator entity services
    // =========================================================================
    
    /**
     * WorkItemService — Work item (backlog) CRUD via Firebase
     * Wraps: Firebase RTDB `command-center/{uid}/backlog` path
     * Used by: Future BacklogView, Claude Prep targeting, deploy close-the-loop
     * 
     * Work items are the building blocks of project planning:
     *   id: 'WI-NNN' (auto-generated)
     *   appId: which app this belongs to
     *   title, description: what to build
     *   type: feature | bugfix | enhancement | chore | research
     *   priority: core | nice-to-have | out-of-scope
     *   milestone: prototype | alpha | beta | production
     *   status: idea → ready → in-progress → review → done → deferred
     *   effort: quick | session | multi-session | epic
     *   criteria: acceptance criteria array
     *   context: { filesAffected, sections, dependencies, notes, relatedItems }
     *   tags: string array for filtering
     *   Timestamps: createdAt, startedAt, completedAt, completedInVersion, sessionId
     */
    const WorkItemService = {
        BASE_PATH: 'command-center',
        
        _ref(uid) {
            if (!firebaseDb || !uid) return null;
            return firebaseDb.ref(`${this.BASE_PATH}/${uid}/backlog`);
        },
        
        // Listen for all work items (returns unsubscribe function)
        listen(uid, callback) {
            const ref = this._ref(uid);
            if (!ref) return () => {};
            
            ref.on('value', (snapshot) => {
                const data = snapshot.val();
                if (data) {
                    const list = Object.entries(data).map(([id, item]) => ({ id, ...item }));
                    callback(list.sort((a, b) => new Date(b.createdAt || 0) - new Date(a.createdAt || 0)));
                } else {
                    callback([]);
                }
            });
            
            return () => ref.off();
        },
        
        // Get a single work item
        async get(uid, itemId) {
            const ref = this._ref(uid);
            if (!ref) return null;
            const snapshot = await ref.child(itemId).once('value');
            const data = snapshot.val();
            return data ? { id: itemId, ...data } : null;
        },
        
        // Create a new work item
        async create(uid, itemData) {
            const ref = this._ref(uid);
            if (!ref) return null;
            
            const item = {
                appId: itemData.appId,
                streamId: itemData.streamId || null,  // Phase 5.3: optional stream assignment
                title: itemData.title,
                description: itemData.description || '',
                type: itemData.type || 'feature',
                priority: itemData.priority || 'core',
                milestone: itemData.milestone || 'beta',
                status: itemData.status || 'idea',
                effort: itemData.effort || 'session',
                criteria: itemData.criteria || [],
                context: {
                    filesAffected: itemData.context?.filesAffected || [],
                    sections: itemData.context?.sections || [],
                    dependencies: itemData.context?.dependencies || [],
                    notes: itemData.context?.notes || '',
                    relatedItems: itemData.context?.relatedItems || []
                },
                tags: itemData.tags || [],
                createdAt: new Date().toISOString(),
                createdBy: itemData.createdBy || 'manual',
                source: itemData.source || 'manual',
                startedAt: null,
                completedAt: null,
                completedInVersion: null,
                sessionId: null
            };
            
            await ref.child(itemData.id).set(item);
            console.log(`[WorkItemService] Created ${itemData.id}: ${item.title}`);
            return { id: itemData.id, ...item };
        },
        
        // Update a work item (partial)
        async update(uid, itemId, updates) {
            const ref = this._ref(uid);
            if (!ref) return;
            await ref.child(itemId).update(updates);
        },
        
        // Transition status with timestamps
        async updateStatus(uid, itemId, newStatus, extraData = {}) {
            const now = new Date().toISOString();
            const updates = { status: newStatus, ...extraData };
            
            // Auto-set timestamps on status transitions
            switch (newStatus) {
                case 'in-progress':
                    updates.startedAt = now;
                    break;
                case 'review':
                    updates.reviewStartedAt = now;
                    break;
                case 'done':
                    updates.completedAt = now;
                    break;
                case 'deferred':
                    updates.deferredAt = now;
                    break;
            }
            
            await this.update(uid, itemId, updates);
            console.log(`[WorkItemService] ${itemId} → ${newStatus}`);
        },
        
        // Complete a work item (from deploy close-the-loop)
        async complete(uid, itemId, version) {
            await this.updateStatus(uid, itemId, 'done', {
                completedInVersion: version
            });
        },
        
        // Check if item has criteria (used for auto-transition suggestions)
        hasCriteria(item) {
            return item?.criteria && item.criteria.length > 0 && item.criteria.some(c => c.trim());
        },
        
        // Check if item is stale (in-progress or review for 7+ days)
        isStale(item) {
            if (item.status !== 'in-progress' && item.status !== 'review') return false;
            const startDate = item.status === 'review' ? item.reviewStartedAt : item.startedAt;
            if (!startDate) return false;
            return (Date.now() - new Date(startDate).getTime()) > 7 * 24 * 60 * 60 * 1000;
        },
        
        // Get stale days count
        getStaleDays(item) {
            const startDate = item.status === 'review' ? item.reviewStartedAt : item.startedAt;
            if (!startDate) return 0;
            return Math.floor((Date.now() - new Date(startDate).getTime()) / (24 * 60 * 60 * 1000));
        },
        
        // Get work items filtered by app
        filterByApp(items, appId) {
            return items.filter(i => i.appId === appId);
        },
        
        // Get work items filtered by stream (Phase 5.3)
        filterByStream(items, streamId) {
            return items.filter(i => i.streamId === streamId);
        },
        
        // Get unassigned work items (no stream) for an app
        getUnassigned(items, appId) {
            return items.filter(i => (!i.streamId) && (!appId || i.appId === appId));
        },
        
        // Get work items filtered by milestone
        filterByMilestone(items, milestone) {
            return items.filter(i => i.milestone === milestone);
        },
        
        // Get work items filtered by status
        filterByStatus(items, status) {
            return items.filter(i => i.status === status);
        },
        
        // Get in-progress items (for deploy close-the-loop)
        getInProgress(items, appId) {
            return items.filter(i => i.status === 'in-progress' && (!appId || i.appId === appId));
        },
        
        // Get items in review (for post-deploy completion)
        getInReview(items, appId) {
            return items.filter(i => i.status === 'review' && (!appId || i.appId === appId));
        },
        
        // Batch create work items (for scoping flow)
        async createBatch(uid, itemsData) {
            const ref = this._ref(uid);
            if (!ref) return [];
            
            const results = [];
            const updates = {};
            for (const itemData of itemsData) {
                const item = {
                    appId: itemData.appId,
                    streamId: itemData.streamId || null,  // Phase 5.3
                    title: itemData.title,
                    description: itemData.description || '',
                    type: itemData.type || 'feature',
                    priority: itemData.priority || 'core',
                    milestone: itemData.milestone || 'beta',
                    status: itemData.status || 'idea',
                    effort: itemData.effort || 'session',
                    criteria: itemData.criteria || [],
                    context: {
                        filesAffected: itemData.context?.filesAffected || [],
                        sections: itemData.context?.sections || [],
                        dependencies: itemData.context?.dependencies || [],
                        notes: itemData.context?.notes || '',
                        relatedItems: itemData.context?.relatedItems || []
                    },
                    tags: itemData.tags || [],
                    createdAt: new Date().toISOString(),
                    createdBy: itemData.createdBy || 'manual',
                    source: itemData.source || 'manual',
                    startedAt: null,
                    completedAt: null,
                    completedInVersion: null,
                    sessionId: null
                };
                updates[itemData.id] = item;
                results.push({ id: itemData.id, ...item });
            }
            await ref.update(updates);
            console.log(`[WorkItemService] Batch created ${results.length} items`);
            return results;
        },
        
        // Delete a work item
        async delete(uid, itemId) {
            const ref = this._ref(uid);
            if (!ref) return;
            await ref.child(itemId).remove();
            console.log(`[WorkItemService] Deleted ${itemId}`);
        },
        
        // Generate next work item ID from existing list
        getNextId(currentItems) {
            const existing = currentItems.map(i => parseInt(i.id?.replace('WI-', '') || '0'));
            const max = Math.max(0, ...existing);
            return `WI-${String(max + 1).padStart(3, '0')}`;
        }
    };
    
    /**
     * SessionService — Claude session tracking via Firebase
     * Wraps: Firebase RTDB `command-center/{uid}/sessions` path
     * Used by: Claude Prep (create on package generation), deploy (link session to deploy)
     * 
     * A session represents one AI interaction cycle: prep → build → handoff → deploy
     *   id: auto-generated timestamp-based
     *   appId: which app the session is for
     *   type: build | design | fix | test | research | review | polish | document
     *   workItemId: optional linked work item
     *   engineId: which AI engine was targeted
     *   status: prep | active | completed | abandoned
     *   packageTokens: estimated token count of the generated package
     *   deployId: linked deploy record (set after deploy)
     *   Timestamps: createdAt, completedAt
     */
    const SessionService = {
        BASE_PATH: 'command-center',
        
        _ref(uid) {
            if (!firebaseDb || !uid) return null;
            return firebaseDb.ref(`${this.BASE_PATH}/${uid}/sessions`);
        },
        
        // Listen for all sessions
        listen(uid, callback) {
            const ref = this._ref(uid);
            if (!ref) return () => {};
            
            ref.on('value', (snapshot) => {
                const data = snapshot.val();
                if (data) {
                    const list = Object.entries(data).map(([id, s]) => ({ id, ...s }));
                    callback(list.sort((a, b) => new Date(b.createdAt || 0) - new Date(a.createdAt || 0)));
                } else {
                    callback([]);
                }
            });
            
            return () => ref.off();
        },
        
        // Create a session record (called when Claude Prep generates a package)
        async create(uid, sessionData) {
            const ref = this._ref(uid);
            if (!ref) return null;
            
            const sessionId = `sess-${Date.now()}`;
            const session = {
                appId: sessionData.appId,
                type: sessionData.type || 'build',
                workItemId: sessionData.workItemId || null,
                engineId: sessionData.engineId || 'claude-sonnet-4.5',
                status: 'prep',
                packageTokens: sessionData.packageTokens || 0,
                packageFiles: sessionData.packageFiles || [],
                deployId: null,
                notes: sessionData.notes || '',
                // Phase 3: Review tracking
                review: null,       // { criteriaResults: [{id, text, met: bool}], reviewedBy, reviewedAt, notes }
                deliverables: null,  // { files: [string], importedAt, summary }
                createdAt: new Date().toISOString(),
                completedAt: null
            };
            
            await ref.child(sessionId).set(session);
            console.log(`[SessionService] Created ${sessionId} for ${session.appId} (${session.type})`);
            return { id: sessionId, ...session };
        },
        
        // Update a session
        async update(uid, sessionId, updates) {
            const ref = this._ref(uid);
            if (!ref) return;
            await ref.child(sessionId).update(updates);
        },
        
        // Link a deploy to a session
        async linkDeploy(uid, sessionId, deployId) {
            await this.update(uid, sessionId, {
                deployId,
                status: 'completed',
                completedAt: new Date().toISOString()
            });
            console.log(`[SessionService] Linked deploy ${deployId} to session ${sessionId}`);
        },
        
        // Phase 3: Start review — session moves from prep to review
        async startReview(uid, sessionId, deliverables) {
            await this.update(uid, sessionId, {
                status: 'review',
                deliverables: {
                    files: deliverables.files || [],
                    importedAt: new Date().toISOString(),
                    summary: deliverables.summary || ''
                }
            });
            console.log(`[SessionService] ${sessionId} → review (${deliverables.files?.length || 0} files)`);
        },
        
        // Phase 3: Complete review with criteria results
        async completeReview(uid, sessionId, reviewData) {
            await this.update(uid, sessionId, {
                review: {
                    criteriaResults: reviewData.criteriaResults || [],
                    reviewedBy: reviewData.reviewedBy || 'Owner',
                    reviewedAt: new Date().toISOString(),
                    notes: reviewData.notes || '',
                    allMet: (reviewData.criteriaResults || []).every(c => c.met)
                }
            });
            console.log(`[SessionService] ${sessionId} review complete`);
        },
        
        // Get recent sessions for an app
        getForApp(sessions, appId, limit = 5) {
            return sessions
                .filter(s => s.appId === appId)
                .slice(0, limit);
        },
        
        // Get active (non-completed) sessions
        getActive(sessions, appId) {
            return sessions.filter(s => 
                s.status !== 'completed' && s.status !== 'abandoned' &&
                (!appId || s.appId === appId)
            );
        }
    };
    
    /**
     * ActivityLogService — Audit trail for all meaningful actions (Phase 3.4)
     * Wraps: Firebase RTDB `command-center/{uid}/activity` path
     * 
     * Every meaningful action (deploy, session create/complete, work item transitions,
     * scoping, reviews) writes an event. For solo use: audit trail.
     * For Phase 5 multi-person: the activity feed everyone sees.
     */
    const ActivityLogService = {
        BASE_PATH: 'command-center',
        MAX_EVENTS: 500,
        
        _ref(uid) {
            if (!firebaseDb || !uid) return null;
            return firebaseDb.ref(`${this.BASE_PATH}/${uid}/activity`);
        },
        
        // Listen for activity events (returns unsubscribe function)
        listen(uid, callback, limit = 100) {
            const ref = this._ref(uid);
            if (!ref) return () => {};
            
            ref.orderByChild('timestamp').limitToLast(limit).on('value', (snapshot) => {
                const data = snapshot.val();
                if (data) {
                    const list = Object.entries(data).map(([id, evt]) => ({ id, ...evt }));
                    callback(list.sort((a, b) => new Date(b.timestamp || 0) - new Date(a.timestamp || 0)));
                } else {
                    callback([]);
                }
            });
            
            return () => ref.off();
        },
        
        // Log an activity event
        async log(uid, event) {
            const ref = this._ref(uid);
            if (!ref) return null;
            
            const eventId = `evt-${Date.now()}-${Math.random().toString(36).slice(2, 6)}`;
            const entry = {
                appId: event.appId || null,
                streamId: event.streamId || null,
                actor: event.actor || 'Owner',
                action: event.action,          // deploy, session_create, session_complete, item_transition, scope, review
                summary: event.summary,        // Human-readable: "Dave deployed Core Gameplay v0.9"
                metadata: event.metadata || {},
                timestamp: new Date().toISOString()
            };
            
            await ref.child(eventId).set(entry);
            return { id: eventId, ...entry };
        },
        
        // Convenience loggers for common actions
        async logDeploy(uid, actor, appName, version, env, sessionId) {
            return this.log(uid, {
                appId: appName,
                actor,
                action: 'deploy',
                summary: `${actor} deployed ${appName} v${version} to ${env}`,
                metadata: { version, environment: env, sessionId }
            });
        },
        
        async logSessionCreate(uid, actor, appName, sessionType, sessionId) {
            return this.log(uid, {
                appId: appName,
                actor,
                action: 'session_create',
                summary: `${actor} started ${sessionType} session for ${appName}`,
                metadata: { sessionType, sessionId }
            });
        },
        
        async logSessionComplete(uid, actor, appName, sessionId, itemsCompleted) {
            return this.log(uid, {
                appId: appName,
                actor,
                action: 'session_complete',
                summary: `${actor} completed session for ${appName} — ${itemsCompleted} item${itemsCompleted !== 1 ? 's' : ''} done`,
                metadata: { sessionId, itemsCompleted }
            });
        },
        
        async logItemTransition(uid, actor, appName, itemId, itemTitle, fromStatus, toStatus) {
            return this.log(uid, {
                appId: appName,
                actor,
                action: 'item_transition',
                summary: `${actor} moved "${itemTitle}" from ${fromStatus} to ${toStatus}`,
                metadata: { itemId, fromStatus, toStatus }
            });
        },
        
        async logReview(uid, actor, appName, sessionId, criteriaMetCount, criteriaTotalCount) {
            return this.log(uid, {
                appId: appName,
                actor,
                action: 'review',
                summary: `${actor} reviewed ${appName} — ${criteriaMetCount}/${criteriaTotalCount} criteria met`,
                metadata: { sessionId, criteriaMetCount, criteriaTotalCount }
            });
        }
    };
    
    /**
     * WorkStreamService — Minimal stub (full implementation in Analytics satellite)
     */
    const WorkStreamService = {
        BASE_PATH: 'command-center',
        _ref(uid) { if (!firebaseDb || !uid) return null; return firebaseDb.ref(`${this.BASE_PATH}/${uid}/streams`); },
        listen(uid, callback) {
            const ref = this._ref(uid);
            if (!ref) return () => {};
            ref.on('value', (snapshot) => {
                const data = snapshot.val();
                if (data) {
                    const list = Object.entries(data).map(([id, s]) => ({
                        id, ...s,
                        // Migrate: ensure extended fields exist
                        appIds: s.appIds || (s.appId ? [s.appId] : []),
                        concepts: s.concepts || [],
                        openItems: s.openItems || [],
                        next: s.next || ''
                    }));
                    callback(list.sort((a, b) => (a.order || 0) - (b.order || 0)));
                } else { callback([]); }
            });
            return () => ref.off();
        },
        async update(uid, streamId, updates) {
            const ref = this._ref(uid);
            if (!ref) return;
            await ref.child(streamId).update(updates);
            console.log(`[WorkStreamService] Updated ${streamId} (${Object.keys(updates).join(', ')})`);
        },
        filterByApp(streams, appId) { return (streams || []).filter(s => s.appId === appId || (s.appIds && s.appIds.includes(appId))); }
    };
    
    /**
     * StreamInterfaceService — Minimal stub (full implementation in Analytics satellite)
     */
    const StreamInterfaceService = {
        BASE_PATH: 'command-center',
        _ref(uid) { if (!firebaseDb || !uid) return null; return firebaseDb.ref(`${this.BASE_PATH}/${uid}/interfaces`); },
        listen(uid, callback) {
            const ref = this._ref(uid);
            if (!ref) return () => {};
            ref.on('value', (snapshot) => {
                const data = snapshot.val();
                callback(data ? Object.entries(data).map(([id, i]) => ({ id, ...i })) : []);
            });
            return () => ref.off();
        },
        async update(uid, interfaceId, updates) {
            const ref = this._ref(uid);
            if (!ref) return;
            await ref.child(interfaceId).update(updates);
        },
        getByStream(interfaces, streamId) { return (interfaces || []).filter(i => i.streamId === streamId); }
    };
    
    /**
     * DependencyService — Minimal stub (full implementation in Analytics satellite)
     */
    const DependencyService = {
        BASE_PATH: 'command-center',
        _ref(uid) { if (!firebaseDb || !uid) return null; return firebaseDb.ref(`${this.BASE_PATH}/${uid}/dependencies`); },
        listen(uid, callback) {
            const ref = this._ref(uid);
            if (!ref) return () => {};
            ref.on('value', (snapshot) => {
                const data = snapshot.val();
                callback(data ? Object.entries(data).map(([id, d]) => ({ id, ...d })) : []);
            });
            return () => ref.off();
        },
        async update(uid, depId, updates) {
            const ref = this._ref(uid);
            if (!ref) return;
            await ref.child(depId).update(updates);
        }
    };

    
    /**
     * DependencyAlertService — Auto-remediation alerts (Phase 5.4)
     * Wraps: Firebase RTDB `command-center/{uid}/dependencyAlerts` path
     * 
     * When a session changes a provided interface, alerts are generated
     * for every dependent stream. Each alert auto-creates a work item
     * in the dependent stream with change context for prompt chaining.
     * 
     *   id: 'DA-NNN'
     *   dependencyId: which dependency was affected
     *   interfaceId: which interface changed
     *   triggeredBySession: session ID that caused the change
     *   triggeredByItem: work item ID that caused the change
     *   changeDescription: what changed (user-provided)
     *   changeNotes: detailed notes for the dependent stream's Claude session
     *   triggeredAt: timestamp
     *   triggeredBy: actor name
     *   generatedItemId: auto-created work item in dependent stream
     *   resolution: pending | updated | no_impact
     *   resolvedBy, resolvedAt
     */
    const DependencyAlertService = {
        BASE_PATH: 'command-center',
        
        _ref(uid) {
            if (!firebaseDb || !uid) return null;
            return firebaseDb.ref(`${this.BASE_PATH}/${uid}/dependencyAlerts`);
        },
        
        listen(uid, callback) {
            const ref = this._ref(uid);
            if (!ref) return () => {};
            
            ref.on('value', (snapshot) => {
                const data = snapshot.val();
                if (data) {
                    const list = Object.entries(data).map(([id, alert]) => ({ id, ...alert }));
                    callback(list.sort((a, b) => new Date(b.triggeredAt || 0) - new Date(a.triggeredAt || 0)));
                } else {
                    callback([]);
                }
            });
            
            return () => ref.off();
        },
        
        async create(uid, data) {
            const ref = this._ref(uid);
            if (!ref) return null;
            
            const alert = {
                dependencyId: data.dependencyId,
                interfaceId: data.interfaceId,
                triggeredBySession: data.triggeredBySession || null,
                triggeredByItem: data.triggeredByItem || null,
                changeDescription: data.changeDescription,
                changeNotes: data.changeNotes || '',
                triggeredAt: new Date().toISOString(),
                triggeredBy: data.triggeredBy || 'Owner',
                generatedItemId: data.generatedItemId || null,
                resolution: 'pending',
                resolvedBy: null,
                resolvedAt: null
            };
            
            await ref.child(data.id).set(alert);
            console.log(`[DependencyAlertService] Created ${data.id}: ${alert.changeDescription}`);
            return { id: data.id, ...alert };
        },
        
        async resolve(uid, alertId, resolution, resolvedBy) {
            const ref = this._ref(uid);
            if (!ref) return;
            await ref.child(alertId).update({
                resolution: resolution,  // 'updated' or 'no_impact'
                resolvedBy: resolvedBy || 'Owner',
                resolvedAt: new Date().toISOString()
            });
            console.log(`[DependencyAlertService] Resolved ${alertId}: ${resolution}`);
        },
        
        async updateGeneratedItem(uid, alertId, itemId) {
            const ref = this._ref(uid);
            if (!ref) return;
            await ref.child(alertId).update({ generatedItemId: itemId });
        },
        
        async delete(uid, alertId) {
            const ref = this._ref(uid);
            if (!ref) return;
            await ref.child(alertId).remove();
        },
        
        // Get pending alerts for a stream (items that need attention)
        getPendingForStream(alerts, dependencies, streamId) {
            const streamDepIds = dependencies.filter(d => d.dependentStreamId === streamId).map(d => d.id);
            return alerts.filter(a => a.resolution === 'pending' && streamDepIds.includes(a.dependencyId));
        },
        
        // Get all pending alerts
        getPending(alerts) {
            return alerts.filter(a => a.resolution === 'pending');
        },
        
        // Get alerts triggered by a specific session
        getBySession(alerts, sessionId) {
            return alerts.filter(a => a.triggeredBySession === sessionId);
        },
        
        getNextId(current) {
            const existing = current.map(a => parseInt(a.id?.replace('DA-', '') || '0'));
            const max = Math.max(0, ...existing);
            return `DA-${String(max + 1).padStart(3, '0')}`;
        },
        
        /**
         * triggerAlerts — Core auto-remediation flow (Phase 5.4)
         * 
         * Called when a user confirms an interface changed during post-session review.
         * For each dependency on the changed interface:
         *   1. Creates a dependency alert
         *   2. Auto-creates a work item in the dependent stream with change context
         *   3. Marks the dependency status as 'changed'
         *   4. Logs to activity feed
         * 
         * The generated work item includes changeContext so when the dependent stream
         * owner preps a Claude session, the session brief includes what changed and why.
         * This is the prompt chain: session output → change context → next session input.
         */
        async triggerAlerts(uid, { interfaceId, changeDescription, changeNotes, sessionId, workItemId, actor, interfaces, dependencies, streams, workItems, alerts }) {
            const iface = interfaces.find(i => i.id === interfaceId);
            if (!iface) return [];
            
            // Find all dependencies that consume this interface
            const affectedDeps = dependencies.filter(d => d.interfaceId === interfaceId);
            if (affectedDeps.length === 0) return [];
            
            const providerStream = streams.find(s => s.id === iface.streamId);
            const results = [];
            
            for (const dep of affectedDeps) {
                const dependentStream = streams.find(s => s.id === dep.dependentStreamId);
                if (!dependentStream) continue;
                
                // 1. Create the alert
                const alertId = this.getNextId(alerts.concat(results.map(r => r.alert)));
                
                // 2. Auto-create a work item in the dependent stream
                const itemId = WorkItemService.getNextId(workItems);
                const workItem = await WorkItemService.create(uid, {
                    id: itemId,
                    appId: dependentStream.appId || iface.appId || '',
                    streamId: dep.dependentStreamId,
                    title: `Update: ${iface.description} changed`,
                    description: `Interface "${iface.description}" provided by ${providerStream?.name || 'unknown stream'} has changed.\n\n**What changed:** ${changeDescription}\n\n**Why this stream is affected:** ${dep.context || 'This stream depends on this interface.'}\n\n**Change notes from source session:**\n${changeNotes || 'No additional notes.'}`,
                    type: 'dependency_update',
                    priority: 'core',
                    status: 'ready',
                    effort: 'session',
                    criteria: [
                        `Verify ${dependentStream.name} works correctly with the updated interface`,
                        `Update any references to: ${iface.description}`
                    ],
                    context: {
                        notes: `Auto-generated from dependency alert ${alertId}. Source session: ${sessionId || 'N/A'}.`,
                        dependencies: [iface.description],
                        relatedItems: workItemId ? [workItemId] : []
                    },
                    tags: ['dependency-update', 'auto-generated'],
                    createdBy: actor,
                    source: 'dependency_alert'
                });
                
                // 3. Create the alert record
                const alert = await this.create(uid, {
                    id: alertId,
                    dependencyId: dep.id,
                    interfaceId: interfaceId,
                    triggeredBySession: sessionId,
                    triggeredByItem: workItemId,
                    changeDescription: changeDescription,
                    changeNotes: changeNotes,
                    triggeredBy: actor,
                    generatedItemId: itemId
                });
                
                // 4. Mark the dependency as 'changed'
                await DependencyService.update(uid, dep.id, { 
                    status: 'changed',
                    lastChangedAt: new Date().toISOString(),
                    lastChangedBy: actor
                });
                
                // 5. Log to activity feed
                ActivityLogService.log(uid, {
                    appId: dependentStream.appId,
                    streamId: dep.dependentStreamId,
                    actor: actor,
                    action: 'dependency_alert',
                    summary: `Dependency alert: "${iface.description}" changed — ${dependentStream.name} has update queued`,
                    metadata: { alertId, interfaceId, dependencyId: dep.id, generatedItemId: itemId }
                }).catch(e => console.warn('[Activity] Dependency alert log failed:', e));
                
                results.push({ alert, workItem, dependency: dep, dependentStream });
            }
            
            return results;
        }
    };
    
    /**
     * TeamService — Multi-person access management (Phase 5.7)
     * Wraps: Firebase RTDB `command-center/{uid}/team` path
     * 
     * Enables shared workspace access. The owner's UID remains the canonical
     * data path — team members read/write to the owner's path with role-based
     * permissions enforced in UI (Firebase rules lock down in production).
     * 
     * Roles:
     *   owner — full access, can manage team members
     *   editor — can create/edit work items, sessions, deploys, streams
     *   viewer — read-only access to all data
     * 
     * Data model:
     *   command-center/{ownerUid}/team/{memberUid} = { email, name, photoURL, role, invitedAt, joinedAt }
     *   command-center/{memberUid}/teamMembership = { ownerUid, role, workspaceName }
     */
    const TeamService = {
        BASE_PATH: 'command-center',
        
        _teamRef(uid) {
            if (!firebaseDb || !uid) return null;
            return firebaseDb.ref(`${this.BASE_PATH}/${uid}/team`);
        },
        
        _membershipRef(uid) {
            if (!firebaseDb || !uid) return null;
            return firebaseDb.ref(`${this.BASE_PATH}/${uid}/teamMembership`);
        },
        
        // Listen for team members (owner's perspective)
        listen(uid, callback) {
            const ref = this._teamRef(uid);
            if (!ref) return () => {};
            
            ref.on('value', (snapshot) => {
                const data = snapshot.val();
                if (data) {
                    const list = Object.entries(data).map(([memberId, member]) => ({ uid: memberId, ...member }));
                    callback(list.sort((a, b) => (a.name || a.email || '').localeCompare(b.name || b.email || '')));
                } else {
                    callback([]);
                }
            });
            
            return () => ref.off();
        },
        
        // Listen for workspaces this user belongs to (member's perspective)
        listenMemberships(uid, callback) {
            const ref = this._membershipRef(uid);
            if (!ref) return () => {};
            
            ref.on('value', (snapshot) => {
                const data = snapshot.val();
                callback(data || null);
            });
            
            return () => ref.off();
        },
        
        // Invite a team member (by email)
        async invite(ownerUid, email, role = 'editor', invitedBy = 'Owner') {
            const ref = this._teamRef(ownerUid);
            if (!ref) return null;
            
            const tempKey = `pending-${btoa(email).replace(/[^a-zA-Z0-9]/g, '').slice(0, 20)}`;
            
            const member = {
                email: email.toLowerCase().trim(),
                name: null,
                photoURL: null,
                role: role,
                status: 'invited',
                invitedAt: new Date().toISOString(),
                invitedBy: invitedBy,
                joinedAt: null
            };
            
            await ref.child(tempKey).set(member);
            console.log(`[TeamService] Invited ${email} as ${role}`);
            return { uid: tempKey, ...member };
        },
        
        // Accept invite — called when invited user signs in
        async acceptInvite(ownerUid, memberUid, memberProfile) {
            const ref = this._teamRef(ownerUid);
            if (!ref) return;
            
            const snap = await ref.once('value');
            const team = snap.val() || {};
            const pendingKey = Object.keys(team).find(k => 
                k.startsWith('pending-') && team[k].email === memberProfile.email?.toLowerCase()
            );
            
            if (!pendingKey) {
                console.warn(`[TeamService] No pending invite for ${memberProfile.email}`);
                return null;
            }
            
            const invite = team[pendingKey];
            
            await ref.child(pendingKey).remove();
            await ref.child(memberUid).set({
                email: memberProfile.email,
                name: memberProfile.displayName || memberProfile.email.split('@')[0],
                photoURL: memberProfile.photoURL || null,
                role: invite.role,
                status: 'active',
                invitedAt: invite.invitedAt,
                invitedBy: invite.invitedBy,
                joinedAt: new Date().toISOString()
            });
            
            // Write membership pointer on the member's node
            await this._membershipRef(memberUid)?.set({
                ownerUid: ownerUid,
                role: invite.role,
                workspaceName: 'Command Center'
            });
            
            console.log(`[TeamService] ${memberProfile.email} joined as ${invite.role}`);
            return { uid: memberUid, role: invite.role };
        },
        
        // Update member role
        async updateRole(ownerUid, memberUid, newRole) {
            const ref = this._teamRef(ownerUid);
            if (!ref) return;
            await ref.child(memberUid).update({ role: newRole });
            await this._membershipRef(memberUid)?.update({ role: newRole });
        },
        
        // Remove team member
        async remove(ownerUid, memberUid) {
            const ref = this._teamRef(ownerUid);
            if (!ref) return;
            await ref.child(memberUid).remove();
            await this._membershipRef(memberUid)?.remove();
        },
        
        // Get the effective workspace UID (owner's UID if member, own UID if owner)
        getWorkspaceUid(currentUid, membership) {
            if (membership?.ownerUid) return membership.ownerUid;
            return currentUid;
        },
        
        canEdit(membership) {
            if (!membership) return true; // Owner
            return membership.role === 'owner' || membership.role === 'editor';
        },
        
        canManageTeam(membership) {
            if (!membership) return true; // Owner
            return membership.role === 'owner';
        },
        
        // Generate Firebase security rules template
        generateRulesTemplate(ownerUid) {
            return JSON.stringify({
                rules: {
                    "command-center": {
                        [ownerUid]: {
                            ".read": `auth.uid === '${ownerUid}' || root.child('command-center/${ownerUid}/team/' + auth.uid).exists()`,
                            ".write": `auth.uid === '${ownerUid}' || (root.child('command-center/${ownerUid}/team/' + auth.uid).exists() && root.child('command-center/${ownerUid}/team/' + auth.uid + '/role').val() !== 'viewer')`,
                            "team": { ".write": `auth.uid === '${ownerUid}'` }
                        },
                        "$uid": {
                            "teamMembership": {
                                ".read": "auth.uid === $uid",
                                ".write": "auth != null"
                            }
                        }
                    }
                }
            }, null, 2);
        }
    };
    
    /**
     * TokenRegistryService — Token estimation and caching
     * Provides heuristic token counting for context budget management.
     * Cache stored in localStorage for instant access during Claude Prep.
     * 
     * Three estimation tiers:
     *   Tier 1: Heuristic (instant, browser-only) — used by default
     *   Tier 2: js-tiktoken (accurate for GPT) — future
     *   Tier 3: Anthropic API countTokens (exact for Claude) — future
     */
    const TokenRegistryService = {
        STORAGE_KEY: 'cc_token_registry',
        
        // Content type ratios (tokens per character) based on empirical data
        RATIOS: {
            code:     0.37,   // ~18 tokens per line, ~49 chars/line (JS/HTML/CSS)
            markdown: 0.35,   // ~1.35 tokens per word, ~3.8 chars/word
            prose:    0.33,   // ~1.3 tokens per word, ~4 chars/word
            json:     0.40,   // Higher due to structural characters
        },
        
        // Detect content type from filename or content
        detectContentType(filename) {
            if (!filename) return 'prose';
            const ext = filename.split('.').pop()?.toLowerCase();
            switch (ext) {
                case 'html': case 'htm': case 'js': case 'jsx': case 'ts':
                case 'tsx': case 'css': case 'scss': case 'py': case 'rb':
                case 'java': case 'c': case 'cpp': case 'go': case 'rs':
                case 'php': case 'sh': case 'bash': case 'yaml': case 'yml':
                case 'xml': case 'svg':
                    return 'code';
                case 'md': case 'mdx': case 'txt':
                    return 'markdown';
                case 'json': case 'jsonl':
                    return 'json';
                default:
                    return 'prose';
            }
        },
        
        // Tier 1: Heuristic token estimation (instant, no dependencies)
        estimateTokens(text, filenameOrType) {
            if (!text) return 0;
            const contentType = this.RATIOS[filenameOrType] 
                ? filenameOrType 
                : this.detectContentType(filenameOrType);
            const ratio = this.RATIOS[contentType] || 0.35;
            return Math.ceil(text.length * ratio);
        },
        
        // Estimate tokens from byte count (when text isn't available)
        estimateFromBytes(bytes, filenameOrType) {
            if (!bytes) return 0;
            const contentType = this.RATIOS[filenameOrType]
                ? filenameOrType
                : this.detectContentType(filenameOrType);
            const ratio = this.RATIOS[contentType] || 0.35;
            return Math.ceil(bytes * ratio);
        },
        
        // Load cached registry from localStorage
        load() {
            try {
                return JSON.parse(localStorage.getItem(this.STORAGE_KEY) || '{}');
            } catch { return {}; }
        },
        
        // Save registry to localStorage
        save(registry) {
            try {
                localStorage.setItem(this.STORAGE_KEY, JSON.stringify(registry));
            } catch (e) {
                console.error('[TokenRegistryService] Save failed:', e);
            }
        },
        
        // Cache a token count for a specific app artifact
        cacheArtifact(appId, path, tokenData) {
            const registry = this.load();
            if (!registry[appId]) registry[appId] = { artifacts: {}, lastScanned: null };
            registry[appId].artifacts[path] = {
                path,
                tokens: tokenData.tokens,
                bytes: tokenData.bytes,
                type: tokenData.type || 'source',
                version: tokenData.version || null,
                lastUpdated: new Date().toISOString()
            };
            registry[appId].lastScanned = new Date().toISOString();
            this.save(registry);
        },
        
        // Get cached data for an app
        getForApp(appId) {
            const registry = this.load();
            return registry[appId] || null;
        },
        
        // Calculate totals from a list of token counts
        calculateTotals(artifacts) {
            const totals = { source: 0, documentation: 0, instructions: 0, total: 0 };
            for (const art of Object.values(artifacts)) {
                const tokens = art.tokens?.estimated || art.tokens || 0;
                const type = art.type || 'source';
                if (totals[type] !== undefined) {
                    totals[type] += tokens;
                }
                totals.total += tokens;
            }
            return totals;
        },
        
        // Format token count for display
        formatTokens(count) {
            if (count >= 1000000) return `${(count / 1000000).toFixed(1)}M`;
            if (count >= 1000) return `${(count / 1000).toFixed(1)}K`;
            return String(count);
        }
    };
    
    /**
     * EngineRegistryService — AI engine profiles and recommendations
     * Static reference data for AI model capabilities, costs, and constraints.
     * User preferences (default engine) stored in localStorage.
     * 
     * Engine profiles inform:
     *   - Context budget calculation in Claude Prep
     *   - Engine recommendation per session type
     *   - Cost estimation per session
     *   - Platform feature awareness (Projects, Skills, Artifacts, etc.)
     */
    const EngineRegistryService = {
        PREF_KEY: 'cc_default_engine',
        
        // Static engine definitions
        ENGINES: {
            'claude-sonnet-4.5': {
                id: 'claude-sonnet-4.5',
                provider: 'anthropic',
                name: 'Claude Sonnet 4.5',
                tier: 'balanced',
                contextWindow: 200000,
                contextWindowExtended: 1000000,
                maxOutput: 64000,
                cost: {
                    input: 3.00,
                    output: 15.00,
                    cacheWrite: 3.75,
                    cacheRead: 0.30,
                    longContextInput: 6.00,
                    longContextOutput: 22.50
                },
                strengths: ['Coding and refactoring', 'Agentic workflows', 'Multi-step reasoning', 'Extended thinking'],
                bestFor: ['coding', 'architecture', 'testing', 'complex-features'],
                notes: 'Default recommendation for most sessions. Best coding model per benchmarks.',
                features: { projects: true, skills: true, artifacts: true, extendedThinking: true, computerUse: true, webSearch: true, memory: true }
            },
            'claude-haiku-4.5': {
                id: 'claude-haiku-4.5',
                provider: 'anthropic',
                name: 'Claude Haiku 4.5',
                tier: 'fast',
                contextWindow: 200000,
                maxOutput: 64000,
                cost: { input: 1.00, output: 5.00, cacheWrite: 1.25, cacheRead: 0.10 },
                strengths: ['Speed', 'Cost efficiency', 'Classification'],
                bestFor: ['quick-fixes', 'text-changes', 'chores', 'research'],
                notes: 'Use for simple bug fixes, text updates, research tasks. 3x cheaper than Sonnet.',
                features: { projects: true, skills: true, artifacts: true, extendedThinking: true, computerUse: true, webSearch: true, memory: true }
            },
            'claude-opus-4.5': {
                id: 'claude-opus-4.5',
                provider: 'anthropic',
                name: 'Claude Opus 4.5',
                tier: 'flagship',
                contextWindow: 200000,
                contextWindowExtended: 1000000,
                maxOutput: 64000,
                cost: { input: 5.00, output: 25.00, cacheWrite: 6.25, cacheRead: 0.50 },
                strengths: ['Most intelligent', 'Complex architecture', 'Novel problem solving'],
                bestFor: ['design', 'architecture', 'complex-debugging', 'research'],
                notes: 'Reserve for high-complexity work: architecture design, novel patterns, difficult debugging.',
                features: { projects: true, skills: true, artifacts: true, extendedThinking: true, computerUse: true, webSearch: true, memory: true }
            },
            'gpt-4.1': {
                id: 'gpt-4.1',
                provider: 'openai',
                name: 'GPT-4.1',
                tier: 'balanced',
                contextWindow: 1000000,
                maxOutput: 32768,
                cost: { input: 2.00, output: 8.00 },
                strengths: ['Large context native', 'Good at instruction following'],
                bestFor: ['large-codebase-review', 'migration'],
                notes: 'Useful when full source must be in context. Cheaper per token but lower coding quality than Sonnet.',
                features: { projects: false, skills: false, artifacts: false }
            },
            'gemini-2.5-pro': {
                id: 'gemini-2.5-pro',
                provider: 'google',
                name: 'Gemini 2.5 Pro',
                tier: 'balanced',
                contextWindow: 2000000,
                maxOutput: 65536,
                cost: { input: 1.25, output: 10.00 },
                strengths: ['Largest context window', 'Multimodal', 'Competitive coding'],
                bestFor: ['full-codebase-analysis', 'design-review', 'documentation'],
                notes: '2M tokens means entire CC codebase fits in one session. Good for architectural review.',
                features: { projects: false, skills: false, artifacts: false }
            }
        },
        
        // Session type → recommended engine mapping
        SESSION_TYPE_ENGINES: {
            'build':    'claude-sonnet-4.5',
            'design':   'claude-opus-4.5',
            'fix':      'claude-sonnet-4.5',
            'test':     'claude-sonnet-4.5',
            'research': 'claude-haiku-4.5',
            'review':   'claude-sonnet-4.5',
            'polish':   'claude-haiku-4.5',
            'document': 'claude-haiku-4.5'
        },
        
        // Work item type → suggested session type
        WORK_ITEM_SESSION_MAP: {
            'feature':     'build',
            'bugfix':      'fix',
            'enhancement': 'build',
            'chore':       'build',
            'research':    'research'
        },
        
        // Get all engines
        getAll() {
            return Object.values(this.ENGINES);
        },
        
        // Get a specific engine
        get(engineId) {
            return this.ENGINES[engineId] || null;
        },
        
        // Get user's default engine
        getDefault() {
            const pref = localStorage.getItem(this.PREF_KEY);
            return pref && this.ENGINES[pref] ? pref : 'claude-sonnet-4.5';
        },
        
        // Set user's default engine
        setDefault(engineId) {
            if (this.ENGINES[engineId]) {
                localStorage.setItem(this.PREF_KEY, engineId);
            }
        },
        
        // Recommend engine for a session type
        recommendForSessionType(sessionType) {
            const engineId = this.SESSION_TYPE_ENGINES[sessionType] || 'claude-sonnet-4.5';
            return this.ENGINES[engineId];
        },
        
        // Recommend engine based on work item
        recommendForWorkItem(workItem) {
            const sessionType = this.WORK_ITEM_SESSION_MAP[workItem.type] || 'build';
            return {
                sessionType,
                engine: this.recommendForSessionType(sessionType)
            };
        },
        
        // Check if a package fits within an engine's context window
        checkBudget(tokenCount, engineId, useExtended = false) {
            const engine = this.get(engineId || this.getDefault());
            if (!engine) return { fits: false, engine: null };
            
            const limit = useExtended && engine.contextWindowExtended 
                ? engine.contextWindowExtended 
                : engine.contextWindow;
            
            // Reserve ~20% for conversation/reasoning room
            const usableLimit = Math.floor(limit * 0.80);
            
            return {
                fits: tokenCount <= usableLimit,
                engine,
                limit,
                usableLimit,
                tokenCount,
                remaining: usableLimit - tokenCount,
                percentUsed: Math.round((tokenCount / usableLimit) * 100),
                overBy: tokenCount > usableLimit ? tokenCount - usableLimit : 0,
                recommendations: this._getBudgetRecommendations(tokenCount, engine, useExtended)
            };
        },
        
        // Generate context budget recommendations
        _getBudgetRecommendations(tokenCount, engine, useExtended) {
            const recs = [];
            const limit = useExtended && engine.contextWindowExtended
                ? engine.contextWindowExtended
                : engine.contextWindow;
            const usableLimit = Math.floor(limit * 0.80);
            
            if (tokenCount <= usableLimit) return recs;
            
            // Over budget — generate recommendations
            if (!useExtended && engine.contextWindowExtended) {
                recs.push({
                    action: 'extended-context',
                    label: `Switch to ${TokenRegistryService.formatTokens(engine.contextWindowExtended)} extended context`,
                    savings: null,
                    cost: engine.cost.longContextInput ? `$${engine.cost.longContextInput}/$${engine.cost.longContextOutput} per MTok` : null
                });
            }
            
            recs.push({
                action: 'architecture-summary',
                label: 'Use architecture summary instead of full source',
                savings: `~${TokenRegistryService.formatTokens(Math.floor(tokenCount * 0.85))} saved`,
                cost: null
            });
            
            recs.push({
                action: 'section-extraction',
                label: 'Include only relevant code sections for this work item',
                savings: `~${TokenRegistryService.formatTokens(Math.floor(tokenCount * 0.90))} saved`,
                cost: null
            });
            
            recs.push({
                action: 'skip-changelog',
                label: 'Skip CHANGELOG.md (low value for build sessions)',
                savings: null,
                cost: null
            });
            
            // Suggest a different engine if this one can't handle it
            const biggerEngines = Object.values(this.ENGINES).filter(e => 
                e.id !== engine.id && 
                (e.contextWindow > limit || (e.contextWindowExtended && e.contextWindowExtended > limit))
            );
            if (biggerEngines.length > 0) {
                const best = biggerEngines.sort((a, b) => 
                    (b.contextWindowExtended || b.contextWindow) - (a.contextWindowExtended || a.contextWindow)
                )[0];
                recs.push({
                    action: 'switch-engine',
                    label: `Switch to ${best.name} (${TokenRegistryService.formatTokens(best.contextWindowExtended || best.contextWindow)} context)`,
                    savings: null,
                    cost: `$${best.cost.input}/$${best.cost.output} per MTok`
                });
            }
            
            return recs;
        },
        
        // Estimate session cost
        estimateSessionCost(packageTokens, outputTokens, engineId) {
            const engine = this.get(engineId || this.getDefault());
            if (!engine) return null;
            
            const inputCost = (packageTokens / 1000000) * engine.cost.input;
            const outputCost = (outputTokens / 1000000) * engine.cost.output;
            
            return {
                inputCost: Math.round(inputCost * 100) / 100,
                outputCost: Math.round(outputCost * 100) / 100,
                totalCost: Math.round((inputCost + outputCost) * 100) / 100,
                engine: engine.name
            };
        }
    };

    // =========================================================================
    // CLAUDE API SERVICE (v8.59.0 — Ingestion Pipeline Phase 2)
    // =========================================================================

    const ClaudeAPIService = {
        getApiKey() {
            try { return localStorage.getItem('cc_anthropic_api_key') || ''; } catch { return ''; }
        },
        isConfigured() { return !!this.getApiKey(); },
        async call({ model = 'claude-haiku-4-5-20251001', system, userMessage, maxTokens = 4096 }) {
            if (IS_TEST_MODE && window.MockClaudeAPIService) return window.MockClaudeAPIService.call({ model, system, userMessage, maxTokens });
            const apiKey = this.getApiKey();
            if (!apiKey) throw new Error('Anthropic API key not configured. Go to Settings → Anthropic API Key to add it.');
            const response = await fetch('https://api.anthropic.com/v1/messages', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'x-api-key': apiKey,
                    'anthropic-version': '2023-06-01',
                    'anthropic-dangerous-direct-browser-access': 'true'
                },
                body: JSON.stringify({
                    model, max_tokens: maxTokens, system,
                    messages: [{ role: 'user', content: userMessage }]
                })
            });
            if (!response.ok) {
                const error = await response.json().catch(() => ({}));
                throw new Error(error.error?.message || `Claude API error: ${response.status}`);
            }
            const data = await response.json();
            return data.content.filter(block => block.type === 'text').map(block => block.text).join('\n');
        }
    };

    // =========================================================================
    // ODRC SUMMARY GENERATOR (v8.59.0)
    // =========================================================================

    const ODRCSummaryGenerator = {
        _renderGroup(type, concepts, ideas) {
            const items = concepts.filter(c => c.type === type && c.status === 'active');
            if (items.length === 0) return '';
            const lines = [`## ${type}s`];
            items.forEach(c => {
                const ideaName = ideas.find(i => i.id === c.ideaOrigin)?.name || 'unknown';
                lines.push(`- ${c.content} *(from: ${ideaName})*`);
            });
            return lines.join('\n');
        },

        generateScoped(concepts, ideas, specId) {
            // Filter concepts with matching specId in scopeTags
            let scoped = concepts.filter(c => c.status === 'active' && (c.scopeTags || []).includes(specId));
            if (scoped.length === 0) scoped = concepts.filter(c => c.status === 'active'); // fallback to full
            const scope = scoped.length === concepts.filter(c => c.status === 'active').length ? 'full active landscape' : `scoped to spec ${specId}`;
            const sections = ODRC_TYPES.map(t => this._renderGroup(t, scoped, ideas)).filter(Boolean);
            return `# ODRC State Summary\nScope: ${scope}\n\n${sections.join('\n\n')}`;
        },

        generateFull(concepts, ideas) {
            const active = concepts.filter(c => c.status === 'active');
            const sections = ODRC_TYPES.map(t => this._renderGroup(t, active, ideas)).filter(Boolean);
            return `# ODRC State Summary\nScope: full active landscape\n\n${sections.join('\n\n')}`;
        }
    };

    // =========================================================================
    // REVIEW PROMPT GENERATOR (v8.59.0)
    // =========================================================================

    const ReviewPromptGenerator = {
        async generateReviewPrompt(completionJob, odrcSummary) {
            const system = `You are a code reviewer for a software project. You will generate a review prompt that another AI assistant will use to validate completed work. The review prompt should instruct the reviewer to check: correctness of implementation, alignment with rules and decisions, side effects or regressions, whether claimed ODRC resolutions are accurate, and completeness of the task. Be specific to the actual work described. Output only the review prompt in markdown.`;
            const userMessage = `Generate a review prompt for this completed work:\n\n## Task\n${completionJob.task}\n\n## Status\n${completionJob.status}\n\n## Files Changed\n${(completionJob.files || []).map(f => `- ${f.path} (${f.action})`).join('\n')}\n\n## ODRC References\n${completionJob.odrc ? JSON.stringify(completionJob.odrc, null, 2) : 'None'}\n\n## Unexpected Findings\n${(completionJob.unexpectedFindings || []).map(f => `- ${f}`).join('\n') || 'None'}\n\n## Unresolved Items\n${(completionJob.unresolved || []).map(u => `- ${u.item}: ${u.reason}`).join('\n') || 'None'}\n\n## Active ODRC State\n${odrcSummary}`;
            return await ClaudeAPIService.call({ system, userMessage });
        },

        async generateClassificationPrompt(completionJob, odrcSummary) {
            const system = `You are helping classify unplanned development work into a project's ODRC (Opens, Decisions, Rules, Constraints) framework. You will generate a classification prompt that another AI assistant will use to: (1) determine if this work resolves any existing OPENs, (2) identify if it aligns with existing DECISIONs or RULEs, (3) suggest new OPENs if gaps were discovered, and (4) categorize the work type (UX fix, performance, integration, bug fix, tech debt, feature, refactor). Output only the classification prompt in markdown.\n\nIMPORTANT: At the end of the prompt, instruct the reviewer to output structured ODRC recommendations in this exact format:\n\n## ODRC Updates\n- RESOLVE OPEN: "description" → matched to concept_id {id}\n- NEW OPEN: "description" → tag to Idea {name}\n- NEW OPEN: "description" → untagged\n- NEW DECISION: "description"`;
            const userMessage = `Generate a classification prompt for this unplanned work:\n\n## Task\n${completionJob.task}\n\n## Status\n${completionJob.status}\n\n## Files Changed\n${(completionJob.files || []).map(f => `- ${f.path} (${f.action})`).join('\n')}\n\n## Full ODRC Landscape\n${odrcSummary}`;
            return await ClaudeAPIService.call({ system, userMessage });
        },

        async generateBatchClassificationPrompt(jobs, odrcSummary) {
            const system = `You are helping classify multiple pieces of unplanned development work into a project's ODRC (Opens, Decisions, Rules, Constraints) framework. For each job, determine: (1) if it resolves any existing OPENs, (2) if it aligns with existing DECISIONs or RULEs, (3) what new OPENs were discovered, and (4) the work category (UX fix, performance, integration, bug fix, tech debt, feature, refactor).\n\nOutput your analysis for each job, then a consolidated ODRC Updates section at the end using this exact format:\n\n## ODRC Updates\n- RESOLVE OPEN: "description" → matched to concept_id {id}\n- NEW OPEN: "description" → tag to Idea {name}\n- NEW OPEN: "description" → untagged\n- NEW DECISION: "description"`;
            const jobSummaries = jobs.map((job, i) => {
                let summary = `### Job ${i + 1}: ${job.task}\nStatus: ${job.status}\nFiles: ${(job.files || []).map(f => f.path).join(', ')}\nCommits: ${(job.commits || []).map(c => c.message).join('; ')}`;
                if (job.unexpectedFindings?.length) summary += `\nUnexpected: ${job.unexpectedFindings.join('; ')}`;
                if (job.unresolved?.length) summary += `\nUnresolved: ${job.unresolved.map(u => u.item).join('; ')}`;
                return summary;
            }).join('\n\n');
            const userMessage = `Classify the following ${jobs.length} unplanned jobs:\n\n${jobSummaries}\n\n## Full ODRC Landscape\n${odrcSummary}`;
            return await ClaudeAPIService.call({ system, userMessage, maxTokens: 8192 });
        }
    };

    // =========================================================================
    // VALIDATION BUNDLE ASSEMBLER (v8.59.0)
    // =========================================================================

    const ValidationBundleAssembler = {
        async assemble({ completionJob, github, repoFullName, globalConcepts, globalIdeas, bundleSizeLimit = 5242880, onProgress }) {
            const zip = new JSZip();
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const bundleName = `validation-bundle-${timestamp}`;
            const errors = [];
            const excluded = [];

            // Step 1: Fetch completion file
            onProgress('fetching-completion', 'Reading completion file from repo...');
            try {
                const completionContent = await github.getFileContent(repoFullName, `cc/completions/${completionJob.fileName}`);
                if (completionContent?.textContent) {
                    zip.file('completion-file.md', completionContent.textContent);
                } else {
                    errors.push('Could not fetch completion file — using cached data');
                    zip.file('completion-file.md', this._reconstructFromCache(completionJob));
                }
            } catch (e) {
                errors.push('Could not fetch completion file — using cached data');
                zip.file('completion-file.md', this._reconstructFromCache(completionJob));
            }

            // Step 2: Fetch spec
            onProgress('fetching-spec', 'Reading spec archive...');
            try {
                if (completionJob.specId) {
                    const specContent = await github.getFileContent(repoFullName, `cc/specs/${completionJob.specId}.md`);
                    if (specContent?.textContent) {
                        zip.file('spec.md', specContent.textContent);
                    } else {
                        const currentSpec = await github.getFileContent(repoFullName, 'CLAUDE.md');
                        if (currentSpec?.textContent) {
                            zip.file('spec.md', currentSpec.textContent);
                            errors.push('Archived spec not found — included current CLAUDE.md instead');
                        }
                    }
                } else {
                    const currentSpec = await github.getFileContent(repoFullName, 'CLAUDE.md');
                    if (currentSpec?.textContent) zip.file('spec.md', currentSpec.textContent);
                }
            } catch (e) { errors.push(`Spec fetch error: ${e.message}`); }

            // Step 3: Fetch changed code files
            onProgress('fetching-files', `Fetching ${completionJob.files?.length || 0} changed files...`);
            let totalFileSize = 0;
            for (const file of (completionJob.files || [])) {
                try {
                    const fileContent = await github.getFileContent(repoFullName, file.path);
                    if (fileContent?.textContent) {
                        const fileSize = new Blob([fileContent.textContent]).size;
                        if (totalFileSize + fileSize > bundleSizeLimit) {
                            excluded.push({ path: file.path, size: fileSize, reason: 'Bundle size limit exceeded' });
                            continue;
                        }
                        zip.file(`files/${file.path}`, fileContent.textContent);
                        totalFileSize += fileSize;
                    }
                } catch (e) { errors.push(`Could not fetch ${file.path}: ${e.message}`); }
            }

            // Step 4: Generate ODRC summary
            onProgress('generating-summary', 'Building ODRC state summary...');
            const isPlanned = !!completionJob.specId;
            const odrcSummary = isPlanned
                ? ODRCSummaryGenerator.generateScoped(globalConcepts, globalIdeas, completionJob.specId)
                : ODRCSummaryGenerator.generateFull(globalConcepts, globalIdeas);
            zip.file('odrc-summary.md', odrcSummary);

            // Step 5: Generate review prompt via Claude API
            onProgress('generating-prompt', 'Generating review prompt via Claude API...');
            try {
                const prompt = isPlanned
                    ? await ReviewPromptGenerator.generateReviewPrompt(completionJob, odrcSummary)
                    : await ReviewPromptGenerator.generateClassificationPrompt(completionJob, odrcSummary);
                zip.file('review-prompt.md', prompt);
            } catch (e) {
                errors.push(`Review prompt generation failed: ${e.message}`);
                zip.file('review-prompt.md', this._staticPromptFallback(completionJob, isPlanned));
            }

            // Step 6: Manifest
            const manifest = {
                bundleName, createdAt: new Date().toISOString(),
                completionFile: completionJob.fileName, repo: repoFullName,
                specId: completionJob.specId || null, mode: isPlanned ? 'review' : 'classification',
                filesIncluded: (completionJob.files || []).filter(f => !excluded.find(e => e.path === f.path)).map(f => f.path),
                filesExcluded: excluded.map(e => ({ path: e.path, reason: e.reason })),
                errors
            };
            zip.file('manifest.json', JSON.stringify(manifest, null, 2));

            // Step 7: Generate zip
            onProgress('building-zip', 'Compressing bundle...');
            const blob = await zip.generateAsync({ type: 'blob' });
            onProgress('done', `Bundle ready: ${(blob.size / 1024).toFixed(1)} KB`);
            return { blob, bundleName, manifest };
        },

        download(blob, bundleName) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url; a.download = `${bundleName}.zip`;
            document.body.appendChild(a); a.click();
            document.body.removeChild(a); URL.revokeObjectURL(url);
        },

        _reconstructFromCache(job) {
            return ['---', `task: "${job.task}"`, `status: ${job.status}`, 'files:',
                ...(job.files || []).map(f => `  - path: "${f.path}"\n    action: ${f.action}`),
                'commits:', ...(job.commits || []).map(c => `  - sha: "${c.sha}"\n    message: "${c.message}"`),
                '---', '', '*Reconstruction from cached data. Original file could not be fetched.*'
            ].join('\n');
        },

        _staticPromptFallback(job, isPlanned) {
            const header = isPlanned ? '# Review Prompt' : '# Classification Prompt';
            const instructions = isPlanned
                ? '1. **Correctness** — Does the implementation match the task?\n2. **Rule compliance** — Were all RULEs followed?\n3. **Side effects** — Could changes break anything?\n4. **ODRC alignment** — Are claimed resolutions accurate?\n5. **Completeness** — Is the task fully done?'
                : '1. **Match to existing OPENs** — Does this resolve any?\n2. **Categorize** — What type of work? (UX fix, performance, bug fix, feature, refactor)\n3. **New OPENs** — Any new questions or gaps?';
            return `${header}\n\n*Static fallback — Claude API call failed during assembly.*\n\n## Instructions\n\n${instructions}\n\n## ODRC Update Format\n\n\`\`\`\n## ODRC Updates\n- RESOLVE OPEN: "description" → resolution explanation\n- NEW OPEN: "description" → tag to Idea {name}\n- NEW DECISION: "description"\n\`\`\``;
        }
    };

    // =========================================================================
    // ORPHAN DETECTION SERVICE (v8.60.0 — Phase 3)
    // =========================================================================

    const OrphanDetectionService = {
        _ref(uid) {
            return firebase.database().ref(`command-center/${uid}/orphanCommits`);
        },
        async create(uid, orphanData) {
            const ref = this._ref(uid).push();
            const record = { ...orphanData, id: ref.key };
            await ref.set(record);
            console.log('[CC] OrphanDetectionService.create:', record.commitSha?.slice(0, 7));
            return record;
        },
        async getAll(uid) {
            const snap = await this._ref(uid).once('value');
            const val = snap.val();
            return val ? Object.values(val) : [];
        },
        async getByRepo(uid, repoFullName) {
            const all = await this.getAll(uid);
            return all.filter(o => o.repoFullName === repoFullName);
        },
        async updateState(uid, orphanId, newState) {
            await this._ref(uid).child(orphanId).update({ state: newState });
            console.log('[CC] OrphanDetectionService.updateState:', orphanId, '->', newState);
        },
        listen(uid, callback) {
            const ref = this._ref(uid);
            const handler = (snap) => {
                const val = snap.val();
                callback(val ? Object.values(val) : []);
            };
            ref.on('value', handler);
            return () => ref.off('value', handler);
        }
    };

    // =========================================================================
    // ODRC UPDATE INGESTION SERVICE (v8.60.0 — Phase 3)
    // =========================================================================

    const ODRCUpdateIngestionService = {
        // Parse structured ODRC update text into actionable items
        // Tolerant of minor format variations (quotes, arrow styles, whitespace)
        parse(text) {
            const updates = [];
            const lines = text.split('\n').map(l => l.trim()).filter(l => l.startsWith('- '));

            for (const line of lines) {
                // Normalize arrow formats: →, ->, ==>
                const normalized = line.replace(/\s*(?:→|->|==>)\s*/g, ' → ');

                // Priority 1: RESOLVE OPEN: "desc" → matched to concept_id xyz (strict)
                const resolveMatch = normalized.match(/^- RESOLVE OPEN:\s*"?(.+?)"?\s*→\s*matched to concept_id\s+(.+)$/i);
                if (resolveMatch) {
                    updates.push({ action: 'resolve', type: 'OPEN', description: resolveMatch[1].trim(), conceptId: resolveMatch[2].trim() });
                    continue;
                }

                // Priority 2: RESOLVE OPEN {N}: "desc" → resolution text (numbered format)
                // v8.61.1: Flex RESOLVE patterns — conceptId null, store resolution text
                const resolveNumberedMatch = normalized.match(/^- RESOLVE OPEN\s+\d+:\s*"?(.+?)"?\s*→\s*(.+)$/i);
                if (resolveNumberedMatch) {
                    updates.push({ action: 'resolve', type: 'OPEN', description: resolveNumberedMatch[1].trim(), conceptId: null, resolution: resolveNumberedMatch[2].trim() });
                    continue;
                }

                // Priority 3: RESOLVE OPEN: "desc" → freeform resolution text
                const resolveFlexMatch = normalized.match(/^- RESOLVE OPEN:\s*"?(.+?)"?\s*→\s*(.+)$/i);
                if (resolveFlexMatch) {
                    updates.push({ action: 'resolve', type: 'OPEN', description: resolveFlexMatch[1].trim(), conceptId: null, resolution: resolveFlexMatch[2].trim() });
                    continue;
                }

                // NEW {TYPE}: "desc" → tag to Idea {name}
                const newTaggedMatch = normalized.match(/^- NEW (OPEN|DECISION|RULE|CONSTRAINT):\s*"?(.+?)"?\s*→\s*tag to Idea\s+(.+)$/i);
                if (newTaggedMatch) {
                    updates.push({ action: 'create', type: newTaggedMatch[1].toUpperCase(), description: newTaggedMatch[2].trim(), targetIdea: newTaggedMatch[3].trim() });
                    continue;
                }

                // NEW {TYPE}: "desc" → untagged
                const newUntaggedMatch = normalized.match(/^- NEW (OPEN|DECISION|RULE|CONSTRAINT):\s*"?(.+?)"?\s*→\s*untagged$/i);
                if (newUntaggedMatch) {
                    updates.push({ action: 'create', type: newUntaggedMatch[1].toUpperCase(), description: newUntaggedMatch[2].trim(), targetIdea: null });
                    continue;
                }

                // NEW {TYPE}: "desc" (no routing specified)
                const newSimpleMatch = normalized.match(/^- NEW (OPEN|DECISION|RULE|CONSTRAINT):\s*"?(.+?)"?\s*$/i);
                if (newSimpleMatch) {
                    updates.push({ action: 'create', type: newSimpleMatch[1].toUpperCase(), description: newSimpleMatch[2].trim(), targetIdea: null });
                    continue;
                }

                // Log unparseable lines
                if (line.includes('OPEN') || line.includes('DECISION') || line.includes('RULE') || line.includes('CONSTRAINT')) {
                    console.log('[CC] ODRCUpdateIngestionService: unparseable line:', line);
                }
            }

            return updates;
        },

        // Execute confirmed updates against Firebase
        async execute(uid, updates, globalIdeas) {
            const results = [];
            for (const update of updates) {
                try {
                    if (update.action === 'resolve' && update.conceptId) {
                        await ConceptManager.resolve(uid, update.conceptId);
                        results.push({ ...update, status: 'success' });
                    } else if (update.action === 'resolve' && !update.conceptId && update.overrideConceptId) {
                        // v8.61.1: Flex RESOLVE — user selected the OPEN to resolve via checklist dropdown
                        await ConceptManager.resolve(uid, update.overrideConceptId);
                        results.push({ ...update, status: 'success', resolvedConceptId: update.overrideConceptId });
                    } else if (update.action === 'resolve' && !update.conceptId && !update.overrideConceptId) {
                        // v8.61.1: Flex RESOLVE — no concept selected, skip
                        results.push({ ...update, status: 'skipped', reason: 'No OPEN selected for resolution' });
                    } else if (update.action === 'create') {
                        let ideaId = null;
                        if (update.targetIdea) {
                            const idea = globalIdeas.find(i => i.name.toLowerCase().includes(update.targetIdea.toLowerCase()));
                            ideaId = idea?.id || null;
                        }
                        // Use overrideIdeaId if user selected a different idea in the UI
                        const finalIdeaId = update.overrideIdeaId !== undefined ? update.overrideIdeaId : ideaId;
                        await ConceptManager.create(uid, { type: update.type, content: update.description, ideaOrigin: finalIdeaId, scopeTags: [] });
                        results.push({ ...update, status: 'success', resolvedIdeaId: finalIdeaId });
                    }
                } catch (e) {
                    results.push({ ...update, status: 'error', error: e.message });
                }
            }
            return results;
        }
    };

    // =========================================================================
    // SESSION PACKAGE PROCESSOR (v8.66.0 — Session JSON Ingestion)
    // =========================================================================

    const SESSION_JSON_SCHEMA_VERSION = '1.0.0';

    const SessionPackageProcessor = {
        validate(sessionData) {
            const errors = [];
            const warnings = [];
            const requiredRoot = ['schema_version', 'session_id', 'date', 'idea', 'app', 'context_summary', 'session_config', 'chain', 'odrc', 'debrief_summary', 'next_session', 'artifacts'];
            for (const field of requiredRoot) {
                if (sessionData[field] === undefined || sessionData[field] === null) {
                    errors.push(`Missing required field: ${field}`);
                }
            }
            if (sessionData.schema_version && sessionData.schema_version !== SESSION_JSON_SCHEMA_VERSION) {
                warnings.push(`Schema version mismatch: expected ${SESSION_JSON_SCHEMA_VERSION}, got ${sessionData.schema_version}`);
            }
            if (sessionData.idea) {
                if (!sessionData.idea.slug) errors.push('Missing idea.slug');
                if (!sessionData.idea.id) errors.push('Missing idea.id');
                const validPhases = ['inception', 'exploring', 'converging', 'spec-ready', 'complete'];
                if (sessionData.idea.phase && !validPhases.includes(sessionData.idea.phase)) {
                    warnings.push(`Unknown idea phase: ${sessionData.idea.phase}`);
                }
            }
            if (sessionData.chain) {
                if (typeof sessionData.chain.link_count !== 'number') errors.push('chain.link_count must be a number');
                if (!Array.isArray(sessionData.chain.links)) errors.push('chain.links must be an array');
            }
            if (sessionData.odrc) {
                if (!Array.isArray(sessionData.odrc.items)) errors.push('odrc.items must be an array');
                const validTypes = ['decision', 'rule', 'constraint', 'open_new', 'open_resolved'];
                (sessionData.odrc.items || []).forEach((item, i) => {
                    if (!validTypes.includes(item.type)) errors.push(`odrc.items[${i}]: invalid type "${item.type}"`);
                    if (!item.text) errors.push(`odrc.items[${i}]: missing text`);
                });
            }
            if (sessionData.artifacts && !Array.isArray(sessionData.artifacts)) {
                errors.push('artifacts must be an array');
            }
            return { valid: errors.length === 0, errors, warnings };
        },

        mapODRCType(jsonType) {
            switch (jsonType) {
                case 'decision': return 'DECISION';
                case 'rule': return 'RULE';
                case 'constraint': return 'CONSTRAINT';
                case 'open_new': return 'OPEN';
                case 'open_resolved': return 'OPEN';
                default: return null;
            }
        },

        toIngestionUpdates(sessionData) {
            const updates = [];
            for (const item of (sessionData.odrc?.items || [])) {
                if (item.type === 'open_resolved') {
                    updates.push({
                        action: 'resolve',
                        type: 'OPEN',
                        description: item.original_open || item.text,
                        conceptId: null,
                        resolution: item.text
                    });
                } else {
                    const mappedType = this.mapODRCType(item.type);
                    if (mappedType) {
                        updates.push({
                            action: 'create',
                            type: mappedType,
                            description: item.text,
                            targetIdea: null,
                            sourceLink: item.source_link,
                            isTangent: item.is_tangent || false,
                            affinity: item.affinity || null,
                            targetIdeaSlug: (item.is_tangent && item.affinity)
                                ? item.affinity : null
                        });
                    }
                }
            }
            return updates;
        },

        buildSessionLogEntry(sessionData) {
            const odrc = sessionData.odrc?.counts || {};
            return {
                sessionId: sessionData.session_id,
                date: sessionData.date,
                summary: sessionData.context_summary,
                conceptsCreated: (odrc.decisions_new || 0) + (odrc.rules_new || 0) + (odrc.constraints_new || 0) + (odrc.opens_new || 0),
                conceptsResolved: odrc.opens_resolved || 0,
                type: sessionData.session_config?.mode || 'exploration',
                chain: sessionData.chain ? {
                    linkCount: sessionData.chain.link_count,
                    summation: sessionData.chain.summation,
                    totalConceptBlocks: (sessionData.chain.links || []).reduce((sum, l) => sum + (l.concept_blocks || 0), 0),
                    totalElapsedMinutes: (sessionData.chain.links || []).reduce((sum, l) => sum + (l.elapsed_minutes || 0), 0)
                } : null,
                debriefSummary: sessionData.debrief_summary || null,
                nextSession: sessionData.next_session || null,
                schemaVersion: sessionData.schema_version
            };
        },

        extractMetadata(sessionData) {
            return {
                ideaSlug: sessionData.idea?.slug || null,
                ideaId: sessionData.idea?.id || null,
                sessionNumber: sessionData.session_id || null,
                appId: sessionData.app || null
            };
        },

        // v8.69.0: Extract debrief data from session package
        extractDebrief(sessionData, debriefContent) {
            return {
                summary: sessionData.debrief_summary || null,
                fullContent: debriefContent || null,
                nextSession: sessionData.next_session || null
            };
        }
    };

    // v8.69.0: Detect whether a zip is a session package (contains session.json at root)
    function isSessionPackageZip(zip) {
        const paths = [];
        zip.forEach((path) => paths.push(path));
        const hasSessionJson = paths.some(p =>
            p === 'session.json' || p.endsWith('/session.json')
        );
        const hasDebrief = paths.some(p =>
            p === 'debrief.md' || p.endsWith('/debrief.md')
        );
        return { isSessionPackage: hasSessionJson, hasDebrief };
    }

    // =========================================================================
    // ODRC CONTENT DETECTION (v8.61.0 — Idea-to-Chat Pipeline Phase 3)
    // =========================================================================

    // Detect ODRC content in file text (content-based detection)
    // v8.61.1: Tightened — skip matches inside code blocks, require 3+ matches without header
    function detectODRCContent(fileContent) {
        if (!fileContent || typeof fileContent !== 'string') return false;

        // Primary signal: ## ODRC Updates header (no false positive risk — this is our known header)
        const hasODRCHeader = /^##\s+ODRC Updates/m.test(fileContent);
        if (hasODRCHeader) return true;

        // Secondary signal: 3+ ODRC action lines outside of code blocks
        // Build code block ranges to exclude documentation/examples
        const codeBlockRanges = [];
        const codeBlockRegex = /```[\s\S]*?```/g;
        let cbMatch;
        while ((cbMatch = codeBlockRegex.exec(fileContent)) !== null) {
            codeBlockRanges.push([cbMatch.index, cbMatch.index + cbMatch[0].length]);
        }
        const isInCodeBlock = (pos) => {
            const lineStart = fileContent.lastIndexOf('\n', pos) + 1;
            return codeBlockRanges.some(([start, end]) => lineStart >= start && lineStart < end);
        };

        // Count all ODRC action line matches outside code blocks
        const odrcLineRegex = /^-\s+(?:NEW\s+(?:DECISION|OPEN|RULE|CONSTRAINT)|RESOLVE\s+OPEN):/gm;
        let realMatches = 0;
        let m;
        while ((m = odrcLineRegex.exec(fileContent)) !== null) {
            if (!isInCodeBlock(m.index)) realMatches++;
        }

        return realMatches >= 3;
    }

    // Extract metadata from ODRC content header block
    function extractODRCMetadata(fileContent) {
        if (!fileContent || typeof fileContent !== 'string') return { ideaSlug: null, ideaId: null, sessionNumber: null, appId: null };
        const ideaMatch = fileContent.match(/^#\s*Idea:\s*(.+)$/m);
        const ideaIdMatch = fileContent.match(/^#\s*IdeaId:\s*(.+)$/m); // v8.64.0 A3
        const sessionMatch = fileContent.match(/^#\s*Session:\s*(.+)$/m);
        const appMatch = fileContent.match(/^#\s*App:\s*(.+)$/m);

        // v8.64.2: Validate ideaSlug — reject placeholder markers like "(new — needs creation)"
        let ideaSlug = ideaMatch ? ideaMatch[1].trim() : null;
        if (ideaSlug && (
            ideaSlug.startsWith('(') ||       // parenthesized markers
            ideaSlug.includes('—') ||          // em-dash (non-slug char)
            ideaSlug.includes('…') ||          // ellipsis
            /^(new|none|tbd|todo|create)/i.test(ideaSlug) || // common placeholder words
            !/[a-z0-9]/.test(ideaSlug)         // no alphanumeric chars at all
        )) {
            console.log('[CC] extractODRCMetadata: rejected invalid slug:', ideaSlug);
            ideaSlug = null;
        }

        return {
            ideaSlug,
            ideaId: ideaIdMatch ? ideaIdMatch[1].trim() : null, // v8.64.0 A3: Firebase key for unambiguous routing
            sessionNumber: sessionMatch ? sessionMatch[1].trim() : null,
            appId: appMatch ? appMatch[1].trim() : null
        };
    }

    // Extract the ODRC Updates section from a larger document
    function extractODRCSection(fileContent) {
        if (!fileContent || typeof fileContent !== 'string') return null;
        const odrcStart = fileContent.indexOf('## ODRC Updates');
        if (odrcStart === -1) return null;
        return fileContent.substring(odrcStart);
    }

    // v8.62.0 B2: Detect session type from inbound file content
    function detectSessionType(fileContent) {
        if (!fileContent || typeof fileContent !== 'string') return 'exploration';
        if (/^# CLAUDE\.md/m.test(fileContent)) return 'claude-md';
        if (/^## Task Summary/m.test(fileContent) && /^## What to Build/m.test(fileContent)) return 'spec';
        return 'exploration';
    }

    // v8.66.0: Detect inbound artifact type — four-path routing (added session-json)
    function detectInboundArtifactType(fileContent) {
        if (!fileContent || typeof fileContent !== 'string') return null;
        // Check for session.json (highest priority — contains ODRC data inside JSON)
        try {
            const parsed = JSON.parse(fileContent);
            if (parsed.schema_version && parsed.session_id && parsed.odrc) return 'session-json';
        } catch {} // Not JSON, continue to other checks
        // Check for ODRC updates (existing detection)
        if (detectODRCContent(fileContent)) return 'odrc';
        // Check for CLAUDE.md (has both header and spec-id)
        if (/^# CLAUDE\.md/m.test(fileContent) && /^# cc-spec-id:/m.test(fileContent)) return 'claude-md';
        // Check for spec document
        if (/^## Task Summary/m.test(fileContent) && /^## What to Build/m.test(fileContent)) return 'spec';
        return null; // Not a pipeline artifact
    }

    // Duplicate detection — compare new item against existing concepts
    // Returns array of { existingConcept, overlapPercent } for potential matches
    function findDuplicateConcepts(newDescription, existingConcepts) {
        const COMMON_WORDS = new Set(['the', 'is', 'a', 'an', 'and', 'for', 'to', 'in', 'of', 'on', 'at', 'by', 'or', 'be', 'as', 'it', 'with', 'that', 'this', 'are', 'was', 'not', 'but', 'from', 'have', 'has', 'will', 'should', 'can', 'all', 'each', 'when', 'if', 'no']);
        const tokenize = (text) => text.toLowerCase().replace(/[^a-z0-9\s]/g, '').split(/\s+/).filter(w => w.length > 1 && !COMMON_WORDS.has(w));
        const newWords = new Set(tokenize(newDescription));
        if (newWords.size === 0) return [];

        const matches = [];
        for (const concept of existingConcepts) {
            const existingWords = new Set(tokenize(concept.content));
            if (existingWords.size === 0) continue;
            const shorter = Math.min(newWords.size, existingWords.size);
            let overlap = 0;
            for (const w of newWords) {
                if (existingWords.has(w)) overlap++;
            }
            const overlapPercent = overlap / shorter;
            if (overlapPercent > 0.5) {
                matches.push({ existingConcept: concept, overlapPercent: Math.round(overlapPercent * 100) });
            }
        }
        return matches.sort((a, b) => b.overlapPercent - a.overlapPercent);
    }

    // Execute ODRC import — write concepts, generate summary, add session log entry
    async function executeODRCImport(uid, linkedIdea, checkedItems, globalIdeas, github, app, sessionType, pendingImport) {
        // v8.69.0: Separate tangent items that route to different ideas
        const primaryItems = [];
        const tangentRoutes = {}; // { ideaId: [items] }

        for (const item of checkedItems) {
            if (item.targetIdeaSlug && item.targetIdeaSlug !== (linkedIdea.slug || IdeaManager.generateSlug(linkedIdea.name))) {
                const targetIdea = (globalIdeas || []).find(i =>
                    i.slug === item.targetIdeaSlug ||
                    IdeaManager.generateSlug(i.name) === item.targetIdeaSlug
                );
                if (targetIdea) {
                    if (!tangentRoutes[targetIdea.id]) tangentRoutes[targetIdea.id] = [];
                    tangentRoutes[targetIdea.id].push({
                        ...item,
                        overrideIdeaId: targetIdea.id
                    });
                    continue;
                }
                console.warn('[CC] Tangent affinity unresolved:', item.targetIdeaSlug, '— falling back to primary idea');
            }
            primaryItems.push(item);
        }

        // 1. Execute primary items on linked idea
        const updatesForExecution = primaryItems.map(item => ({
            ...item,
            overrideIdeaId: item.action === 'create' ? linkedIdea.id : undefined
        }));
        const results = await ODRCUpdateIngestionService.execute(uid, updatesForExecution, globalIdeas);

        const created = results.filter(r => r.action === 'create' && r.status === 'success').length;
        const resolved = results.filter(r => r.action === 'resolve' && r.status === 'success').length;

        // v8.69.0: Execute tangent items on their target ideas
        let tangentCreated = 0;
        for (const [ideaId, items] of Object.entries(tangentRoutes)) {
            try {
                const tangentResults = await ODRCUpdateIngestionService.execute(uid, items, globalIdeas);
                tangentCreated += tangentResults.filter(r => r.action === 'create' && r.status === 'success').length;
            } catch (e) {
                console.warn('[CC] Tangent routing failed for idea', ideaId, ':', e.message);
            }
        }

        // 2. Generate summary via ClaudeAPIService (best-effort)
        let summary = `${created} concept(s) created, ${resolved} OPEN(s) resolved`;
        if (tangentCreated > 0) summary += `, ${tangentCreated} tangent(s) routed`;
        try {
            if (ClaudeAPIService.isConfigured()) {
                summary = await ClaudeAPIService.call({
                    model: 'claude-haiku-4-5-20251001',
                    system: 'Generate a one-sentence summary of these ODRC updates for a session log. Be concise.',
                    userMessage: checkedItems.map(i => `${i.action} ${i.type}: ${i.description}`).join('\n'),
                    maxTokens: 200
                });
            }
        } catch (e) {
            console.warn('[CC] Summary generation failed, using default:', e.message);
        }

        // 3. Add session log entry — enriched from session.json if available
        let sessionLogEntry;
        if (pendingImport?.sessionData) {
            sessionLogEntry = SessionPackageProcessor.buildSessionLogEntry(pendingImport.sessionData);
            const defaultSummary = `${created} concept(s) created, ${resolved} OPEN(s) resolved`;
            if (tangentCreated > 0 && summary === defaultSummary) {
                summary += `, ${tangentCreated} tangent(s) routed`;
            }
            if (summary !== defaultSummary) {
                sessionLogEntry.summary = summary;
            }
            sessionLogEntry.conceptsCreated = created;
            sessionLogEntry.conceptsResolved = resolved;
        } else {
            const sessionNum = (linkedIdea.sessionLog?.length || 0) + 1;
            const sessionId = generateSessionId(sessionNum);
            const slug = linkedIdea.slug || IdeaManager.generateSlug(linkedIdea.name);
            const docPath = `docs/sessions/${slug}/${sessionId}.md`;
            sessionLogEntry = {
                sessionId,
                date: Date.now(),
                docPath,
                summary,
                conceptsCreated: created,
                conceptsResolved: resolved,
                type: sessionType || 'exploration'
            };
        }

        // v8.67.0: Enrich with lifecycle fields if active session exists
        if (linkedIdea.activeSession) {
            sessionLogEntry.status = 'complete';
            sessionLogEntry.completedAt = new Date().toISOString();
            sessionLogEntry.ideaPhaseAtStart = linkedIdea.activeSession.ideaPhaseAtStart;
            sessionLogEntry.ideaPhaseAtEnd = linkedIdea.phase || computeIdeaPhase(
                (await ConceptManager.getByIdea(uid, linkedIdea.id)) || []
            );
        }

        await IdeaManager.addSessionLogEntry(uid, linkedIdea.id, sessionLogEntry);

        // v8.69.0: Store debrief if present (fire-and-forget after primary import)
        if (pendingImport?.debriefContent) {
            try {
                await IdeaManager.storeDebrief(uid, linkedIdea.id,
                    sessionLogEntry.sessionId, {
                        summary: pendingImport.sessionData?.debrief_summary || null,
                        content: pendingImport.debriefContent,
                        nextSession: pendingImport.sessionData?.next_session || null
                    }
                );
            } catch (e) {
                console.warn('[CC] Debrief storage failed:', e.message);
            }
        }

        // v8.67.0: Clear active session after successful import
        if (linkedIdea.activeSession) {
            await IdeaManager.completeSession(uid, linkedIdea.id);
        }

        // 4. Return results for display
        return { created, resolved, tangentCreated, summary, sessionId: sessionLogEntry.sessionId };
    }

    // =========================================================================
    // SESSION TYPES + SESSION BRIEF GENERATOR (v8.25.0 — Phase 2.1)
    // =========================================================================

    // (Domain services extracted to Infrastructure satellite: PorkbunService, GoDaddyService, DomainProviderRegistry)
    

    // [v8.63.0] SESSION_TYPES and SessionBriefGenerator removed — replaced by IdeationBriefGenerator
    // Minimal stubs retained for ClaudePrepModal backward compatibility
    const SESSION_TYPES = {
        build: { id: 'build', label: 'Build', icon: '🔨', description: 'Implement features', suggestedEngine: 'claude-sonnet-4.5', roleFrame: 'Build new functionality.', scopeRules: [], deliveryRequirements: [], contextStrategy: { alwaysInclude: [], preferInclude: [], skipWhenTight: [], includeSource: true }, workItemFocus: '', autoSuggestFrom: ['feature', 'enhancement', 'chore'] },
        fix: { id: 'fix', label: 'Fix', icon: '🔧', description: 'Fix bugs', suggestedEngine: 'claude-sonnet-4.5', roleFrame: 'Fix reported issues.', scopeRules: [], deliveryRequirements: [], contextStrategy: { alwaysInclude: [], preferInclude: [], skipWhenTight: [], includeSource: true }, workItemFocus: '', autoSuggestFrom: ['bugfix'] },
        design: { id: 'design', label: 'Design', icon: '🎨', description: 'Design features', suggestedEngine: 'claude-opus-4.5', roleFrame: 'Design systems.', scopeRules: [], deliveryRequirements: [], contextStrategy: { alwaysInclude: [], preferInclude: [], skipWhenTight: [], includeSource: true }, workItemFocus: '', autoSuggestFrom: ['research'] },
        review: { id: 'review', label: 'Review', icon: '👁️', description: 'Review code', suggestedEngine: 'claude-sonnet-4.5', roleFrame: 'Review quality.', scopeRules: [], deliveryRequirements: [], contextStrategy: { alwaysInclude: [], preferInclude: [], skipWhenTight: [], includeSource: true }, workItemFocus: '', autoSuggestFrom: [] }
    };
    const SessionBriefGenerator = {
        generate() { return ''; },
        getAll() { return Object.values(SESSION_TYPES); },
        get(id) { return SESSION_TYPES[id] || null; },
        suggestFromWorkItem(wi) { return 'build'; },
        getFileStrategy(t) { return SESSION_TYPES[t]?.contextStrategy || { alwaysInclude: [], preferInclude: [], skipWhenTight: [], includeSource: true }; }
    };
    
    // =========================================================================
    // IDEATION BRIEF GENERATOR (v8.61.0 — Idea-to-Chat Pipeline)
    // =========================================================================

    // v8.65.2: Lens/Mode constants for skills-based brief generation
    const LENS_OPTIONS = {
        technical: 'Technical — feasibility, architecture, dependencies, implementation risk',
        economics: 'Economics — cost structure, pricing, ROI, resource requirements',
        competitive: 'Competitive — differentiation, market positioning, alternatives',
        customer: 'Voice of Customer — problem-solution fit, friction, adoption',
        operational: 'Operational — maintenance, scaling, support'
    };

    const MODE_OPTIONS = {
        exploration: 'Exploration — open discovery, surface OPENs, make early Decisions',
        'stress-test': 'Stress Test — challenge mode, find gaps, validate Decisions',
        spec: 'Spec — convergence, resolve OPENs, establish Rules and Constraints',
        review: 'Review — evaluate completeness and readiness'
    };

    const LENS_DESCRIPTIONS = {
        technical: 'Probes feasibility, architecture, and implementation risk',
        economics: 'Probes cost structure, pricing, and economic viability',
        competitive: 'Probes differentiation, market position, and alternatives',
        customer: 'Probes user needs, problem-solution fit, and adoption friction',
        operational: 'Probes maintenance, scaling, and operational support'
    };

    const MODE_DESCRIPTIONS = {
        exploration: 'Open discovery focused on surfacing OPENs and early Decisions',
        'stress-test': 'Challenge mode focused on finding gaps and validating Decisions',
        spec: 'Convergence focused on resolving OPENs and locking down Rules/Constraints',
        review: 'Evaluative mode confirming completeness and build-readiness'
    };

    const IdeationBriefGenerator = {
        // v8.62.0 B1: Determine session type from idea state
        getSessionType(idea, concepts) {
            const phase = idea.phase || computeIdeaPhase(concepts);
            if (phase === 'inception') return 'exploration';
            if (phase === 'complete') return 'exploration';
            const hasSpec = (idea.sessionLog || []).some(s => s.type === 'spec');
            if (phase === 'spec-ready' && hasSpec) return 'claude-md';
            if (phase === 'spec-ready') return 'spec';
            return 'exploration';
        },

        // v8.65.2 B2: Session config with lens/mode
        getSessionConfig(idea, concepts, selectedLens, selectedMode) {
            const sessionType = this.getSessionType(idea, concepts);
            return {
                sessionType,
                lens: selectedLens || null,
                mode: selectedMode || this.getDefaultMode(sessionType)
            };
        },

        getDefaultMode(sessionType) {
            switch (sessionType) {
                case 'spec': return 'spec';
                case 'claude-md': return null;
                default: return 'exploration';
            }
        },

        // v8.62.0 B1: Three-type system prompt — exploration, spec, claude-md
        // v8.65.2 B3: Stripped embedded instructions — skills handle ODRC framework, output format, session protocol
        getSystemPrompt(sessionType, phase = null) {
            switch (sessionType) {
                case 'spec':
                    return `You are generating a lean session brief for a SPECIFICATION session.
The idea has reached spec-ready status. The developer has skills loaded that handle ODRC framework and session protocol.

Generate a markdown document with these sections:
- Session header (idea name, app, session number, phase: spec-ready)
- Skills Directive — list the specific skills to read (provided in the user message)
- Spec Goal — what the specification should cover
- Idea Summary
- Current ODRC State — all active concepts grouped by type, highlighting any remaining OPENs that must be resolved
- Session Metadata — idea slug, IdeaId, app ID, session number

Do NOT embed ODRC output format definitions — skills handle that.`;

                case 'claude-md':
                    return `You are generating a session brief for a CLAUDE.md GENERATION session.
A specification already exists for this idea. Generate a brief that instructs Chat to:
1. Review the specification
2. Produce a CLAUDE.md file following the LOCKED TEMPLATE below
3. Include all implementation details from the spec
4. Validate line references against the codebase (if included)
5. Include ODRC Updates section at the end (format defined in cc-odrc-framework skill)

LOCKED CLAUDE.md TEMPLATE — Chat MUST follow this structure:
\`\`\`
# CLAUDE.md — {Task Name}
# cc-spec-id: {spec_id}
# App: {app_name} (index.html)
# Base version: {current_version}
# Target version: {next_version}
# Depends on: {dependencies}

---

## Before You Begin
{Scope assessment prompt — ask Code if this should split into phases}

---

## Task Summary
{What to build, in 2-3 sentences}

---

## What to Build
{Detailed implementation sections with code examples, organized by phase if applicable}

---

## Existing Infrastructure Reference
{Table of components, locations, and what they do}

---

## Architecture Rules
### State Management Rules
### Data Flow Rules

---

## Conventions
{Project-specific conventions — slug formats, naming, patterns}

---

## File Structure
{What files are created/modified}

---

## Post-Task Obligations
RULE: Before reporting this task as complete:
1. Commit all code changes
2. Archive this CLAUDE.md to cc/specs/{spec_id}.md
3. Generate completion file to .cc/completions/
4. Commit spec archive and completion file separately

Completion file format:
{Inline YAML template with all required fields}
\`\`\`

Generate a markdown document with these sections:
- Session header (idea name, app, session number)
- Skills Directive — list skills to read
- CLAUDE.md Generation Goal
- Idea Summary
- Current ODRC State
- Session Metadata`;

                default: { // exploration
                    let prompt = `You are generating a lean session brief for a Claude Chat ideation session.
The developer has skills loaded in claude.ai that handle ODRC framework, session structure, output format, and session protocol. The brief should NOT repeat ODRC definitions, output templates, or behavioral instructions — skills handle all of that.

Generate a markdown document with ONLY these sections:
- Session header (idea name, app, session number, phase)
- Skills Directive — list the specific skills to read (provided in the user message)
- Session Goal — "What are you looking to get out of today's session?"
- Idea Summary — what this idea is about
- Prior Session Summary — if sessions exist, summarize the most recent
- Current ODRC State — all active concepts grouped by type (OPEN, DECISION, RULE, CONSTRAINT)
- Session Metadata — idea slug, IdeaId, app ID, session number (needed for ODRC output routing)

Keep the brief focused on CONTEXT, not INSTRUCTIONS. The skills provide all instructions.`;

                    if (phase === 'inception') {
                        prompt += `\n\nINCEPTION PHASE: This is a new, unvalidated idea. Add an "Inception Validation" section to the brief BEFORE the Session Goal, with this content:

## Inception Validation
This is a new idea that hasn't been validated yet. Before exploring:
1. Challenge the idea name — does it accurately describe the concept?
2. Pressure-test the topic sentence — is it specific enough to scope work?
3. Confirm the end goal — what does "done" look like for this idea?

Spend the first 3-5 minutes on validation. If answers are confident, move on.
If vague, suggest stepping back to refine the idea definition before deep exploration.`;
                    }

                    return prompt;
                }
            }
        },

        // Main entry point — generates the session brief markdown
        // v8.65.2 B4: Accept lens/mode for skills-based briefs
        async generate(idea, app, concepts, globalConcepts, lens = null, mode = null) {
            const ideaContext = this.buildIdeaContext(idea, concepts);
            const appContext = this.buildAppContext(app, globalConcepts);
            const odrcState = ODRCSummaryGenerator.generateScoped(concepts, [idea], null);
            const sessionType = this.getSessionType(idea, concepts);
            const effectiveMode = mode || this.getDefaultMode(sessionType);

            try {
                const brief = await ClaudeAPIService.call({
                    model: 'claude-sonnet-4-20250514',
                    system: this.getSystemPrompt(sessionType, ideaContext.phase),
                    userMessage: this.buildUserMessage(ideaContext, appContext, odrcState, lens, effectiveMode),
                    maxTokens: 4096
                });
                return brief;
            } catch (e) {
                console.warn('[CC] IdeationBriefGenerator: AI generation failed, using template fallback:', e.message);
                return this.buildTemplateBrief(idea, app, concepts, ideaContext, appContext, odrcState, sessionType, lens, effectiveMode);
            }
        },

        buildIdeaContext(idea, concepts) {
            const activeConcepts = concepts.filter(c => c.status === 'active');
            const sessionCount = idea.sessionLog?.length || 0;
            const latestSession = sessionCount > 0 ? idea.sessionLog[sessionCount - 1] : null;
            const computed = computeIdeaPhase(concepts);
            const phase = idea.phase || computed;

            return {
                name: idea.name,
                slug: idea.slug || IdeaManager.generateSlug(idea.name),
                description: idea.description || '',
                phase,
                computedPhase: computed,
                manualPhase: idea.phase,
                sessionCount,
                latestSession,
                sessionLog: idea.sessionLog || [],
                conceptCounts: {
                    total: activeConcepts.length,
                    opens: activeConcepts.filter(c => c.type === 'OPEN').length,
                    decisions: activeConcepts.filter(c => c.type === 'DECISION').length,
                    rules: activeConcepts.filter(c => c.type === 'RULE').length,
                    constraints: activeConcepts.filter(c => c.type === 'CONSTRAINT').length
                }
            };
        },

        buildAppContext(app, globalConcepts) {
            if (!app) return { name: 'Unknown', description: '', version: '' };
            return {
                name: app.name || app.id,
                description: app.description || '',
                version: app.version || '',
                id: app.id
            };
        },

        // v8.65.2 B5: Include lens/mode and skills directive in user message
        buildUserMessage(ideaContext, appContext, odrcState, lens = null, mode = null) {
            const sessionNum = ideaContext.sessionCount + 1;
            let msg = `Generate a session brief for:\n\n`;
            msg += `**Idea:** ${ideaContext.name}\n`;
            msg += `**App:** ${appContext.name}\n`;
            msg += `**Session Number:** ${sessionNum}\n`;
            msg += `**Idea Slug:** ${ideaContext.slug}\n`;
            msg += `**Phase:** ${ideaContext.phase}\n\n`;

            // Skills directive for the AI to embed in the brief
            msg += `**Skills Directive to embed in the brief:**\n`;
            msg += `- cc-odrc-framework\n- cc-session-structure\n- cc-artifact-manifest\n- cc-post-session-package\n`;
            if (lens && LENS_DESCRIPTIONS[lens]) {
                msg += `- cc-lens-${lens} — ${LENS_DESCRIPTIONS[lens]}\n`;
            }
            if (mode && MODE_DESCRIPTIONS[mode]) {
                msg += `- cc-mode-${mode} — ${MODE_DESCRIPTIONS[mode]}\n`;
            }
            msg += `\n`;

            msg += `**Idea Description:**\n${ideaContext.description}\n\n`;

            if (ideaContext.latestSession) {
                msg += `**Most Recent Session:**\n`;
                msg += `- ID: ${ideaContext.latestSession.sessionId}\n`;
                msg += `- Date: ${new Date(ideaContext.latestSession.date).toLocaleDateString()}\n`;
                msg += `- Summary: ${ideaContext.latestSession.summary}\n`;
                msg += `- Created: ${ideaContext.latestSession.conceptsCreated} concepts, Resolved: ${ideaContext.latestSession.conceptsResolved}\n\n`;
                if (ideaContext.latestSession.debriefSummary) {
                    msg += `**Prior Session Context (Debrief):**\n${ideaContext.latestSession.debriefSummary}\n\n`;
                }
            }

            if (ideaContext.sessionLog.length > 1) {
                msg += `**Full Session Log:**\n`;
                ideaContext.sessionLog.forEach(s => {
                    msg += `- ${s.sessionId} (${new Date(s.date).toLocaleDateString()}): ${s.summary}\n`;
                });
                msg += `\n`;
                msg += `Note: Flag any OPENs persisting across 2+ sessions as "long-standing".\n\n`;
            }

            msg += `**App Context:**\n`;
            msg += `- Name: ${appContext.name}\n`;
            msg += `- Description: ${appContext.description}\n`;
            msg += `- Version: ${appContext.version}\n\n`;
            msg += `**Current ODRC State:**\n${odrcState}\n\n`;
            msg += `**Concept Counts:** ${ideaContext.conceptCounts.total} active (${ideaContext.conceptCounts.opens} OPENs, ${ideaContext.conceptCounts.decisions} DECISIONs, ${ideaContext.conceptCounts.rules} RULEs, ${ideaContext.conceptCounts.constraints} CONSTRAINTs)`;

            return msg;
        },

        // Template fallback when AI is unavailable
        // v8.61.1: Added phase param for spec-ready framing
        // v8.62.0 B1: Template handles all three session types
        // v8.65.2 B6: Skills Directive replaces Expected Output Format
        buildTemplateBrief(idea, app, concepts, ideaContext, appContext, odrcState, sessionType, lens = null, mode = null) {
            const sessionNum = ideaContext.sessionCount + 1;
            const slug = ideaContext.slug;
            const appId = app?.id || 'unknown';

            const titlePrefix = sessionType === 'claude-md' ? 'CLAUDE.md Generation Brief'
                : sessionType === 'spec' ? 'Specification Brief'
                : 'Session Brief';
            let brief = `# ${titlePrefix} — ${ideaContext.name} (Session ${sessionNum})\n`;
            brief += `App: ${appContext.name} | Phase: ${ideaContext.phase} | Session Type: ${sessionType} | Generated: ${new Date().toLocaleString()}\n\n`;
            brief += `---\n\n`;
            if (ideaContext.phase === 'inception') {
                brief += `## Inception Validation\n`;
                brief += `This is a new idea that hasn't been validated yet. Before exploring:\n`;
                brief += `1. Challenge the idea name — does it accurately describe the concept?\n`;
                brief += `2. Pressure-test the topic sentence — is it specific enough to scope work?\n`;
                brief += `3. Confirm the end goal — what does "done" look like for this idea?\n\n`;
                brief += `Spend the first 3-5 minutes on validation. If answers are confident, move on.\n`;
                brief += `If vague, suggest stepping back to refine the idea definition before deep exploration.\n\n`;
                brief += `---\n\n`;
            }
            if (sessionType === 'claude-md') {
                brief += `## CLAUDE.md Generation Goal\nProduce a CLAUDE.md from the existing specification using the locked template structure. Validate all implementation details.\n\n`;
            } else if (sessionType === 'spec') {
                brief += `## Spec Goal\nConsolidate accumulated DECISIONs, RULEs, and CONSTRAINTs into an implementable specification. Resolve any remaining OPENs.\n\n`;
            } else {
                brief += `## What are you looking to get out of today's session?\n*(State your goal for this session)*\n\n`;
            }
            brief += `---\n\n`;
            brief += `## Idea Summary\n`;
            brief += `${ideaContext.description || 'No description set.'}\n\n`;

            if (ideaContext.latestSession) {
                brief += `## Prior Session Summary\n`;
                brief += `**${ideaContext.latestSession.sessionId}** (${new Date(ideaContext.latestSession.date).toLocaleDateString()}):\n`;
                brief += `${ideaContext.latestSession.summary}\n`;
                brief += `Created ${ideaContext.latestSession.conceptsCreated} concepts, resolved ${ideaContext.latestSession.conceptsResolved}.\n\n`;
            }

            if (ideaContext.sessionLog.length > 1) {
                brief += `## Session History\n`;
                brief += `| Session | Date | Summary | Created | Resolved |\n`;
                brief += `|---------|------|---------|---------|----------|\n`;
                ideaContext.sessionLog.forEach(s => {
                    brief += `| ${s.sessionId} | ${new Date(s.date).toLocaleDateString()} | ${s.summary} | ${s.conceptsCreated} | ${s.conceptsResolved} |\n`;
                });
                brief += `\n`;
            }

            brief += `## Current ODRC State\n\n`;
            // v8.62.0 A3: Strip generic scope header from ODRC summary
            const odrcStateClean = odrcState.replace(/^# ODRC State Summary\nScope:.*\n/m, '');
            brief += odrcStateClean + '\n\n';
            // v8.65.2 B6: Skills Directive replaces Expected Output Format
            brief += `## Skills Directive\n\n`;
            brief += `Read these skills before starting the session:\n`;
            brief += `- **cc-odrc-framework** — ODRC thinking model and output format\n`;
            brief += `- **cc-session-structure** — Session opening, pacing, and closing protocol\n`;
            brief += `- **cc-artifact-manifest** — Track all files created during the session\n`;
            brief += `- **cc-post-session-package** — Required output deliverables\n`;
            if (lens && LENS_DESCRIPTIONS[lens]) {
                brief += `- **cc-lens-${lens}** — ${LENS_DESCRIPTIONS[lens]}\n`;
            }
            if (mode && MODE_DESCRIPTIONS[mode]) {
                brief += `- **cc-mode-${mode}** — ${MODE_DESCRIPTIONS[mode]}\n`;
            }
            brief += `\n`;

            brief += `## Session Metadata\n\n`;
            brief += `Use this metadata in the ODRC Updates header (format defined in cc-odrc-framework skill):\n`;
            brief += `- Idea: ${slug}\n`;
            brief += `- IdeaId: ${idea.id}\n`;
            brief += `- App: ${appId}\n`;
            brief += `- Session: S-${new Date().toISOString().slice(0, 10)}-${String(sessionNum).padStart(3, '0')}\n\n`;

            // v8.62.0 A3: Only include Supporting Documents if zip will be the output method
            if (ideaContext.sessionCount > 0 || brief.length >= 8000) {
                brief += `## Supporting Documents\n`;
                brief += `Check the zip package for additional files included with this brief.\n`;
            }

            return brief;
        },

        // v8.62.0 B1: Session-type-aware handshake prompt
        // v8.65.2 B7: Reference skills instead of embedding instructions
        getHandshakePrompt(ideaName, sessionNumber, appName, sessionType, lens, mode) {
            let prompt = `Please review the attached session brief for ${ideaName} (Session ${sessionNumber}, App: ${appName}).\n\n`;
            prompt += `Read the skills listed in the Skills Directive section of the brief before proceeding.\n\n`;
            prompt += `Confirm you've reviewed the brief and skills, then ask me what I want to accomplish in this session.`;
            return prompt;
        }
    };

    // =========================================================================
    // END DATA SERVICE LAYER
    // =========================================================================
    
    function extractVersionFromHTML(content) {
        // Collect all version candidates with their source
        const candidates = [];
        
        // Priority 1: const APP_VERSION - the authoritative runtime version
        const appVersionMatch = content.match(/const\s+APP_VERSION\s*=\s*['"]([^'"]+)['"]/);
        if (appVersionMatch) {
            candidates.push({ version: appVersionMatch[1], source: 'APP_VERSION', priority: 1 });
        }
        
        // Priority 2: meta version tag
        const metaMatch = content.match(/<meta\s+name=["']version["']\s+content=["']([^"']+)["']/i);
        if (metaMatch) {
            candidates.push({ version: metaMatch[1], source: 'meta', priority: 2 });
        }
        
        // Priority 2b: meta tag with reversed attributes
        const metaMatch2 = content.match(/<meta\s+content=["']([^"']+)["']\s+name=["']version["']/i);
        if (metaMatch2 && !metaMatch) {
            candidates.push({ version: metaMatch2[1], source: 'meta', priority: 2 });
        }
        
        // Priority 3: const VERSION (without APP_ prefix)
        const versionConstMatch = content.match(/const\s+VERSION\s*=\s*['"]([^'"]+)['"]/);
        if (versionConstMatch) {
            candidates.push({ version: versionConstMatch[1], source: 'VERSION', priority: 3 });
        }
        
        // Priority 4: HTML comment with VERSION label
        const commentMatch = content.match(/<!--\s*VERSION:\s*([^\s]+)\s*-->/i);
        if (commentMatch) {
            candidates.push({ version: commentMatch[1], source: 'comment', priority: 4 });
        }
        
        // Priority 5: data-version attribute
        const dataMatch = content.match(/data-version=["']([^"']+)["']/i);
        if (dataMatch) {
            candidates.push({ version: dataMatch[1], source: 'data-attr', priority: 5 });
        }
        
        // If we have candidates, return the highest priority one
        if (candidates.length > 0) {
            candidates.sort((a, b) => a.priority - b.priority);
            return candidates[0].version;
        }
        
        // Fallback: JSON-style version field (but skip if looks like example/docs)
        const jsonMatch = content.match(/["']version["']\s*:\s*["'](\d+\.\d+\.\d+)["']/i);
        if (jsonMatch && jsonMatch[1] !== '1.0.0') return jsonMatch[1];
        
        // Fallback: JSDoc @version tag
        const jsdocMatch = content.match(/@version\s+(\d+\.\d+\.\d+)/i);
        if (jsdocMatch && jsdocMatch[1] !== '1.0.0') return jsdocMatch[1];
        
        return null;
    }
    
    // Find ALL version-like strings in HTML for debugging
    function findAllVersionStrings(content) {
        const versions = [];
        
        // Helper to check if a match is inside a comment or code example
        function shouldSkip(matchIndex, matchText) {
            // Get surrounding context (200 chars before, line content)
            const before = content.substring(Math.max(0, matchIndex - 200), matchIndex);
            const lineStart = content.lastIndexOf('\n', matchIndex) + 1;
            const lineEnd = content.indexOf('\n', matchIndex);
            const lineContent = content.substring(lineStart, lineEnd === -1 ? matchIndex + 100 : lineEnd);
            
            // Skip if inside a comment block or pattern documentation
            if (/^\s*(\/\/|\*|#)/.test(lineContent)) return true;
            if (/Pattern|Example|e\.g\.|like|→|-->/i.test(lineContent)) return true;
            
            // Skip if the match looks like documentation (Pattern 1:, Pattern 2:, etc.)
            if (/Pattern\s*\d+|\/\/\s*Pattern/i.test(before.slice(-80))) return true;
            
            // Skip if this appears to be inside function code that manipulates versions
            // (i.e., the fixVersionsInContent function, version bump examples, etc.)
            if (/fixVersions|incrementVersion|bumpVersion|parseVersion/i.test(before.slice(-150))) return true;
            
            // Skip template literal patterns - these are code, not actual versions
            if (matchText && matchText.includes('${')) return true;
            if (matchText && matchText.includes('targetVersion')) return true;
            
            // Skip if inside a generate* function (skeleton docs, HTML templates, Claude prompts)
            // These contain meta version tags as template output, not the app's own version
            const fnContext = before.slice(-1000);
            if (/function\s+generate\w*\s*\(/.test(fnContext) && !/function\s+(extractVersion|findAllVersion|validateVersion)/.test(fnContext)) return true;
            
            // Skip placeholder version patterns (X.X.X, X.Y.Z, etc.)
            if (matchText && /^[A-Z]\.[A-Z]\.[A-Z]$/.test(matchText)) return true;
            
            // Skip if it's a version format example like "1.0.0 → 1.0.1"
            if (/\d+\.\d+\.\d+\s*→/.test(lineContent)) return true;
            
            return false;
        }
        
        // Meta tag versions
        const metaMatches = content.matchAll(/<meta\s+[^>]*name=["']version["'][^>]*content=["']([^"']+)["'][^>]*>/gi);
        for (const m of metaMatches) {
            if (shouldSkip(m.index, m[1])) continue;
            versions.push({ source: 'meta tag', value: m[1], line: content.substring(0, m.index).split('\n').length });
        }
        // Also check reverse order: content before name
        const metaMatches2 = content.matchAll(/<meta\s+[^>]*content=["']([^"']+)["'][^>]*name=["']version["'][^>]*>/gi);
        for (const m of metaMatches2) {
            if (shouldSkip(m.index, m[1])) continue;
            versions.push({ source: 'meta tag', value: m[1], line: content.substring(0, m.index).split('\n').length });
        }
        
        // JS variable versions - but NOT inside comments, template literals, or the integration module definition
        const jsMatches = content.matchAll(/^\s*const\s+(VERSION|APP_VERSION|GAME_VERSION)\s*=\s*['"]([^'"]+)['"]/gm);
        for (const m of jsMatches) {
            // Skip if it's inside the GameShelf integration module (those are module versions, not app versions)
            const before = content.substring(Math.max(0, m.index - 200), m.index);
            if (before.includes('GAMESHELF_VERSION') || before.includes('Integration Module')) continue;
            if (shouldSkip(m.index, m[2])) continue;
            versions.push({ source: `JS: ${m[1]}`, value: m[2], line: content.substring(0, m.index).split('\n').length });
        }
        
        // Footer versions - look for patterns like "v1.0.0 •" or ">v1.0.0<" or "v1.0.0 &bull;"
        const footerMatches = content.matchAll(/[>\s]v(\d+\.\d+\.\d+)\s*[•<·&]/g);
        for (const m of footerMatches) {
            if (shouldSkip(m.index, m[1])) continue;
            versions.push({ source: 'footer/visible', value: m[1], line: content.substring(0, m.index).split('\n').length });
        }
        
        // Version in about/info sections
        const aboutMatches = content.matchAll(/Version:?\s*<\/?\w*>?\s*v?(\d+\.\d+\.\d+)/gi);
        for (const m of aboutMatches) {
            if (shouldSkip(m.index, m[1])) continue;
            versions.push({ source: 'about/info text', value: m[1], line: content.substring(0, m.index).split('\n').length });
        }
        
        return versions;
    }
    
    // Validate version consistency in HTML content
    function validateVersions(content, filename) {
        const versions = findAllVersionStrings(content);
        const primary = extractVersionFromHTML(content);
        
        // Get unique version values
        const uniqueVersions = [...new Set(versions.map(v => v.value))];
        
        const result = {
            isValid: true,
            primary: primary,
            allVersions: versions,
            uniqueVersions: uniqueVersions,
            mismatches: [],
            missing: []
        };
        
        // Check for mismatches
        if (uniqueVersions.length > 1) {
            result.isValid = false;
            result.mismatches = versions.filter(v => v.value !== primary);
        }
        
        // Check for missing meta tag
        const hasMeta = versions.some(v => v.source === 'meta tag');
        if (!hasMeta) {
            result.isValid = false;
            result.missing.push('meta tag');
        }
        
        // Check for missing JS VERSION constant (for apps that should have one)
        const hasJsVersion = versions.some(v => v.source.startsWith('JS:'));
        if (!hasJsVersion && content.includes('const VERSION')) {
            // There's a VERSION constant but we didn't capture it - might be okay
        }
        
        return result;
    }
    
    // Auto-fix version strings in HTML content
    function fixVersionsInContent(content, targetVersion) {
        let fixed = content;
        
        // Fix or add meta tag
        const metaRegex = /<meta\s+name=["']version["']\s+content=["'][^"']*["']\s*\/?>/i;
        const metaRegex2 = /<meta\s+content=["'][^"']*["']\s+name=["']version["']\s*\/?>/i;
        
        if (metaRegex.test(fixed)) {
            fixed = fixed.replace(metaRegex, `<meta name="version" content="${targetVersion}">`);
        } else if (metaRegex2.test(fixed)) {
            fixed = fixed.replace(metaRegex2, `<meta name="version" content="${targetVersion}">`);
        } else {
            // Add meta tag after charset or viewport
            fixed = fixed.replace(
                /(<meta\s+[^>]*viewport[^>]*>)/i,
                `$1\n    <meta name="version" content="${targetVersion}">`
            );
        }
        
        // Fix const VERSION = '8.36.0' (but not GAMESHELF_VERSION)
        fixed = fixed.replace(
            /(const\s+VERSION\s*=\s*['"])[^'"]*(['"])/g,
            `$1${targetVersion}$2`
        );
        
        // Fix CACHE_VERSION = 'v8.7.6' in service workers (with or without 'v' prefix)
        fixed = fixed.replace(
            /(CACHE_VERSION\s*=\s*['"])v?[^'"]*(['"])/g,
            `$1v${targetVersion}$2`
        );
        
        // Fix console.log version strings like "App v1.0.0 starting" or "Command Center v8.7.5"
        fixed = fixed.replace(
            /(console\.log\(['"][^'"]*\s+v)\d+\.\d+\.\d+(\s+[^'"]*['"])/g,
            `$1${targetVersion}$2`
        );
        
        // Fix footer versions like "v1.0.0 •" or "v1.0.0 ·" or "v1.0.0 &bull;"
        fixed = fixed.replace(
            /(>\s*)v\d+\.\d+\.\d+(\s*[•·])/g,
            `$1v${targetVersion}$2`
        );
        fixed = fixed.replace(
            /(>\s*)v\d+\.\d+\.\d+(\s*&bull;)/g,
            `$1v${targetVersion}$2`
        );
        
        // Fix about/version display
        fixed = fixed.replace(
            /(Version:?\s*<\/?\w*>?\s*)v?\d+\.\d+\.\d+/gi,
            `$1v${targetVersion}`
        );
        
        return fixed;
    }
    
    function parseVersion(version) {
        if (!version) return null;
        const parts = version.replace(/^v/i, '').split('.').map(p => parseInt(p, 10) || 0);
        while (parts.length < 4) parts.push(0);
        return parts;
    }
    
    function compareVersions(a, b) {
        const pa = parseVersion(a);
        const pb = parseVersion(b);
        if (!pa || !pb) return 0;
        for (let i = 0; i < 4; i++) {
            if (pa[i] > pb[i]) return 1;
            if (pa[i] < pb[i]) return -1;
        }
        return 0;
    }
    
    function isNewerVersion(newVersion, currentVersion) {
        if (!currentVersion) return true;
        return compareVersions(newVersion, currentVersion) > 0;
    }
    
    function bumpVersion(version, type) {
        if (!version) return '1.0.0';
        const parts = version.replace(/^v/i, '').split('.').map(Number);
        while (parts.length < 3) parts.push(0);
        if (type === 'major') { parts[0]++; parts[1] = 0; parts[2] = 0; }
        else if (type === 'minor') { parts[1]++; parts[2] = 0; }
        else { parts[2]++; }
        return parts.join('.');
    }
    
    function formatVersion(v) {
        return v ? `v${v}` : '—';
    }

    // =========================================================================
    // DYNAMIC CONFIGURATION SYSTEM (v7.0.0)
    // =========================================================================
    
    // Environment definitions - extensible for dev, test, prod, beta
    const DEFAULT_ENVIRONMENTS = {
        available: ['dev', 'test', 'prod', 'beta'],
        active: ['test', 'prod'],  // Currently enabled
        colors: {
            dev: { bg: 'bg-purple-600', text: 'text-purple-300', border: 'border-purple-500', hex: '#9333ea' },
            test: { bg: 'bg-blue-600', text: 'text-blue-300', border: 'border-blue-500', hex: '#2563eb' },
            prod: { bg: 'bg-green-600', text: 'text-green-300', border: 'border-green-500', hex: '#16a34a' },
            beta: { bg: 'bg-orange-600', text: 'text-orange-300', border: 'border-orange-500', hex: '#ea580c' }
        },
        labels: { dev: 'DEV', test: 'TEST', prod: 'PROD', beta: 'BETA' },
        icons: { dev: '🛠️', test: '🧪', prod: '🚀', beta: '🔬' }
    };
    
    // App type categories (v8.3.3)
    const APP_TYPES = {
        public: { label: 'Public Apps', description: 'User-facing apps with Test → Prod workflow', collapsed: false },
        internal: { label: 'Internal Tools', description: 'Prod only - no test environment', collapsed: false },
        other: { label: 'Other Projects', description: 'Side projects and prototypes', collapsed: true }
    };
    
    // Project definitions (v8.8.0) - Umbrella grouping for apps
    // Seed data — used only for initial migration into config.projects
    // Seed project definitions — ONLY used for first-time initialization.
    // After first load, config.projects is the source of truth.
    // UI components may reference SEED_PROJECTS as a fallback safety net
    // but it should never be reached in normal operation.
    const SEED_PROJECTS = {
        'gameshelf': { id: 'gameshelf', name: 'Game Shelf', icon: 'gs-logo', color: 'indigo', description: 'Daily puzzle game platform', order: 1, state: 'active' },
        'command-center': { id: 'command-center', name: 'Command Center', icon: '🏗️', color: 'cyan', description: 'Deploy & manage apps', order: 2, state: 'active' },
        'firebase': { id: 'firebase', name: 'Firebase Code', icon: '⚡', color: 'orange', description: 'Server-side functions & APIs', order: 3, state: 'active' },
        'quotle-info': { id: 'quotle-info', name: 'Quotle-info', icon: '📖', color: 'rose', description: 'Quote context engine', order: 4, state: 'active' },
        'labelkeeper': { id: 'labelkeeper', name: 'LabelKeeper', icon: '🏷️', color: 'emerald', description: 'Label printing tool', order: 5, state: 'active' },
        'superbowl': { id: 'superbowl', name: 'Super Bowl', icon: '🏈', color: 'amber', description: 'Super Bowl squares & pools', order: 6, state: 'active' },
        'other': { id: 'other', name: 'Other', icon: '📦', color: 'slate', description: 'Uncategorized apps', order: 99, state: 'active' }
    };
    
    // Seed app definitions — ONLY used for first-time initialization (empty config).
    // After first load, config.apps is the source of truth. Do NOT reference
    // these as fallbacks in runtime code — use config.apps[appId] instead.
    const DEFAULT_APP_DEFINITIONS = {
        // ===== PUBLIC APPS (Test → Prod workflow) =====
        gameshelf: {
            id: 'gameshelf', name: 'Game Shelf', icon: 'gs-logo', project: 'gameshelf',
            appType: 'public',
            targetPath: 'index.html', swPath: 'sw.js', hasServiceWorker: true,
            subPath: 'app',
            repos: { test: '', prod: '' },
            versions: { test: '', prod: '' },
            repoPatterns: {
                test: ['gameshelftest', 'gameshelf-test'],
                prod: ['gameshelf']
            },
            detectionPatterns: ['gameshelfdata', 'game.shelf.pwa', '#setup-welcome', 'APP_VERSION']
        },
        beta: {
            id: 'beta', name: 'Beta Hub', icon: '🚀', project: 'gameshelf',
            appType: 'public',
            targetPath: 'index.html', swPath: null, hasServiceWorker: false,
            subPath: 'beta',
            repos: { test: '', prod: '' },
            versions: { test: '', prod: '' },
            repoPatterns: {
                test: [],  // No test for Beta Hub - uses same repo as Game Shelf
                prod: ['gameshelf']
            },
            detectionPatterns: ['<title>Game Shelf Beta Hub', 'Beta Hub v\\d', 'beta-hub', 'Early Access signup']
        },
        slate: {
            id: 'slate', name: 'Slate', icon: '🪨', project: 'gameshelf',
            appType: 'public',
            targetPath: 'index.html', swPath: 'sw.js', hasServiceWorker: true,
            subPath: 'slate',
            repos: { test: '', prod: '' },
            versions: { test: '', prod: '' },
            repoPatterns: {
                test: ['slatetest', 'slate-test'],
                prod: ['gameshelf']
            },
            detectionPatterns: ['<title>slate', 'slate.*daily.*word', 'chalkboard-bg', 'slate-board']
        },
        rungs: {
            id: 'rungs', name: 'Rungs', icon: '🪜', project: 'gameshelf',
            appType: 'public',
            targetPath: 'index.html', swPath: 'sw.js', hasServiceWorker: true,
            subPath: 'rungs',
            repos: { test: '', prod: '' },
            versions: { test: '', prod: '' },
            repoPatterns: {
                test: ['rungstest', 'rungs-test'],
                prod: ['gameshelf']
            },
            detectionPatterns: ['<title>rungs', 'rungs.*daily', 'word-ladder', 'rung-container']
        },
        quotle: {
            id: 'quotle', name: 'Quotle', icon: '💬', project: 'gameshelf',
            appType: 'public',
            targetPath: 'index.html', swPath: 'sw.js', hasServiceWorker: true,
            subPath: 'quotle',
            repos: { test: '', prod: '' },
            versions: { test: '', prod: '' },
            repoPatterns: {
                test: ['quotletest', 'quotle-test'],
                prod: ['gameshelf']
            },
            detectionPatterns: ['<title>quotle', 'quotle.*daily.*quote', 'quotes-database']
        },
        wordboxing: {
            id: 'wordboxing', name: 'Word Boxing', icon: '🥊', project: 'gameshelf',
            appType: 'public',
            targetPath: 'index.html', swPath: 'sw.js', hasServiceWorker: true,
            subPath: 'wordboxing',
            repos: { test: '', prod: '' },
            versions: { test: '', prod: '' },
            repoPatterns: {
                test: ['wordboxingtest', 'wordboxing-test'],
                prod: ['gameshelf']
            },
            detectionPatterns: ['<title>word\\s*boxing', 'word-boxing', 'boxing-ring']
        },
        landing: {
            id: 'landing', name: 'Landing Page', icon: '📣', project: 'gameshelf',
            appType: 'public',
            targetPath: 'index.html', swPath: '', hasServiceWorker: false,
            subPath: '',  // Root of gameshelf repo
            repos: { test: '', prod: '' },
            versions: { test: '', prod: '' },
            repoPatterns: {
                test: ['gameshelftest'],
                prod: ['gameshelf']
            },
            detectionPatterns: ['Track Every Daily Puzzle', 'track.*every.*daily.*puzzle', 'Join the Beta', 'cta-button']
        },
        terms: {
            id: 'terms', name: 'Terms of Service', icon: '📋', project: 'gameshelf',
            appType: 'public',
            targetPath: 'index.html', swPath: '', hasServiceWorker: false,
            subPath: 'terms',
            repos: { test: '', prod: '' },
            versions: { test: '', prod: '' },
            repoPatterns: {
                test: ['gameshelftest'],
                prod: ['gameshelf']
            },
            detectionPatterns: ['gameshelf-terms', '<title>Terms of Service', 'Terms of Service.*Game Shelf']
        },
        privacy: {
            id: 'privacy', name: 'Privacy Policy', icon: '🔒', project: 'gameshelf',
            appType: 'public',
            targetPath: 'index.html', swPath: '', hasServiceWorker: false,
            subPath: 'privacy',
            repos: { test: '', prod: '' },
            versions: { test: '', prod: '' },
            repoPatterns: {
                test: ['gameshelftest'],
                prod: ['gameshelf']
            },
            detectionPatterns: ['gameshelf-privacy', '<title>Privacy Policy', 'Privacy Policy.*Game Shelf']
        },
        
        // ===== INTERNAL TOOLS (Prod only) =====
        testplan: {
            id: 'testplan', name: 'Test Plan', icon: '🧪', project: 'gameshelf',
            appType: 'internal',
            targetPath: 'index.html', swPath: '', hasServiceWorker: false,
            subPath: '',
            repos: { prod: '' },
            versions: { prod: '' },
            repoPatterns: {
                prod: ['gameshelf-testplan']
            },
            detectionPatterns: ['<title>.*test\\s*plan', 'playwright.*runner', 'test-plan-app']
        },
        'command-center': {
            id: 'command-center', name: 'Command Center', icon: '🏗️', project: 'command-center',
            appType: 'public',
            targetPath: 'index.html', swPath: '', hasServiceWorker: false,
            subPath: '',
            repos: { test: '', prod: '' },
            versions: { test: '', prod: '' },
            repoPatterns: {
                test: ['command-center-test'],
                prod: ['command-center']
            },
            detectionPatterns: ['<title>.*command\\s*center', '<title>.*ship\\s*it', 'command-center', 'claude.*deploy.*queue']
        },
        'cc-infrastructure': {
            id: 'cc-infrastructure', name: 'CC Infrastructure', icon: '🔧', project: 'command-center',
            appType: 'internal',
            targetPath: 'index.html', swPath: '', hasServiceWorker: false,
            subPath: 'infrastructure',
            repos: { prod: '' },
            versions: { prod: '' },
            repoPatterns: {
                prod: ['command-center']
            },
            detectionPatterns: ['<title>.*infrastructure.*command', 'cc-infrastructure', 'Infrastructure Satellite']
        },
        'cc-quality': {
            id: 'cc-quality', name: 'CC Quality', icon: '✅', project: 'command-center',
            appType: 'internal',
            targetPath: 'index.html', swPath: '', hasServiceWorker: false,
            subPath: 'quality',
            repos: { prod: '' },
            versions: { prod: '' },
            repoPatterns: {
                prod: ['command-center']
            },
            detectionPatterns: ['<title>.*quality.*command', 'cc-quality', 'Quality Satellite']
        },
        'cc-analytics': {
            id: 'cc-analytics', name: 'CC Analytics', icon: '📊', project: 'command-center',
            appType: 'internal',
            targetPath: 'index.html', swPath: '', hasServiceWorker: false,
            subPath: 'analytics',
            repos: { prod: '' },
            versions: { prod: '' },
            repoPatterns: {
                prod: ['command-center']
            },
            detectionPatterns: ['<title>.*analytics.*command', 'cc-analytics', 'Analytics Satellite']
        },
        'firebase-functions': {
            id: 'firebase-functions', name: 'Firebase Functions', icon: '⚡', project: 'firebase',
            appType: 'internal',
            targetPath: 'functions/index.js', swPath: '', hasServiceWorker: false,
            subPath: '',
            deployType: 'github-actions',
            repos: { prod: '' },
            versions: { prod: '' },
            repoPatterns: {
                prod: ['gameshelf-functions']
            },
            detectionPatterns: ['firebase-functions', 'onRequest', 'onCall', 'getHint', 'ANTHROPIC_API_KEY']
        },
        
        // ===== OTHER PROJECTS (Collapsed by default) =====
        'quotle-info': {
            id: 'quotle-info', name: 'Quotle-info', icon: '📖', project: 'quotle-info',
            appType: 'other',
            targetPath: 'index.html', swPath: '', hasServiceWorker: false,
            subPath: '',
            repos: { prod: '' },
            versions: { prod: '' },
            repoPatterns: {
                prod: ['quote-info']
            },
            detectionPatterns: ['quotle.info', 'Quote Context Engine', 'quotle-info/quotes']
        },
        'quotle-info-admin': {
            id: 'quotle-info-admin', name: 'Quotle-info Admin', icon: '📖🔧', project: 'quotle-info',
            appType: 'other',
            targetPath: 'index.html', swPath: '', hasServiceWorker: false,
            subPath: 'admin',
            repos: { prod: '' },
            versions: { prod: '' },
            repoPatterns: {
                prod: ['quote-info']
            },
            detectionPatterns: ['Database Manager', 'quotle-info.*manager', 'Enrichment Queue']
        },
        'sb-squares': {
            id: 'sb-squares', name: 'SB Squares', icon: '🏈', project: 'superbowl',
            appType: 'other',
            targetPath: 'index.html', swPath: '', hasServiceWorker: false,
            subPath: '',
            repos: { prod: '' },
            versions: { prod: '' },
            repoPatterns: {
                prod: ['sb-squares-lx', 'superbowl']
            },
            detectionPatterns: ['sb-squares', 'super.*bowl.*squares', 'football.*pool']
        },
        'labelkeeper': {
            id: 'labelkeeper', name: 'LabelKeeper', icon: '🏷️', project: 'labelkeeper',
            appType: 'public',
            targetPath: 'index.html', swPath: '', hasServiceWorker: false,
            subPath: '',
            repos: { test: '', prod: '' },
            versions: { test: '', prod: '' },
            repoPatterns: {
                test: ['labelkeepertest'],
                prod: ['labelkeeper']
            },
            detectionPatterns: ['labelkeeper', 'label.keeper']
        },
        'teacher-assist': {
            id: 'teacher-assist', name: 'Teacher Assist', icon: '👩‍🏫', project: 'other',
            appType: 'other',
            targetPath: 'index.html', swPath: '', hasServiceWorker: false,
            subPath: '',
            repos: { test: '', prod: '' },
            versions: { test: '', prod: '' },
            repoPatterns: {
                test: ['teacher-assist-test'],
                prod: ['teacher-assist']
            },
            detectionPatterns: ['teacher.assist', 'teacher-assist']
        },
        'daily-shelf': {
            id: 'daily-shelf', name: 'Daily Shelf', icon: '📅', project: 'other',
            appType: 'other',
            targetPath: 'index.html', swPath: '', hasServiceWorker: false,
            subPath: '',
            repos: { test: '', prod: '' },
            versions: { test: '', prod: '' },
            repoPatterns: {
                test: ['daily-shelf-test'],
                prod: ['daily-shelf']
            },
            detectionPatterns: ['daily.shelf', 'daily-shelf']
        },
        'ui-prototypes': {
            id: 'ui-prototypes', name: 'UI Prototypes', icon: '🎨', project: 'other',
            appType: 'other',
            targetPath: 'index.html', swPath: '', hasServiceWorker: false,
            subPath: '',
            repos: { test: '', prod: '' },
            versions: { test: '', prod: '' },
            repoPatterns: {
                test: ['gameshelf-ui-test'],
                prod: ['gameshelf-ui']
            },
            detectionPatterns: ['ui.prototype', 'gameshelf-ui']
        }
    };
    
    // Machine-readable seed manifest for config ↔ code drift detection.
    // When CC deploys itself, this is parsed from the staged HTML and compared
    // against the running config to detect mismatches.
    // Format: /* CC_SEED_MANIFEST_START */ JSON /* CC_SEED_MANIFEST_END */
    /* CC_SEED_MANIFEST_START */
    const CC_SEED_MANIFEST = {
        "appId": "command-center",
        "title": "Command Center",
        "projects": {
            "gameshelf": { "name": "Game Shelf", "icon": "gs-logo", "color": "indigo" },
            "command-center": { "name": "Command Center", "icon": "🏗️", "color": "cyan" },
            "firebase": { "name": "Firebase Code", "icon": "⚡", "color": "orange" },
            "quotle-info": { "name": "Quotle-info", "icon": "📖", "color": "rose" },
            "labelkeeper": { "name": "LabelKeeper", "icon": "🏷️", "color": "emerald" },
            "superbowl": { "name": "Super Bowl", "icon": "🏈", "color": "amber" },
            "other": { "name": "Other", "icon": "📦", "color": "slate" }
        },
        "apps": {
            "gameshelf": { "name": "Game Shelf", "project": "gameshelf", "icon": "gs-logo", "subPath": "app", "appType": "public", "hasServiceWorker": true },
            "beta": { "name": "Beta Hub", "project": "gameshelf", "icon": "🚀", "subPath": "beta", "appType": "public", "hasServiceWorker": false },
            "slate": { "name": "Slate", "project": "gameshelf", "icon": "🪨", "subPath": "slate", "appType": "public", "hasServiceWorker": true },
            "rungs": { "name": "Rungs", "project": "gameshelf", "icon": "🪜", "subPath": "rungs", "appType": "public", "hasServiceWorker": true },
            "quotle": { "name": "Quotle", "project": "gameshelf", "icon": "💬", "subPath": "quotle", "appType": "public", "hasServiceWorker": true },
            "wordboxing": { "name": "Word Boxing", "project": "gameshelf", "icon": "🥊", "subPath": "wordboxing", "appType": "public", "hasServiceWorker": true },
            "command-center": { "name": "Command Center", "project": "command-center", "icon": "🏗️", "subPath": "", "appType": "internal", "hasServiceWorker": false },
            "testplan": { "name": "Test Plan", "project": "gameshelf", "icon": "🧪", "subPath": "", "appType": "internal", "hasServiceWorker": false },
            "firebase-functions": { "name": "Firebase Functions", "project": "firebase", "icon": "⚡", "subPath": "", "appType": "internal", "hasServiceWorker": false },
            "labelkeeper": { "name": "LabelKeeper", "project": "labelkeeper", "icon": "🏷️", "subPath": "", "appType": "public", "hasServiceWorker": false }
        }
    };
    /* CC_SEED_MANIFEST_END */
    
    // Configuration manager
    const ConfigManager = {
        STORAGE_KEY: 'commandCenterConfig',
        REPO_STORAGE_KEY: 'githubRepoAssignments',
        
        // Load config from localStorage or use defaults
        load() {
            try {
                const stored = localStorage.getItem(this.STORAGE_KEY);
                if (stored) {
                    const config = JSON.parse(stored);
                    return this.mergeWithDefaults(config);
                }
            } catch (e) {
                console.warn('Failed to load config, using defaults:', e);
            }
            return this.getDefaultConfig();
        },
        
        // Save config to localStorage + Firebase
        save(config) {
            try {
                // Add sync timestamp
                config._updatedAt = Date.now();
                config._updatedBy = 'local';
                
                // 1. localStorage (immediate, synchronous)
                localStorage.setItem(this.STORAGE_KEY, JSON.stringify(config));
                // 1b. Satellite-readable copy (gs_config)
                try { localStorage.setItem('gs_config', JSON.stringify(config)); } catch {}
                
                // 2. Firebase (async, fire-and-forget)
                if (FirebaseConfigSync.initialized) {
                    FirebaseConfigSync.pushConfig(config).catch(err =>
                        console.warn('[ConfigManager] Firebase sync failed:', err.message)
                    );
                }
                
                return true;
            } catch (e) {
                console.error('Failed to save config:', e);
                return false;
            }
        },
        
        // Get default configuration
        getDefaultConfig() {
            return {
                version: '7.0.0',
                ownerName: '',
                environments: { ...DEFAULT_ENVIRONMENTS },
                apps: JSON.parse(JSON.stringify(DEFAULT_APP_DEFINITIONS)),
                projects: JSON.parse(JSON.stringify(SEED_PROJECTS))
            };
        },
        
        // Merge stored config with defaults (handles upgrades)
        mergeWithDefaults(stored) {
            const defaults = this.getDefaultConfig();
            
            // v8.15.0: Migrate app id 'management' → 'command-center'
            if (stored.apps && stored.apps['management'] && !stored.apps['command-center']) {
                stored.apps['command-center'] = { ...stored.apps['management'], id: 'command-center' };
                delete stored.apps['management'];
                console.log('🔄 Migrated app: management → command-center');
            }
            
            // Ensure environments structure
            if (!stored.environments) {
                stored.environments = defaults.environments;
            } else {
                stored.environments = { ...defaults.environments, ...stored.environments };
            }
            
            // v8.37.0: Ensure ownerName field exists
            if (stored.ownerName === undefined) {
                stored.ownerName = '';
            }
            
            // v8.12.0: Ensure projects structure exists — one-time migration
            if (!stored.projects) {
                stored.projects = JSON.parse(JSON.stringify(SEED_PROJECTS));
                // Migrate _standalone → other for any existing apps
                for (const app of Object.values(stored.apps || {})) {
                    if (app.project === '_standalone') app.project = 'other';
                }
                // Migrate cc_projectStates into project objects
                try {
                    const oldStates = JSON.parse(localStorage.getItem('cc_projectStates') || '{}');
                    for (const [id, state] of Object.entries(oldStates)) {
                        const projId = id === '_standalone' ? 'other' : id;
                        if (stored.projects[projId]) {
                            stored.projects[projId].state = state;
                        }
                    }
                } catch (e) { /* ignore */ }
            }
            // Note: We do NOT force-merge SEED_PROJECTS into existing stored.projects.
            // Once projects exist in config, the user's stored data is the source of truth.
            // New projects are created through the UI, not by adding seeds here.
            // HOWEVER: ensure any project referenced by an app actually has a definition.
            // v8.56.1: Fix "two Other groups" — if an app references project 'firebase'
            // but stored.projects has no 'firebase' entry, add it from seeds.
            if (stored.projects && stored.apps) {
                const referencedProjects = new Set(Object.values(stored.apps).map(a => a.project).filter(Boolean));
                for (const projId of referencedProjects) {
                    if (projId !== 'other' && !stored.projects[projId] && SEED_PROJECTS[projId]) {
                        stored.projects[projId] = JSON.parse(JSON.stringify(SEED_PROJECTS[projId]));
                        console.log(`[ConfigMigration] Added missing project definition: ${projId} ("${SEED_PROJECTS[projId].name}")`);
                    }
                }
            }
            
            // v8.13.1.7: Stored apps are the source of truth.
            // Only seed default apps if the apps object is completely empty (first-time setup).
            // After that, apps are created/edited/deleted through the UI.
            if (!stored.apps || Object.keys(stored.apps).length === 0) {
                stored.apps = JSON.parse(JSON.stringify(defaults.apps));
            } else {
                // v8.55.1: Add new seed apps that don't exist in stored config yet
                // This handles apps added in code updates (like CC satellites)
                for (const [id, seedApp] of Object.entries(defaults.apps)) {
                    if (!stored.apps[id]) {
                        stored.apps[id] = JSON.parse(JSON.stringify(seedApp));
                        console.log(`[ConfigMigration] Added new app: ${id} (project: ${seedApp.project || 'other'})`);
                    }
                }
                
                // Ensure structural fields exist on each stored app (schema migration only)
                // This adds NEW fields from the schema without overwriting user values
                for (const [id, app] of Object.entries(stored.apps)) {
                    if (!app.repos) app.repos = { test: '', prod: '' };
                    if (!app.versions) app.versions = { test: '', prod: '' };
                    if (!app.createdAt) app.createdAt = Date.now();
                    if (!app.detectionPatterns) app.detectionPatterns = [];
                    if (app.appType === undefined) app.appType = 'public';
                    if (app.hasServiceWorker === undefined) app.hasServiceWorker = false;
                    // v8.18.0: Ensure project field exists — fall back to seed definition or 'other'
                    if (!app.project) app.project = DEFAULT_APP_DEFINITIONS[id]?.project || 'other';
                    // v8.55.1: Sync project field from seed if it changed (e.g., firebase-functions moved to 'firebase')
                    const seedProject = DEFAULT_APP_DEFINITIONS[id]?.project;
                    if (seedProject && app.project !== seedProject) {
                        console.log(`[ConfigMigration] ${id}: project ${app.project} → ${seedProject}`);
                        app.project = seedProject;
                    }
                    // v8.20.0: Ensure lifecycle object exists (Phase 0.2 orchestrator)
                    if (!app.lifecycle) app.lifecycle = {};
                    if (!app.lifecycle.category) app.lifecycle.category = app.appType === 'internal' ? 'admin' : null;
                    if (!app.lifecycle.currentMaturity) app.lifecycle.currentMaturity = null;
                    if (!app.lifecycle.maturityTarget) app.lifecycle.maturityTarget = null;
                    if (!app.lifecycle.problemStatement) app.lifecycle.problemStatement = '';
                    if (!app.lifecycle.targetAudience) app.lifecycle.targetAudience = '';
                    if (!app.lifecycle.userGoal) app.lifecycle.userGoal = '';
                    if (!app.lifecycle.successMetric) app.lifecycle.successMetric = '';
                    if (!app.lifecycle.stack) app.lifecycle.stack = {};
                    if (!app.lifecycle.maturityCriteria) app.lifecycle.maturityCriteria = {};
                }
            }
            
            return stored;
        },
        
        // Migrate from old format (testRepo/prodRepo to repos object)
        migrateFromOldFormat(oldApps, config) {
            const repoAssignments = JSON.parse(localStorage.getItem(this.REPO_STORAGE_KEY) || '{}');
            let synced = 0;
            
            for (const [id, oldApp] of Object.entries(oldApps)) {
                if (config.apps[id]) {
                    // Check repo assignments first, then fall back to old format
                    const assignment = repoAssignments[id] || {};
                    const newTest = assignment.testRepo || oldApp.testRepo || '';
                    const newProd = assignment.prodRepo || oldApp.prodRepo || '';
                    if (newTest || newProd) {
                        config.apps[id].repos.test = newTest;
                        config.apps[id].repos.prod = newProd;
                        synced++;
                    }
                    config.apps[id].versions.test = oldApp.currentTestVersion || '';
                    config.apps[id].versions.prod = oldApp.currentProdVersion || '';
                }
            }
            console.log(`[ConfigManager] migrateFromOldFormat: synced repos for ${synced}/${Object.keys(oldApps).length} apps`);
            
            return config;
        },
        
        // Add a new app
        addApp(config, appData) {
            const id = appData.id || appData.name.toLowerCase().replace(/\s+/g, '');
            config.apps[id] = {
                id,
                name: appData.name,
                icon: appData.icon || '📦',
                targetPath: appData.targetPath || 'index.html',
                swPath: appData.swPath || '',
                hasServiceWorker: appData.hasServiceWorker || false,
                repos: { dev: '', test: '', prod: '', beta: '' },
                versions: { dev: '', test: '', prod: '', beta: '' },
                repoPatterns: {
                    dev: [`${id}dev`, `${id}-dev`],
                    test: [`${id}test`, `${id}-test`],
                    prod: [id],
                    beta: [`${id}beta`, `${id}-beta`]
                },
                detectionPatterns: appData.detectionPatterns || [`<title>${appData.name.toLowerCase()}`],
                // v8.20.0: Include lifecycle metadata
                lifecycle: appData.lifecycle || {
                    category: null,
                    currentMaturity: null,
                    maturityTarget: null,
                    problemStatement: '',
                    targetAudience: '',
                    userGoal: '',
                    successMetric: '',
                    stack: {},
                    maturityCriteria: {}
                }
            };
            return config;
        },
        
        // Remove an app
        removeApp(config, appId) {
            delete config.apps[appId];
            return config;
        },
        
        // Update app
        updateApp(config, appId, updates) {
            if (config.apps[appId]) {
                config.apps[appId] = { ...config.apps[appId], ...updates };
            }
            return config;
        },
        
        // Add a new project
        addProject(config, projectData) {
            const id = projectData.id || projectData.name.toLowerCase().replace(/\s+/g, '-');
            config.projects[id] = {
                id,
                name: projectData.name,
                icon: projectData.icon || '📦',
                color: projectData.color || 'slate',
                description: projectData.description || '',
                order: projectData.order ?? (Math.max(...Object.values(config.projects).map(p => p.order || 0)) + 1),
                state: projectData.state || 'active'
            };
            return config;
        },
        
        // Update a project
        updateProject(config, projectId, updates) {
            if (config.projects[projectId]) {
                config.projects[projectId] = { ...config.projects[projectId], ...updates };
            }
            return config;
        },
        
        // Remove a project (reassigns orphaned apps to 'other')
        removeProject(config, projectId) {
            if (projectId === 'other') return config; // Can't delete catch-all
            // Reassign any apps in this project to 'other'
            for (const app of Object.values(config.apps)) {
                if (app.project === projectId) {
                    app.project = 'other';
                }
            }
            delete config.projects[projectId];
            return config;
        },
        
        // Get number of apps in a project
        getProjectAppCount(config, projectId) {
            return Object.values(config.apps).filter(a => (a.project || 'other') === projectId).length;
        },
        
        // Enable/disable an environment
        toggleEnvironment(config, envId) {
            const idx = config.environments.active.indexOf(envId);
            if (idx >= 0) {
                // Don't allow disabling all environments
                if (config.environments.active.length > 1) {
                    config.environments.active.splice(idx, 1);
                }
            } else {
                config.environments.active.push(envId);
                // Sort by the defined order
                config.environments.active.sort((a, b) => 
                    config.environments.available.indexOf(a) - config.environments.available.indexOf(b)
                );
            }
            return config;
        },
        
        // Convert config to legacy apps format for backward compatibility
        toLegacyAppsFormat(config) {
            const apps = {};
            const activeEnvs = config.environments.active;
            
            for (const [id, app] of Object.entries(config.apps)) {
                apps[id] = {
                    id: app.id,
                    name: app.name,
                    icon: app.icon,
                    appType: app.appType || 'public',  // v8.3.3: App category
                    project: app.project || 'other',  // v8.8.0: Project grouping
                    targetPath: app.targetPath,
                    subPath: app.subPath || '',
                    swPath: app.swPath,
                    hasServiceWorker: app.hasServiceWorker,
                    repoPatterns: app.repoPatterns,
                    detectionPatterns: app.detectionPatterns,
                    deployType: app.deployType || null,  // v8.3.3: For GitHub Actions deploys
                    createdAt: app.createdAt || null,  // v8.8.0: Timestamp tracking
                    updatedAt: app.updatedAt || null,  // v8.8.0: Timestamp tracking
                    // Legacy format fields
                    testRepo: app.repos?.test || '',
                    prodRepo: app.repos?.prod || '',
                    currentTestVersion: app.versions?.test || '',
                    currentProdVersion: app.versions?.prod || '',
                    // New format - include all env repos
                    repos: app.repos || {},
                    versions: app.versions || {}
                };
            }
            
            return apps;
        },
        
        // Build detection signatures from config
        buildDetectionSignatures(config) {
            return Object.values(config.apps).map(app => ({
                id: app.id,
                patterns: app.detectionPatterns.map(p => {
                    try {
                        return new RegExp(p, 'i');
                    } catch (e) {
                        console.warn(`Invalid pattern for ${app.id}: ${p}`);
                        return null;
                    }
                }).filter(Boolean),
                confidence: 'high'
            }));
        },
        
        // Get active environments
        getActiveEnvironments(config) {
            return config.environments.active;
        },
        
        // Get environment display info
        getEnvDisplay(config, envId) {
            return {
                label: config.environments.labels[envId] || envId.toUpperCase(),
                icon: config.environments.icons[envId] || '📦',
                colors: config.environments.colors[envId] || config.environments.colors.test
            };
        }
    };

    // v8.68.0: Session package detection signatures
    // TODO: Integrate with directory watching (File System Access API) when implemented.
    // Currently used only as a matching utility — no active polling.
    function buildSessionPackageSignatures(globalIdeas) {
        return (globalIdeas || [])
            .filter(i => i.status === 'active' && i.activeSession)
            .map(idea => {
                const slug = (idea.slug || '').replace(/[^a-z0-9-]/g, '');
                return {
                    ideaId: idea.id,
                    ideaName: idea.name,
                    sessionId: idea.activeSession.sessionId,
                    pattern: new RegExp(
                        `session-brief-${slug}-S\\d{3}\\.zip$`, 'i'
                    )
                };
            });
    }

    // =========================================================================
    // ICONS
    // =========================================================================
    
    const Icons = {
        // Game Shelf badge logo (puzzle pieces G and S)
        GameShelfLogo: ({ size = 20 }) => (
            <svg viewBox="0 0 100 100" width={size} height={size} xmlns="http://www.w3.org/2000/svg">
                <defs>
                    <linearGradient id="gsBadgeGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                        <stop offset="0%" style={{stopColor:'#667eea'}}/>
                        <stop offset="100%" style={{stopColor:'#764ba2'}}/>
                    </linearGradient>
                </defs>
                <rect x="5" y="5" width="90" height="90" rx="20" fill="url(#gsBadgeGrad)"/>
                <g transform="rotate(-12, 35, 50)">
                    <rect x="15" y="28" width="28" height="36" rx="4" fill="white"/>
                    <circle cx="43" cy="46" r="6" fill="white"/>
                    <text x="29" y="54" fontFamily="Arial" fontSize="20" fontWeight="bold" fill="#667eea" textAnchor="middle">G</text>
                </g>
                <g transform="rotate(12, 65, 50)">
                    <rect x="57" y="28" width="28" height="36" rx="4" fill="rgba(255,255,255,0.9)"/>
                    <circle cx="57" cy="46" r="6" fill="url(#gsBadgeGrad)"/>
                    <text x="71" y="54" fontFamily="Arial" fontSize="20" fontWeight="bold" fill="#764ba2" textAnchor="middle">S</text>
                </g>
            </svg>
        ),
        Upload: () => <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12" /></svg>,
        Rocket: () => <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15.59 14.37a6 6 0 01-5.84 7.38v-4.8m5.84-2.58a14.98 14.98 0 006.16-12.12A14.98 14.98 0 009.631 8.41m5.96 5.96a14.926 14.926 0 01-5.841 2.58m-.119-8.54a6 6 0 00-7.381 5.84h4.8m2.581-5.84a14.927 14.927 0 00-2.58 5.84m2.699 2.7c-.103.021-.207.041-.311.06a15.09 15.09 0 01-2.448-2.448 14.9 14.9 0 01.06-.312m-2.24 2.39a4.493 4.493 0 00-1.757 4.306 4.493 4.493 0 004.306-1.758M16.5 9a1.5 1.5 0 11-3 0 1.5 1.5 0 013 0z" /></svg>,
        X: () => <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" /></svg>,
        Settings: () => <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" /><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" /></svg>,
        History: () => <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>,
        ExternalLink: () => <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14" /></svg>,
        ArrowRight: () => <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M14 5l7 7m0 0l-7 7m7-7H3" /></svg>,
        Zap: () => <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 10V3L4 14h7v7l9-11h-7z" /></svg>,
        AlertTriangle: () => <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" /></svg>,
        Rewind: () => <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12.066 11.2a1 1 0 000 1.6l5.334 4A1 1 0 0019 16V8a1 1 0 00-1.6-.8l-5.333 4zM4.066 11.2a1 1 0 000 1.6l5.334 4A1 1 0 0011 16V8a1 1 0 00-1.6-.8l-5.334 4z" /></svg>,
        GitBranch: () => <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 9l3 3-3 3m5 0h3M5 20h14a2 2 0 002-2V6a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z" /></svg>,
        Check: () => <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" /></svg>,
        Shield: () => <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 9c0 5.591 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.042-.133-2.052-.382-3.016z" /></svg>,
        Refresh: () => <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" /></svg>,
        Play: () => <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z" /><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>,
        Folder: () => <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-6l-2-2H5a2 2 0 00-2 2z" /></svg>,
        File: () => <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" /></svg>,
        Trash: () => <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" /></svg>,
        Archive: () => <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 8h14M5 8a2 2 0 110-4h14a2 2 0 110 4M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8m-9 4h4" /></svg>,
        Eye: () => <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" /><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z" /></svg>,
        Download: () => <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" /></svg>,
        Plus: () => <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v16m8-8H4" /></svg>,
        Database: () => <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 7v10c0 2.21 3.582 4 8 4s8-1.79 8-4V7M4 7c0 2.21 3.582 4 8 4s8-1.79 8-4M4 7c0-2.21 3.582-4 8-4s8 1.79 8 4m0 5c0 2.21-3.582 4-8 4s-8-1.79-8-4" /></svg>,
        User: () => <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" /></svg>,
        AlertCircle: () => <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>,
        Edit: () => <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" /></svg>,
        Copy: () => <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" /></svg>,
        Search: () => <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" /></svg>,
    };
    
    // Helper to render app icons (handles both emojis and special logo identifiers)
    const AppIcon = ({ icon, size = 20 }) => {
        if (icon === 'gs-logo') {
            return <Icons.GameShelfLogo size={size} />;
        }
        // Return emoji as-is
        return <span style={{ fontSize: size * 0.9 }}>{icon}</span>;
    };
    
    // Helper for native <option> elements that can't render components
    const getAppEmoji = (icon) => {
        if (icon === 'gs-logo') return '🎮'; // Fallback emoji for Game Shelf
        return icon || '📦';
    };

    // =========================================================================
    // UTILITIES
    // =========================================================================
    
    function parseFilename(filename) {
        const patterns = [
            /^(gameshelf|game[-_]?shelf)[-_]v?(\d+)[_.](\d+)[_.](\d+)[_.](\d+)\.html$/i,
            /^(\w+)[-_]v?(\d+)[_.](\d+)[_.](\d+)\.html$/i,
        ];
        for (const pattern of patterns) {
            const match = filename.match(pattern);
            if (match) {
                let app = match[1].toLowerCase().replace(/[-_]/g, '');
                const version = match.length === 6 
                    ? `${match[2]}.${match[3]}.${match[4]}.${match[5]}`
                    : `${match[2]}.${match[3]}.${match[4]}`;
                return { app, version };
            }
        }
        const appMatch = filename.match(/^(\w+)/);
        return { app: appMatch ? appMatch[1].toLowerCase() : null, version: null };
    }
    
    // Detect app from HTML content
    // Primary: Explicit gs-app-id meta tag (definitive, permanent)
    // Fallback: Pattern matching for legacy files
    function detectAppFromContent(content) {
        if (!content || typeof content !== 'string') return null;
        
        // =====================================================================
        // PRIMARY: Check for explicit app identifier (100% reliable)
        // Format: <meta name="gs-app-id" content="appname">
        // =====================================================================
        const appIdMatch = content.match(/<meta\s+name=["']gs-app-id["']\s+content=["']([^"']+)["']/i);
        if (appIdMatch) {
            const appId = appIdMatch[1].toLowerCase();
            return {
                id: appId,
                confidence: 'definite',
                method: 'gs-app-id',
                matchCount: 1,
                matchedPatterns: ['gs-app-id meta tag']
            };
        }
        
        // =====================================================================
        // SECONDARY: Dynamic patterns from app config (user-configurable)
        // Scores all apps and picks the best (most matches) to avoid
        // broad patterns shadowing specific ones (e.g. "rungs" vs "rungs builder")
        // =====================================================================
        const allApps = window.__CC_APPS || {};
        const dynamicCandidates = [];
        
        for (const [appId, app] of Object.entries(allApps)) {
            const patterns = app.detectionPatterns || [];
            if (!patterns.length) continue;
            
            let matchCount = 0;
            let matchedPatterns = [];
            let totalPatternLength = 0;
            
            for (const pat of patterns) {
                try {
                    const regex = new RegExp(pat, 'i');
                    if (regex.test(content)) {
                        matchCount++;
                        matchedPatterns.push(pat);
                        totalPatternLength += pat.length;
                    }
                } catch (e) { /* skip invalid regex */ }
            }
            
            if (matchCount > 0) {
                dynamicCandidates.push({
                    id: appId,
                    confidence: matchCount >= 2 ? 'high' : 'medium',
                    method: 'dynamic-pattern',
                    matchCount,
                    matchedPatterns,
                    // Specificity score: prefer more matches, then longer patterns
                    specificity: matchCount * 1000 + totalPatternLength
                });
            }
        }
        
        if (dynamicCandidates.length > 0) {
            // Pick the most specific match
            dynamicCandidates.sort((a, b) => b.specificity - a.specificity);
            const best = dynamicCandidates[0];
            return {
                id: best.id,
                confidence: best.confidence,
                method: best.method,
                matchCount: best.matchCount,
                matchedPatterns: best.matchedPatterns
            };
        }
        
        // =====================================================================
        // FALLBACK: Hardcoded pattern matching for legacy files without gs-app-id
        // This can be removed once all apps have the meta tag
        // =====================================================================
        const sample = content.substring(0, 5000).toLowerCase();
        
        // Legacy signatures - ordered by specificity
        const signatures = [
            {
                id: 'command-center',
                patterns: [
                    /<title>.*command\s*center/i,
                    /<title>.*ship\s*it/i,
                    /command-center/i,
                    /claude.*deploy.*queue/i
                ]
            },
            {
                id: 'beta',
                patterns: [
                    /<title>game\s*shelf\s*beta\s*hub/i,
                    /beta\s*hub\s*v\d/i,
                    /gs-app-id.*beta/i,
                    /earlyAccess.*surveyResponses/i
                ]
            },
            {
                id: 'landing',
                patterns: [
                    /track\s*every\s*daily\s*puzzle/i,
                    /join\s*the\s*beta/i,
                    /cta-button/i,
                    /<h1[^>]*>GAME\s*SHELF<\/h1>/i
                ]
            },
            {
                id: 'gameshelf',
                patterns: [
                    /gameshelfdata/i,
                    /game\.shelf\.pwa/i,
                    /#setup-welcome/i,
                    /APP_VERSION\s*=/i
                ]
            },
            {
                id: 'testplan',
                patterns: [
                    /<title>.*test\s*plan/i,
                    /playwright.*runner/i,
                    /lean-tests\.spec/i
                ]
            },
            {
                id: 'quotle',
                patterns: [
                    /<title>quotle/i,
                    /quotle.*daily.*quote/i,
                    /quotes-database/i
                ]
            },
            {
                id: 'slate',
                patterns: [
                    /<title>slate/i,
                    /slate.*daily.*word/i,
                    /chalkboard-bg/i
                ]
            },
            {
                id: 'rungs',
                patterns: [
                    /<title>rungs/i,
                    /rungs.*daily/i,
                    /word-ladder/i
                ]
            },
            {
                id: 'wordboxing',
                patterns: [
                    /<title>word\s*boxing/i,
                    /word-boxing/i,
                    /boxing-ring/i
                ]
            },
            {
                id: 'edutrack',
                patterns: [
                    /<title>edutrack/i,
                    /edutrack-data/i,
                    /ET-[A-Z]{2}-\d{3}/,
                    /student-codes/i
                ]
            },
            {
                id: 'firebase-functions',
                patterns: [
                    /firebase-functions/i,
                    /exports\.getHint/i,
                    /onRequest|onCall/i,
                    /ANTHROPIC_API_KEY/i
                ]
            }
        ];
        
        // Check each app's signatures
        for (const app of signatures) {
            let matchCount = 0;
            let matchedPatterns = [];
            
            for (const pattern of app.patterns) {
                if (pattern.test(content)) {
                    matchCount++;
                    matchedPatterns.push(pattern.toString());
                }
            }
            
            if (matchCount > 0) {
                return {
                    id: app.id,
                    confidence: matchCount >= 2 ? 'high' : 'medium',
                    method: 'pattern-match',
                    matchCount,
                    matchedPatterns
                };
            }
        }
        
        return null;
    }
    
    function formatBytes(bytes) {
        if (bytes < 1024) return bytes + ' B';
        if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
        return (bytes / (1024 * 1024)).toFixed(2) + ' MB';
    }
    
    function formatDate(date) {
        return new Date(date).toLocaleString();
    }
    
    // Get the URL for a GitHub Pages site
    // Supports custom domains and subPaths for consolidated repos
    function getGitHubPagesUrl(repo, subPath = '') {
        if (!repo) return null;
        const [owner, repoName] = repo.split('/');
        
        // Check for custom domain
        if (CUSTOM_DOMAINS[repo]) {
            const domain = CUSTOM_DOMAINS[repo];
            // Custom domain - subPath goes after domain
            if (subPath) {
                return `https://${domain}/${subPath}/`;
            }
            return `https://${domain}/`;
        }
        
        // Standard GitHub Pages URL
        if (subPath) {
            return `https://${owner}.github.io/${repoName}/${subPath}/`;
        }
        return `https://${owner}.github.io/${repoName}/`;
    }
    
    // Helper to get satellite app URL (resolves to absolute GitHub Pages URL)
    // Satellites always live in the production repo (command-center), not the test repo
    // Works from any context: hosted on GitHub Pages, local file://, or in components without 'apps'
    function getSatelliteUrl(apps, subPath) {
        // 1. Try to resolve from apps config (most accurate — uses custom domains, etc.)
        const ccApp = apps && apps['command-center'];
        const prodRepo = ccApp?.prodRepo || ccApp?.repos?.prod || '';
        if (prodRepo) {
            return getGitHubPagesUrl(prodRepo, subPath);
        }
        // 2. If on GitHub Pages, always use the production repo for satellites
        //    Satellites only exist in production (command-center), not test (command-center-test)
        if (window.location.hostname.endsWith('.github.io')) {
            const owner = window.location.hostname.split('.')[0];
            return `${window.location.origin}/command-center/${subPath}/`;
        }
        // 3. Fallback: relative path (works when already at the right base)
        return `${subPath}/`;
    }

    // Helper to get effective subPath (falls back to defaults if stored value is empty)
    function getEffectiveSubPath(app, appId) {
        return app.subPath || '';
    }
    
    // Helper to get full file path in repo (prepends subPath if needed)
    function getRepoFilePath(app, filename) {
        if (app.subPath) {
            return `${app.subPath}/${filename}`;
        }
        return filename;
    }
    
    function autoMapRepos(apps, repos) {
        const updatedApps = { ...apps };
        console.log('Auto-mapping repos. Available:', repos.map(r => r.name));
        
        for (const [appId, app] of Object.entries(updatedApps)) {
            const patterns = app.repoPatterns;
            if (!patterns) continue;
            
            if (!app.testRepo && patterns.test) {
                for (const pattern of patterns.test) {
                    const found = repos.find(r => r.name.toLowerCase() === pattern.toLowerCase());
                    if (found) { 
                        console.log(`[${appId}] Mapped TEST: ${found.fullName}`);
                        updatedApps[appId] = { ...updatedApps[appId], testRepo: found.fullName }; 
                        break; 
                    }
                }
            }
            if (!app.prodRepo && patterns.prod) {
                for (const pattern of patterns.prod) {
                    const found = repos.find(r => r.name.toLowerCase() === pattern.toLowerCase() && !r.name.toLowerCase().includes('test'));
                    if (found) { 
                        console.log(`[${appId}] Mapped PROD: ${found.fullName}`);
                        updatedApps[appId] = { ...updatedApps[appId], prodRepo: found.fullName }; 
                        break; 
                    }
                }
            }
        }
        return updatedApps;
    }
    
    // v8.8.0: Group apps by project
    function getProjectsWithApps(apps, projects, filterFn = null) {
        const projectMap = {};
        const projectDefs = projects || SEED_PROJECTS;
        const appList = Object.values(apps).filter(a => (a.testRepo || a.prodRepo) && (!filterFn || filterFn(a)));
        
        for (const app of appList) {
            const projId = app.project || 'other';
            if (!projectMap[projId]) {
                const projDef = projectDefs[projId] || projectDefs['other'] || { id: projId, name: projId, icon: '📦', color: 'slate', order: 98 };
                projectMap[projId] = { ...projDef, id: projId, apps: [] };
            }
            projectMap[projId].apps.push(app);
        }
        
        // Sort projects by order, then apps within each project by name
        return Object.values(projectMap)
            .sort((a, b) => (a.order || 99) - (b.order || 99))
            .map(p => ({ ...p, apps: p.apps.sort((a, b) => a.name.localeCompare(b.name)) }));
    }
    
    // Project color classes
    const PROJECT_COLORS = {
        indigo: { bg: 'bg-indigo-600/15', border: 'border-indigo-500/30', text: 'text-indigo-400', accent: 'bg-indigo-600' },
        rose: { bg: 'bg-rose-600/15', border: 'border-rose-500/30', text: 'text-rose-400', accent: 'bg-rose-600' },
        emerald: { bg: 'bg-emerald-600/15', border: 'border-emerald-500/30', text: 'text-emerald-400', accent: 'bg-emerald-600' },
        amber: { bg: 'bg-amber-600/15', border: 'border-amber-500/30', text: 'text-amber-400', accent: 'bg-amber-600' },
        slate: { bg: 'bg-slate-600/15', border: 'border-slate-500/30', text: 'text-slate-400', accent: 'bg-slate-600' },
        cyan: { bg: 'bg-cyan-600/15', border: 'border-cyan-500/30', text: 'text-cyan-400', accent: 'bg-cyan-600' },
        purple: { bg: 'bg-purple-600/15', border: 'border-purple-500/30', text: 'text-purple-400', accent: 'bg-purple-600' }
    };
    
    function getProjectColor(color) {
        return PROJECT_COLORS[color] || PROJECT_COLORS.slate;
    }

    function getFileIcon(filename) {
        const ext = filename.split('.').pop()?.toLowerCase();
        const icons = {
            html: '📄', js: '📜', css: '🎨', json: '📋', md: '📝',
            png: '🖼️', jpg: '🖼️', jpeg: '🖼️', gif: '🖼️', svg: '🎨',
            ico: '🔷', txt: '📃', xml: '📰', yml: '⚙️', yaml: '⚙️'
        };
        return icons[ext] || '📄';
    }

    // =========================================================================
    // GITHUB API
    // =========================================================================
    
    class GitHubAPI {
        constructor(token) {
            this.token = token;
            this.baseUrl = 'https://api.github.com';
        }
        
        // Helper: Clean base64 content from GitHub (remove newlines)
        cleanBase64(content) {
            return content ? content.replace(/[\r\n\s]/g, '') : '';
        }
        
        // Helper: Decode base64 content from GitHub to UTF-8 string
        decodeContent(content) {
            const clean = this.cleanBase64(content);
            return decodeURIComponent(escape(atob(clean)));
        }
        
        async request(endpoint, options = {}, retries = 0) {
            const url = `${this.baseUrl}${endpoint}`;
            const maxRetries = options._maxRetries ?? 3;
            try {
                const response = await fetch(url, {
                    ...options,
                    headers: {
                        'Authorization': `token ${this.token}`,
                        'Accept': 'application/vnd.github.v3+json',
                        'Content-Type': 'application/json',
                        ...options.headers
                    }
                });
                
                // Track rate limit from response headers
                const remaining = response.headers.get('X-RateLimit-Remaining');
                const limit = response.headers.get('X-RateLimit-Limit');
                const resetTime = response.headers.get('X-RateLimit-Reset');
                
                if (remaining !== null) {
                    this.rateLimit = { remaining: parseInt(remaining), limit: parseInt(limit), resetTime: parseInt(resetTime) * 1000 };
                    if (parseInt(remaining) < 100) {
                        console.warn(`⚠️ GitHub API rate limit low: ${remaining}/${limit} remaining. Resets at ${new Date(this.rateLimit.resetTime).toLocaleTimeString()}`);
                    }
                }
                
                // Handle rate limit exceeded
                if (response.status === 403 && remaining === '0') {
                    const resetDate = new Date(parseInt(resetTime) * 1000);
                    throw new Error(`GitHub API rate limit exceeded. Resets at ${resetDate.toLocaleTimeString()}. Please wait and try again.`);
                }
                
                // Retry on 400/502/503 (transient GitHub errors)
                if ((response.status === 400 || response.status === 502 || response.status === 503) && retries < maxRetries) {
                    const delay = Math.min(1000 * Math.pow(2, retries), 8000); // 1s, 2s, 4s, 8s
                    console.warn(`⚠️ GitHub API ${response.status} on ${endpoint} — retry ${retries + 1}/${maxRetries} in ${delay}ms`);
                    await new Promise(r => setTimeout(r, delay));
                    return this.request(endpoint, options, retries + 1);
                }
                
                if (!response.ok) {
                    const error = await response.json().catch(() => ({}));
                    console.error('GitHub API Error:', {
                        url,
                        status: response.status,
                        error,
                        body: options.body ? JSON.parse(options.body) : null
                    });
                    throw new Error(error.message || `GitHub API error: ${response.status}`);
                }
                return response.json();
            } catch (e) {
                // Retry on network errors (TypeError: Load failed, CORS issues)
                if (e instanceof TypeError && retries < maxRetries) {
                    const delay = Math.min(1000 * Math.pow(2, retries), 8000);
                    console.warn(`⚠️ Network error on ${endpoint} — retry ${retries + 1}/${maxRetries} in ${delay}ms: ${e.message}`);
                    await new Promise(r => setTimeout(r, delay));
                    return this.request(endpoint, options, retries + 1);
                }
                console.error('Request failed:', url, e);
                throw e;
            }
        }
        
        // Get current rate limit status
        getRateLimit() {
            return this.rateLimit || { remaining: null, limit: null, resetTime: null };
        }
        
        // Check if user has push (write) access to a repo
        async checkPushAccess(repo) {
            try {
                const [owner, repoName] = repo.split('/');
                const data = await this.request(`/repos/${owner}/${repoName}`);
                return data?.permissions?.push === true;
            } catch (e) {
                // 404 = repo doesn't exist or no access at all
                return false;
            }
        }

        // Check if a file exists in a repo (returns true/false)
        async fileExists(repo, path) {
            try {
                const [owner, repoName] = repo.split('/');
                await this.request(`/repos/${owner}/${repoName}/contents/${path}?_=${Date.now()}`);
                return true;
            } catch {
                return false;
            }
        }

        async listRepos() {
            const repos = await this.request('/user/repos?per_page=100&sort=updated');
            return repos.map(r => ({ fullName: r.full_name, name: r.name, owner: r.owner.login }));
        }
        
        async getFile(repo, path) {
            try {
                const [owner, repoName] = repo.split('/');
                // Add timestamp to bust GitHub API cache
                return await this.request(`/repos/${owner}/${repoName}/contents/${path}?_=${Date.now()}`);
            } catch { return null; }
        }
        
        // Get file content - handles large files (>1MB) that GitHub API doesn't return content for
        async getFileContent(repo, path) {
            try {
                const file = await this.getFile(repo, path);
                if (!file) return null;
                
                // For large files (>1MB), GitHub API doesn't return content - use download_url
                if (!file.content && file.download_url) {
                    console.log(`Large file detected (${path}), using download_url`);
                    // Add cache-busting to download_url
                    const cacheBustUrl = file.download_url + (file.download_url.includes('?') ? '&' : '?') + '_=' + Date.now();
                    const response = await fetch(cacheBustUrl);
                    const content = await response.text();
                    return { ...file, content: null, textContent: content };
                }
                
                // Normal file - decode base64 content
                const textContent = this.decodeContent(file.content);
                return { ...file, textContent };
            } catch (e) {
                console.warn(`Failed to get file content for ${path}:`, e);
                return null;
            }
        }
        
        // Get file content at specific commit - handles large files
        async getFileContentAtCommit(repo, path, commitSha) {
            try {
                const file = await this.getFileAtCommit(repo, path, commitSha);
                if (!file) return null;
                
                // For large files, use raw URL with commit ref
                if (!file.content && file.download_url) {
                    console.log(`Large file detected at commit (${path}), using download_url`);
                    const response = await fetch(file.download_url);
                    const content = await response.text();
                    return { ...file, content: null, textContent: content };
                }
                
                // Normal file - decode base64 content
                const textContent = this.decodeContent(file.content);
                return { ...file, textContent };
            } catch (e) {
                console.warn(`Failed to get file content at commit for ${path}:`, e);
                return null;
            }
        }
        
        async getFileAtCommit(repo, path, commitSha) {
            try {
                const [owner, repoName] = repo.split('/');
                return await this.request(`/repos/${owner}/${repoName}/contents/${path}?ref=${commitSha}`);
            } catch { return null; }
        }
        
        // Get blob content directly via Git Blob API - bypasses CDN caching
        async getBlobContent(repo, sha) {
            try {
                const [owner, repoName] = repo.split('/');
                const blob = await this.request(`/repos/${owner}/${repoName}/git/blobs/${sha}?_=${Date.now()}`);
                if (blob && blob.content) {
                    return {
                        content: blob.content,
                        encoding: blob.encoding,
                        size: blob.size
                    };
                }
                return null;
            } catch (e) {
                console.warn(`Failed to get blob ${sha}:`, e);
                return null;
            }
        }
        
        async listRepoContents(repo, path = '') {
            try {
                const [owner, repoName] = repo.split('/');
                const endpoint = path 
                    ? `/repos/${owner}/${repoName}/contents/${path}`
                    : `/repos/${owner}/${repoName}/contents`;
                // Add timestamp to bust any caching
                const cacheBuster = `?_=${Date.now()}`;
                const contents = await this.request(endpoint + cacheBuster);
                return Array.isArray(contents) ? contents : [contents];
            } catch { return []; }
        }
        
        
        async createOrUpdateFile(repo, path, content, message, sha = null, branch = 'main') {
            const [owner, repoName] = repo.split('/');
            const body = {
                message,
                content: btoa(unescape(encodeURIComponent(content))),
                committer: { name: 'Command Center', email: 'deploy@gameshelf.app' },
                branch
            };
            if (sha) body.sha = sha;
            
            const url = `/repos/${owner}/${repoName}/contents/${path}`;
            console.log('createOrUpdateFile request:', { 
                url,
                repo, 
                path, 
                sha, 
                branch,
                messageLength: message.length, 
                contentLength: content.length,
                base64Length: body.content.length
            });
            
            try {
                return await this.request(url, { method: 'PUT', body: JSON.stringify(body) });
            } catch (error) {
                console.error('createOrUpdateFile failed:', {
                    url,
                    error: error.message,
                    sha,
                    bodyPreview: JSON.stringify(body).substring(0, 200)
                });
                throw error;
            }
        }
        
        async deleteFile(repo, path, message, sha) {
            const [owner, repoName] = repo.split('/');
            return this.request(`/repos/${owner}/${repoName}/contents/${path}`, {
                method: 'DELETE',
                body: JSON.stringify({
                    message,
                    sha,
                    committer: { name: 'Command Center', email: 'deploy@gameshelf.app' }
                })
            });
        }
        
        async createTag(repo, tagName, sha, message) {
            const [owner, repoName] = repo.split('/');
            
            // Check if tag already exists
            try {
                await this.request(`/repos/${owner}/${repoName}/git/ref/tags/${tagName}`);
                console.log(`Tag ${tagName} already exists, skipping`);
                return { existing: true, tag: tagName };
            } catch {
                // Tag doesn't exist, create it
            }
            
            const tagObj = await this.request(`/repos/${owner}/${repoName}/git/tags`, {
                method: 'POST',
                body: JSON.stringify({
                    tag: tagName, message, object: sha, type: 'commit',
                    tagger: { name: 'Command Center', email: 'deploy@gameshelf.app', date: new Date().toISOString() }
                })
            });
            await this.request(`/repos/${owner}/${repoName}/git/refs`, {
                method: 'POST',
                body: JSON.stringify({ ref: `refs/tags/${tagName}`, sha: tagObj.sha })
            });
            return tagObj;
        }
        
        async enablePages(repo) {
            const [owner, repoName] = repo.split('/');
            try {
                await this.request(`/repos/${owner}/${repoName}/pages`);
                return { alreadyEnabled: true };
            } catch {}
            const response = await fetch(`${this.baseUrl}/repos/${owner}/${repoName}/pages`, {
                method: 'POST',
                headers: { 'Authorization': `token ${this.token}`, 'Accept': 'application/vnd.github.v3+json', 'Content-Type': 'application/json' },
                body: JSON.stringify({ source: { branch: 'main', path: '/' } })
            });
            if (!response.ok) throw new Error(`Failed to enable Pages`);
            return { enabled: true };
        }
        
        // Get recent workflow runs for a repo
        async getWorkflowRuns(repo, options = {}) {
            const [owner, repoName] = repo.split('/');
            const params = new URLSearchParams();
            if (options.per_page) params.append('per_page', options.per_page);
            if (options.branch) params.append('branch', options.branch);
            if (options.event) params.append('event', options.event);
            if (options.status) params.append('status', options.status);
            
            const queryString = params.toString();
            const endpoint = `/repos/${owner}/${repoName}/actions/runs${queryString ? '?' + queryString : ''}`;
            
            try {
                const result = await this.request(endpoint);
                return result.workflow_runs || [];
            } catch (e) {
                console.error('Failed to get workflow runs:', e);
                return [];
            }
        }
        
        // Get a specific workflow run
        async getWorkflowRun(repo, runId) {
            const [owner, repoName] = repo.split('/');
            try {
                return await this.request(`/repos/${owner}/${repoName}/actions/runs/${runId}`);
            } catch (e) {
                console.error('Failed to get workflow run:', e);
                return null;
            }
        }
        
        // Get workflow run logs URL (returns URL, not content - logs require redirect)
        async getWorkflowRunLogsUrl(repo, runId) {
            const [owner, repoName] = repo.split('/');
            return `https://github.com/${owner}/${repoName}/actions/runs/${runId}`;
        }
        
        // Monitor a workflow run until completion
        async waitForWorkflowRun(repo, runId, maxWaitMs = 300000, onStatus = null) {
            const startTime = Date.now();
            let lastStatus = null;
            
            while (Date.now() - startTime < maxWaitMs) {
                const run = await this.getWorkflowRun(repo, runId);
                
                if (run && run.status !== lastStatus) {
                    lastStatus = run.status;
                    if (onStatus) onStatus(run);
                }
                
                // Terminal states
                if (run?.status === 'completed') {
                    return { 
                        success: run.conclusion === 'success',
                        conclusion: run.conclusion, // success, failure, cancelled, skipped
                        run,
                        logsUrl: await this.getWorkflowRunLogsUrl(repo, runId)
                    };
                }
                
                // Wait 5 seconds before checking again
                await new Promise(r => setTimeout(r, 5000));
            }
            
            return { 
                success: false, 
                error: 'Timeout waiting for workflow', 
                logsUrl: await this.getWorkflowRunLogsUrl(repo, runId)
            };
        }
        
        // Find a workflow run triggered after a specific time
        async findRecentWorkflowRun(repo, afterTime, maxWaitMs = 30000) {
            const startTime = Date.now();
            
            while (Date.now() - startTime < maxWaitMs) {
                const runs = await this.getWorkflowRuns(repo, { per_page: 5 });
                
                // Find a run that started after our commit
                const recentRun = runs.find(run => {
                    const runTime = new Date(run.created_at).getTime();
                    return runTime >= afterTime - 5000; // 5 second tolerance
                });
                
                if (recentRun) {
                    return recentRun;
                }
                
                // Wait 3 seconds before checking again
                await new Promise(r => setTimeout(r, 3000));
            }
            
            return null;
        }
        
        // Batch commit multiple files in one commit
        async batchCommit(repo, files, message) {
            const [owner, repoName] = repo.split('/');
            
            console.log('=== BATCH COMMIT START ===');
            console.log('Repo:', repo);
            console.log('Message:', message);
            console.log('Files to commit:', files.map(f => ({ path: f.path, contentLength: f.content?.length, encoding: f.encoding })));
            
            // Get current commit SHA
            const ref = await this.request(`/repos/${owner}/${repoName}/git/ref/heads/main`);
            const commitSha = ref.object.sha;
            console.log('Current commit SHA:', commitSha);
            
            // Get current tree
            const commit = await this.request(`/repos/${owner}/${repoName}/git/commits/${commitSha}`);
            const treeSha = commit.tree.sha;
            console.log('Current tree SHA:', treeSha);
            
            // Create blobs sequentially (parallel uploads cause CORS/throttling failures on GitHub)
            const treeItems = [];
            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                console.log(`Creating blob for: ${file.path} (${i + 1}/${files.length})`);
                const blob = await this.request(`/repos/${owner}/${repoName}/git/blobs`, {
                    method: 'POST',
                    body: JSON.stringify({
                        content: file.content,
                        encoding: file.encoding || 'utf-8'
                    })
                });
                console.log('Blob created:', file.path, '-> SHA:', blob.sha);
                treeItems.push({
                    path: file.path,
                    mode: '100644',
                    type: 'blob',
                    sha: blob.sha
                });
                // Small delay between blob uploads to avoid GitHub throttling
                if (i < files.length - 1) {
                    await new Promise(r => setTimeout(r, 250));
                }
            }
            
            console.log('Tree items:', treeItems);
            
            // Create new tree
            const treePayload = {
                base_tree: treeSha,
                tree: treeItems
            };
            console.log('Creating tree with payload:', JSON.stringify(treePayload, null, 2));
            
            const newTree = await this.request(`/repos/${owner}/${repoName}/git/trees`, {
                method: 'POST',
                body: JSON.stringify(treePayload)
            });
            console.log('New tree SHA:', newTree.sha);
            
            // Create commit
            const newCommit = await this.request(`/repos/${owner}/${repoName}/git/commits`, {
                method: 'POST',
                body: JSON.stringify({
                    message,
                    tree: newTree.sha,
                    parents: [commitSha],
                    committer: { name: 'Command Center', email: 'deploy@gameshelf.app' }
                })
            });
            console.log('New commit SHA:', newCommit.sha);
            
            // Update ref (force: true handles non-fast-forward cases)
            const updatedRef = await this.request(`/repos/${owner}/${repoName}/git/refs/heads/main`, {
                method: 'PATCH',
                body: JSON.stringify({ sha: newCommit.sha, force: true })
            });
            console.log('Ref updated:', updatedRef);
            console.log('=== BATCH COMMIT COMPLETE ===');
            
            return newCommit;
        }

        // Phase 3: List recent commits for orphan detection
        async listRecentCommits(repo, perPage = 30) {
            const [owner, repoName] = repo.split('/');
            return await this.request(`/repos/${owner}/${repoName}/commits?per_page=${perPage}&_=${Date.now()}`);
        }

        // Phase 3: Get single commit details (includes files changed)
        async getCommitDetail(repo, sha) {
            const [owner, repoName] = repo.split('/');
            return await this.request(`/repos/${owner}/${repoName}/commits/${sha}`);
        }
    }

    // =========================================================================
    // ODRC CONCEPT SYSTEM (Ideation Platform v1)
    // =========================================================================

    // Valid ODRC types
    const ODRC_TYPES = ['OPEN', 'DECISION', 'RULE', 'CONSTRAINT'];

    // Valid concept statuses
    const CONCEPT_STATUSES = ['active', 'superseded', 'resolved', 'transitioned'];

    // State machine: maps current type to array of valid target types
    const ODRC_TRANSITIONS = {
        'OPEN':       ['DECISION', 'RULE', 'CONSTRAINT'],
        'DECISION':   ['RULE'],
        'CONSTRAINT': ['DECISION', 'RULE'],
        'RULE':       ['OPEN']
    };

    // Validate a type transition is allowed
    function isValidODRCTransition(fromType, toType) {
        if (!ODRC_TRANSITIONS[fromType]) return false;
        return ODRC_TRANSITIONS[fromType].includes(toType);
    }

    // ODRC Concept Manager — Firebase CRUD + state machine
    const ConceptManager = {
        // Get Firebase ref for concepts under a user
        _ref(uid) {
            return firebaseDb.ref(`command-center/${uid}/concepts`);
        },

        // Create a new concept
        async create(uid, { type, content, ideaOrigin, scopeTags = [] }) {
            if (!ODRC_TYPES.includes(type)) {
                throw new Error(`Invalid concept type: ${type}. Must be one of: ${ODRC_TYPES.join(', ')}`);
            }
            const ref = this._ref(uid).push();
            const now = new Date().toISOString();
            const concept = {
                id: ref.key,
                type,
                content,
                ideaOrigin,
                status: 'active',
                resolvedBy: null,
                transitionedFrom: null,
                scopeTags,
                createdAt: now,
                updatedAt: now
            };
            await ref.set(concept);
            return concept;
        },

        // Read all concepts for a user
        async getAll(uid) {
            const snapshot = await this._ref(uid).once('value');
            const data = snapshot.val();
            if (!data) return [];
            return Object.values(data);
        },

        // Read concepts filtered by ideaOrigin
        async getByIdea(uid, ideaId) {
            const all = await this.getAll(uid);
            return all.filter(c => c.ideaOrigin === ideaId);
        },

        // Read all active concepts for an app (across all its ideas)
        async getActiveForApp(uid, ideaIds) {
            const all = await this.getAll(uid);
            return all.filter(c => ideaIds.includes(c.ideaOrigin) && c.status === 'active');
        },

        // Update a concept's content, scopeTags, or other editable fields
        async update(uid, conceptId, updates) {
            const allowed = ['content', 'scopeTags'];
            const filtered = {};
            for (const key of allowed) {
                if (updates[key] !== undefined) filtered[key] = updates[key];
            }
            filtered.updatedAt = new Date().toISOString();
            await this._ref(uid).child(conceptId).update(filtered);
            return filtered;
        },

        // Transition a concept to a new type (follows state machine)
        // Creates a new concept of the target type and marks the original as transitioned
        async transition(uid, conceptId, newType) {
            if (!ODRC_TYPES.includes(newType)) {
                throw new Error(`Invalid target type: ${newType}`);
            }

            // Fetch current concept
            const snapshot = await this._ref(uid).child(conceptId).once('value');
            const concept = snapshot.val();
            if (!concept) throw new Error(`Concept not found: ${conceptId}`);
            if (concept.status !== 'active') throw new Error(`Cannot transition non-active concept (status: ${concept.status})`);

            if (!isValidODRCTransition(concept.type, newType)) {
                throw new Error(`Invalid transition: ${concept.type} → ${newType}. Allowed: ${ODRC_TRANSITIONS[concept.type].join(', ')}`);
            }

            const now = new Date().toISOString();

            // Create the new concept (inherits content, scopeTags, ideaOrigin)
            const newRef = this._ref(uid).push();
            const newConcept = {
                id: newRef.key,
                type: newType,
                content: concept.content,
                ideaOrigin: concept.ideaOrigin,
                status: 'active',
                resolvedBy: null,
                transitionedFrom: conceptId,
                scopeTags: concept.scopeTags || [],
                createdAt: now,
                updatedAt: now
            };

            // Mark old concept as transitioned
            const oldUpdate = {
                status: 'transitioned',
                resolvedBy: newRef.key,
                updatedAt: now
            };

            // If a CONSTRAINT transitions, flag related concepts for review
            let flaggedConcepts = [];
            if (concept.type === 'CONSTRAINT' && concept.scopeTags && concept.scopeTags.length > 0) {
                flaggedConcepts = await this._flagRelatedConcepts(uid, concept.scopeTags, conceptId);
            }

            // Write both atomically via multi-path update
            const updates = {};
            updates[`${conceptId}/status`] = oldUpdate.status;
            updates[`${conceptId}/resolvedBy`] = oldUpdate.resolvedBy;
            updates[`${conceptId}/updatedAt`] = oldUpdate.updatedAt;
            updates[newRef.key] = newConcept;
            await this._ref(uid).update(updates);

            return { newConcept, flaggedConcepts };
        },

        // Flag active DECISIONs and RULEs that share scope tags with a transitioning CONSTRAINT
        async _flagRelatedConcepts(uid, scopeTags, excludeConceptId) {
            const all = await this.getAll(uid);
            const flagged = [];
            for (const c of all) {
                if (c.id === excludeConceptId) continue;
                if (c.status !== 'active') continue;
                if (c.type !== 'DECISION' && c.type !== 'RULE') continue;
                const hasOverlap = (c.scopeTags || []).some(tag => scopeTags.includes(tag));
                if (hasOverlap) {
                    flagged.push(c);
                }
            }
            return flagged;
        },

        // Supersede a concept (replace it with a new one, same type)
        async supersede(uid, conceptId, newContent) {
            const snapshot = await this._ref(uid).child(conceptId).once('value');
            const concept = snapshot.val();
            if (!concept) throw new Error(`Concept not found: ${conceptId}`);

            const now = new Date().toISOString();
            const newRef = this._ref(uid).push();
            const newConcept = {
                id: newRef.key,
                type: concept.type,
                content: newContent,
                ideaOrigin: concept.ideaOrigin,
                status: 'active',
                resolvedBy: null,
                transitionedFrom: conceptId,
                scopeTags: concept.scopeTags || [],
                createdAt: now,
                updatedAt: now
            };

            const updates = {};
            updates[`${conceptId}/status`] = 'superseded';
            updates[`${conceptId}/resolvedBy`] = newRef.key;
            updates[`${conceptId}/updatedAt`] = now;
            updates[newRef.key] = newConcept;
            await this._ref(uid).update(updates);

            return newConcept;
        },

        // Resolve a concept (typically an OPEN — mark as resolved without transitioning)
        async resolve(uid, conceptId) {
            const now = new Date().toISOString();
            await this._ref(uid).child(conceptId).update({
                status: 'resolved',
                updatedAt: now
            });
        },

        // Delete a concept
        async remove(uid, conceptId) {
            await this._ref(uid).child(conceptId).remove();
        },

        // Listen for real-time changes to all concepts
        listen(uid, callback) {
            const ref = this._ref(uid);
            const handler = (snapshot) => {
                const data = snapshot.val();
                callback(data ? Object.values(data) : []);
            };
            ref.on('value', handler);
            return () => ref.off('value', handler);
        }
    };

    // =========================================================================
    // IDEA MANAGEMENT SYSTEM (Ideation Platform v1)
    // =========================================================================

    // Valid idea statuses
    const IDEA_STATUSES = ['active', 'graduated', 'archived'];

    // Valid idea types
    const IDEA_TYPES = ['base', 'addon'];

    // Idea Manager — Firebase CRUD + App relationship
    const IdeaManager = {
        // Get Firebase ref for ideas under a user
        _ref(uid) {
            return firebaseDb.ref(`command-center/${uid}/ideas`);
        },

        // Generate kebab-case slug from idea name
        generateSlug(name) {
            return name
                .toLowerCase()
                .replace(/[^a-z0-9\s-]/g, '')
                .replace(/\s+/g, '-')
                .replace(/-+/g, '-')
                .substring(0, 60);
        },

        // Generate unique slug within an app scope
        async _uniqueSlug(uid, name, appId) {
            const base = this.generateSlug(name);
            if (!appId) return base;
            const appIdeas = await this.getByApp(uid, appId);
            const existing = appIdeas.map(i => i.slug).filter(Boolean);
            if (!existing.includes(base)) return base;
            let counter = 2;
            while (existing.includes(`${base}-${counter}`)) counter++;
            return `${base}-${counter}`;
        },

        // Add session log entry — call after ODRC import
        // v8.66.0: Accepts enriched fields from session.json (chain, debriefSummary, nextSession)
        async addSessionLogEntry(uid, ideaId, entry) {
            const snapshot = await this._ref(uid).child(ideaId).once('value');
            const idea = snapshot.val();
            if (!idea) throw new Error(`Idea not found: ${ideaId}`);
            const sessionLog = idea.sessionLog || [];
            sessionLog.push({
                sessionId: entry.sessionId,
                date: entry.date,
                docPath: entry.docPath || null,
                summary: entry.summary,
                conceptsCreated: entry.conceptsCreated,
                conceptsResolved: entry.conceptsResolved,
                type: entry.type || 'exploration',
                chain: entry.chain || null,
                debriefSummary: entry.debriefSummary || null,
                nextSession: entry.nextSession || null,
                schemaVersion: entry.schemaVersion || null,
                // v8.67.0: Session lifecycle fields
                status: entry.status || null,
                completedAt: entry.completedAt || null,
                ideaPhaseAtStart: entry.ideaPhaseAtStart || null,
                ideaPhaseAtEnd: entry.ideaPhaseAtEnd || null
            });
            await this._ref(uid).child(ideaId).update({
                sessionLog,
                lastSessionDate: entry.date,
                updatedAt: new Date().toISOString()
            });
            console.log('[CC] Added session log entry:', entry.sessionId, 'to idea:', ideaId);
        },

        // v8.67.0: Phase advancement
        async advancePhase(uid, ideaId, newPhase) {
            const validPhases = ['inception', 'exploring', 'converging', 'spec-ready', 'complete'];
            if (!validPhases.includes(newPhase)) throw new Error(`Invalid phase: ${newPhase}`);
            await this._ref(uid).child(ideaId).update({
                phase: newPhase,
                phaseUpdatedAt: new Date().toISOString()
            });
            console.log(`[CC] Idea ${ideaId} phase → ${newPhase}`);
        },

        // v8.67.0: Session lifecycle — activate
        async activateSession(uid, ideaId, sessionData) {
            const ideaRef = this._ref(uid).child(ideaId);
            const snap = await ideaRef.child('activeSession').once('value');
            if (snap.val()) throw new Error('Idea already has an active session');
            const now = new Date().toISOString();
            await ideaRef.update({
                activeSession: {
                    sessionId: sessionData.sessionId,
                    status: 'active',
                    createdAt: now,
                    lastActivityAt: now,
                    briefDownloaded: false,
                    artifactsReceived: 0,
                    ideaPhaseAtStart: sessionData.ideaPhaseAtStart
                },
                updatedAt: now // v8.69.3: Bump updatedAt so idea sorts as recent
            });
            console.log(`[CC] Session ${sessionData.sessionId} activated on idea ${ideaId}`);
        },

        // v8.67.0: Session lifecycle — complete
        async completeSession(uid, ideaId) {
            await this._ref(uid).child(ideaId).update({
                activeSession: null,
                updatedAt: new Date().toISOString() // v8.69.3: Bump updatedAt on completion
            });
        },

        // v8.67.0: Session lifecycle — abandon
        async abandonSession(uid, ideaId, sessionId) {
            const abandonedEntry = {
                sessionId,
                date: Date.now(),
                summary: 'Session abandoned',
                conceptsCreated: 0,
                conceptsResolved: 0,
                type: 'abandoned',
                status: 'abandoned',
                completedAt: new Date().toISOString()
            };
            await this.addSessionLogEntry(uid, ideaId, abandonedEntry);
            await this._ref(uid).child(ideaId).child('activeSession').set(null);
            console.log(`[CC] Session ${sessionId} abandoned on idea ${ideaId}`);
        },

        // v8.67.0: Session lifecycle — update activity
        async updateSessionActivity(uid, ideaId, updates) {
            await this._ref(uid).child(ideaId).child('activeSession').update({
                ...updates,
                lastActivityAt: new Date().toISOString()
            });
        },

        // v8.69.0: Store debrief for a session
        async storeDebrief(uid, ideaId, sessionId, debrief) {
            await this._ref(uid).child(ideaId)
                .child('debriefs').child(sessionId).set({
                    summary: debrief.summary,
                    content: debrief.content,
                    nextSession: debrief.nextSession,
                    storedAt: new Date().toISOString()
                });
            console.log(`[CC] Stored debrief for ${sessionId} on idea ${ideaId}`);
        },

        // Create a new idea
        async create(uid, { name, description, type = 'base', appId = null, parentIdeaId = null, projectId = null }) {
            if (!IDEA_TYPES.includes(type)) {
                throw new Error(`Invalid idea type: ${type}. Must be one of: ${IDEA_TYPES.join(', ')}`);
            }

            // Calculate sequence number
            let sequence = 1;
            if (appId) {
                const appIdeas = await this.getByApp(uid, appId);
                sequence = appIdeas.length > 0 ? Math.max(...appIdeas.map(i => i.sequence || 0)) + 1 : 1;
            }

            // Auto-generate unique slug
            const slug = await this._uniqueSlug(uid, name, appId);

            const ref = this._ref(uid).push();
            const now = new Date().toISOString();
            const idea = {
                id: ref.key,
                name,
                description,
                slug,
                type,
                appId,
                parentIdeaId,
                projectId,
                sequence,
                status: 'active',
                sessionLog: [],
                lastSessionDate: null,
                phase: 'inception',
                phaseUpdatedAt: now,
                activeSession: null,
                createdAt: now,
                updatedAt: now
            };
            await ref.set(idea);

            // If linked to an app, update the app's ideas reference
            if (appId) {
                await this._addIdeaToApp(uid, appId, ref.key);
            }

            return idea;
        },

        // Read all ideas for a user
        async getAll(uid) {
            const snapshot = await this._ref(uid).once('value');
            const data = snapshot.val();
            if (!data) return [];
            return Object.values(data);
        },

        // Read ideas for a specific app, ordered by sequence
        async getByApp(uid, appId) {
            const all = await this.getAll(uid);
            return all
                .filter(i => i.appId === appId)
                .sort((a, b) => (a.sequence || 0) - (b.sequence || 0));
        },

        // Get the latest active idea for an app
        async getActiveForApp(uid, appId) {
            const appIdeas = await this.getByApp(uid, appId);
            return appIdeas.filter(i => i.status === 'active').pop() || null;
        },

        // Update editable fields of an idea
        async update(uid, ideaId, updates) {
            const allowed = ['name', 'description', 'status', 'phase', 'projectId', 'appId']; // v8.64.0 A2: slug removed — immutable after creation; v8.69.2: appId added for linking unlinked ideas
            const filtered = {};
            for (const key of allowed) {
                if (updates[key] !== undefined) filtered[key] = updates[key];
            }
            filtered.updatedAt = new Date().toISOString();
            await this._ref(uid).child(ideaId).update(filtered);
            // v8.69.2: If appId changed, update the appIdeas index
            if (updates.appId) {
                await this._addIdeaToApp(uid, updates.appId, ideaId);
            }
            return filtered;
        },

        // Graduate an idea — link it to an app and mark as graduated
        async graduate(uid, ideaId, appId) {
            const snapshot = await this._ref(uid).child(ideaId).once('value');
            const idea = snapshot.val();
            if (!idea) throw new Error(`Idea not found: ${ideaId}`);

            // Calculate sequence for the app
            const appIdeas = await this.getByApp(uid, appId);
            const sequence = appIdeas.length > 0 ? Math.max(...appIdeas.map(i => i.sequence || 0)) + 1 : 1;

            // Determine type: first idea for an app is base, rest are addons
            const type = appIdeas.length === 0 ? 'base' : 'addon';
            const parentIdeaId = appIdeas.length > 0 ? appIdeas[appIdeas.length - 1].id : null;

            const now = new Date().toISOString();
            await this._ref(uid).child(ideaId).update({
                appId,
                sequence,
                type,
                parentIdeaId,
                status: 'graduated',
                updatedAt: now
            });

            // Update app's ideas reference
            await this._addIdeaToApp(uid, appId, ideaId);

            return { appId, sequence, type, parentIdeaId };
        },

        // Archive an idea
        async archive(uid, ideaId) {
            const now = new Date().toISOString();
            await this._ref(uid).child(ideaId).update({
                status: 'archived',
                updatedAt: now
            });
        },

        // Delete an idea (and clean up app reference)
        async remove(uid, ideaId) {
            const snapshot = await this._ref(uid).child(ideaId).once('value');
            const idea = snapshot.val();
            if (idea && idea.appId) {
                await this._removeIdeaFromApp(uid, idea.appId, ideaId);
            }
            await this._ref(uid).child(ideaId).remove();
        },

        // Add idea reference to app config in Firebase
        async _addIdeaToApp(uid, appId, ideaId) {
            const appIdeasRef = firebaseDb.ref(`command-center/${uid}/appIdeas/${appId}`);
            const snapshot = await appIdeasRef.once('value');
            const existing = snapshot.val() || [];
            if (!existing.includes(ideaId)) {
                existing.push(ideaId);
                await appIdeasRef.set(existing);
            }
        },

        // Remove idea reference from app config in Firebase
        async _removeIdeaFromApp(uid, appId, ideaId) {
            const appIdeasRef = firebaseDb.ref(`command-center/${uid}/appIdeas/${appId}`);
            const snapshot = await appIdeasRef.once('value');
            const existing = snapshot.val() || [];
            const filtered = existing.filter(id => id !== ideaId);
            await appIdeasRef.set(filtered);
        },

        // Get idea IDs linked to an app (from the appIdeas index)
        async getIdeaIdsForApp(uid, appId) {
            const snapshot = await firebaseDb.ref(`command-center/${uid}/appIdeas/${appId}`).once('value');
            return snapshot.val() || [];
        },

        // Listen for real-time changes to all ideas
        listen(uid, callback) {
            const ref = this._ref(uid);
            const handler = (snapshot) => {
                const data = snapshot.val();
                callback(data ? Object.values(data) : []);
            };
            ref.on('value', handler);
            return () => ref.off('value', handler);
        },

        // Listen for real-time changes to app-idea index
        listenAppIdeas(uid, appId, callback) {
            const ref = firebaseDb.ref(`command-center/${uid}/appIdeas/${appId}`);
            const handler = (snapshot) => {
                callback(snapshot.val() || []);
            };
            ref.on('value', handler);
            return () => ref.off('value', handler);
        },

        // v8.64.0 A1: One-time backfill for Ideas created before data model extension
        // Idempotent — skips Ideas that already have all fields, safe to run on every load
        async backfillMissingFields(uid) {
            const snapshot = await this._ref(uid).once('value');
            const data = snapshot.val();
            if (!data) return;

            let backfillCount = 0;
            const updates = {};

            for (const [key, idea] of Object.entries(data)) {
                const patch = {};
                let needsUpdate = false;

                // Backfill slug — generate from name, ensure unique within app scope
                if (!idea.slug) {
                    const base = this.generateSlug(idea.name || 'untitled');
                    const siblings = Object.values(data).filter(i =>
                        i.appId === idea.appId && i.slug && i.id !== idea.id
                    );
                    const existingSlugs = siblings.map(i => i.slug);
                    // Also include slugs we're generating in this batch to avoid collisions
                    for (const [otherKey, otherPatch] of Object.entries(updates)) {
                        if (otherPatch.slug) existingSlugs.push(otherPatch.slug);
                    }
                    let slug = base;
                    if (existingSlugs.includes(slug)) {
                        let counter = 2;
                        while (existingSlugs.includes(`${slug}-${counter}`)) counter++;
                        slug = `${base}-${counter}`;
                    }
                    patch.slug = slug;
                    needsUpdate = true;
                }

                if (!idea.sessionLog) { patch.sessionLog = []; needsUpdate = true; }
                if (idea.lastSessionDate === undefined) { patch.lastSessionDate = null; needsUpdate = true; }
                if (idea.phase === undefined) { patch.phase = null; needsUpdate = true; }
                if (idea.activeSession === undefined) { patch.activeSession = null; needsUpdate = true; }
                if (idea.phaseUpdatedAt === undefined) { patch.phaseUpdatedAt = null; needsUpdate = true; }
                if (idea.parentIdeaId === undefined) { patch.parentIdeaId = null; needsUpdate = true; }

                // Backfill projectId — infer from appId's project if possible
                // For CC, appId IS the projectId. Smarter inference (app config lookup) can come later.
                if (idea.projectId === undefined) {
                    patch.projectId = idea.appId || null;
                    needsUpdate = true;
                }

                if (needsUpdate) {
                    updates[key] = patch;
                    backfillCount++;
                }
            }

            // Write all patches in a single multi-path update
            if (backfillCount > 0) {
                const multiUpdate = {};
                for (const [key, patch] of Object.entries(updates)) {
                    for (const [field, value] of Object.entries(patch)) {
                        multiUpdate[`${key}/${field}`] = value;
                    }
                }
                await this._ref(uid).update(multiUpdate);
                console.log(`[CC] Idea backfill: updated ${backfillCount} idea(s) with missing fields`);
            } else {
                console.log('[CC] Idea backfill: all ideas up to date');
            }
        }
    };

    // Compute idea phase from ODRC concept state (standalone utility)
    // Returns 'exploring', 'converging', or 'spec-ready'
    // If idea has a manual phase override (non-null), use that instead
    function computeIdeaPhase(concepts) {
        const active = concepts.filter(c => c.status === 'active');
        const opens = active.filter(c => c.type === 'OPEN').length;
        const decisions = active.filter(c => c.type === 'DECISION').length;
        const rules = active.filter(c => c.type === 'RULE').length;
        const constraints = active.filter(c => c.type === 'CONSTRAINT').length;

        // Check spec-ready first (highest priority)
        if (opens === 0 || (opens <= 2 && decisions >= 10)) return 'spec-ready';
        // Then converging
        if (decisions >= opens && (rules > 0 || constraints > 0)) return 'converging';
        // Default
        return 'exploring';
    }

    // v8.68.0: Format relative time ago
    function formatTimeAgo(dateStr) {
        if (!dateStr) return '';
        const ms = Date.now() - new Date(dateStr).getTime();
        const minutes = Math.floor(ms / 60000);
        if (minutes < 60) return `${minutes}m ago`;
        const hours = Math.floor(minutes / 60);
        if (hours < 24) return `${hours}h ago`;
        const days = Math.floor(hours / 24);
        return `${days}d ago`;
    }

    // Generate session ID in S-YYYY-MM-DD-NNN format
    function generateSessionId(sessionNumber) {
        const now = new Date();
        const y = now.getFullYear();
        const m = String(now.getMonth() + 1).padStart(2, '0');
        const d = String(now.getDate()).padStart(2, '0');
        const n = String(sessionNumber).padStart(3, '0');
        return `S-${y}-${m}-${d}-${n}`;
    }

    // v8.68.0: Helper to get recent active ideas enriched with metadata + session state
    function getRecentIdeas(globalIdeas, globalConcepts, apps, maxCount = 8) {
        const active = [...(globalIdeas || [])].filter(idea => idea.status === 'active');

        // v8.69.3: Compute best recency timestamp from all available signals
        const getRecencyTimestamp = (idea) => {
            const candidates = [];
            // 1. lastSessionDate (set by ODRC import)
            if (idea.lastSessionDate) {
                candidates.push(typeof idea.lastSessionDate === 'number'
                    ? idea.lastSessionDate
                    : new Date(idea.lastSessionDate).getTime());
            }
            // 2. Most recent sessionLog entry date
            if (idea.sessionLog?.length > 0) {
                const lastEntry = idea.sessionLog[idea.sessionLog.length - 1];
                if (lastEntry.date) {
                    candidates.push(typeof lastEntry.date === 'number'
                        ? lastEntry.date
                        : new Date(lastEntry.date).getTime());
                }
                if (lastEntry.completedAt) candidates.push(new Date(lastEntry.completedAt).getTime());
            }
            // 3. Active session timestamps
            if (idea.activeSession) {
                if (idea.activeSession.lastActivityAt) candidates.push(new Date(idea.activeSession.lastActivityAt).getTime());
                if (idea.activeSession.createdAt) candidates.push(new Date(idea.activeSession.createdAt).getTime());
            }
            // 4. updatedAt / createdAt fallback
            if (idea.updatedAt) candidates.push(new Date(idea.updatedAt).getTime());
            if (idea.createdAt) candidates.push(new Date(idea.createdAt).getTime());
            // Return the most recent valid timestamp
            const valid = candidates.filter(t => t && !isNaN(t));
            return valid.length > 0 ? Math.max(...valid) : 0;
        };

        // Two-tier sort: active sessions first, then pending by recency
        const sortByRecency = (a, b) => getRecencyTimestamp(b) - getRecencyTimestamp(a);
        const withSession = active.filter(i => i.activeSession).sort(sortByRecency);
        const withoutSession = active.filter(i => !i.activeSession).sort(sortByRecency);
        const sorted = [...withSession, ...withoutSession].slice(0, maxCount);

        return sorted.map(idea => {
            const ideaConcepts = (globalConcepts || []).filter(c => c.ideaOrigin === idea.id);
            const openCount = ideaConcepts.filter(c => c.type === 'OPEN' && c.status === 'active').length;
            const totalConcepts = ideaConcepts.length;
            const appName = idea.appId && apps?.[idea.appId] ? (apps[idea.appId].name || idea.appId) : 'unassigned';
            const sessionLog = idea.sessionLog || [];
            const lastSession = sessionLog.length > 0 ? sessionLog[sessionLog.length - 1] : null;

            return {
                ...idea,
                openCount,
                totalConcepts,
                appName,
                lastSession,
                sessionCount: sessionLog.length,
                phase: idea.phase || computeIdeaPhase(ideaConcepts.filter(c => c.status === 'active')),
                // v8.68.0: Session lifecycle enrichment
                sessionState: idea.activeSession ? 'active' : 'pending',
                activeSessionId: idea.activeSession?.sessionId || null,
                activeSessionCreatedAt: idea.activeSession?.createdAt || null,
                briefDownloaded: idea.activeSession?.briefDownloaded || false,
                staleDays: idea.activeSession
                    ? Math.floor((Date.now() - new Date(idea.activeSession.lastActivityAt || idea.activeSession.createdAt).getTime()) / 86400000)
                    : null
            };
        });
    }

    // =========================================================================
    // COMPLETION FILE SERVICE (v8.58.0 — Ingestion Pipeline Phase 1)
    // =========================================================================

    const CompletionFileService = {
        _ref(uid) { return firebaseDb.ref(`command-center/${uid}/completionJobs`); },

        async create(uid, jobData) {
            const ref = this._ref(uid).push();
            const record = {
                id: ref.key,
                repoFullName: jobData.repoFullName || '',
                fileName: jobData.fileName || '',
                detectedAt: new Date().toISOString(),
                state: 'new',
                validationStatus: jobData.validationStatus || 'pass',
                validationErrors: jobData.validationErrors || [],
                classified: !!(jobData.specId),
                specId: jobData.specId || null,
                task: jobData.task || '',
                status: jobData.status || '',
                files: jobData.files || [],
                commits: jobData.commits || [],
                odrc: jobData.odrc || null,
                unexpectedFindings: jobData.unexpectedFindings || [],
                unresolved: jobData.unresolved || [],
                checkOutcome: null,
                checkNotes: null
            };
            await ref.set(record);
            console.log('[CC] CompletionFileService.create:', record.fileName);
            return record;
        },

        async getAll(uid) {
            const snapshot = await this._ref(uid).once('value');
            const data = snapshot.val() || {};
            return Object.values(data).sort((a, b) => (b.detectedAt || '').localeCompare(a.detectedAt || ''));
        },

        async getByRepo(uid, repoFullName) {
            const all = await this.getAll(uid);
            return all.filter(j => j.repoFullName === repoFullName);
        },

        async getByState(uid, state) {
            const all = await this.getAll(uid);
            return all.filter(j => j.state === state);
        },

        async updateState(uid, jobId, newState) {
            await this._ref(uid).child(jobId).update({ state: newState });
            console.log('[CC] CompletionFileService.updateState:', jobId, '→', newState);
        },

        async updateCheckOutcome(uid, jobId, outcome, notes) {
            await this._ref(uid).child(jobId).update({
                state: 'checked',
                checkOutcome: outcome,
                checkNotes: notes || null
            });
            console.log('[CC] CompletionFileService.updateCheckOutcome:', jobId, outcome);
        },

        listen(uid, callback) {
            const ref = this._ref(uid);
            const handler = (snapshot) => {
                const data = snapshot.val() || {};
                callback(Object.values(data).sort((a, b) => (b.detectedAt || '').localeCompare(a.detectedAt || '')));
            };
            ref.on('value', handler);
            return () => ref.off('value', handler);
        }
    };

    // =========================================================================
    // COMPLETION FILE SETTINGS (v8.58.0)
    // =========================================================================

    const CompletionFileSettings = {
        _ref(uid) { return firebaseDb.ref(`command-center/${uid}/settings/completionFiles`); },

        getDefaults() {
            return {
                unclassifiedNudgeThreshold: 5,
                orphanNudgeThreshold: 5,
                bundleSizeLimit: 5242880,
                orphanDetectionDays: 14
            };
        },

        async load(uid) {
            const snapshot = await this._ref(uid).once('value');
            return { ...this.getDefaults(), ...(snapshot.val() || {}) };
        },

        async save(uid, settings) {
            await this._ref(uid).set(settings);
            console.log('[CC] CompletionFileSettings.save:', settings);
        },

        listen(uid, callback) {
            const ref = this._ref(uid);
            const handler = (snapshot) => {
                callback({ ...CompletionFileSettings.getDefaults(), ...(snapshot.val() || {}) });
            };
            ref.on('value', handler);
            return () => ref.off('value', handler);
        }
    };

    // =========================================================================
    // COMPLETION FILE POLLING (v8.58.0)
    // =========================================================================

    function parseCompletionFrontmatter(content) {
        if (!content || typeof content !== 'string') return null;
        const match = content.match(/^---\s*\n([\s\S]*?)\n---/);
        if (!match) return null;
        try {
            const parsed = jsyaml.load(match[1]);
            // Extract body (everything after second ---)
            const bodyStart = content.indexOf('---', content.indexOf('---') + 3) + 3;
            const body = content.slice(bodyStart).trim();
            return { ...parsed, _body: body };
        } catch (e) {
            console.warn('[CC] YAML parse error:', e.message);
            return null;
        }
    }

    function validateCompletionFile(parsed) {
        const errors = [];
        if (!parsed.task || typeof parsed.task !== 'string') errors.push('Missing or invalid "task" field');
        if (!['complete', 'partial', 'blocked'].includes(parsed.status)) errors.push(`Invalid "status": "${parsed.status}" — must be complete, partial, or blocked`);
        if (!Array.isArray(parsed.files)) errors.push('Missing "files" array');
        else if (parsed.files.some(f => !f.path || !f.action)) errors.push('Each file entry needs "path" and "action"');
        if (!Array.isArray(parsed.commits)) errors.push('Missing "commits" array');
        else if (parsed.commits.some(c => !c.sha || !c.message)) errors.push('Each commit entry needs "sha" and "message"');
        return { valid: errors.length === 0, errors };
    }

    async function pollCompletionFiles(github, repoFullName, uid, existingJobs, existingOrphans) {
        if (!github || !repoFullName || !uid) return [];
        const existingFileNames = new Set(existingJobs.filter(j => j.repoFullName === repoFullName).map(j => j.fileName));
        const newJobs = [];

        try {
            const files = await github.listRepoContents(repoFullName, 'cc/completions');
            if (!files || !Array.isArray(files)) return [];

            for (const file of files) {
                if (!file.name || !file.name.endsWith('.md')) continue;
                if (existingFileNames.has(file.name)) continue;

                try {
                    const fileData = await github.getFileContent(repoFullName, `cc/completions/${file.name}`);
                    const content = fileData?.textContent || fileData?.content || '';
                    if (!content) continue;

                    const parsed = parseCompletionFrontmatter(content);
                    if (!parsed) {
                        const job = await CompletionFileService.create(uid, {
                            repoFullName, fileName: file.name,
                            validationStatus: 'warning',
                            validationErrors: ['Could not parse YAML frontmatter'],
                            task: file.name
                        });
                        newJobs.push(job);
                        continue;
                    }

                    const validation = validateCompletionFile(parsed);
                    const specIdMatch = content.match(/cc-spec-id:\s*(\S+)/);

                    const job = await CompletionFileService.create(uid, {
                        repoFullName, fileName: file.name,
                        validationStatus: validation.valid ? 'pass' : 'warning',
                        validationErrors: validation.errors,
                        specId: specIdMatch ? specIdMatch[1] : null,
                        task: parsed.task || '',
                        status: parsed.status || '',
                        files: parsed.files || [],
                        commits: parsed.commits || [],
                        odrc: parsed.odrc || null,
                        unexpectedFindings: parsed.unexpected_findings || parsed.unexpectedFindings || [],
                        unresolved: parsed.unresolved || []
                    });
                    newJobs.push(job);
                    console.log('[CC] Detected completion file:', file.name, 'in', repoFullName);

                    // Phase 3: Auto-match orphans — if this job's commits match existing orphans, mark them reconstructed
                    if (existingOrphans && job.commits?.length > 0) {
                        const jobCommitShas = job.commits.map(c => c.sha);
                        const matchingOrphans = existingOrphans.filter(o =>
                            o.repoFullName === repoFullName &&
                            jobCommitShas.some(sha => o.commitSha?.startsWith(sha) || sha?.startsWith(o.commitSha)) &&
                            o.state !== 'ignored'
                        );
                        for (const orphan of matchingOrphans) {
                            await OrphanDetectionService.updateState(uid, orphan.id, 'reconstructed');
                            console.log('[CC] Auto-matched orphan commit', orphan.commitSha?.slice(0, 7), 'to completion file', file.name);
                        }
                    }
                } catch (e) {
                    console.warn('[CC] Error reading completion file:', file.name, e.message);
                }
            }
        } catch (e) {
            if (!e.message?.includes('404') && !e.message?.includes('Not Found')) {
                console.warn('[CC] Error polling completions in', repoFullName, ':', e.message);
            }
        }

        return newJobs;
    }

    // Phase 3: Poll for orphaned commits (commits with no matching completion file)
    async function pollOrphanCommits(github, repoFullName, uid, existingJobs, existingOrphans, settings) {
        if (!github || !repoFullName || !uid) return [];
        const detectionDays = settings?.orphanDetectionDays || 14;
        const cutoffDate = new Date(Date.now() - detectionDays * 24 * 60 * 60 * 1000);
        const newOrphans = [];

        try {
            const commits = await github.listRecentCommits(repoFullName, 30);
            if (!commits || !Array.isArray(commits)) return [];

            // Build set of all commit SHAs from existing completion files
            const knownShas = new Set();
            for (const job of existingJobs) {
                for (const c of (job.commits || [])) {
                    if (c.sha) knownShas.add(c.sha);
                    // Also add abbreviated versions for prefix matching
                    if (c.sha?.length >= 7) knownShas.add(c.sha.slice(0, 7));
                }
            }

            // Build set of already-tracked orphan SHAs
            const existingOrphanShas = new Set(existingOrphans.map(o => o.commitSha).filter(Boolean));

            for (const commit of commits) {
                const sha = commit.sha;
                if (!sha) continue;

                // Skip if commit is too old
                const commitDate = new Date(commit.commit?.author?.date || commit.commit?.committer?.date);
                if (commitDate < cutoffDate) continue;

                // Skip merge commits (more than 1 parent)
                if (commit.parents?.length > 1) continue;

                // Skip if already tracked as orphan
                if (existingOrphanShas.has(sha)) continue;

                // Skip if commit SHA matches any known completion file commit (full or abbreviated match)
                if (knownShas.has(sha) || knownShas.has(sha.slice(0, 7))) continue;

                // Skip if ALL changed files are under cc/ directory
                // We need commit detail for file list — fetch it
                try {
                    const detail = await github.getCommitDetail(repoFullName, sha);
                    const changedFiles = (detail?.files || []).map(f => ({ path: f.filename, status: f.status }));
                    if (changedFiles.length > 0 && changedFiles.every(f => f.path.startsWith('cc/'))) continue;

                    // This is an orphan commit
                    const orphan = await OrphanDetectionService.create(uid, {
                        repoFullName,
                        commitSha: sha,
                        commitMessage: commit.commit?.message || '',
                        commitDate: commitDate.toISOString(),
                        filesChanged: changedFiles,
                        detectedAt: new Date().toISOString(),
                        state: 'detected'
                    });
                    newOrphans.push(orphan);
                    console.log('[CC] Detected orphan commit:', sha.slice(0, 7), commit.commit?.message?.split('\n')[0]);
                } catch (e) {
                    console.warn('[CC] Error fetching commit detail:', sha.slice(0, 7), e.message);
                }
            }
        } catch (e) {
            console.warn('[CC] Error polling orphan commits in', repoFullName, ':', e.message);
        }

        return newOrphans;
    }

    // Phase 3: Generate reconstruction markdown for orphaned commits
    function generateOrphanReconstructionPackage(orphans) {
        const lines = [
            '# Reconstruction Task — Orphaned Commits',
            '',
            'The following commits were made without completion files. Please reconstruct',
            'completion files for each commit (or group related commits into single completion files).',
            '',
            '## Instructions',
            '- Use `git show {sha}` to inspect each commit',
            '- Read the current CLAUDE.md for rules and decisions context',
            '- Produce completion files to cc/completions/ following the standard format',
            '- One completion file per logical task (group related commits if they\'re part of the same task)',
            '- Required fields: task, status, files, commits',
            '- Include what you can infer for contextual fields',
            '- Note in the body that this is a reconstruction and narrative context may be incomplete',
            '',
            '## Orphaned Commits',
            ''
        ];

        orphans.forEach((orphan, i) => {
            lines.push(`### Commit ${i + 1}`);
            lines.push(`- SHA: ${orphan.commitSha}`);
            lines.push(`- Date: ${orphan.commitDate}`);
            lines.push(`- Message: ${orphan.commitMessage?.split('\n')[0] || 'No message'}`);
            if (orphan.filesChanged?.length > 0) {
                lines.push('- Files changed:');
                orphan.filesChanged.forEach(f => {
                    lines.push(`  - ${f.path} (${f.status})`);
                });
            }
            lines.push('');
        });

        return lines.join('\n');
    }

    // =========================================================================
    // MAIN APP
    // =========================================================================
    
    function App() {
        const [view, setView] = React.useState('dashboard');
        const [viewPayload, setViewPayload] = React.useState(null); // v8.65.0: cross-view deep-link payload
        // (multi-app zip state managed in DashboardView)
        const [pendingSessionReturn, setPendingSessionReturn] = React.useState(null); // SESSION_RETURN.json auto-review (Phase B)
        const [pendingOdrcImport, setPendingOdrcImport] = React.useState(null); // ODRC Updates from Chat session (Phase 3)
        // v8.62.0 A6: Non-blocking notification banners (replaces modal dialogs for background detection)
        const [notifications, setNotifications] = React.useState([]);
        const addNotification = React.useCallback((notification) => {
            const id = Date.now();
            setNotifications(prev => [...prev, { id, ...notification }]);
            // Auto-dismiss after 30 seconds
            setTimeout(() => {
                setNotifications(prev => prev.filter(n => n.id !== id));
            }, 30000);
        }, []);
        const dismissNotification = React.useCallback((id) => {
            setNotifications(prev => prev.filter(n => n.id !== id));
        }, []);
        const [githubToken, setGithubToken] = React.useState(() => {
            try { return localStorage.getItem('cc_token') || ''; } catch { return ''; }
        });
        
        // Token expiration tracking (v8.3.3)
        const tokenExpires = React.useMemo(() => {
            try { return localStorage.getItem('cc_token_expires') || ''; } catch { return ''; }
        }, [githubToken]);
        const daysUntilExpiry = tokenExpires ? Math.ceil((new Date(tokenExpires) - new Date()) / (1000 * 60 * 60 * 24)) : null;
        const tokenExpiryWarning = githubToken && daysUntilExpiry !== null && daysUntilExpiry <= 14;
        
        // v8.3.3: File protocol detection for local file warning
        const isFileProtocol = window.location.protocol === 'file:';
        const [fileProtocolBannerDismissed, setFileProtocolBannerDismissed] = React.useState(() => {
            try { return sessionStorage.getItem('cc_file_banner_dismissed') === 'true'; } catch { return false; }
        });
        const dismissFileProtocolBanner = () => {
            setFileProtocolBannerDismissed(true);
            try { sessionStorage.setItem('cc_file_banner_dismissed', 'true'); } catch {}
        };
        
        // Dynamic configuration (v7.0.0)
        const [config, setConfig] = React.useState(() => {
            return ConfigManager.load();
        });
        
        // v8.17.0: Firebase config sync status
        const [syncStatus, setSyncStatus] = React.useState(() => 
            FirebaseConfigSync.initialized ? 'syncing' : 'offline'
        );
        const [syncInitialized, setSyncInitialized] = React.useState(false);
        
        // Apps derived from config (legacy compatibility + v7 format)
        const [apps, setApps] = React.useState(() => {
            try { 
                const s = localStorage.getItem('cc_apps_v6'); 
                const oldApps = s ? JSON.parse(s) : null;
                if (oldApps) {
                    // Migrate old format to config
                    const cfg = ConfigManager.load();
                    const migrated = ConfigManager.migrateFromOldFormat(oldApps, cfg);
                    ConfigManager.save(migrated);
                    return ConfigManager.toLegacyAppsFormat(migrated);
                }
                return ConfigManager.toLegacyAppsFormat(ConfigManager.load()); 
            } catch { 
                return ConfigManager.toLegacyAppsFormat(ConfigManager.load()); 
            }
        });
        const [stagedFiles, setStagedFiles] = React.useState([]);
        const [deployments, setDeployments] = React.useState(() => DeployService.load());
        const [activeDeployments, setActiveDeployments] = React.useState([]);
        const [availableRepos, setAvailableRepos] = React.useState([]);
        const [repoHealthAlert, setRepoHealthAlert] = React.useState(null); // { issues: [{app, repo, target, unexpectedFiles}] }
        
        // Helper functions for managing multiple deployments
        const addActiveDeployment = (deployment) => {
            setActiveDeployments(prev => [deployment, ...prev]);
        };
        
        const updateActiveDeployment = (deploymentId, updates) => {
            setActiveDeployments(prev => prev.map(d => 
                d.id === deploymentId ? { ...d, ...updates } : d
            ));
        };
        
        const removeActiveDeployment = (deploymentId) => {
            setActiveDeployments(prev => prev.filter(d => d.id !== deploymentId));
        };
        
        // Track deployments that need auto-close
        const pendingAutoClose = React.useRef(new Set());
        
        // Auto-close successful deployments after delay
        // v8.5.0: Fixed - check both step status AND ensure deployment is truly done
        React.useEffect(() => {
            activeDeployments.forEach(deployment => {
                // Check if deployment is truly complete:
                // 1. Status is 'success' or 'error' or 'failed'
                // 2. No steps are still 'running'
                // 3. All steps are either 'complete', 'error', or 'warning'
                const hasRunningSteps = deployment.steps?.some(s => s.status === 'running');
                const allStepsDone = deployment.steps?.every(s => 
                    s.status === 'complete' || s.status === 'error' || s.status === 'warning'
                );
                const deploymentDone = deployment.status === 'success' || deployment.status === 'error' || deployment.status === 'failed';
                const isFullyComplete = deploymentDone && !hasRunningSteps && (allStepsDone || !deployment.steps?.length);
                
                console.log(`[AutoClose] ${deployment.id}: status=${deployment.status}, hasRunning=${hasRunningSteps}, allDone=${allStepsDone}, fullyComplete=${isFullyComplete}`);
                
                if (isFullyComplete && !pendingAutoClose.current.has(deployment.id)) {
                    console.log(`[AutoClose] Scheduling auto-close for ${deployment.id} in 4s`);
                    pendingAutoClose.current.add(deployment.id);
                    setTimeout(() => {
                        console.log(`[AutoClose] Removing ${deployment.id}`);
                        setActiveDeployments(prev => prev.filter(d => d.id !== deployment.id));
                        pendingAutoClose.current.delete(deployment.id);
                    }, 4000);
                }
            });
        }, [activeDeployments]);
        
        // Compatibility: Create setActiveDeployment that updates/adds to array
        // This allows existing code to work while supporting multiple deployments
        const setActiveDeployment = (deploymentOrNull) => {
            if (deploymentOrNull === null) {
                // Clear all (legacy behavior - now we auto-close instead)
                return;
            }
            
            setActiveDeployments(prev => {
                const existing = prev.find(d => d.id === deploymentOrNull.id);
                if (existing) {
                    // Update existing
                    return prev.map(d => d.id === deploymentOrNull.id ? deploymentOrNull : d);
                } else {
                    // Add new
                    return [deploymentOrNull, ...prev];
                }
            });
        };
        
        // Get most recent active deployment (for legacy code that expects single)
        const activeDeployment = activeDeployments[0] || null;
        const [modal, setModal] = React.useState(null);
        const [showHistoryPanel, setShowHistoryPanel] = React.useState(false); // N6: Deploy History slide-out
        const [dialog, setDialog] = React.useState(null); // { type: 'alert'|'confirm'|'prompt', title, message, defaultValue, onConfirm, onCancel }
        const [settings, setSettings] = React.useState({ createTag: true, updateServiceWorker: true });
        
        // Config change handler
        const handleConfigChange = (newConfig) => {
            setConfig(newConfig);
            setApps(ConfigManager.toLegacyAppsFormat(newConfig));
            ConfigManager.save(newConfig);
        };
        
        // Expose apps to detection function (detectAppFromContent runs outside React)
        React.useEffect(() => { window.__CC_APPS = apps; }, [apps]);
        
        // Get active environments from config
        const activeEnvironments = config.environments.active;
        const getEnvColors = (env) => config.environments.colors[env] || config.environments.colors.test;
        const getEnvLabel = (env) => config.environments.labels[env] || env.toUpperCase();
        
        // Dialog helper functions (Promise-based for async usage)
        const showAlert = (message, title) => {
            return new Promise((resolve) => {
                setDialog({ type: 'alert', title, message, onConfirm: resolve });
            });
        };
        
        const showConfirm = (message, title) => {
            return new Promise((resolve) => {
                setDialog({ 
                    type: 'confirm', 
                    title, 
                    message, 
                    onConfirm: () => resolve(true),
                    onCancel: () => resolve(false)
                });
            });
        };
        
        const showPrompt = (message, defaultValue, title) => {
            return new Promise((resolve) => {
                setDialog({ 
                    type: 'prompt', 
                    title, 
                    message, 
                    defaultValue,
                    onConfirm: (value) => resolve(value),
                    onCancel: () => resolve(null)
                });
            });
        };
        const [refreshing, setRefreshing] = React.useState(false);
        
        // Rollback snapshots - stores last known good version for each app/repo/target
        // Format: { "appId:target": { content, version, savedAt, repo } }
        const [rollbackSnapshots, setRollbackSnapshots] = React.useState(() => RollbackService.load());
        
        React.useEffect(() => { RollbackService.save(rollbackSnapshots); }, [rollbackSnapshots]);
        
        // Save snapshot before deploy (call this before pushing new content)
        const saveRollbackSnapshot = async (appId, target, repo, targetPath) => {
            if (!github) return null;
            
            try {
                const fileData = await github.getFileContent(repo, targetPath);
                if (!fileData) return null;
                
                // Use textContent which handles both normal and large files
                const content = fileData.textContent;
                const version = extractVersionFromHTML(content);
                
                const key = `${appId}:${target}`;
                const snapshot = {
                    content,
                    version,
                    savedAt: new Date().toISOString(),
                    repo,
                    targetPath,
                    sha: fileData.sha
                };
                
                setRollbackSnapshots(prev => ({ ...prev, [key]: snapshot }));
                console.log(`📸 Saved rollback snapshot for ${appId} ${target}: v${version}`);
                return snapshot;
            } catch (err) {
                console.error('Failed to save rollback snapshot:', err);
                return null;
            }
        };
        
        // Quick rollback using saved snapshot
        const quickRollback = async (appId, target) => {
            const key = `${appId}:${target}`;
            const snapshot = rollbackSnapshots[key];
            
            if (!snapshot) {
                await showAlert('No rollback snapshot available for this app/environment.', 'Rollback Not Available');
                return;
            }
            
            const app = apps[appId];
            // Ensure subPath is set from defaults (localStorage may have empty string from old config)
            const effectiveSubPath = app.subPath || '';
            
            const confirmed = await showConfirm(
                `Roll back ${app.name} ${target.toUpperCase()} to v${snapshot.version || 'unknown'}?\n\nSaved: ${new Date(snapshot.savedAt).toLocaleString()}`,
                '⏪ Quick Rollback'
            );
            
            if (!confirmed) return;
            
            const deployment = {
                id: Date.now(), status: 'running', steps: [],
                appId, appName: app.name, repo: snapshot.repo, target,
                isRollback: true, isQuickRollback: true,
                version: snapshot.version,
                startedAt: new Date().toISOString()
            };
            
            setActiveDeployment(deployment);
            setDeployments(prev => [deployment, ...prev]);
            
            const addStep = (name, status, details = null) => {
                const idx = deployment.steps.findIndex(s => s.name === name);
                if (idx >= 0) deployment.steps[idx] = { name, status, details };
                else deployment.steps.push({ name, status, details });
                setActiveDeployment({ ...deployment });
            };
            
            try {
                addStep('Preparing rollback', 'running');
                const currentFileData = await github.getFileContent(snapshot.repo, snapshot.targetPath);
                // Use textContent which handles both normal and large files
                const currentVersion = currentFileData ? extractVersionFromHTML(currentFileData.textContent) : null;
                deployment.previousVersion = currentVersion;
                addStep('Preparing rollback', 'complete', `${formatVersion(currentVersion)} → ${formatVersion(snapshot.version)}`);
                
                addStep('Restoring snapshot', 'running');
                const result = await github.createOrUpdateFile(
                    snapshot.repo, snapshot.targetPath, snapshot.content,
                    `Quick rollback ${app.name} to v${snapshot.version} (was v${currentVersion})`,
                    currentFileData?.sha
                );
                deployment.commitSha = result.commit.sha;
                addStep('Restoring snapshot', 'complete', result.commit.sha.substring(0, 7));
                
                deployment.status = 'success';
                deployment.url = getGitHubPagesUrl(snapshot.repo, effectiveSubPath);
                
                const versionKey = target === 'prod' ? 'currentProdVersion' : 'currentTestVersion';
                updateApp(appId, { [versionKey]: snapshot.version });
                
                // Monitor deployment
                if (deployment.url && snapshot.version) {
                    addStep('GitHub Pages', 'running', 'Waiting for deploy...');
                    monitorLiveDeployment(deployment.url, snapshot.version, snapshot.repo, (status, detail) => {
                        addStep('GitHub Pages', status, detail);
                        setActiveDeployment({ ...deployment });
                        setDeployments(prev => prev.map(d => d.id === deployment.id ? { ...deployment } : d));
                    }, appId, target);
                }
                
            } catch (err) {
                console.error('Quick rollback failed:', err);
                addStep('Rollback Failed', 'error', err.message);
                deployment.status = 'error';
            }
            
            setActiveDeployment({ ...deployment });
            setDeployments(prev => prev.map(d => d.id === deployment.id ? { ...deployment } : d));
        };
        
        // Clear rollback snapshot (after successful deploy verification)
        const clearRollbackSnapshot = (appId, target) => {
            const key = `${appId}:${target}`;
            setRollbackSnapshots(prev => {
                const next = { ...prev };
                delete next[key];
                return next;
            });
        };
        const [deployingRepos, setDeployingRepos] = React.useState({}); // { appId: { version, startTime, repo } }
        
        // Session log state (persisted to localStorage)
        const [sessionLog, setSessionLog] = React.useState(() => SessionLogService.load());
        
        // Global issues state (synced with Firebase)
        const [globalIssues, setGlobalIssues] = React.useState([]);
        const [globalWorkItems, setGlobalWorkItems] = React.useState([]);
        const [globalSessions, setGlobalSessions] = React.useState([]);
        const [globalActivity, setGlobalActivity] = React.useState([]); // Phase 3.4: Activity log
        const [globalStreams, setGlobalStreams] = React.useState([]); // Phase 5.2: Work streams
        const [globalInterfaces, setGlobalInterfaces] = React.useState([]); // Phase 5.4: Stream interfaces
        const [globalDependencies, setGlobalDependencies] = React.useState([]); // Phase 5.4: Dependencies
        const [globalDependencyAlerts, setGlobalDependencyAlerts] = React.useState([]); // Phase 5.4: Dependency alerts
        const [teamMembers, setTeamMembers] = React.useState([]); // Phase 5.7: Team members
        const [teamMembership, setTeamMembership] = React.useState(null); // Phase 5.7: Current user's membership (null = owner)
        const [globalConcepts, setGlobalConcepts] = React.useState([]); // Ideation: ODRC concepts
        const [globalIdeas, setGlobalIdeas] = React.useState([]); // Ideation: Ideas
        const [globalCompletionJobs, setGlobalCompletionJobs] = React.useState([]); // Ingestion: Completion jobs
        const [globalOrphanCommits, setGlobalOrphanCommits] = React.useState([]); // Phase 3: Orphan commits
        const [completionFileSettings, setCompletionFileSettings] = React.useState(CompletionFileSettings.getDefaults());
        const [firebaseUid, setFirebaseUid] = React.useState(null);
        const [firebaseUser, setFirebaseUser] = React.useState(null);
        
        // Listen for Firebase auth and load issues
        React.useEffect(() => {
            if (!firebaseAuth) return;
            
            let unsubscribeIssues = () => {};
            let unsubscribeWorkItems = () => {};
            let unsubscribeSessions = () => {};
            let unsubscribeActivity = () => {};
            let unsubscribeStreams = () => {};
            let unsubscribeInterfaces = () => {};
            let unsubscribeDependencies = () => {};
            let unsubscribeDependencyAlerts = () => {};
            let unsubscribeTeam = () => {};
            let unsubscribeTeamMembership = () => {};
            let unsubscribeConcepts = () => {};
            let unsubscribeIdeas = () => {};
            let unsubscribeCompletionJobs = () => {};
            let unsubscribeCompletionSettings = () => {};
            let unsubscribeOrphans = () => {};

            const unsubscribe = firebaseAuth.onAuthStateChanged((u) => {
                setFirebaseUser(u);
                if (u) {
                    setFirebaseUid(u.uid);
                    // Listen for issues changes via IssueService
                    unsubscribeIssues = IssueService.listen(u.uid, setGlobalIssues);
                    // Listen for work items via WorkItemService (v8.22.0)
                    unsubscribeWorkItems = WorkItemService.listen(u.uid, setGlobalWorkItems);
                    // Listen for sessions via SessionService (v8.27.0)
                    unsubscribeSessions = SessionService.listen(u.uid, setGlobalSessions);
                    // Listen for activity via ActivityLogService (v8.39.0 — Phase 3.4)
                    unsubscribeActivity = ActivityLogService.listen(u.uid, setGlobalActivity);
                    // Listen for streams via WorkStreamService (v8.43.0 — Phase 5.2)
                    unsubscribeStreams = WorkStreamService.listen(u.uid, setGlobalStreams);
                    // Listen for interfaces via StreamInterfaceService (v8.43.0 — Phase 5.4)
                    unsubscribeInterfaces = StreamInterfaceService.listen(u.uid, setGlobalInterfaces);
                    // Listen for dependencies via DependencyService (v8.43.0 — Phase 5.4)
                    unsubscribeDependencies = DependencyService.listen(u.uid, setGlobalDependencies);
                    // Listen for dependency alerts via DependencyAlertService (v8.44.0 — Phase 5.4)
                    unsubscribeDependencyAlerts = DependencyAlertService.listen(u.uid, setGlobalDependencyAlerts);
                    // Listen for team members via TeamService (v8.46.0 — Phase 5.7)
                    unsubscribeTeam = TeamService.listen(u.uid, setTeamMembers);
                    unsubscribeTeamMembership = TeamService.listenMemberships(u.uid, setTeamMembership);
                    // Listen for ODRC concepts and ideas (Ideation Platform)
                    unsubscribeConcepts = ConceptManager.listen(u.uid, setGlobalConcepts);
                    unsubscribeIdeas = IdeaManager.listen(u.uid, setGlobalIdeas);
                    // v8.64.0 A1: Backfill missing fields on existing Ideas (idempotent, async)
                    IdeaManager.backfillMissingFields(u.uid).catch(e =>
                        console.error('[CC] Idea backfill failed:', e)
                    );
                    // Listen for completion jobs and settings (Ingestion Pipeline)
                    unsubscribeCompletionJobs = CompletionFileService.listen(u.uid, setGlobalCompletionJobs);
                    unsubscribeCompletionSettings = CompletionFileSettings.listen(u.uid, setCompletionFileSettings);
                    // Listen for orphan commits (Phase 3)
                    unsubscribeOrphans = OrphanDetectionService.listen(u.uid, setGlobalOrphanCommits);
                } else {
                    setFirebaseUid(null);
                    setGlobalIssues([]);
                    setGlobalWorkItems([]);
                    setGlobalSessions([]);
                    setGlobalActivity([]);
                    setGlobalStreams([]);
                    setGlobalInterfaces([]);
                    setGlobalDependencies([]);
                    setTeamMembers([]);
                    setTeamMembership(null);
                    setGlobalConcepts([]);
                    setGlobalIdeas([]);
                    setGlobalCompletionJobs([]);
                    setGlobalOrphanCommits([]);
                    setCompletionFileSettings(CompletionFileSettings.getDefaults());
                }
            });
            
            return () => {
                unsubscribe();
                unsubscribeIssues();
                unsubscribeWorkItems();
                unsubscribeSessions();
                unsubscribeActivity();
                unsubscribeStreams();
                unsubscribeInterfaces();
                unsubscribeDependencies();
                unsubscribeDependencyAlerts();
                unsubscribeTeam();
                unsubscribeTeamMembership();
                unsubscribeConcepts();
                unsubscribeIdeas();
                unsubscribeCompletionJobs();
                unsubscribeCompletionSettings();
                unsubscribeOrphans();
            };
        }, []);

        // Completion file + orphan commit detection — poll on mount and view changes to dashboard/jobHistory
        const completionPollRef = React.useRef(false);
        React.useEffect(() => {
            if (!firebaseUid || !github || completionPollRef.current) return;
            if (view !== 'dashboard' && view !== 'jobHistory') return;
            completionPollRef.current = true;

            const runPoll = async () => {
                const configuredApps = Object.values(apps).filter(a => a.testRepo || a.prodRepo || a.repos);
                const checkedRepos = new Set();
                let allNewJobs = [];
                let allNewOrphans = [];
                for (const app of configuredApps) {
                    const repoNames = [app.testRepo, app.prodRepo, app.repos?.test, app.repos?.prod].filter(Boolean);
                    for (const repo of repoNames) {
                        if (checkedRepos.has(repo)) continue;
                        checkedRepos.add(repo);
                        try {
                            const newJobs = await pollCompletionFiles(github, repo, firebaseUid, globalCompletionJobs, globalOrphanCommits);
                            allNewJobs = allNewJobs.concat(newJobs);
                        } catch (e) { console.warn('[CC] Poll error for', repo, e.message); }
                        // Phase 3: Also poll for orphan commits
                        try {
                            const newOrphans = await pollOrphanCommits(github, repo, firebaseUid, globalCompletionJobs, globalOrphanCommits, completionFileSettings);
                            allNewOrphans = allNewOrphans.concat(newOrphans);
                        } catch (e) { console.warn('[CC] Orphan poll error for', repo, e.message); }
                    }
                }
                // v8.62.0 A6: Non-blocking notification banners instead of modal dialogs
                if (allNewJobs.length > 0) {
                    const repoNames = [...new Set(allNewJobs.map(j => j.repoFullName?.split('/').pop()))].join(', ');
                    addNotification({
                        icon: '📦',
                        title: `${allNewJobs.length} new completion file${allNewJobs.length !== 1 ? 's' : ''}`,
                        message: `Found in ${repoNames}`,
                        action: { label: 'Review', handler: () => { setView('jobHistory'); } }
                    });
                }
                if (allNewOrphans.length > 0) {
                    const repoNames = [...new Set(allNewOrphans.map(o => o.repoFullName?.split('/').pop()))].join(', ');
                    addNotification({
                        icon: '📍',
                        title: `${allNewOrphans.length} orphaned commit${allNewOrphans.length !== 1 ? 's' : ''}`,
                        message: `In ${repoNames} — no completion file`,
                        action: { label: 'View', handler: () => { setView('jobHistory'); } }
                    });
                }
                // Reset so next navigation triggers another poll
                setTimeout(() => { completionPollRef.current = false; }, 60000);
            };
            runPoll();
        }, [view, firebaseUid, github]);

        // Link issues to a deployed version
        // Phase 5.7: Effective workspace UID — if user is a team member, use owner's UID for data access
        const workspaceUid = React.useMemo(() => {
            return TeamService.getWorkspaceUid(firebaseUid, teamMembership);
        }, [firebaseUid, teamMembership]);
        
        // Phase 5.7: Permission check — editors and owners can write, viewers are read-only
        const canEdit = React.useMemo(() => TeamService.canEdit(teamMembership), [teamMembership]);
        
        const linkIssuesToVersion = async (issueIds, version, appId) => {
            if (!firebaseUid || !issueIds.length) return;
            await IssueService.linkToVersion(firebaseUid, issueIds, version, appId);
        };
        
        // Use ref to always have latest apps state for async operations
        const appsRef = React.useRef(apps);
        React.useEffect(() => { appsRef.current = apps; }, [apps]);
        
        const github = React.useMemo(() => IS_TEST_MODE && window.MockGitHubAPI ? window.MockGitHubAPI : (githubToken ? new GitHubAPI(githubToken) : null), [githubToken]);
        
        // Persist
        React.useEffect(() => { try { if (githubToken) { localStorage.setItem('cc_token', githubToken); localStorage.setItem('gs_github_token', githubToken); } } catch {} }, [githubToken]);
        React.useEffect(() => { try { StorageManager.safeSet('cc_apps_v6', JSON.stringify(apps)); } catch {} }, [apps]);
        React.useEffect(() => { DeployService.save(deployments); }, [deployments]);
        React.useEffect(() => { SessionLogService.save(sessionLog); }, [sessionLog]);
        
        // v8.17.0: Firebase Config Sync — startup overlay
        // Load localStorage first (instant), then pull from Firebase and overlay if newer.
        // On first run (Firebase empty), push local data up to seed Firebase.
        React.useEffect(() => {
            if (!FirebaseConfigSync.initialized || syncInitialized) return;
            
            const unsubscribe = FirebaseConfigSync.onStatusChange(setSyncStatus);
            
            const doSync = async () => {
                console.log('[ConfigSync] Starting startup overlay...');
                const remote = await FirebaseConfigSync.pullAll();
                
                if (!remote) {
                    // Firebase unreachable — stay with localStorage
                    console.log('[ConfigSync] Firebase unreachable, running offline');
                    setSyncInitialized(true);
                    return;
                }
                
                if (remote.config && remote.config._updatedAt) {
                    // Firebase has data — overlay onto local
                    // v8.18.3: Always overlay in Phase 1 (single user). Timestamp comparison
                    // was causing issues where migration bumped local timestamp, blocking overlay.
                    console.log('[ConfigSync] Firebase has config, overlaying...');
                    // Strip sync metadata before merging
                    const { _updatedAt, _updatedBy, ...cleanConfig } = remote.config;
                    const merged = ConfigManager.mergeWithDefaults(cleanConfig);
                        merged._updatedAt = _updatedAt;
                        merged._updatedBy = _updatedBy;
                        
                        // v8.18.5: Merge local apps INTO Firebase overlay — local is authoritative
                        // Preserve: local-only apps, local repos, local projects, local versions
                        const localCfg = ConfigManager.load();
                        let reposPreserved = 0;
                        let appsPreserved = 0;
                        if (localCfg.apps) {
                            if (!merged.apps) merged.apps = {};
                            for (const [id, localApp] of Object.entries(localCfg.apps)) {
                                if (!merged.apps[id]) {
                                    // App exists locally but not in Firebase — preserve it
                                    merged.apps[id] = { ...localApp };
                                    appsPreserved++;
                                } else {
                                    // App exists in both — preserve local repos (authoritative)
                                    if (localApp.repos) {
                                        if (!merged.apps[id].repos) merged.apps[id].repos = {};
                                        if (localApp.repos.test && localApp.repos.test !== merged.apps[id].repos.test) {
                                            merged.apps[id].repos.test = localApp.repos.test;
                                            reposPreserved++;
                                        }
                                        if (localApp.repos.prod && localApp.repos.prod !== merged.apps[id].repos.prod) {
                                            merged.apps[id].repos.prod = localApp.repos.prod;
                                            reposPreserved++;
                                        }
                                    }
                                    // Preserve local versions if Firebase has empty ones
                                    if (localApp.versions) {
                                        if (!merged.apps[id].versions) merged.apps[id].versions = {};
                                        for (const [env, ver] of Object.entries(localApp.versions)) {
                                            if (ver && !merged.apps[id].versions[env]) {
                                                merged.apps[id].versions[env] = ver;
                                            }
                                        }
                                    }
                                }
                            }
                            if (appsPreserved > 0) console.log(`[ConfigSync] Preserved ${appsPreserved} local-only apps during overlay`);
                            if (reposPreserved > 0) console.log(`[ConfigSync] Preserved ${reposPreserved} local repo assignments during overlay`);
                        }
                        
                        // Also preserve local-only projects
                        if (localCfg.projects && merged.projects) {
                            for (const [id, proj] of Object.entries(localCfg.projects)) {
                                if (!merged.projects[id]) {
                                    merged.projects[id] = { ...proj };
                                }
                            }
                        }
                        
                        // Save to localStorage (without re-pushing to Firebase)
                        try { localStorage.setItem(ConfigManager.STORAGE_KEY, JSON.stringify(merged)); localStorage.setItem('gs_config', JSON.stringify(merged)); } catch {}
                        
                        setConfig(merged);
                        setApps(ConfigManager.toLegacyAppsFormat(merged));
                        
                        // Push merged config back if we preserved local data
                        // v8.61.1: Use silent push — don't let this optional re-push
                        // set status to 'error' (pullAll already confirmed connection works)
                        if (reposPreserved > 0 || appsPreserved > 0) {
                            FirebaseConfigSync.pushConfig(merged).catch(() => {
                                // Restore synced status — pull succeeded, this push is optional
                                if (FirebaseConfigSync.syncStatus === 'error') {
                                    FirebaseConfigSync._setStatus('synced');
                                }
                            });
                        }
                    
                    // Overlay deploy history if Firebase is newer
                    if (remote.deployHistory && Array.isArray(remote.deployHistory) && remote.deployHistory.length > 0) {
                        const remoteTs = remote.deployHistory._updatedAt || 0;
                        setDeployments(prev => {
                            if (remoteTs > 0 || remote.deployHistory.length > prev.length) {
                                DeployService.overlay(remote.deployHistory);
                                return Array.isArray(remote.deployHistory) ? remote.deployHistory : prev;
                            }
                            return prev;
                        });
                    }
                    
                    // Overlay session log if Firebase has data
                    if (remote.sessionLog && remote.sessionLog._updatedAt) {
                        const overlaid = SessionLogService.overlay(remote.sessionLog);
                        if (overlaid) {
                            setSessionLog(overlaid);
                        }
                    }
                    
                    console.log('[ConfigSync] Startup overlay complete');
                } else {
                    // Firebase is empty — first run, seed it with local data
                    console.log('[ConfigSync] Firebase empty, seeding with local data...');
                    const localConfig = ConfigManager.load();
                    const localDeployments = DeployService.load();
                    const localRulesHistory = (() => { try { return JSON.parse(localStorage.getItem('cc_rulesHistory') || '[]'); } catch { return []; } })();
                    const localSessionLog = SessionLogService.load();
                    const localDeletionHistory = (() => { try { return JSON.parse(localStorage.getItem('cc_deletion_history') || '[]'); } catch { return []; } })();
                    const localRollbackSnapshots = RollbackService.load();
                    
                    await FirebaseConfigSync.pushAll({
                        config: localConfig,
                        deployHistory: localDeployments,
                        rulesHistory: localRulesHistory,
                        sessionLog: localSessionLog,
                        deletionHistory: localDeletionHistory,
                        rollbackSnapshots: localRollbackSnapshots
                    });
                    
                    console.log('[ConfigSync] Initial seed complete');
                }
                
                setSyncInitialized(true);
            };
            
            doSync();
            
            return () => unsubscribe();
        }, [syncInitialized]);
        
        // v8.18.0: Force sync handler for Settings UI
        const handleForceSync = async (direction) => {
            if (!FirebaseConfigSync.initialized) return;
            
            if (direction === 'pull') {
                const remote = await FirebaseConfigSync.pullAll();
                if (!remote) throw new Error('Firebase unreachable');
                
                if (remote.config && remote.config._updatedAt) {
                    const { _updatedAt, _updatedBy, ...cleanConfig } = remote.config;
                    const merged = ConfigManager.mergeWithDefaults(cleanConfig);
                    merged._updatedAt = _updatedAt;
                    merged._updatedBy = _updatedBy;
                    try { localStorage.setItem(ConfigManager.STORAGE_KEY, JSON.stringify(merged)); localStorage.setItem('gs_config', JSON.stringify(merged)); } catch {}
                    setConfig(merged);
                    setApps(ConfigManager.toLegacyAppsFormat(merged));
                }
                
                if (remote.deployHistory && Array.isArray(remote.deployHistory) && remote.deployHistory.length > 0) {
                    DeployService.overlay(remote.deployHistory);
                    setDeployments(Array.isArray(remote.deployHistory) ? remote.deployHistory : []);
                }
                
                if (remote.sessionLog && remote.sessionLog._updatedAt) {
                    const overlaid = SessionLogService.overlay(remote.sessionLog);
                    if (overlaid) setSessionLog(overlaid);
                }
            }
        };
        
        // Monitor live site until new version appears
        const monitorLiveDeployment = async (url, expectedVersion, repo, onUpdate, appId = null, target = 'prod') => {
            const maxWaitMs = 180000; // 3 minutes max
            const pollInterval = 5000; // Check every 5 seconds
            const startTime = Date.now();
            let attempts = 0;
            let corsFailures = 0;
            const maxCorsFailures = 3; // Give up after 3 CORS errors
            
            // Key for deployingRepos - use appId:target if provided, otherwise fall back to repo
            const deployKey = appId ? `${appId}:${target}` : repo;
            
            console.log(`=== MONITORING LIVE DEPLOYMENT ===`);
            console.log(`URL: ${url}`);
            console.log(`Repo: ${repo}`);
            console.log(`Expected version: ${expectedVersion}`);
            console.log(`Deploy key: ${deployKey}`);
            
            // Mark app as deploying
            setDeployingRepos(prev => ({ ...prev, [deployKey]: { version: expectedVersion, startTime, repo } }));
            
            while (Date.now() - startTime < maxWaitMs) {
                attempts++;
                const elapsed = Math.round((Date.now() - startTime) / 1000);
                
                try {
                    // Fetch the live site with cache-busting
                    // Don't set custom headers - they trigger CORS preflight which GitHub Pages doesn't support
                    const response = await fetch(`${url}?_t=${Date.now()}`, {
                        cache: 'no-store'
                    });
                    
                    if (response.ok) {
                        const html = await response.text();
                        const liveVersion = extractVersionFromHTML(html);
                        
                        console.log(`[${elapsed}s] Live version: ${liveVersion || 'unknown'}, expecting: ${expectedVersion}`);
                        corsFailures = 0; // Reset on success
                        
                        if (liveVersion === expectedVersion) {
                            console.log(`=== DEPLOYMENT COMPLETE! Version ${liveVersion} is live ===`);
                            onUpdate('complete', `v${liveVersion} is LIVE! (${elapsed}s)`);
                            
                            // v8.3.3: Ensure indicator shows for at least 2 seconds
                            const minDisplayMs = 2000;
                            const elapsedMs = Date.now() - startTime;
                            const remainingMs = Math.max(0, minDisplayMs - elapsedMs);
                            
                            // Clear deploying state after minimum display time
                            setTimeout(() => {
                                setDeployingRepos(prev => {
                                    const next = { ...prev };
                                    delete next[deployKey];
                                    return next;
                                });
                            }, remainingMs);
                            
                            return { success: true, duration: elapsed };
                        } else {
                            onUpdate('running', `Waiting... ${elapsed}s (live: ${liveVersion || '?'})`);
                        }
                    } else {
                        onUpdate('running', `Waiting... ${elapsed}s (site loading)`);
                    }
                } catch (e) {
                    corsFailures++;
                    console.log(`[${elapsed}s] Fetch error (${corsFailures}/${maxCorsFailures}):`, e.message);
                    
                    // If we keep getting CORS/network errors, stop monitoring
                    if (corsFailures >= maxCorsFailures) {
                        console.log(`=== CORS/NETWORK ERRORS - STOPPING MONITOR ===`);
                        onUpdate('complete', `Commit pushed ✓ (verify at site)`);
                        setDeployingRepos(prev => {
                            const next = { ...prev };
                            delete next[deployKey];
                            return next;
                        });
                        return { success: true, corsBlocked: true };
                    }
                    
                    onUpdate('running', `Waiting... ${elapsed}s`);
                }
                
                await new Promise(r => setTimeout(r, pollInterval));
            }
            
            console.log(`=== DEPLOYMENT MONITORING TIMEOUT ===`);
            onUpdate('warning', `Timeout - check manually`);
            // Clear deploying state on timeout
            setDeployingRepos(prev => {
                const next = { ...prev };
                delete next[deployKey];
                return next;
            });
            return { success: false, timeout: true };
        };
        
        // Refresh repos list
        const refreshRepos = async () => {
            if (!github) return;
            try {
                const repos = await github.listRepos();
                setAvailableRepos(repos);
                // Re-run auto-mapping
                setApps(prev => autoMapRepos(prev, repos));
            } catch (e) {
                console.error('Failed to refresh repos:', e);
            }
        };
        
        // Fetch repos and auto-refresh versions on load
        React.useEffect(() => {
            if (github) {
                github.listRepos().then(async (repos) => {
                    setAvailableRepos(repos);
                    
                    // Get current apps state and map repos
                    setApps(prev => {
                        const mapped = autoMapRepos(prev, repos);
                        
                        // v8.18.1: Sync auto-detected repos back to config so Firebase gets them
                        setConfig(prevConfig => {
                            let changed = false;
                            const updatedConfig = { ...prevConfig, apps: { ...prevConfig.apps } };
                            for (const [id, app] of Object.entries(mapped)) {
                                if (updatedConfig.apps[id]) {
                                    const configApp = updatedConfig.apps[id];
                                    if (app.testRepo && configApp.repos?.test !== app.testRepo) {
                                        updatedConfig.apps[id] = { ...configApp, repos: { ...configApp.repos, test: app.testRepo } };
                                        changed = true;
                                    }
                                    if (app.prodRepo && configApp.repos?.prod !== app.prodRepo) {
                                        updatedConfig.apps[id] = { ...updatedConfig.apps[id], repos: { ...(updatedConfig.apps[id].repos || {}), prod: app.prodRepo } };
                                        changed = true;
                                    }
                                }
                            }
                            if (changed) {
                                ConfigManager.save(updatedConfig);
                            }
                            return changed ? updatedConfig : prevConfig;
                        });
                        
                        return mapped;
                    });
                    
                    // Small delay to let state settle, then refresh versions
                    await new Promise(r => setTimeout(r, 500));
                    refreshAllVersions();
                }).catch(console.error);
            }
        }, [github]);
        
        // Refresh all versions from repos
        const refreshAllVersions = async () => {
            if (!github) return;
            setRefreshing(true);
            
            // Always use latest apps state from ref
            const currentApps = appsRef.current;
            console.log('=== REFRESHING VERSIONS FROM REPOS ===');
            
            const updates = {};
            
            // Build project→repo map for inheritance (same logic as resolveZipContents)
            const projectRepos = {};
            for (const [id, a] of Object.entries(currentApps)) {
                const repo = a.prodRepo || a.testRepo;
                if (repo && a.project) projectRepos[a.project] = repo;
            }
            
            for (const [appId, app] of Object.entries(currentApps)) {
                // Inherit repo from project siblings if app doesn't have one
                const effectiveTestRepo = app.testRepo || (app.project ? projectRepos[app.project] : '') || '';
                const effectiveProdRepo = app.prodRepo || (app.project ? projectRepos[app.project] : '') || '';
                
                // Ensure subPath is set from defaults (localStorage may have empty string from old config)
                const effectiveSubPath = app.subPath || '';
                const appWithSubPath = { ...app, subPath: effectiveSubPath };
                
                // Get the full path including subPath if set
                const fullTargetPath = getRepoFilePath(appWithSubPath, app.targetPath);
                
                if (effectiveTestRepo) {
                    try {
                        console.log(`[${appId}] Fetching TEST from ${effectiveTestRepo}/${fullTargetPath}...`);
                        const testFileData = await github.getFileContent(effectiveTestRepo, fullTargetPath);
                        if (testFileData) {
                            // Use textContent which handles both normal and large files
                            const content = testFileData.textContent;
                            const version = extractVersionFromHTML(content);
                            console.log(`[${appId}] TEST version from REPO: ${version || 'NO VERSION'}`);
                            console.log(`[${appId}] TEST file SHA: ${testFileData.sha}`);
                            if (version) updates[appId] = { ...updates[appId], currentTestVersion: version };
                        } else {
                            console.log(`[${appId}] TEST: FILE NOT FOUND`);
                        }
                    } catch (e) {
                        console.error(`[${appId}] TEST error:`, e.message);
                    }
                }
                if (effectiveProdRepo) {
                    try {
                        console.log(`[${appId}] Fetching PROD from ${effectiveProdRepo}/${fullTargetPath}...`);
                        const prodFileData = await github.getFileContent(effectiveProdRepo, fullTargetPath);
                        if (prodFileData) {
                            // Use textContent which handles both normal and large files
                            const content = prodFileData.textContent;
                            const version = extractVersionFromHTML(content);
                            console.log(`[${appId}] PROD version from REPO: ${version || 'NO VERSION'}`);
                            console.log(`[${appId}] PROD file SHA: ${prodFileData.sha}`);
                            if (version) updates[appId] = { ...updates[appId], currentProdVersion: version };
                        } else {
                            console.log(`[${appId}] PROD: FILE NOT FOUND`);
                        }
                    } catch (e) {
                        console.error(`[${appId}] PROD error:`, e.message);
                    }
                }
            }
            
            setApps(prev => {
                const newApps = { ...prev };
                for (const [appId, upd] of Object.entries(updates)) {
                    newApps[appId] = { ...newApps[appId], ...upd };
                }
                console.log('Updated apps state:', Object.entries(newApps).map(([id, a]) => `${id}: TEST=${a.currentTestVersion || '—'}, PROD=${a.currentProdVersion || '—'}`));
                return newApps;
            });
            
            setRefreshing(false);
            console.log('=== REFRESH COMPLETE ===');
            
            // Run daily repo health check
            runRepoHealthCheck();
        };
        
        // Lightweight repo health check — runs once per day
        const runRepoHealthCheck = async () => {
            if (!github) return;
            
            // Check last run time
            const HEALTH_CHECK_KEY = 'cc_repo_health_last';
            const lastRun = localStorage.getItem(HEALTH_CHECK_KEY);
            const now = new Date();
            if (lastRun) {
                const lastDate = new Date(lastRun);
                const hoursSince = (now - lastDate) / (1000 * 60 * 60);
                if (hoursSince < 24) {
                    console.log(`[HealthCheck] Skipping — last ran ${hoursSince.toFixed(1)}h ago`);
                    return;
                }
            }
            
            console.log('[HealthCheck] Running daily repo health check...');
            localStorage.setItem(HEALTH_CHECK_KEY, now.toISOString());
            
            const currentApps = appsRef.current;
            const issues = [];
            
            // Only check apps deployed in the last 30 days
            const thirtyDaysAgo = new Date(now - 30 * 24 * 60 * 60 * 1000);
            let currentDeployments = DeployService.load();
            const recentlyDeployed = new Set(
                currentDeployments
                    .filter(d => d.status === 'success' && new Date(d.completedAt || d.startedAt) > thirtyDaysAgo)
                    .map(d => d.appId)
            );
            
            console.log(`[HealthCheck] Checking ${recentlyDeployed.size} recently deployed apps:`, Array.from(recentlyDeployed).join(', '));
            
            for (const [appId, app] of Object.entries(currentApps)) {
                // Skip apps not deployed in last 30 days
                if (!recentlyDeployed.has(appId)) continue;
                
                // Check both test and prod repos
                const repos = [];
                const testRepo = app.testRepo || app.repos?.test;
                const prodRepo = app.prodRepo || app.repos?.prod;
                if (testRepo) repos.push({ repo: testRepo, target: 'test' });
                if (prodRepo) repos.push({ repo: prodRepo, target: 'prod' });
                
                for (const { repo, target } of repos) {
                    try {
                        const contents = await github.listRepoContents(repo, '');
                        const subPath = app.subPath || '';
                        
                        // Build expected set
                        const expected = new Set();
                        const addExp = (f) => expected.add(subPath ? `${subPath}/${f}` : f);
                        addExp(app.targetPath || 'index.html');
                        if (app.hasServiceWorker) {
                            addExp(app.swPath || 'sw.js');
                            addExp('manifest.json');
                        }
                        // Standard files
                        ['README.md', 'LICENSE', '.gitignore', 'CNAME', 'icons'].forEach(f => expected.add(f));
                        // Doc files (root level)
                        ['CONTEXT.md', 'PROJECT_PLAN.md', 'CHANGELOG.md', 'RELEASE_NOTES.txt', 'ARCHITECTURE.md', 'CLAUDE-PREP-STANDARD.md', 'DATA_MODEL.md'].forEach(f => expected.add(f));
                        // .github dir
                        expected.add('.github');
                        
                        const unexpected = contents.filter(item => !expected.has(item.name));
                        
                        if (unexpected.length > 0) {
                            issues.push({
                                appId, appName: app.name, appIcon: app.icon,
                                repo, target,
                                unexpectedFiles: unexpected.map(f => ({ name: f.name, type: f.type }))
                            });
                        }
                    } catch (e) {
                        // Skip repos we can't access
                    }
                }
            }
            
            if (issues.length > 0) {
                console.log(`[HealthCheck] Found ${issues.length} repos with unexpected files`);
                setRepoHealthAlert({ issues });
            } else {
                console.log('[HealthCheck] All repos clean');
            }
        };
        
        // Load repo files
        const updateApp = (appId, updates) => setApps(prev => ({ ...prev, [appId]: { ...prev[appId], ...updates } }));
        
        // v8.69.0: Process session package zip — extract, validate, route to import checklist
        const processSessionPackage = async (zip, zipFilename, hasDebrief) => {
            console.log('[CC] Processing session package:', zipFilename);

            // 1. Extract session.json
            const sessionJsonEntry = zip.file('session.json')
                || zip.file(/session\.json$/)[0];
            if (!sessionJsonEntry) {
                console.error('[CC] Session package missing session.json');
                await showAlert('Session package missing session.json', '❌ Error');
                return;
            }

            const sessionJsonContent = await sessionJsonEntry.async('string');
            let sessionData;
            try {
                sessionData = JSON.parse(sessionJsonContent);
            } catch (e) {
                console.error('[CC] session.json parse error:', e.message);
                await showAlert('Invalid session.json: ' + e.message, '❌ Error');
                return;
            }

            // 2. Validate
            const validation = SessionPackageProcessor.validate(sessionData);
            if (!validation.valid) {
                console.error('[CC] session.json validation errors:', validation.errors);
                await showAlert(
                    `Validation failed:\n${validation.errors.join('\n')}`,
                    '❌ Validation Error'
                );
                return;
            }
            if (validation.warnings.length > 0) {
                console.warn('[CC] session.json warnings:', validation.warnings);
            }

            // 3. Extract debrief.md if present
            let debriefContent = null;
            if (hasDebrief) {
                const debriefEntry = zip.file('debrief.md')
                    || zip.file(/debrief\.md$/)[0];
                if (debriefEntry) {
                    debriefContent = await debriefEntry.async('string');
                }
            }

            // 4. Collect artifact filenames
            const artifactFiles = [];
            zip.forEach((path, entry) => {
                if (path !== 'session.json' && path !== 'debrief.md' && !entry.dir) {
                    artifactFiles.push(path);
                }
            });

            // 5. Map ODRC items
            const parsedUpdates = SessionPackageProcessor.toIngestionUpdates(sessionData);
            const metadata = SessionPackageProcessor.extractMetadata(sessionData);

            // 6. Route to import checklist
            setPendingOdrcImport({
                fileName: zipFilename,
                fullContent: sessionJsonContent,
                odrcSection: null,
                metadata,
                parsedUpdates,
                sourceApp: metadata.appId,
                artifactType: 'session-json',
                sessionData,
                debriefContent,
                artifactFiles,
                validationWarnings: validation.warnings
            });
        };

        // File upload - now accepts multiple file types
        const handleFileDrop = (e) => {
            e.preventDefault();
            const files = e.dataTransfer?.files || e.target.files;
            
            // Capture files into array BEFORE resetting input
            // (FileList is live and gets cleared when input is reset)
            const fileArray = Array.from(files || []);
            
            // Reset file input so same file can be selected again
            // (without this, onChange won't fire for the same file twice)
            if (e.target && e.target.value) {
                e.target.value = '';
            }
            
            // Exit early if no files
            if (fileArray.length === 0) return;
            
            fileArray.forEach(async (file) => {
                // Handle ZIP files specially
                if (file.name.endsWith('.zip')) {
                    console.log('=== PROCESSING ZIP FILE ===');
                    console.log('Name:', file.name);
                    
                    if (typeof JSZip === 'undefined') {
                        await showAlert('ZIP support not available', 'Error');
                        return;
                    }
                    
                    try {
                        const zip = await JSZip.loadAsync(file);

                        // v8.69.0: Session package detection — highest priority
                        const { isSessionPackage, hasDebrief } = isSessionPackageZip(zip);
                        if (isSessionPackage) {
                            await processSessionPackage(zip, file.name, hasDebrief);
                            return;
                        }

                        // Check if this is a multi-app archive (gs-active, CC deploy package, or any mixed zip)
                        const allPaths = [];
                        zip.forEach((path) => { allPaths.push(path); });

                        const isMultiApp = isMultiAppZip(zip, apps);
                        console.log('[SmartDeploy] isMultiApp:', isMultiApp);
                        
                        if (isMultiApp) {
                            // Resolve all files to apps using path matching
                            const resolved = await resolveZipContents(zip, apps);
                            
                            // Log resolution summary
                            const repoEntries = Object.entries(resolved.repos);
                            for (const [repoKey, bucket] of repoEntries) {
                                const appIds = Object.keys(bucket.apps);
                                for (const appId of appIds) {
                                    const appData = bucket.apps[appId];
                                    const deployCount = appData.files.filter(f => classifyFileAction(f.relativePath) !== 'push-doc').length;
                                    const docCount = appData.files.filter(f => classifyFileAction(f.relativePath) === 'push-doc').length;
                                    console.log(`[SmartDeploy] App: ${appId} → ${bucket.target} | ${deployCount} deploy, ${docCount} docs | v${appData.version || '?'}`);
                                }
                                if (bucket.sharedFiles?.length) console.log(`[SmartDeploy] Shared: ${bucket.sharedFiles.length} files`);
                            }
                            if (resolved.unmatched?.length) console.log('[SmartDeploy] Unmatched:', resolved.unmatched);
                            if (resolved.zipDirs?.length) console.log('[SmartDeploy] Zip dirs:', resolved.zipDirs);
                            
                            // Clear any existing staged files
                            setStagedFiles([]);
                            
                            // Stage all resolved files
                            const newStagedFiles = [];
                            
                            for (const [repoKey, bucket] of Object.entries(resolved.repos)) {
                                // App files
                                for (const [appId, appData] of Object.entries(bucket.apps)) {
                                    for (const file of appData.files) {
                                        let content;
                                        let isText = true;
                                        try {
                                            content = await file.entry.async('string');
                                        } catch (e) {
                                            content = await file.entry.async('base64');
                                            isText = false;
                                        }
                                        
                                        const fileName = file.relativePath.split('/').pop();
                                        const fileAction = classifyFileAction(file.relativePath);
                                        
                                        let version = null;
                                        if (file.relativePath.endsWith('.html') || file.relativePath === 'sw.js') {
                                            version = extractVersionFromHTML(content);
                                        }

                                        // v8.66.0: Four-path inbound artifact detection in zip entries
                                        if (isText) {
                                            const artifactType = detectInboundArtifactType(content);
                                            const hasOdrcSection = extractODRCSection(content);

                                            if (artifactType === 'session-json') {
                                                console.log('[CC] session.json detected in zip entry:', file.relativePath);
                                                try {
                                                    const sessionData = JSON.parse(content);
                                                    const validation = SessionPackageProcessor.validate(sessionData);
                                                    if (validation.errors.length === 0) {
                                                        const metadata = SessionPackageProcessor.extractMetadata(sessionData);
                                                        const parsed = SessionPackageProcessor.toIngestionUpdates(sessionData);
                                                        if (parsed.length > 0) {
                                                            setPendingOdrcImport({
                                                                fileName: file.relativePath,
                                                                fullContent: content,
                                                                odrcSection: null,
                                                                metadata,
                                                                parsedUpdates: parsed,
                                                                sourceApp: appId,
                                                                artifactType: 'session-json',
                                                                sessionData
                                                            });
                                                        }
                                                        if (validation.warnings.length > 0) {
                                                            console.warn('[CC] session.json warnings:', validation.warnings);
                                                        }
                                                    } else {
                                                        console.error('[CC] session.json validation failed:', validation.errors);
                                                    }
                                                } catch (e) {
                                                    console.error('[CC] session.json parse error:', e.message);
                                                }
                                            } else if (artifactType === 'odrc') {
                                                console.log('[CC] ODRC content detected in zip entry:', file.relativePath);
                                                const metadata = extractODRCMetadata(content);
                                                const parsed = ODRCUpdateIngestionService.parse(hasOdrcSection || content);
                                                if (parsed.length > 0) {
                                                    setPendingOdrcImport({
                                                        fileName: file.relativePath,
                                                        fullContent: content,
                                                        odrcSection: hasOdrcSection || content,
                                                        metadata,
                                                        parsedUpdates: parsed,
                                                        sourceApp: appId
                                                    });
                                                }
                                            } else if ((artifactType === 'spec' || artifactType === 'claude-md') && hasOdrcSection) {
                                                console.log(`[CC] ${artifactType} artifact with ODRC section in zip entry:`, file.relativePath);
                                                const metadata = extractODRCMetadata(content);
                                                const parsed = ODRCUpdateIngestionService.parse(hasOdrcSection);
                                                if (parsed.length > 0) {
                                                    setPendingOdrcImport({
                                                        fileName: file.relativePath,
                                                        fullContent: content,
                                                        odrcSection: hasOdrcSection,
                                                        metadata,
                                                        parsedUpdates: parsed,
                                                        sourceApp: appId,
                                                        artifactType
                                                    });
                                                }
                                            }
                                        }

                                        if (fileAction === 'skip') {
                                            // Handle SESSION_RETURN.json
                                            if (fileName === 'SESSION_RETURN.json' && isText) {
                                                const validation = validateSessionReturn(content);
                                                if (validation.valid) {
                                                    setPendingSessionReturn({ data: validation.data, warnings: validation.warnings, sourceApp: appId, raw: content });
                                                }
                                            }
                                            continue;
                                        }
                                        
                                        newStagedFiles.push({
                                            id: Date.now() + Math.random(),
                                            name: file.relativePath,
                                            originalPath: file.zipPath,
                                            size: content.length,
                                            content,
                                            encoding: isText ? 'utf-8' : 'base64',
                                            isText,
                                            suggestedApp: appId,
                                            version,
                                            versionSource: version ? 'extracted' : 'none',
                                            fileAction,
                                            targetPath: file.repoPath,
                                            repoPath: file.repoPath,
                                            fullRepoPath: true,
                                            multiApp: true,
                                            repoKey,
                                            repo: bucket.repo,
                                            deployTarget: bucket.target,
                                            appVersion: appData.version // app-level version from index.html
                                        });
                                    }
                                }
                                
                                // Shared files
                                for (const file of (bucket.sharedFiles || [])) {
                                    let content;
                                    let isText = true;
                                    try {
                                        content = await file.entry.async('string');
                                    } catch (e) {
                                        content = await file.entry.async('base64');
                                        isText = false;
                                    }
                                    
                                    newStagedFiles.push({
                                        id: Date.now() + Math.random(),
                                        name: file.relativePath,
                                        originalPath: file.zipPath,
                                        size: content.length,
                                        content,
                                        encoding: isText ? 'utf-8' : 'base64',
                                        isText,
                                        suggestedApp: '_shared',
                                        fileAction: 'deploy',
                                        targetPath: file.repoPath,
                                        repoPath: file.repoPath,
                                        fullRepoPath: true,
                                        multiApp: true,
                                        repoKey,
                                        repo: bucket.repo,
                                        deployTarget: bucket.target
                                    });
                                }
                            }
                            
                            // Attach package metadata to first file for validation
                            if (newStagedFiles.length > 0) {
                                newStagedFiles[0].zipDirs = resolved.zipDirs;
                            }
                            setStagedFiles(newStagedFiles);
                            
                            // Log unmatched for debugging
                            if (resolved.unmatched.length > 0) {
                                console.log('Unmatched files:', resolved.unmatched);
                            }
                            
                            return;
                        }
                        
                        let primaryApp = null;
                        let primaryVersion = null;
                        console.log('[SmartDeploy] Single-app zip path — extracting files individually');
                        
                        // Detect if ZIP has a root folder (common in downloads)
                        const hasRootFolder = allPaths.filter(p => !p.endsWith('/')).length > 0 && 
                            allPaths.filter(p => !p.endsWith('/')).every(p => p.includes('/'));
                        const rootFolder = hasRootFolder ? allPaths.find(p => !p.endsWith('/'))?.split('/')[0] + '/' : '';
                        
                        // === PWA PACKAGE VALIDATION ===
                        // Detect if this is a PWA deployment package (has -latest folder pattern)
                        const latestFolderPattern = /^([a-z]+-latest)\//i;
                        const expectedLatestFolders = ['gameshelf-latest', 'quotle-latest', 'slate-latest', 'rungs-latest', 'wordboxing-latest'];
                        
                        // Check for nested folder issue (extra parent folder wrapping the -latest folder)
                        const pathsAfterRoot = allPaths.map(p => rootFolder && p.startsWith(rootFolder) ? p.substring(rootFolder.length) : p);
                        const hasLatestFolder = pathsAfterRoot.some(p => expectedLatestFolders.some(f => p.startsWith(f + '/')));
                        const hasNestedLatest = allPaths.some(p => {
                            const parts = p.split('/').filter(Boolean);
                            // Check if there's a -latest folder that's NOT at the root level after stripping rootFolder
                            return parts.length >= 3 && expectedLatestFolders.includes(parts[1]);
                        });
                        
                        // Find index.html to check structure
                        const indexPath = allPaths.find(p => p.endsWith('index.html'));
                        const indexDepth = indexPath ? indexPath.split('/').filter(Boolean).length : 0;
                        
                        // Validate PWA package structure
                        if (hasLatestFolder || hasNestedLatest || (rootFolder && indexDepth > 2)) {
                            // This looks like a PWA package - validate structure
                            const expectedPaths = pathsAfterRoot.filter(p => !p.endsWith('/'));
                            const hasIndexAtRoot = expectedPaths.some(p => p === 'index.html' || p.match(/^[a-z]+-latest\/index\.html$/i));
                            const hasNestedIndex = expectedPaths.some(p => {
                                const parts = p.split('/').filter(Boolean);
                                return parts.length > 2 && parts[parts.length - 1] === 'index.html';
                            });
                            
                            if (hasNestedIndex && !hasIndexAtRoot) {
                                // Structure is wrong - extra parent folder
                                const actualPath = indexPath;
                                const expectedPath = actualPath.split('/').slice(-2).join('/'); // e.g., gameshelf-latest/index.html
                                
                                await showAlert(
                                    `⚠️ ZIP has incorrect folder structure!\n\n` +
                                    `Found: ${actualPath}\n` +
                                    `Expected: ${expectedPath}\n\n` +
                                    `The ZIP has an extra parent folder wrapping the content.\n\n` +
                                    `To fix: Re-create the ZIP so the -latest folder is at the root level, not inside another folder.`,
                                    '📦 Invalid Package Structure'
                                );
                                return;
                            }
                        }
                        
                        const extractPromises = [];
                        zip.forEach((relativePath, zipEntry) => {
                            if (zipEntry.dir || relativePath.startsWith('.') || relativePath.includes('__MACOSX')) return;
                            
                            // Strip root folder if present (e.g., 'quotle-deploy-v1_0_2/' prefix)
                            let cleanPath = relativePath;
                            if (rootFolder && relativePath.startsWith(rootFolder)) {
                                cleanPath = relativePath.substring(rootFolder.length);
                            }
                            
                            let fileName = cleanPath.split('/').pop();
                            const isText = /\.(html|js|css|json|md|txt|xml|svg|yml|yaml)$/i.test(fileName);
                            
                            // Determine target path - preserve directory structure for non-HTML files
                            let targetPath;
                            if (fileName.endsWith('.html')) {
                                // HTML files → use app's targetPath (usually index.html)
                                // The zip directory structure is for organization, not deployment
                                targetPath = fileName === 'index.html' ? 'index.html' : fileName;
                            } else if (cleanPath.includes('/')) {
                                // Files in subdirectories → preserve path (e.g., icons/icon-72.png)
                                targetPath = cleanPath;
                            } else {
                                // Root non-HTML files → keep filename
                                targetPath = fileName;
                            }
                            
                            extractPromises.push(
                                zipEntry.async(isText ? 'string' : 'binarystring').then(content => {
                                    const parsed = parseFilename(fileName);
                                    let version = null;
                                    let suggestedApp = null;
                                    let appDetection = null;
                                    let versionValidation = null;
                                    
                                    if (fileName.endsWith('.html')) {
                                        appDetection = detectAppFromContent(content);
                                        suggestedApp = appDetection?.id || parsed.app;
                                        version = extractVersionFromHTML(content) || parsed.version;
                                        versionValidation = validateVersions(content, fileName);
                                        if (appDetection) {
                                            primaryApp = suggestedApp;
                                            primaryVersion = version;
                                        }
                                    } else if (fileName === 'sw.js') {
                                        const swMatch = content.match(/CACHE_VERSION\s*=\s*['"]v?([^'"]+)['"]/);
                                        version = swMatch ? swMatch[1] : null;
                                        suggestedApp = parsed.app;
                                    } else {
                                        suggestedApp = parsed.app;
                                    }
                                    
                                    // Detect CLAUDE.md regardless of zip filename
                                    const detectedName = detectClaudeMd(fileName, isText ? content : null);
                                    if (detectedName !== fileName) {
                                        cleanPath = cleanPath.replace(fileName, detectedName);
                                        targetPath = targetPath === fileName ? detectedName : targetPath.replace(fileName, detectedName);
                                        fileName = detectedName;
                                    }

                                    console.log('Extracted:', cleanPath, '→', targetPath, 'v' + version);

                                    const fileAction = classifyFileAction(fileName);
                                    if (fileAction === 'skip') {
                                        // Phase B: Capture SESSION_RETURN.json before skipping
                                        if (fileName === 'SESSION_RETURN.json' && isText) {
                                            console.log('[SESSION_RETURN] Found in zip, capturing for auto-review');
                                            const validation = validateSessionReturn(content);
                                            if (validation.valid) {
                                                setPendingSessionReturn({ 
                                                    data: validation.data, 
                                                    warnings: validation.warnings,
                                                    sourceApp: suggestedApp || primaryApp,
                                                    raw: content
                                                });
                                            } else {
                                                console.warn('[SESSION_RETURN] Validation failed:', validation.errors);
                                                showAlert(
                                                    `SESSION_RETURN.json found but has errors:\n\n${validation.errors.join('\n')}\n\nFalling back to manual review.`,
                                                    '⚠️ Return Manifest Invalid'
                                                );
                                            }
                                        }
                                        return; // Skip SESSION_BRIEF.md etc.
                                    }
                                    
                                    // For push-doc files, compute the repo target path
                                    let docTargetPath = fileName; // Default: just the filename at root
                                    if (fileAction === 'push-doc' && suggestedApp) {
                                        const docApp = apps[suggestedApp];
                                        if (docApp) {
                                            const docsPath = getDocsPath(docApp);
                                            docTargetPath = docsPath ? `${docsPath}/${fileName}` : fileName;
                                        }
                                    }
                                    
                                    setStagedFiles(prev => [...prev, {
                                        id: Date.now() + Math.random(),
                                        name: fileName,
                                        originalPath: cleanPath,
                                        size: content.length,
                                        content: isText ? content : btoa(content),
                                        encoding: isText ? 'utf-8' : 'base64',
                                        isText,
                                        suggestedApp,
                                        appDetection,
                                        version,
                                        versionSource: version ? 'extracted' : 'none',
                                        versionValidation,
                                        fileAction,
                                        targetPath: fileAction === 'push-doc' ? docTargetPath : targetPath
                                    }]);
                                })
                            );
                        });
                        
                        await Promise.all(extractPromises);
                        console.log('=== ZIP EXTRACTED ===');
                        console.log('Primary app:', primaryApp, 'v' + primaryVersion);
                        
                        // Assign primaryApp to doc files that don't have a detected app
                        if (primaryApp) {
                            setStagedFiles(currentFiles => 
                                currentFiles.map(f => {
                                    if (f.fileAction === 'push-doc' && !f.suggestedApp) {
                                        // Also recompute the doc target path now that we know the app
                                        const docApp = apps[primaryApp];
                                        const docsPath = docApp ? getDocsPath(docApp) : '';
                                        const docTargetPath = docsPath ? `${docsPath}/${f.name}` : f.name;
                                        return { ...f, suggestedApp: primaryApp, targetPath: docTargetPath };
                                    }
                                    return f;
                                })
                            );
                        }
                        
                        // Post-extraction validation is now handled by the unified
                        // validatePackage() panel in DashboardView (selection-driven)
                        
                        
                    } catch (err) {
                        console.error('[SmartDeploy] ZIP extraction failed:', err);
                        showAlert('Failed to extract ZIP: ' + err.message, 'ZIP Error');
                    }
                    return;
                }
                
                // Handle regular files
                console.log(`[SmartDeploy] Single file drop: ${file.name}`);
                const reader = new FileReader();
                reader.onload = (e) => {
                    const content = e.target.result;
                    const isText = file.type.startsWith('text/') || 
                        /\.(html|js|css|json|md|txt|xml|svg|yml|yaml)$/i.test(file.name);
                    
                    const parsed = parseFilename(file.name);
                    let version = null;
                    let versionSource = 'none';
                    let versionValidation = null;
                    
                    // App detection: try content first, fall back to filename
                    let suggestedApp = null;
                    let appDetection = null;
                    
                    if (file.name.endsWith('.html') && isText) {
                        // Try content-based detection
                        appDetection = detectAppFromContent(content);
                        
                        if (appDetection) {
                            suggestedApp = appDetection.id;
                            console.log('=== APP DETECTED FROM CONTENT ===');
                            console.log('Detected:', appDetection.id);
                            console.log('Confidence:', appDetection.confidence);
                            console.log('Matches:', appDetection.matchCount);
                        } else {
                            // Fall back to filename
                            suggestedApp = parsed.app;
                            console.log('=== APP FROM FILENAME ===');
                            console.log('Parsed:', parsed.app);
                        }
                        
                        const htmlVersion = extractVersionFromHTML(content);
                        version = htmlVersion || parsed.version;
                        versionSource = htmlVersion ? 'html' : (parsed.version ? 'filename' : 'none');
                        
                        // Full version validation
                        versionValidation = validateVersions(content, file.name);
                        
                        console.log('=== VERSION VALIDATION ===');
                        console.log('File:', file.name);
                        console.log('Primary version:', versionValidation.primary);
                        console.log('All versions found:', versionValidation.allVersions);
                        console.log('Unique versions:', versionValidation.uniqueVersions);
                        console.log('Is valid:', versionValidation.isValid);
                        if (!versionValidation.isValid) {
                            console.warn('⚠️ VERSION ISSUES:', {
                                mismatches: versionValidation.mismatches,
                                missing: versionValidation.missing
                            });
                        }
                    } else if (file.name.endsWith('.js') && isText) {
                        // Check if this is Firebase Functions code
                        appDetection = detectAppFromContent(content);
                        if (appDetection) {
                            suggestedApp = appDetection.id;
                            console.log('=== JS FILE APP DETECTED ===');
                            console.log('Detected:', appDetection.id);
                            console.log('Confidence:', appDetection.confidence);
                        } else {
                            suggestedApp = parsed.app;
                        }
                    } else if ((file.name.endsWith('.yml') || file.name.endsWith('.yaml')) && isText) {
                        // Check if this is a Firebase/GitHub Actions workflow
                        if (/firebase-action|FIREBASE_TOKEN|deploy.*functions/i.test(content)) {
                            suggestedApp = 'firebase-functions';
                            appDetection = {
                                id: 'firebase-functions',
                                confidence: 'high',
                                method: 'workflow-pattern',
                                matchCount: 1,
                                matchedPatterns: ['GitHub Actions Firebase workflow']
                            };
                            console.log('=== YML FILE DETECTED AS FIREBASE WORKFLOW ===');
                        } else {
                            suggestedApp = parsed.app;
                        }
                    } else {
                        suggestedApp = parsed.app;
                    }
                    
                    console.log('=== FILE UPLOADED ===');
                    console.log('Name:', file.name);
                    console.log('Size:', file.size);
                    console.log('Version:', version);
                    console.log('Suggested App:', suggestedApp, appDetection ? '(from content)' : '(from filename)');
                    
                    // Clean up Claude download filenames (e.g., index_4.js → index.js)
                    let cleanedName = file.name;
                    const claudeDownloadPattern = /^(.+?)_\d+(\.[a-z]+)$/i;
                    const claudeMatch = file.name.match(claudeDownloadPattern);
                    if (claudeMatch) {
                        cleanedName = claudeMatch[1] + claudeMatch[2];
                        console.log('Cleaned filename:', file.name, '→', cleanedName);
                    }
                    // Detect CLAUDE.md regardless of upload filename (e.g., Claude-2.md)
                    cleanedName = detectClaudeMd(cleanedName, isText ? content : null);

                    // v8.66.0: Four-path inbound artifact detection
                    if (isText) {
                        const artifactType = detectInboundArtifactType(content);
                        const hasOdrcSection = extractODRCSection(content);

                        if (artifactType === 'session-json') {
                            console.log('[CC] session.json detected in single file:', file.name);
                            try {
                                const sessionData = JSON.parse(content);
                                const validation = SessionPackageProcessor.validate(sessionData);
                                if (validation.errors.length === 0) {
                                    const metadata = SessionPackageProcessor.extractMetadata(sessionData);
                                    const parsed = SessionPackageProcessor.toIngestionUpdates(sessionData);
                                    if (parsed.length > 0) {
                                        setPendingOdrcImport({
                                            fileName: cleanedName,
                                            fullContent: content,
                                            odrcSection: null,
                                            metadata,
                                            parsedUpdates: parsed,
                                            sourceApp: suggestedApp,
                                            artifactType: 'session-json',
                                            sessionData
                                        });
                                    }
                                    if (validation.warnings.length > 0) {
                                        console.warn('[CC] session.json warnings:', validation.warnings);
                                    }
                                } else {
                                    console.error('[CC] session.json validation failed:', validation.errors);
                                }
                            } catch (e) {
                                console.error('[CC] session.json parse error:', e.message);
                            }
                        } else if (artifactType === 'odrc') {
                            // Pure ODRC file — existing flow
                            console.log('[CC] ODRC content detected in single file:', file.name);
                            const metadata = extractODRCMetadata(content);
                            const odrcSection = hasOdrcSection || content;
                            const parsed = ODRCUpdateIngestionService.parse(odrcSection);
                            if (parsed.length > 0) {
                                setPendingOdrcImport({
                                    fileName: cleanedName,
                                    fullContent: content,
                                    odrcSection,
                                    metadata,
                                    parsedUpdates: parsed,
                                    sourceApp: suggestedApp
                                });
                            }
                        } else if (artifactType === 'spec' || artifactType === 'claude-md') {
                            // Spec or CLAUDE.md artifact — may also contain ODRC updates
                            console.log(`[CC] ${artifactType} artifact detected in single file:`, file.name);
                            const metadata = extractODRCMetadata(content);

                            // If it also has ODRC updates, extract and show checklist
                            if (hasOdrcSection) {
                                const parsed = ODRCUpdateIngestionService.parse(hasOdrcSection);
                                if (parsed.length > 0) {
                                    setPendingOdrcImport({
                                        fileName: cleanedName,
                                        fullContent: content,
                                        odrcSection: hasOdrcSection,
                                        metadata,
                                        parsedUpdates: parsed,
                                        sourceApp: suggestedApp,
                                        artifactType // spec or claude-md — tells modal to also push the doc
                                    });
                                }
                            }

                            // Notify about the artifact
                            if (typeof addNotification === 'function') {
                                const typeLabel = artifactType === 'claude-md' ? 'CLAUDE.md' : 'Spec document';
                                addNotification({
                                    icon: artifactType === 'claude-md' ? '📄' : '📋',
                                    title: `${typeLabel} detected`,
                                    message: `${file.name} — will be staged for deploy`,
                                    action: null
                                });
                            }
                        }
                    }

                    // Determine targetPath: use app-specific path if detected, else default logic
                    let targetPath;
                    if (suggestedApp === 'firebase-functions' && (cleanedName.endsWith('.yml') || cleanedName.endsWith('.yaml'))) {
                        // Workflow files go to .github/workflows/
                        targetPath = '.github/workflows/deploy.yml';
                    } else if (suggestedApp && apps[suggestedApp]) {
                        targetPath = apps[suggestedApp].targetPath || 'index.html';
                    } else if (file.name.endsWith('.html')) {
                        targetPath = 'index.html';
                    } else {
                        targetPath = cleanedName;
                    }
                    
                    const fileAction = classifyFileAction(cleanedName);
                    if (fileAction === 'skip') {
                        // Phase B: Capture SESSION_RETURN.json before skipping
                        if (cleanedName === 'SESSION_RETURN.json' && isText) {
                            console.log('[SESSION_RETURN] Found as single file drop, capturing for auto-review');
                            const validation = validateSessionReturn(content);
                            if (validation.valid) {
                                setPendingSessionReturn({
                                    data: validation.data,
                                    warnings: validation.warnings,
                                    sourceApp: suggestedApp,
                                    raw: content
                                });
                            } else {
                                console.warn('[SESSION_RETURN] Validation failed:', validation.errors);
                                showAlert(
                                    `SESSION_RETURN.json has errors:\n\n${validation.errors.join('\n')}\n\nFalling back to manual review.`,
                                    '⚠️ Return Manifest Invalid'
                                );
                            }
                        }
                        return;
                    }
                    
                    // For push-doc files, compute repo target path
                    let finalTargetPath = targetPath;
                    if (fileAction === 'push-doc' && suggestedApp) {
                        const docApp = apps[suggestedApp];
                        if (docApp) {
                            const docsPath = getDocsPath(docApp);
                            finalTargetPath = docsPath ? `${docsPath}/${cleanedName}` : cleanedName;
                        }
                    }
                    
                    setStagedFiles(prev => [...prev, {
                        id: Date.now() + Math.random(),
                        name: cleanedName,
                        originalName: file.name !== cleanedName ? file.name : undefined,
                        size: file.size,
                        content: isText ? content : btoa(content),
                        encoding: isText ? 'utf-8' : 'base64',
                        isText,
                        suggestedApp,
                        appDetection, // Store detection details
                        version,
                        versionSource,
                        versionValidation,
                        fileAction,
                        targetPath: finalTargetPath
                    }]);
                };
                
                if (file.type.startsWith('text/') || /\.(html|js|css|json|md|txt|xml|svg|yml|yaml)$/i.test(file.name)) {
                    reader.readAsText(file);
                } else {
                    reader.readAsBinaryString(file);
                }
            });
        };
        
        const removeStaged = (id) => setStagedFiles(prev => prev.filter(f => f.id !== id));
        const updateStagedFile = (id, updates) => setStagedFiles(prev => prev.map(f => f.id === id ? { ...f, ...updates } : f));
        
        // Get current deployed version from repo
        const fetchCurrentVersion = async (repo, targetPath) => {
            if (!github || !repo) return null;
            const fileData = await github.getFileContent(repo, targetPath);
            if (!fileData) return null;
            // Use textContent which handles both normal and large files
            return extractVersionFromHTML(fileData.textContent);
        };
        
        // Deploy single file (legacy support)
        const handleDeploy = async (file, appId, target, forceDeploy = false) => {
            if (!github) { await showAlert('Configure GitHub token', 'Configuration Required'); return; }
            
            const app = apps[appId];
            if (!app) {
                console.error(`[Deploy] App not found: "${appId}". Available:`, Object.keys(apps));
                await showAlert(`App "${appId}" not found in configuration`, 'Deploy Error');
                return;
            }
            // Ensure subPath is set from defaults (localStorage may have empty string from old config)
            const effectiveSubPath = app.subPath || '';
            const appWithSubPath = { ...app, subPath: effectiveSubPath };
            
            const repo = target === 'prod' ? app.prodRepo : app.testRepo;
            if (!repo) { await showAlert(`Configure ${target} repo`, 'Configuration Required'); return; }
            
            // Get full path including subPath
            const fullTargetPath = getRepoFilePath(appWithSubPath, file.targetPath || app.targetPath);
            
            const newVersion = file.version;
            // Version validation is now handled pre-deploy by the unified validation panel
            
            // 📸 Save rollback snapshot BEFORE deploying
            await saveRollbackSnapshot(appId, target, repo, fullTargetPath);
            
            const deployment = {
                id: Date.now(), status: 'running', steps: [],
                appId, appName: app.name, repo, target,
                version: newVersion || 'unknown',
                previousVersion: currentVersion,
                startedAt: new Date().toISOString(),
                fileContent: file.content
            };
            
            setActiveDeployment(deployment);
            setDeployments(prev => [deployment, ...prev]);
            
            const addStep = (name, status, details = null) => {
                const existingIndex = deployment.steps.findIndex(s => s.name === name);
                if (existingIndex >= 0) {
                    deployment.steps[existingIndex] = { name, status, details };
                } else {
                    deployment.steps.push({ name, status, details });
                }
                setActiveDeployment({ ...deployment });
            };
            
            try {
                addStep('Validating', 'running');
                addStep('Validating', 'complete', `${formatVersion(newVersion)} (${formatBytes(file.size)})`);
                
                addStep('Safety Check', 'running');
                if (currentVersion) {
                    if (isNewerVersion(newVersion, currentVersion)) {
                        addStep('Safety Check', 'complete', `${formatVersion(currentVersion)} → ${formatVersion(newVersion)} ✓`);
                    } else {
                        addStep('Safety Check', 'warning', `Force deploy: ${formatVersion(currentVersion)} → ${formatVersion(newVersion)}`);
                    }
                } else {
                    addStep('Safety Check', 'complete', 'First deploy');
                }
                
                addStep('Committing', 'running');
                deployment.preCommitTime = Date.now(); // Capture time before commit for workflow search
                const currentFile = await github.getFile(repo, fullTargetPath);
                const result = await github.createOrUpdateFile(
                    repo, fullTargetPath, file.content,
                    `Deploy ${app.name} ${formatVersion(newVersion)}${currentVersion ? ` (was ${formatVersion(currentVersion)})` : ''}`,
                    currentFile?.sha
                );
                deployment.commitSha = result.commit.sha;
                addStep('Committing', 'complete', result.commit.sha.substring(0, 7));
                
                addStep('GitHub Pages', 'running');
                try {
                    const pagesResult = await github.enablePages(repo);
                    addStep('GitHub Pages', 'complete', pagesResult.alreadyEnabled ? 'Ready' : 'Enabled!');
                } catch (e) {
                    addStep('GitHub Pages', 'warning', e.message);
                }
                
                if (settings.createTag && newVersion) {
                    addStep('Tagging', 'running');
                    try {
                        const tag = target === 'prod' ? `v${newVersion}` : `v${newVersion}-test`;
                        await github.createTag(repo, tag, result.commit.sha, `Release ${newVersion}`);
                        addStep('Tagging', 'complete', tag);
                    } catch {
                        addStep('Tagging', 'warning', 'Tag may exist');
                    }
                }
                
                deployment.status = 'success';
                deployment.url = getGitHubPagesUrl(repo, effectiveSubPath);
                updateApp(appId, { [target === 'prod' ? 'currentProdVersion' : 'currentTestVersion']: newVersion, updatedAt: Date.now() });
                removeStaged(file.id);
                
                // Check for open issues that can be linked to this deploy
                const openIssues = globalIssues.filter(i => 
                    i.app === appId && 
                    (i.status === 'open' || i.status === 'in-progress')
                );
                
                if (openIssues.length > 0 && target === 'test') {
                    // Show issue linking modal after a short delay
                    setTimeout(async () => {
                        const issueList = openIssues.map(i => `${i.id}: ${i.title}`).join('\n');
                        const result = await showPrompt(
                            `This deploy may fix these issues:\n\n${issueList}\n\nEnter issue IDs to link (comma-separated), or leave blank:`,
                            '',
                            '🔗 Link Issues to v' + newVersion
                        );
                        
                        if (result && result.trim()) {
                            const issueIds = result.split(',').map(s => s.trim().toUpperCase());
                            const validIds = issueIds.filter(id => openIssues.some(i => i.id === id));
                            if (validIds.length > 0) {
                                await linkIssuesToVersion(validIds, newVersion, appId);
                            }
                        }
                    }, 500);
                }
                
                // === Phase 2.3: Work Item Completion Dialog ===
                // After successful deploy, check for in-progress and review work items for this app
                if (firebaseUid) {
                    const inProgressItems = WorkItemService.getInProgress(globalWorkItems, appId);
                    const inReviewItems = WorkItemService.getInReview(globalWorkItems, appId);
                    const completableItems = [...inProgressItems, ...inReviewItems];
                    
                    if (completableItems.length > 0) {
                        // Show completion dialog after a delay (after issue linking if any)
                        const wiDelay = openIssues.length > 0 ? 1500 : 500;
                        setTimeout(async () => {
                            const itemList = completableItems.map(wi => `${wi.id}: ${wi.title} (${wi.status})`).join('\n');
                            const confirmed = await showConfirm(
                                `This deploy (v${newVersion}) may complete these work items:\n\n${itemList}\n\nMark ${completableItems.length === 1 ? 'it' : 'them'} as done?`,
                                `✅ Complete Work Items — ${app.name}`
                            );
                            
                            if (confirmed) {
                                for (const wi of completableItems) {
                                    await WorkItemService.complete(firebaseUid, wi.id, newVersion);
                                }
                                console.log(`[Deploy] Completed ${completableItems.length} work items for ${appId} v${newVersion}`);
                            }
                        }, wiDelay);
                    }
                    
                    // === Phase 2.3: Link Deploy to Active Session ===
                    // Find the most recent active (prep status) session for this app and link it
                    const activeSessions = SessionService.getActive(globalSessions, appId);
                    if (activeSessions.length > 0) {
                        const latestSession = activeSessions[0]; // Most recent prep session
                        const deployId = `deploy-${deployment.id}`;
                        await SessionService.linkDeploy(firebaseUid, latestSession.id, deployId);
                        
                        // Enrich deployment record with session + work item data
                        deployment.sessionId = latestSession.id;
                        deployment.sessionType = latestSession.type;
                        deployment.workItemsCompleted = completableItems.map(wi => wi.id);
                        
                        console.log(`[Deploy] Linked to session ${latestSession.id} (${latestSession.type})`);
                    }
                    
                    // === Phase 3.4: Activity Logging ===
                    const actor = config?.ownerName || 'Owner';
                    ActivityLogService.logDeploy(firebaseUid, actor, app.name, newVersion, targetEnv, activeSessions[0]?.id || null).catch(e => console.warn('[Activity] Log failed:', e));
                }
                
                // Start monitoring for deployment completion
                if (app?.deployType === 'github-actions') {
                    // For github-actions apps (Firebase Functions), monitor the workflow
                    addStep('GitHub Actions', 'running', 'Finding workflow...');
                    const searchTime = (deployment.preCommitTime || Date.now()) - 10000;
                    
                    const workflowRun = await github.findRecentWorkflowRun(repo, searchTime, 60000);
                    
                    if (workflowRun) {
                        const logsUrl = await github.getWorkflowRunLogsUrl(repo, workflowRun.id);
                        addStep('GitHub Actions', 'running', `Workflow #${workflowRun.run_number} running...`);
                        deployment.workflowUrl = logsUrl;
                        setActiveDeployment({ ...deployment });
                        
                        const monitorStartTime = Date.now();
                        const result = await github.waitForWorkflowRun(repo, workflowRun.id, 300000, (run) => {
                            addStep('GitHub Actions', 'running', `${run.status}... (${Math.round((Date.now() - monitorStartTime) / 1000)}s)`);
                            setActiveDeployment({ ...deployment });
                            setDeployments(prev => prev.map(d => d.id === deployment.id ? { ...deployment } : d));
                        });
                        
                        if (result.success) {
                            addStep('GitHub Actions', 'complete', `✓ Deployed! (${result.run?.conclusion})`);
                        } else {
                            addStep('GitHub Actions', 'error', `Failed: ${result.conclusion || result.error}`);
                            deployment.status = 'failed';
                            deployment.error = result.conclusion || result.error;
                            if (result.logsUrl) {
                                deployment.workflowUrl = result.logsUrl;
                            }
                        }
                    } else {
                        addStep('GitHub Actions', 'warning', 'Workflow not found - check GitHub manually');
                        deployment.workflowUrl = `https://github.com/${repo}/actions`;
                        deployment.status = 'success'; // Code committed successfully, just couldn't track workflow
                    }
                } else if (deployment.url && newVersion) {
                    // For regular apps, monitor the live site
                    addStep('GitHub Pages', 'running', 'Waiting for deploy...');
                    monitorLiveDeployment(deployment.url, newVersion, repo, (status, detail) => {
                        addStep('GitHub Pages', status, detail);
                        setActiveDeployment({ ...deployment });
                        setDeployments(prev => prev.map(d => d.id === deployment.id ? { ...deployment } : d));
                    }, appId, target);
                }
                
            } catch (error) {
                deployment.status = 'failed';
                deployment.error = error.message;
                addStep('Error', 'error', error.message);
            }
            
            deployment.completedAt = new Date().toISOString();
            setActiveDeployment({ ...deployment });
            setDeployments(prev => prev.map(d => d.id === deployment.id ? deployment : d));
        };
        
        // Multi-file batch deploy
        const handleBatchDeploy = async (files, appId, target) => {
            if (!github) {
                await showAlert('Configure GitHub token first', 'Configuration Required');
                return;
            }
            if (files.length === 0) return;
            
            const app = apps[appId];
            if (!app) {
                console.error(`[BatchDeploy] App not found: "${appId}". Available:`, Object.keys(apps));
                await showAlert(`App "${appId}" not found in configuration`, 'Deploy Error');
                return;
            }
            const appWithDefaults = {
                ...app,
                subPath: app.subPath || ''
            };
            const repo = target === 'prod' ? appWithDefaults.prodRepo : appWithDefaults.testRepo;
            if (!repo) {
                await showAlert(`Configure ${target} repo first`, 'Configuration Required');
                return;
            }
            
            // Find version from index.html if present
            const indexFile = files.find(f => f.targetPath === 'index.html' || f.name === 'index.html');
            const newVersion = indexFile?.version || 'batch';
            
            // Version validation is now handled pre-deploy by the unified validation panel
            
            // Log file details for debugging
            console.log('handleBatchDeploy received:', files.map(f => ({
                name: f.name,
                id: f.id,
                targetPath: f.targetPath,
                version: f.version,
                validationOk: f.versionValidation?.isValid,
                contentLength: f.content?.length
            })));
            console.log('App subPath:', appWithDefaults.subPath);
            
            // 📸 Save rollback snapshot BEFORE deploying
            const fullTargetPath = getRepoFilePath(appWithDefaults, appWithDefaults.targetPath);
            await saveRollbackSnapshot(appId, target, repo, fullTargetPath);
            
            const deployment = {
                id: Date.now(), status: 'running', steps: [],
                appId, appName: appWithDefaults.name, repo, target,
                version: newVersion,
                startedAt: new Date().toISOString(),
                fileCount: files.length
            };
            
            setActiveDeployment(deployment);
            setDeployments(prev => [deployment, ...prev]);
            
            // v8.5.0: Set deploying indicator using appId:target key to avoid shared repo conflicts
            const deployKey = `${appId}:${target}`;
            setDeployingRepos(prev => ({ ...prev, [deployKey]: { version: newVersion, startTime: Date.now(), repo } }));
            
            const addStep = (name, status, details = null) => {
                const existingIndex = deployment.steps.findIndex(s => s.name === name);
                if (existingIndex >= 0) {
                    deployment.steps[existingIndex] = { name, status, details };
                } else {
                    deployment.steps.push({ name, status, details });
                }
                setActiveDeployment({ ...deployment });
            };
            
            try {
                addStep('Preparing batch', 'running');
                addStep('Preparing batch', 'complete', `${files.length} files`);
                
                addStep('Creating commit', 'running');
                // Prepend subPath to all file paths if needed
                // Files with fullRepoPath=true already have the complete repo path (from Smart Deploy multi-app)
                const filesToCommit = files.map(f => ({
                    path: f.fullRepoPath ? (f.targetPath || f.name) : getRepoFilePath(appWithDefaults, f.targetPath || f.name),
                    content: f.content,
                    encoding: f.encoding
                }));
                console.log('Files to commit with paths:', filesToCommit.map(f => f.path));
                
                // Check if any file has a subdirectory that might not exist
                // Use batch commit (Git Data API) for these cases since it auto-creates directories
                const hasSubdirectories = filesToCommit.some(f => f.path.includes('/'));
                
                let result;
                // Use Git Data API (batchCommit) for:
                // 1. Multiple files
                // 2. Files with subdirectories (to auto-create directories)
                // Use Contents API only for single files at repo root (more reliable for simple cases)
                if (filesToCommit.length === 1 && !hasSubdirectories) {
                    const file = filesToCommit[0];
                    console.log('Single file at root, using Contents API for:', file.path);
                    
                    // Get current file SHA if it exists (needed for update)
                    let existingSha = null;
                    try {
                        const existingFile = await github.getFile(repo, file.path);
                        if (existingFile) {
                            existingSha = existingFile.sha;
                            console.log('Existing file SHA:', existingSha);
                        }
                    } catch (e) {
                        console.log('File does not exist yet, will create');
                    }
                    
                    // Decode content if it's base64 encoded, otherwise use as-is
                    let contentToSend = file.content;
                    if (file.encoding === 'base64') {
                        // Content is already base64, need to decode for createOrUpdateFile which re-encodes
                        try {
                            contentToSend = decodeURIComponent(escape(atob(file.content)));
                        } catch (e) {
                            console.log('Content is binary base64, using raw');
                            contentToSend = atob(file.content);
                        }
                    }
                    
                    // Capture time BEFORE commit for GitHub Actions workflow detection
                    deployment.preCommitTime = Date.now();
                    
                    result = await github.createOrUpdateFile(
                        repo,
                        file.path,
                        contentToSend,
                        `Deploy ${appWithDefaults.name} ${formatVersion(newVersion)} (${files.length} files)`,
                        existingSha
                    );
                    result.sha = result.commit.sha;
                } else {
                    // Multiple files OR files with subdirectories - use batch commit (Git Data API)
                    // Git Data API auto-creates directories, which is essential for new subdirectories
                    console.log(`Using Git Data API (batchCommit) - files: ${filesToCommit.length}, hasSubdirs: ${hasSubdirectories}`);
                    
                    // Capture time BEFORE commit for GitHub Actions workflow detection
                    deployment.preCommitTime = Date.now();
                    
                    result = await github.batchCommit(
                        repo,
                        filesToCommit,
                        `Deploy ${appWithDefaults.name} ${formatVersion(newVersion)} (${files.length} files)`
                    );
                }
                deployment.commitSha = result.sha;
                addStep('Creating commit', 'complete', result.sha.substring(0, 7));
                
                // Skip GitHub Pages for GitHub Actions deploys (Firebase Functions doesn't use Pages)
                if (appWithDefaults.deployType !== 'github-actions') {
                    addStep('GitHub Pages', 'running');
                    try {
                        await github.enablePages(repo);
                        addStep('GitHub Pages', 'complete', 'Ready');
                    } catch (e) {
                        addStep('GitHub Pages', 'warning', e.message);
                    }
                }
                
                if (settings.createTag && newVersion !== 'batch') {
                    addStep('Tagging', 'running');
                    try {
                        const tag = target === 'prod' ? `v${newVersion}` : `v${newVersion}-test`;
                        await github.createTag(repo, tag, result.sha, `Release ${newVersion}`);
                        addStep('Tagging', 'complete', tag);
                    } catch {
                        addStep('Tagging', 'warning', 'Tag may exist');
                    }
                }
                
                // For GitHub Actions deploys, don't set success yet - wait for workflow
                if (appWithDefaults.deployType !== 'github-actions') {
                    deployment.status = 'success';
                }
                deployment.url = getGitHubPagesUrl(repo, appWithDefaults.subPath);
                
                // Verify the deployment by fetching back from repo
                console.log('=== VERIFYING DEPLOYMENT ===');
                await new Promise(r => setTimeout(r, 1000)); // Wait a bit for GitHub to process
                
                // Always verify index.html (not binary files like PNGs)
                try {
                    const verifyFileData = await github.getFileContent(repo, fullTargetPath);
                    if (verifyFileData) {
                        // Use textContent which handles both normal and large files
                        const verifyContent = verifyFileData.textContent;
                        const verifyVersion = extractVersionFromHTML(verifyContent);
                        console.log('Verification - version in repo after deploy:', verifyVersion);
                        console.log('Verification - expected version:', newVersion);
                        if (verifyVersion !== newVersion && newVersion !== 'batch') {
                            console.warn('VERSION MISMATCH! Deploy may have failed.');
                            addStep('Verification', 'warning', `Expected ${newVersion}, found ${verifyVersion}`);
                        } else {
                            addStep('Verification', 'complete', `Confirmed ${verifyVersion || 'batch'} in repo`);
                        }
                    }
                } catch (verifyError) {
                    console.warn('Verification skipped:', verifyError.message);
                    addStep('Verification', 'warning', 'Could not verify (deploy likely succeeded)');
                }
                
                if (newVersion !== 'batch') {
                    updateApp(appId, { [target === 'prod' ? 'currentProdVersion' : 'currentTestVersion']: newVersion, updatedAt: Date.now() });
                }
                
                // Don't refresh immediately - GitHub's CDN needs time to propagate
                // The local state is already updated, and verification confirmed the deploy
                // Refresh will happen on next manual refresh or page load
                // setTimeout(() => refreshAllVersions(), 500); // DISABLED - causes version revert due to GitHub caching
                
                // v8.5.0: For GitHub Actions deploys (Firebase Functions), monitor workflow instead of live site
                if (app.deployType === 'github-actions') {
                    addStep('GitHub Actions', 'running', 'Finding workflow...');
                    // Use preCommitTime captured before the commit, with extra buffer
                    const searchTime = (deployment.preCommitTime || Date.now()) - 10000; // 10 second buffer before commit
                    
                    // Find the workflow run triggered by our commit (wait up to 60 seconds for it to appear)
                    const workflowRun = await github.findRecentWorkflowRun(repo, searchTime, 60000);
                    
                    if (workflowRun) {
                        const logsUrl = await github.getWorkflowRunLogsUrl(repo, workflowRun.id);
                        addStep('GitHub Actions', 'running', `Workflow #${workflowRun.run_number} running...`);
                        deployment.workflowUrl = logsUrl;
                        setActiveDeployment({ ...deployment });
                        
                        // Monitor the workflow
                        const monitorStartTime = Date.now();
                        const result = await github.waitForWorkflowRun(repo, workflowRun.id, 300000, (run) => {
                            addStep('GitHub Actions', 'running', `${run.status}... (${Math.round((Date.now() - monitorStartTime) / 1000)}s)`);
                            setActiveDeployment({ ...deployment });
                            setDeployments(prev => prev.map(d => d.id === deployment.id ? { ...deployment } : d));
                        });
                        
                        if (result.success) {
                            addStep('GitHub Actions', 'complete', `✓ Deployed! (${result.run?.conclusion})`);
                            deployment.status = 'success';
                        } else {
                            addStep('GitHub Actions', 'error', `Failed: ${result.conclusion || result.error}`);
                            deployment.status = 'failed';
                            deployment.error = result.conclusion || result.error;
                            // Show link to logs
                            if (result.logsUrl) {
                                deployment.workflowUrl = result.logsUrl;
                            }
                        }
                    } else {
                        addStep('GitHub Actions', 'warning', 'Workflow not found - check GitHub manually');
                        deployment.workflowUrl = `https://github.com/${repo}/actions`;
                    }
                }
                // Start monitoring live site for deployment completion (non-Actions deploys)
                else if (deployment.url && newVersion !== 'batch') {
                    addStep('GitHub Pages', 'running', 'Waiting for deploy...');
                    monitorLiveDeployment(deployment.url, newVersion, repo, (status, detail) => {
                        addStep('GitHub Pages', status, detail);
                        setActiveDeployment({ ...deployment });
                        setDeployments(prev => prev.map(d => d.id === deployment.id ? { ...deployment } : d));
                    }, appId, target);
                }
                
                // Remove deployed files from staged
                files.forEach(f => removeStaged(f.id));
                
            } catch (error) {
                deployment.status = 'failed';
                deployment.error = error.message;
                addStep('Error', 'error', error.message);
                console.error('Batch deployment failed:', error);
                
                // v8.3.3: Clear deploying indicator on failure
                const deployKey = `${appId}:${target}`;
                setDeployingRepos(prev => {
                    const next = { ...prev };
                    delete next[deployKey];
                    return next;
                });
                
                // Check for workflow file permission issue
                let errorMessage = error.message;
                if (error.message.includes('Not Found') && filesToCommit.some(f => f.path.includes('.github/workflows'))) {
                    errorMessage = 'Cannot update workflow files. Your GitHub token needs the "workflow" scope.\n\n' +
                        'To fix:\n' +
                        '1. Go to GitHub → Settings → Developer settings → Personal access tokens\n' +
                        '2. Edit your token and add the "workflow" scope\n' +
                        '3. Update the token in Command Center settings';
                }
                
                await showAlert(errorMessage, 'Deployment Error');
            }
            
            deployment.completedAt = new Date().toISOString();
            setActiveDeployment({ ...deployment });
            setDeployments(prev => prev.map(d => d.id === deployment.id ? deployment : d));
        };
        
        const handlePromote = async (appId) => {
            const app = apps[appId];
            
            // Check for required repos - don't fail silently!
            if (!app) {
                await showAlert(`App "${appId}" not found`, 'Promote Error');
                return;
            }
            
            // Ensure subPath is set from defaults (localStorage may have empty string from old config)
            const effectiveSubPath = app.subPath || '';
            const appWithSubPath = { ...app, subPath: effectiveSubPath };
            
            if (!app.testRepo) {
                await showAlert(`No TEST repo configured for ${app.name}. Assign a test repo first.`, 'Promote Error');
                return;
            }
            if (!app.prodRepo) {
                await showAlert(`No PROD repo configured for ${app.name}. Assign a production repo first.`, 'Promote Error');
                return;
            }
            
            console.log(`[Promote] Starting promotion for ${appId}`);
            console.log(`[Promote] TEST repo: ${app.testRepo}`);
            console.log(`[Promote] PROD repo: ${app.prodRepo}`);
            console.log(`[Promote] subPath: ${effectiveSubPath || '(root)'}`);
            
            setModal(null);
            
            const deployment = {
                id: Date.now(), status: 'running', steps: [],
                appId, appName: app.name, repo: app.prodRepo, target: 'prod',
                isPromotion: true, version: app.currentTestVersion,
                startedAt: new Date().toISOString()
            };
            
            setActiveDeployment(deployment);
            setDeployments(prev => [deployment, ...prev]);
            
            const addStep = (name, status, details = null) => {
                const existingIndex = deployment.steps.findIndex(s => s.name === name);
                if (existingIndex >= 0) {
                    deployment.steps[existingIndex] = { name, status, details };
                } else {
                    deployment.steps.push({ name, status, details });
                }
                setActiveDeployment({ ...deployment });
            };
            
            try {
                // Determine which files to promote
                // For PWA apps: index.html, sw.js, manifest.json, icons/*
                // For regular apps: just the targetPath (index.html)
                const baseFilesToPromote = [app.targetPath];
                if (app.hasServiceWorker && app.swPath) {
                    baseFilesToPromote.push(app.swPath);
                }
                // Always check for manifest.json for PWA apps
                if (app.hasServiceWorker) {
                    baseFilesToPromote.push('manifest.json');
                }
                
                // Convert to full paths with subPath
                const filesToPromote = baseFilesToPromote.map(f => getRepoFilePath(appWithSubPath, f));
                
                // For PWA apps, also check for icons folder
                let iconFiles = [];
                if (app.hasServiceWorker) {
                    try {
                        const iconsPath = getRepoFilePath(appWithSubPath, 'icons');
                        const iconsContents = await github.listRepoContents(app.testRepo, iconsPath);
                        iconFiles = iconsContents
                            .filter(f => f.type === 'file' && /\.(png|ico|svg|webp)$/i.test(f.name))
                            .map(f => getRepoFilePath(appWithSubPath, `icons/${f.name}`));
                        console.log(`Found ${iconFiles.length} icon files in TEST at ${iconsPath}`);
                    } catch (e) {
                        console.log('No icons folder found in TEST');
                    }
                }
                
                addStep('Fetching from TEST', 'running', `${filesToPromote.length + iconFiles.length} files`);
                
                const filesToCommit = [];
                let testVersion = null;
                
                // Fetch main PWA files
                const fullTargetPath = getRepoFilePath(appWithSubPath, app.targetPath);
                for (const filePath of filesToPromote) {
                    try {
                        const testFile = await github.getFile(app.testRepo, filePath);
                        if (testFile) {
                            let base64Content;
                            let decodedContent = null;
                            
                            // Handle large files (>1MB) - GitHub doesn't return content in contents API
                            // Use Git Blob API instead of download_url to bypass CDN caching
                            if (!testFile.content && testFile.sha) {
                                console.log(`📦 Large file detected: ${filePath}, using Git Blob API (SHA: ${testFile.sha})`);
                                const blob = await github.getBlobContent(app.testRepo, testFile.sha);
                                if (blob && blob.content) {
                                    base64Content = github.cleanBase64(blob.content);
                                    decodedContent = github.decodeContent(blob.content);
                                    console.log(`✓ Fetched ${filePath} via Blob API (${blob.size} bytes)`);
                                } else {
                                    // Fallback to download_url if blob API fails
                                    console.log(`⚠ Blob API failed, falling back to download_url`);
                                    if (testFile.download_url) {
                                        const cacheBustUrl = testFile.download_url + (testFile.download_url.includes('?') ? '&' : '?') + '_=' + Date.now();
                                        const response = await fetch(cacheBustUrl);
                                        const textContent = await response.text();
                                        base64Content = btoa(unescape(encodeURIComponent(textContent)));
                                        decodedContent = textContent;
                                    } else {
                                        console.log(`⚠ ${filePath} has no content, no blob, and no download_url, skipping`);
                                        continue;
                                    }
                                }
                            } else if (testFile.content) {
                                // Normal file - use base64 directly
                                base64Content = github.cleanBase64(testFile.content);
                                decodedContent = github.decodeContent(testFile.content);
                            } else {
                                console.log(`⚠ ${filePath} has no content and no sha, skipping`);
                                continue;
                            }
                            
                            filesToCommit.push({
                                path: filePath,
                                content: base64Content,
                                encoding: 'base64'
                            });
                            
                            // Extract version from main HTML file
                            if (filePath === fullTargetPath && decodedContent) {
                                testVersion = extractVersionFromHTML(decodedContent);
                                deployment.fileContent = decodedContent;
                            }
                            
                            console.log(`✓ Found ${filePath} in TEST (${base64Content.length} bytes base64)`);
                        }
                    } catch (e) {
                        // File doesn't exist in TEST, skip it (manifest.json might not exist)
                        console.log(`⚠ ${filePath} not found in TEST, skipping: ${e.message}`);
                    }
                }
                
                // Fetch icon files (binary - use base64)
                for (const iconPath of iconFiles) {
                    try {
                        const iconFile = await github.getFile(app.testRepo, iconPath);
                        if (iconFile) {
                            // Icons should always have content (they're small)
                            // But check just in case
                            if (!iconFile.content) {
                                console.warn(`⚠ Icon ${iconPath} has no content (too large?), skipping`);
                                continue;
                            }
                            filesToCommit.push({
                                path: iconPath,
                                content: github.cleanBase64(iconFile.content),
                                encoding: 'base64'
                            });
                            console.log(`✓ Found ${iconPath} in TEST`);
                        }
                    } catch (e) {
                        console.log(`⚠ ${iconPath} not found in TEST, skipping`);
                    }
                }
                
                if (filesToCommit.length === 0) {
                    throw new Error('No files found in TEST repo');
                }
                
                addStep('Fetching from TEST', 'complete', `${filesToCommit.length} files, ${formatVersion(testVersion)}`);
                
                addStep('Checking PROD', 'running');
                const prodFileData = await github.getFileContent(app.prodRepo, fullTargetPath);
                const prodVersion = prodFileData ? extractVersionFromHTML(prodFileData.textContent) : null;
                deployment.previousVersion = prodVersion;
                addStep('Checking PROD', 'complete', prodVersion ? formatVersion(prodVersion) : 'Empty');
                
                // 📸 Save rollback snapshot BEFORE promoting
                await saveRollbackSnapshot(appId, 'prod', app.prodRepo, fullTargetPath);
                
                addStep('Deploying', 'running', `${filesToCommit.length} files`);
                
                // Capture time before commit for workflow search
                deployment.preCommitTime = Date.now();
                
                // Use batch commit for multiple files
                const result = await github.batchCommit(
                    app.prodRepo,
                    filesToCommit,
                    `Promote ${app.name} ${formatVersion(testVersion)} from test (${filesToCommit.length} files)`
                );
                
                deployment.commitSha = result.sha;
                deployment.fileCount = filesToCommit.length;
                addStep('Deploying', 'complete', `${result.sha.substring(0, 7)} (${filesToCommit.length} files)`);
                
                addStep('GitHub Pages', 'running');
                try {
                    await github.enablePages(app.prodRepo);
                    addStep('GitHub Pages', 'complete', 'Ready');
                } catch {
                    addStep('GitHub Pages', 'warning', 'Check settings');
                }
                
                if (settings.createTag && testVersion) {
                    addStep('Tagging', 'running');
                    try {
                        await github.createTag(app.prodRepo, `v${testVersion}`, result.sha, 'Release');
                        addStep('Tagging', 'complete', `v${testVersion}`);
                    } catch {
                        addStep('Tagging', 'warning', 'May exist');
                    }
                }
                
                deployment.status = 'success';
                deployment.version = testVersion;
                deployment.url = getGitHubPagesUrl(app.prodRepo, effectiveSubPath);
                updateApp(appId, { currentProdVersion: testVersion, updatedAt: Date.now() });
                
                // Don't refresh immediately - GitHub's CDN needs time to propagate
                // setTimeout(() => refreshAllVersions(), 1000); // DISABLED - causes version revert
                
                // Start monitoring for deployment completion
                if (app?.deployType === 'github-actions') {
                    // For github-actions apps, monitor the workflow
                    addStep('GitHub Actions', 'running', 'Finding workflow...');
                    const searchTime = (deployment.preCommitTime || Date.now()) - 10000;
                    
                    const workflowRun = await github.findRecentWorkflowRun(app.prodRepo, searchTime, 60000);
                    
                    if (workflowRun) {
                        const logsUrl = await github.getWorkflowRunLogsUrl(app.prodRepo, workflowRun.id);
                        addStep('GitHub Actions', 'running', `Workflow #${workflowRun.run_number} running...`);
                        deployment.workflowUrl = logsUrl;
                        setActiveDeployment({ ...deployment });
                        
                        const monitorStartTime = Date.now();
                        const result = await github.waitForWorkflowRun(app.prodRepo, workflowRun.id, 300000, (run) => {
                            addStep('GitHub Actions', 'running', `${run.status}... (${Math.round((Date.now() - monitorStartTime) / 1000)}s)`);
                            setActiveDeployment({ ...deployment });
                            setDeployments(prev => prev.map(d => d.id === deployment.id ? { ...deployment } : d));
                        });
                        
                        if (result.success) {
                            addStep('GitHub Actions', 'complete', `✓ Deployed! (${result.run?.conclusion})`);
                        } else {
                            addStep('GitHub Actions', 'error', `Failed: ${result.conclusion || result.error}`);
                            deployment.status = 'failed';
                            deployment.error = result.conclusion || result.error;
                        }
                    } else {
                        addStep('GitHub Actions', 'warning', 'Workflow not found - check GitHub manually');
                        deployment.workflowUrl = `https://github.com/${app.prodRepo}/actions`;
                        deployment.status = 'success'; // Code committed successfully, just couldn't track workflow
                    }
                } else if (deployment.url && testVersion) {
                    // For regular apps, monitor the live site
                    addStep('GitHub Pages', 'running', 'Waiting for deploy...');
                    monitorLiveDeployment(deployment.url, testVersion, app.prodRepo, (status, detail) => {
                        addStep('GitHub Pages', status, detail);
                        setActiveDeployment({ ...deployment });
                        setDeployments(prev => prev.map(d => d.id === deployment.id ? { ...deployment } : d));
                    }, appId, 'prod');
                }
                
            } catch (error) {
                deployment.status = 'failed';
                deployment.error = error.message;
                addStep('Error', 'error', error.message);
            }
            
            deployment.completedAt = new Date().toISOString();
            setActiveDeployment({ ...deployment });
            setDeployments(prev => prev.map(d => d.id === deployment.id ? deployment : d));
        };
        
        // Rollback
        const handleRollback = async (deploymentToRollbackTo) => {
            const app = apps[deploymentToRollbackTo.appId];
            if (!app) return;
            
            // Ensure subPath is set from defaults (localStorage may have empty string from old config)
            const effectiveSubPath = app.subPath || '';
            const appWithSubPath = { ...app, subPath: effectiveSubPath };
            
            setModal(null);
            
            const repo = deploymentToRollbackTo.repo;
            const targetVersion = deploymentToRollbackTo.version;
            
            const deployment = {
                id: Date.now(), status: 'running', steps: [],
                appId: deploymentToRollbackTo.appId, appName: app.name,
                repo, target: deploymentToRollbackTo.target,
                isRollback: true, version: targetVersion,
                rollbackFromCommit: null,
                rollbackToCommit: deploymentToRollbackTo.commitSha,
                startedAt: new Date().toISOString()
            };
            
            setActiveDeployment(deployment);
            setDeployments(prev => [deployment, ...prev]);
            
            const addStep = (name, status, details = null) => {
                const existingIndex = deployment.steps.findIndex(s => s.name === name);
                if (existingIndex >= 0) {
                    deployment.steps[existingIndex] = { name, status, details };
                } else {
                    deployment.steps.push({ name, status, details });
                }
                setActiveDeployment({ ...deployment });
            };
            
            try {
                // Get full path including subPath
                const fullTargetPath = getRepoFilePath(appWithSubPath, app.targetPath);
                
                addStep('Getting current state', 'running');
                const currentFileData = await github.getFileContent(repo, fullTargetPath);
                // Use textContent which handles both normal and large files
                const currentVersion = currentFileData ? extractVersionFromHTML(currentFileData.textContent) : null;
                deployment.previousVersion = currentVersion;
                addStep('Getting current state', 'complete', formatVersion(currentVersion));
                
                addStep('Fetching rollback version', 'running');
                const rollbackFileData = await github.getFileContentAtCommit(repo, fullTargetPath, deploymentToRollbackTo.commitSha);
                if (!rollbackFileData) throw new Error('Cannot find file at that commit');
                // Use textContent which handles both normal and large files
                const content = rollbackFileData.textContent;
                deployment.fileContent = content;
                addStep('Fetching rollback version', 'complete', formatVersion(targetVersion));
                
                addStep('Rolling back', 'running');
                deployment.preCommitTime = Date.now(); // Capture time before commit for workflow search
                const result = await github.createOrUpdateFile(
                    repo, fullTargetPath, content,
                    `Rollback ${app.name} to ${formatVersion(targetVersion)} (was ${formatVersion(currentVersion)})`,
                    currentFileData?.sha
                );
                deployment.commitSha = result.commit.sha;
                addStep('Rolling back', 'complete', result.commit.sha.substring(0, 7));
                
                deployment.status = 'success';
                deployment.url = getGitHubPagesUrl(repo, effectiveSubPath);
                const versionKey = deploymentToRollbackTo.target === 'prod' ? 'currentProdVersion' : 'currentTestVersion';
                updateApp(deploymentToRollbackTo.appId, { [versionKey]: targetVersion });
                
                // Start monitoring for deployment completion
                if (app?.deployType === 'github-actions') {
                    // For github-actions apps, monitor the workflow
                    addStep('GitHub Actions', 'running', 'Finding workflow...');
                    const searchTime = (deployment.preCommitTime || Date.now()) - 10000;
                    
                    const workflowRun = await github.findRecentWorkflowRun(repo, searchTime, 60000);
                    
                    if (workflowRun) {
                        const logsUrl = await github.getWorkflowRunLogsUrl(repo, workflowRun.id);
                        addStep('GitHub Actions', 'running', `Workflow #${workflowRun.run_number} running...`);
                        deployment.workflowUrl = logsUrl;
                        setActiveDeployment({ ...deployment });
                        
                        const monitorStartTime = Date.now();
                        const result = await github.waitForWorkflowRun(repo, workflowRun.id, 300000, (run) => {
                            addStep('GitHub Actions', 'running', `${run.status}... (${Math.round((Date.now() - monitorStartTime) / 1000)}s)`);
                            setActiveDeployment({ ...deployment });
                            setDeployments(prev => prev.map(d => d.id === deployment.id ? { ...deployment } : d));
                        });
                        
                        if (result.success) {
                            addStep('GitHub Actions', 'complete', `✓ Deployed! (${result.run?.conclusion})`);
                        } else {
                            addStep('GitHub Actions', 'error', `Failed: ${result.conclusion || result.error}`);
                            deployment.status = 'failed';
                            deployment.error = result.conclusion || result.error;
                        }
                    } else {
                        addStep('GitHub Actions', 'warning', 'Workflow not found - check GitHub manually');
                        deployment.workflowUrl = `https://github.com/${repo}/actions`;
                        deployment.status = 'success'; // Code committed successfully, just couldn't track workflow
                    }
                } else if (deployment.url && targetVersion) {
                    // For regular apps, monitor the live site
                    addStep('GitHub Pages', 'running', 'Waiting for deploy...');
                    monitorLiveDeployment(deployment.url, targetVersion, repo, (status, detail) => {
                        addStep('GitHub Pages', status, detail);
                        setActiveDeployment({ ...deployment });
                        setDeployments(prev => prev.map(d => d.id === deployment.id ? { ...deployment } : d));
                    }, deploymentToRollbackTo.appId, deploymentToRollbackTo.target);
                }
                
            } catch (error) {
                deployment.status = 'failed';
                deployment.error = error.message;
                addStep('Error', 'error', error.message);
            }
            
            deployment.completedAt = new Date().toISOString();
            setActiveDeployment({ ...deployment });
            setDeployments(prev => prev.map(d => d.id === deployment.id ? deployment : d));
        };
        
        return (
            <div className="min-h-screen" data-testid="app-loaded">
                <header className="bg-slate-800 border-b border-slate-700 sticky top-0 z-50">
                    <div className="max-w-6xl mx-auto px-4 py-3">
                        {/* Top row: Logo and main nav */}
                        <div className="flex items-center justify-between">
                            <div className="flex items-center gap-3">
                                <Icons.GameShelfLogo size={32} />
                                <div>
                                    <h1 className="text-lg font-bold">Command Center</h1>
                                    <div className="text-xs text-slate-400 flex items-center gap-1.5">
                                        v{document.querySelector('meta[name="version"]')?.content || '8.52.0'} • Deploy & manage apps
                                        <span title={`Firebase sync: ${syncStatus}`} className="inline-flex items-center">
                                            {syncStatus === 'synced' && <span className="text-green-400" title="Synced with Firebase">☁️</span>}
                                            {syncStatus === 'syncing' && <span className="text-yellow-400 animate-pulse" title="Syncing...">🔄</span>}
                                            {syncStatus === 'offline' && <span className="text-slate-500" title="Offline — using local data">⚡</span>}
                                            {syncStatus === 'error' && <span className="text-red-400" title="Sync error">⚠️</span>}
                                        </span>
                                    </div>
                                </div>
                            </div>
                            <div className="flex items-center gap-1">
                                <button onClick={() => refreshAllVersions()} disabled={refreshing}
                                    className={`p-2 rounded hover:bg-slate-700 ${refreshing ? 'animate-spin text-indigo-400' : 'text-slate-400'}`}
                                    title="Refresh versions">
                                    <Icons.Refresh />
                                </button>
                                {/* v8.63.0: Flat tab navigation (N1-N4 nav restructure) */}
                                {[
                                    { id: 'home', icon: '🏠', label: 'Home', view: 'dashboard' },
                                    { id: 'projects', icon: '📁', label: 'Projects', view: 'projects' },
                                    { id: 'ideas', icon: '💡', label: 'Ideas', view: 'ideas' },
                                    { id: 'jobs', icon: '📦', label: 'Jobs', view: 'jobHistory', badge: globalCompletionJobs.filter(j => j.state === 'new').length },
                                    { id: 'sessions', icon: '📝', label: 'Sessions', view: 'session' }
                                ].map(tab => (
                                    <button
                                        key={tab.id}
                                        onClick={() => setView(tab.view)}
                                        className={`px-3 py-1.5 rounded text-sm flex items-center gap-1 ${
                                            (view === tab.view || (tab.id === 'home' && view === 'history')) ? 'bg-indigo-600 text-white' : 'text-slate-400 hover:text-white hover:bg-slate-700'
                                        }`}
                                    >
                                        <span>{tab.icon}</span> {tab.label}
                                        {tab.badge > 0 && (
                                            <span className="px-1.5 py-0.5 bg-blue-600 text-white rounded-full text-xs font-bold ml-1">{tab.badge}</span>
                                        )}
                                    </button>
                                ))}
                                {/* Settings — flat tab (N5: Environments moved to Infrastructure satellite) */}
                                <button
                                    onClick={() => setView('settings')}
                                    className={`px-3 py-1.5 rounded text-sm flex items-center gap-1 ${
                                        view === 'settings' ? 'bg-indigo-600 text-white' : 'text-slate-400 hover:text-white hover:bg-slate-700'
                                    }`}
                                >
                                    <span>⚙️</span> Settings
                                </button>
                                {/* Satellite Launcher */}
                                <div className="relative group">
                                    <button className="px-2.5 py-1.5 rounded text-sm flex items-center gap-1 text-slate-400 hover:text-white hover:bg-slate-700" title="Satellite Apps">
                                        <span>🛰️</span>
                                        <span className="text-xs opacity-60">▼</span>
                                    </button>
                                    <div className="absolute top-full right-0 mt-1 bg-slate-800 border border-slate-700 rounded-lg shadow-xl opacity-0 invisible group-hover:opacity-100 group-hover:visible transition-all z-50 min-w-[200px]">
                                        <div className="px-3 py-2 text-xs text-slate-500 border-b border-slate-700 font-semibold uppercase tracking-wider">Satellite Apps</div>
                                        {[
                                            { id: 'infrastructure', icon: '🔧', label: 'Infrastructure', desc: 'Firebase, GitHub, Domains', ready: true },
                                            { id: 'quality', icon: '✅', label: 'Quality', desc: 'Issues, Releases, Archive', ready: true },
                                            { id: 'analytics', icon: '📈', label: 'Analytics', desc: 'Portfolio, Users, Streams, Briefs', ready: true }
                                        ].map(sat => (
                                            <a key={sat.id}
                                                href={sat.ready ? getSatelliteUrl(apps, sat.id) : '#'}
                                                target={sat.ready ? '_blank' : undefined}
                                                rel={sat.ready ? 'noopener' : undefined}
                                                onClick={sat.ready ? undefined : (e) => e.preventDefault()}
                                                className={`flex items-start gap-2.5 px-3 py-2.5 text-sm transition-colors ${sat.ready ? 'text-slate-300 hover:bg-slate-700 cursor-pointer' : 'text-slate-600 cursor-default'}`}
                                            >
                                                <span className="mt-0.5">{sat.icon}</span>
                                                <div>
                                                    <div className="flex items-center gap-1.5">
                                                        {sat.label}
                                                        {!sat.ready && <span className="text-[10px] px-1.5 py-0.5 bg-slate-700 text-slate-500 rounded-full">Coming Soon</span>}
                                                    </div>
                                                    <div className="text-xs text-slate-500 mt-0.5">{sat.desc}</div>
                                                </div>
                                            </a>
                                        ))}
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        {/* Quick Actions Bar (v8.53.0 simplified) */}
                        <div className="mt-3 pt-3 border-t border-slate-700 flex items-center gap-2 flex-wrap">
                            <span className="text-xs text-slate-500 mr-2">⚡ Quick:</span>
                            <button
                                onClick={() => setView('ideas')}
                                className="px-3 py-1 text-xs bg-indigo-600 hover:bg-indigo-500 rounded-full font-medium transition-colors"
                            >
                                💡 Ideas
                            </button>
                            <button
                                onClick={() => setShowHistoryPanel(true)}
                                className="px-3 py-1 text-xs bg-slate-700 hover:bg-slate-600 rounded-full font-medium transition-colors"
                            >
                                📜 Deploy History
                            </button>
                            {stagedFiles.length > 0 && (
                                <button
                                    onClick={() => setModal({ type: 'deployAll' })}
                                    className="px-3 py-1 text-xs bg-green-700 hover:bg-green-600 rounded-full font-medium transition-colors"
                                >
                                    📦 Deploy Staged ({stagedFiles.filter(f => f.fileAction !== 'push-doc').length})
                                </button>
                            )}
                            
                            {/* Status indicators */}
                            <div className="ml-auto flex items-center gap-3 text-xs">
                                {isFileProtocol && (
                                    <span className="flex items-center gap-1 text-blue-400" title="Running from local file - some features limited">
                                        <span className="w-2 h-2 rounded-full bg-blue-400"></span>
                                        Local
                                    </span>
                                )}
                                <span className={`flex items-center gap-1 ${github ? 'text-green-400' : 'text-red-400'}`}>
                                    <span className={`w-2 h-2 rounded-full ${github ? 'bg-green-400' : 'bg-red-400'}`}></span>
                                    GitHub
                                </span>
                                <span className={`flex items-center gap-1 ${firebaseDb ? 'text-green-400' : 'text-amber-400'}`}>
                                    <span className={`w-2 h-2 rounded-full ${firebaseDb ? 'bg-green-400' : 'bg-amber-400'}`}></span>
                                    Firebase
                                </span>
                                <span className="text-slate-500">
                                    {availableRepos.length} repos
                                </span>
                                
                                {/* Google Auth */}
                                {firebaseAuth && (
                                    firebaseUser ? (
                                        <React.Fragment>
                                            {teamMembership && (
                                                <span className="text-xs text-cyan-400 bg-cyan-900/30 border border-cyan-700/30 px-2 py-0.5 rounded-full"
                                                    title={`Viewing ${teamMembership.workspaceName || 'shared workspace'} as ${teamMembership.role}`}>
                                                    👥 {teamMembership.role}
                                                </span>
                                            )}
                                            {!teamMembership && (teamMembers || []).filter(m => m.status === 'active').length > 0 && (
                                                <span className="text-xs text-slate-400" title="Active team members">
                                                    👥 {(teamMembers || []).filter(m => m.status === 'active').length + 1}
                                                </span>
                                            )}
                                            <button onClick={async () => { try { await firebaseAuth.signOut(); } catch {} }}
                                                className="flex items-center gap-1.5 text-green-400 hover:text-green-300 transition-colors"
                                                title={`Signed in as ${firebaseUser.email}\nClick to sign out`}>
                                                <img src={firebaseUser.photoURL || ''} className="w-5 h-5 rounded-full" 
                                                    onError={(e) => { e.target.style.display = 'none'; }}
                                                />
                                                <span className="max-w-[100px] truncate">{firebaseUser.displayName?.split(' ')[0] || firebaseUser.email?.split('@')[0]}</span>
                                            </button>
                                        </React.Fragment>
                                    ) : (
                                        <button onClick={async () => {
                                                if (isFileProtocol) return;
                                                try {
                                                    const provider = new firebase.auth.GoogleAuthProvider();
                                                    await firebaseAuth.signInWithPopup(provider);
                                                } catch (e) {
                                                    console.error('Sign in error:', e);
                                                }
                                            }}
                                            disabled={isFileProtocol}
                                            className={`flex items-center gap-1 ${isFileProtocol ? 'text-slate-600 cursor-not-allowed' : 'text-slate-400 hover:text-white'} transition-colors`}
                                            title={isFileProtocol ? 'Google Sign-in requires HTTPS' : 'Sign in with Google'}>
                                            <span className="w-2 h-2 rounded-full bg-slate-500"></span>
                                            Sign In
                                        </button>
                                    )
                                )}
                            </div>
                        </div>
                    </div>
                </header>

                {/* v8.62.0 A6: Non-blocking notification stack */}
                {notifications.length > 0 && (
                    <div className="fixed top-16 right-4 z-40 flex flex-col gap-2" style={{ maxWidth: '320px' }}>
                        {notifications.map((n, idx) => (
                            <div key={n.id} className="bg-slate-800 border border-slate-600 rounded-lg p-3 shadow-lg animate-pulse-once"
                                style={{ animation: 'fadeIn 0.3s ease-out' }}>
                                <div className="flex items-start justify-between gap-2">
                                    <div className="flex-1 min-w-0">
                                        <div className="text-sm font-medium text-slate-200">{n.icon} {n.title}</div>
                                        <p className="text-xs text-slate-400 mt-1">{n.message}</p>
                                    </div>
                                    <button onClick={() => dismissNotification(n.id)}
                                        className="text-slate-500 hover:text-slate-300 text-sm flex-shrink-0">✕</button>
                                </div>
                                {n.action && (
                                    <button onClick={() => { n.action.handler(); dismissNotification(n.id); }}
                                        className="mt-2 px-3 py-1 text-xs bg-indigo-600 hover:bg-indigo-500 rounded font-medium">
                                        {n.action.label}
                                    </button>
                                )}
                            </div>
                        ))}
                    </div>
                )}

                {/* v8.63.2 N6: Deploy History slide-out panel */}
                {showHistoryPanel && (
                    <div className="fixed inset-0 z-50 flex justify-end" onClick={(e) => { if (e.target === e.currentTarget) setShowHistoryPanel(false); }}>
                        <div className="w-full max-w-4xl bg-slate-900 border-l border-slate-700 shadow-2xl overflow-y-auto animate-slideIn"
                            style={{ animation: 'slideIn 0.2s ease-out' }}>
                            <div className="sticky top-0 bg-slate-900 border-b border-slate-700 px-6 py-4 flex items-center justify-between z-10">
                                <h2 className="text-lg font-bold flex items-center gap-2">📜 Deploy History</h2>
                                <button onClick={() => setShowHistoryPanel(false)}
                                    className="p-2 rounded hover:bg-slate-700 text-slate-400 hover:text-white">✕</button>
                            </div>
                            <div className="p-6">
                                <HistoryView
                                    deployments={deployments} apps={apps}
                                    onRollback={(d) => { setShowHistoryPanel(false); setModal({ type: 'rollback', data: d }); }}
                                    globalWorkItems={globalWorkItems}
                                    globalSessions={globalSessions}
                                />
                            </div>
                        </div>
                    </div>
                )}

                <main className="max-w-6xl mx-auto px-4 py-6">
                    {!githubToken && (
                        <div className="mb-6 p-4 bg-amber-900/50 border border-amber-700 rounded-lg">
                            ⚠️ <strong>GitHub Token Required</strong> - Go to Settings
                        </div>
                    )}
                    
                    {tokenExpiryWarning && (
                        <div className={`mb-6 p-4 rounded-lg border flex items-center justify-between ${
                            daysUntilExpiry <= 3 
                                ? 'bg-red-900/50 border-red-700 text-red-200'
                                : 'bg-amber-900/50 border-amber-700 text-amber-200'
                        }`}>
                            <div>
                                {daysUntilExpiry <= 0 
                                    ? <><span className="text-lg mr-2">🚨</span><strong>GitHub token may have expired!</strong></>
                                    : <><span className="text-lg mr-2">{daysUntilExpiry <= 3 ? '🚨' : '⚠️'}</span><strong>GitHub token expires in {daysUntilExpiry} days</strong> ({new Date(tokenExpires).toLocaleDateString()})</>
                                }
                            </div>
                            <button onClick={() => setView('settings')} className="px-3 py-1 bg-slate-700 rounded text-sm hover:bg-slate-600">
                                Go to Settings →
                            </button>
                        </div>
                    )}
                    
                    {/* v8.3.3: Local file protocol warning */}
                    {isFileProtocol && !fileProtocolBannerDismissed && (
                        <div className="mb-6 p-4 rounded-lg border bg-blue-900/30 border-blue-700 text-blue-200">
                            <div className="flex items-start justify-between gap-4">
                                <div className="flex-1">
                                    <div className="flex items-center gap-2 mb-1">
                                        <span className="text-lg">🌐</span>
                                        <strong>Running Locally</strong>
                                    </div>
                                    <p className="text-sm text-blue-300">
                                        Some features require HTTPS (Google Auth, Firebase sync). 
                                        For full functionality, use the deployed version at{' '}
                                        <a href={(() => {
                                                const ccApp = apps['command-center'];
                                                const prodRepo = ccApp?.prodRepo || ccApp?.repos?.prod || '';
                                                if (prodRepo) {
                                                    const [owner, repo] = prodRepo.split('/');
                                                    return `https://${owner}.github.io/${repo}/`;
                                                }
                                                return '#';
                                            })()}
                                            target="_blank" 
                                            className="underline text-blue-200 hover:text-white">
                                            Command Center on GitHub Pages
                                        </a>
                                    </p>
                                </div>
                                <button 
                                    onClick={dismissFileProtocolBanner}
                                    className="px-2 py-1 bg-slate-700 rounded text-xs hover:bg-slate-600 text-slate-300">
                                    Dismiss
                                </button>
                            </div>
                        </div>
                    )}
                    
                    {view === 'dashboard' && (
                        <>
                        {/* Repo Health Alert */}
                        {repoHealthAlert && (
                            <div className="mb-4 p-4 bg-amber-900/20 rounded-xl border border-amber-700/50">
                                <div className="flex items-center justify-between mb-2">
                                    <div className="text-sm font-medium text-amber-300 flex items-center gap-2">
                                        ⚠️ Repo Health Check — {repoHealthAlert.issues.length} repo{repoHealthAlert.issues.length > 1 ? 's' : ''} with unexpected files
                                    </div>
                                    <div className="flex gap-2">
                                        <a href={getSatelliteUrl(apps, 'infrastructure')} target="_blank" onClick={() => setRepoHealthAlert(null)}
                                            className="px-3 py-1 text-xs bg-amber-700 hover:bg-amber-600 text-amber-100 rounded font-medium inline-flex items-center gap-1 no-underline">
                                            🔄 Open Repo Reset (Infrastructure)
                                        </a>
                                        <button onClick={() => setRepoHealthAlert(null)}
                                            className="px-2 py-1 text-xs text-slate-400 hover:text-white">
                                            ✕ Dismiss
                                        </button>
                                    </div>
                                </div>
                                <div className="space-y-1 text-xs">
                                    {repoHealthAlert.issues.map((issue, i) => (
                                        <div key={i} className="flex items-center gap-2 text-amber-400/80">
                                            <span>{issue.appIcon === 'gs-logo' ? '🎮' : issue.appIcon}</span>
                                            <span className="font-medium">{issue.appName}</span>
                                            <span className="text-amber-600">({issue.target})</span>
                                            <span className="text-slate-500">—</span>
                                            <span>{issue.unexpectedFiles.length} unexpected: {issue.unexpectedFiles.slice(0, 3).map(f => f.name).join(', ')}{issue.unexpectedFiles.length > 3 ? ` +${issue.unexpectedFiles.length - 3} more` : ''}</span>
                                        </div>
                                    ))}
                                </div>
                            </div>
                        )}
                        <DashboardView
                            apps={apps} config={config} stagedFiles={stagedFiles} setStagedFiles={setStagedFiles} github={github}
                            onFileDrop={handleFileDrop} onRemove={removeStaged}
                            onDeploy={handleDeploy} onBatchDeploy={handleBatchDeploy}
                            onPromote={(id) => {
                                console.log('[Promote Modal] Opening for:', id);
                                console.log('[Promote Modal] App state:', apps[id]);
                                console.log('[Promote Modal] testRepo:', apps[id]?.testRepo);
                                console.log('[Promote Modal] prodRepo:', apps[id]?.prodRepo);
                                setModal({ type: 'promote', data: { appId: id } });
                            }}
                            activeDeployments={activeDeployments}
                            removeActiveDeployment={removeActiveDeployment}
                            refreshing={refreshing}
                            onUpdateStagedFile={updateStagedFile}
                            deployingRepos={deployingRepos}
                            showConfirm={showConfirm}
                            showAlert={showAlert}
                            showPrompt={showPrompt}
                            globalIssues={globalIssues}
                            globalWorkItems={globalWorkItems}
                            globalStreams={globalStreams}
                            globalSessions={globalSessions}
                            globalActivity={globalActivity}
                            deployments={deployments}
                            firebaseUid={firebaseUid}
                            setModal={setModal}
                            linkIssuesToVersion={linkIssuesToVersion}
                            setView={setView}
                            rollbackSnapshots={rollbackSnapshots}
                            onQuickRollback={quickRollback}
                            pendingSessionReturn={pendingSessionReturn}
                            setPendingSessionReturn={setPendingSessionReturn}
                            pendingOdrcImport={pendingOdrcImport}
                            setPendingOdrcImport={setPendingOdrcImport}
                            updateApp={updateApp}
                            globalConcepts={globalConcepts}
                            globalIdeas={globalIdeas}
                            addNotification={addNotification}
                            setViewPayload={setViewPayload}
                        />
                        </>
                    )}

                    {view === 'projects' && (
                        <div className="max-w-6xl mx-auto">
                            <div className="flex items-center gap-3 mb-6">
                                <span className="text-2xl">📂</span>
                                <div>
                                    <h1 className="text-2xl font-bold">Projects & Apps</h1>
                                    <p className="text-slate-400 text-sm">Manage project groupings and app configurations</p>
                                </div>
                            </div>
                            <ProjectsTab 
                                config={config}
                                updateConfig={handleConfigChange}
                                activeEnvs={ConfigManager.getActiveEnvironments(config)}
                                envColors={{
                                    test: { text: 'text-blue-400', border: 'border-blue-700' },
                                    prod: { text: 'text-green-400', border: 'border-green-700' },
                                    dev: { text: 'text-yellow-400', border: 'border-yellow-700' },
                                    beta: { text: 'text-purple-400', border: 'border-purple-700' }
                                }}
                                github={github}
                                githubOwner={availableRepos[0]?.owner || 'stewartdavidp-ship-it'}
                                availableRepos={availableRepos}
                                showAlert={showAlert}
                                showConfirm={showConfirm}
                                showPrompt={showPrompt}
                                onRefreshRepos={refreshRepos}
                                deployments={deployments}
                                globalWorkItems={globalWorkItems}
                                firebaseUid={firebaseUid}
                                globalStreams={globalStreams}
                            />
                        </div>
                    )}
                    
                    {/* [v8.63.2] Deploy History moved to slide-out panel (N6) */}
                    
                    {view === 'session' && (
                        <div className="text-center py-20">
                            <div className="text-4xl mb-4">📋</div>
                            <h2 className="text-xl font-bold mb-2">Activity Journal</h2>
                            <p className="text-slate-400">Coming soon — unified timeline of all sessions, specs, and builds.</p>
                            <p className="text-slate-500 text-sm mt-2">Use the Ideas tab to manage ideation sessions.</p>
                        </div>
                    )}
                    
                    {view === 'backlog' && (
                        <BacklogView apps={apps} showAlert={showAlert} showConfirm={showConfirm} showPrompt={showPrompt} setView={setView} config={config} globalStreams={globalStreams} />
                    )}

                    {view === 'ideas' && (
                        <IdeasView apps={apps} globalIdeas={globalIdeas} globalConcepts={globalConcepts}
                            firebaseUid={firebaseUid} showAlert={showAlert} showConfirm={showConfirm}
                            showPrompt={showPrompt} config={config} setView={setView} github={github}
                            viewPayload={viewPayload} setViewPayload={setViewPayload} />
                    )}

                    {view === 'jobHistory' && (
                        <JobHistoryView globalCompletionJobs={globalCompletionJobs} firebaseUid={firebaseUid}
                            github={github} apps={apps} showAlert={showAlert} showConfirm={showConfirm}
                            config={config} completionFileSettings={completionFileSettings}
                            globalConcepts={globalConcepts} globalIdeas={globalIdeas} showPrompt={showPrompt}
                            globalOrphanCommits={globalOrphanCommits} />
                    )}

                    {/* [v8.63.2] Environments moved to Infrastructure satellite (N5) */}
                    
                    {view === 'settings' && (
                        <SettingsView token={githubToken} setToken={setGithubToken} settings={settings} setSettings={setSettings} repoCount={availableRepos.length} syncStatus={syncStatus} onForceSync={handleForceSync} config={config} onConfigChange={handleConfigChange} firebaseUid={firebaseUid} firebaseUser={firebaseUser} teamMembers={teamMembers} teamMembership={teamMembership} showAlert={showAlert} showConfirm={showConfirm} completionFileSettings={completionFileSettings} />
                    )}
                    
                    {view === 'setup' && (
                        <SetupNewAppView
                            apps={apps}
                            github={github}
                            config={config}
                            updateConfig={handleConfigChange}
                            showAlert={showAlert}
                            showConfirm={showConfirm}
                            onRefreshRepos={refreshRepos}
                            githubOwner={availableRepos[0]?.owner || availableRepos[0]?.fullName?.split('/')[0] || 'stewartdavidp-ship-it'}
                            firebaseUid={firebaseUid}
                        />
                    )}
                    
                    {/* Modals */}
                    {modal?.type === 'promote' && (
                        <PromoteModal app={apps[modal.data.appId]} onConfirm={() => handlePromote(modal.data.appId)} onCancel={() => setModal(null)} />
                    )}
                    
                    {/* [v8.63.0] SessionLaunchModal removed */}

                    {modal?.type === 'rollback' && (
                        <RollbackModal deployment={modal.data} apps={apps} onConfirm={() => handleRollback(modal.data)} onCancel={() => setModal(null)} />
                    )}
                    
                    {modal?.type === 'versionWarning' && (
                        <VersionWarningModal
                            data={modal.data}
                            onForce={() => { setModal(null); handleDeploy(modal.data.file, modal.data.appId, modal.data.target, true); }}
                            onCancel={() => setModal(null)}
                        />
                    )}
                    {/* Deploy All Modal */}
                    {modal?.type === 'deployAll' && (
                        <DeployAllModal
                            stagedFiles={stagedFiles}
                            apps={apps}
                            onConfirm={async (files) => {
                                setModal(null);
                                
                                // Split files by action type
                                const deployFiles = files.filter(f => f.fileAction !== 'push-doc');
                                const docFiles = files.filter(f => f.fileAction === 'push-doc');
                                
                                // Deploy files to GitHub Pages
                                // Group by repoKey so _shared files batch with their app files
                                const deployBatches = {};
                                for (const file of deployFiles) {
                                    const key = file.repoKey || file.suggestedApp || file.appId || '_default';
                                    if (!deployBatches[key]) deployBatches[key] = [];
                                    deployBatches[key].push(file);
                                }
                                for (const [batchKey, batchFiles] of Object.entries(deployBatches)) {
                                    let primaryAppId = batchFiles.find(f => f.suggestedApp && f.suggestedApp !== '_shared' && apps[f.suggestedApp])?.suggestedApp;
                                    // Fallback: find an app whose repo matches this batch
                                    if (!primaryAppId) {
                                        const sampleFile = batchFiles[0];
                                        const fileRepo = sampleFile.repo;
                                        const fileTarget = sampleFile.target || 'test';
                                        if (fileRepo) {
                                            primaryAppId = Object.keys(apps).find(id => {
                                                const a = apps[id];
                                                return (fileTarget === 'test' ? a.testRepo : a.prodRepo) === fileRepo
                                                    || (a.repos?.test === fileRepo || a.repos?.prod === fileRepo);
                                            });
                                        }
                                    }
                                    if (!primaryAppId) {
                                        console.warn(`[DeployAll] No valid app for batch ${batchKey}, skipping`);
                                        continue;
                                    }
                                    if (batchFiles.length > 1) {
                                        const mapped = batchFiles.map(f => ({
                                            id: f.id, name: f.name,
                                            targetPath: f.repoPath || f.targetPath,
                                            fullRepoPath: !!f.fullRepoPath,
                                            content: f.content, encoding: f.encoding,
                                            size: f.size, appId: f.suggestedApp,
                                            version: f.appVersion || f.version
                                        }));
                                        await handleBatchDeploy(mapped, primaryAppId, batchFiles[0].target || 'test');
                                    } else {
                                        await handleDeploy(batchFiles[0], primaryAppId, batchFiles[0].target || 'test');
                                    }
                                }
                                
                                // Push doc files to source repo
                                if (docFiles.length > 0 && github) {
                                    // Group docs by app
                                    const docsByApp = {};
                                    for (const doc of docFiles) {
                                        const appId = doc.suggestedApp || doc.appId;
                                        if (!docsByApp[appId]) docsByApp[appId] = [];
                                        docsByApp[appId].push(doc);
                                    }
                                    
                                    const pushedDocIds = [];
                                    const actuallyPushedDocs = []; // Only docs whose content changed
                                    // Determine target from the first doc file (all share same target from DeployAllModal)
                                    const docTarget = docFiles[0]?.target || 'test';
                                    for (const [appId, appDocs] of Object.entries(docsByApp)) {
                                        const app = apps[appId];
                                        if (!app) continue;
                                        const repo = docTarget === 'prod'
                                            ? (app.repos?.prod || app.prodRepo || app.repos?.test || app.testRepo)
                                            : (app.repos?.test || app.testRepo || app.repos?.prod || app.prodRepo);
                                        if (!repo) {
                                            console.warn(`No repo configured for ${appId}, skipping doc push`);
                                            continue;
                                        }
                                        
                                        for (const doc of appDocs) {
                                            try {
                                                // Check for existing file to get SHA
                                                const existing = await github.getFile(repo, doc.targetPath);
                                                const sha = existing?.sha || null;
                                                
                                                // Skip if content is identical to what's in the repo
                                                if (existing && isDocUnchanged(existing, doc.content)) {
                                                    console.log(`⏭️ ${doc.name} unchanged, skipping push`);
                                                    pushedDocIds.push(doc.id); // Still remove from staged
                                                    continue;
                                                }
                                                
                                                const action = sha ? 'Update' : 'Add';
                                                await github.createOrUpdateFile(
                                                    repo,
                                                    doc.targetPath,
                                                    doc.content,
                                                    `${action} ${doc.name} via Command Center`,
                                                    sha
                                                );
                                                console.log(`✅ Pushed ${doc.name} → ${repo}/${doc.targetPath}`);
                                                pushedDocIds.push(doc.id);
                                                actuallyPushedDocs.push({ name: doc.name, content: doc.content });
                                            } catch (e) {
                                                console.error(`❌ Failed to push ${doc.name}:`, e.message);
                                            }
                                        }
                                    }
                                    // Remove successfully pushed docs from staged files
                                    if (pushedDocIds.length > 0) {
                                        setStagedFiles(prev => prev.filter(f => !pushedDocIds.includes(f.id)));
                                        const skipped = pushedDocIds.length - actuallyPushedDocs.length;
                                        const summary = actuallyPushedDocs.map(d => d.name).join(', ');
                                        const msg = skipped > 0
                                            ? `Pushed ${actuallyPushedDocs.length} doc${actuallyPushedDocs.length !== 1 ? 's' : ''} (${skipped} unchanged): ${summary}`
                                            : `Pushed ${actuallyPushedDocs.length} doc${actuallyPushedDocs.length !== 1 ? 's' : ''}: ${summary}`;
                                        await showAlert(msg, '📄 Docs Pushed');

                                        // Check actually-changed docs for concepts (skip unchanged)
                                        if (actuallyPushedDocs.length > 0) {
                                            checkPushedDocsForConcepts(actuallyPushedDocs, globalStreams, showConfirm, showPrompt, {
                                                uid: firebaseUid,
                                                updateStream: WorkStreamService.update.bind(WorkStreamService)
                                            }).catch(e => console.error('[Concepts] Error during concept check:', e));
                                        }
                                    } else if (docFiles.length > 0) {
                                        await showAlert('No docs were pushed — check console for errors.', '⚠️ Doc Push Failed');
                                    }
                                }
                            }}
                            onCancel={() => setModal(null)}
                        />
                    )}
                    
                    {/* Sync Environments Modal */}
                    {modal?.type === 'syncEnvs' && (
                        <SyncEnvsModal
                            apps={apps}
                            github={github}
                            onConfirm={async (selectedApps) => {
                                setModal(null);
                                for (const appId of selectedApps) {
                                    await handlePromote(appId);
                                }
                            }}
                            onCancel={() => setModal(null)}
                            showAlert={showAlert}
                        />
                    )}
                    
                    {/* Version Bump Modal */}
                    {modal?.type === 'versionBump' && (
                        <VersionBumpModal
                            apps={apps}
                            onConfirm={async (bumps) => {
                                setModal(null);
                                await showAlert(`Version bumps prepared!\n\nTo apply, you'll need to update the source files and redeploy.\n\n${bumps.map(b => `${b.app}: ${b.current} → ${b.new}`).join('\n')}`, 'Version Bump Preview');
                            }}
                            onCancel={() => setModal(null)}
                        />
                    )}
                    
                    {/* SESSION_RETURN.json Auto-Review Modal (Phase B) */}
                    {pendingSessionReturn && (
                        <AutoReviewModal
                            returnManifest={pendingSessionReturn}
                            sessions={globalSessions || []}
                            workItems={globalWorkItems || []}
                            apps={apps}
                            onClose={() => setPendingSessionReturn(null)}
                            onApply={async ({ data, matchedSession, wiStatuses, applyWorkItems, applyNewIssues, applyNewIdeas }) => {
                                const results = [];
                                const actor = config?.ownerName || 'Owner';
                                const appId = matchedSession?.appId;
                                const appName = appId ? (apps[appId]?.name || appId) : 'unknown';
                                
                                try {
                                    // 1. Update work item statuses
                                    if (applyWorkItems && firebaseUid && wiStatuses.length > 0) {
                                        for (const wi of wiStatuses) {
                                            try {
                                                if (wi.status === 'completed') {
                                                    await WorkItemService.complete(firebaseUid, wi.id, data.versionBump?.to || null);
                                                    results.push(`✅ ${wi.id} → completed`);
                                                } else if (wi.status === 'blocked' || wi.status === 'deferred') {
                                                    await WorkItemService.updateStatus(firebaseUid, wi.id, 'ready');
                                                    results.push(`⏸ ${wi.id} → ready (was ${wi.status})`);
                                                }
                                                // 'partial' items stay in-progress
                                            } catch (e) {
                                                results.push(`⚠️ ${wi.id}: ${e.message}`);
                                            }
                                        }
                                    }
                                    
                                    // 2. Create work items for discovered issues
                                    if (applyNewIssues && firebaseUid && (data.discoveredIssues || []).length > 0) {
                                        for (const issue of data.discoveredIssues) {
                                            try {
                                                const newWi = await WorkItemService.create(firebaseUid, {
                                                    appId: appId || '',
                                                    title: issue.title,
                                                    description: issue.description || '',
                                                    type: issue.suggestedType || 'bugfix',
                                                    priority: issue.severity || 'medium',
                                                    status: 'ready',
                                                    source: 'session-return'
                                                });
                                                results.push(`🐛 Created: ${newWi.id} — ${issue.title}`);
                                            } catch (e) {
                                                results.push(`⚠️ Issue "${issue.title}": ${e.message}`);
                                            }
                                        }
                                    }
                                    
                                    // 3. Create work items for discovered ideas
                                    if (applyNewIdeas && firebaseUid && (data.discoveredIdeas || []).length > 0) {
                                        for (const idea of data.discoveredIdeas) {
                                            try {
                                                const newWi = await WorkItemService.create(firebaseUid, {
                                                    appId: appId || '',
                                                    title: idea.title,
                                                    description: idea.description || '',
                                                    type: idea.suggestedType || 'feature',
                                                    priority: 'low',
                                                    status: 'ready',
                                                    source: 'session-return'
                                                });
                                                results.push(`💡 Created: ${newWi.id} — ${idea.title}`);
                                            } catch (e) {
                                                results.push(`⚠️ Idea "${idea.title}": ${e.message}`);
                                            }
                                        }
                                    }
                                    
                                    // 4. Complete session review + store return manifest metadata
                                    if (firebaseUid && matchedSession) {
                                        try {
                                            await SessionService.startReview(firebaseUid, matchedSession.id, {
                                                files: [...(data.filesModified || []), ...(data.filesCreated || [])],
                                                summary: data.summary
                                            });
                                            await SessionService.completeReview(firebaseUid, matchedSession.id, {
                                                criteriaResults: (wiStatuses || []).map(wi => ({
                                                    id: wi.id,
                                                    met: wi.status === 'completed',
                                                    text: wi.notes || ''
                                                })),
                                                reviewedBy: 'auto-review (SESSION_RETURN.json)',
                                                notes: data.summary
                                            });
                                            // Store return manifest details on session
                                            await SessionService.update(firebaseUid, matchedSession.id, {
                                                returnManifest: {
                                                    version: data.version,
                                                    versionBump: data.versionBump || null,
                                                    issuesFound: (data.discoveredIssues || []).length,
                                                    ideasFound: (data.discoveredIdeas || []).length,
                                                    interfaceChanges: (data.interfaceChanges || []).length,
                                                    changelog: data.changelog || null,
                                                    appliedAt: new Date().toISOString()
                                                }
                                            });
                                            results.push(`📋 Session ${matchedSession.id} → review complete`);
                                        } catch (e) {
                                            results.push(`⚠️ Session update: ${e.message}`);
                                        }
                                    }
                                    
                                    // 5. Log activity
                                    if (firebaseUid) {
                                        ActivityLogService.log(firebaseUid, {
                                            type: 'auto-review',
                                            actor,
                                            appName,
                                            sessionId: matchedSession?.id,
                                            summary: data.summary,
                                            workItemsProcessed: wiStatuses.length,
                                            issuesCreated: applyNewIssues ? (data.discoveredIssues || []).length : 0,
                                            ideasCreated: applyNewIdeas ? (data.discoveredIdeas || []).length : 0
                                        }).catch(() => {});
                                    }
                                    
                                    setPendingSessionReturn(null);
                                    await showAlert(
                                        `Auto-review applied successfully!\n\n${results.join('\n')}`,
                                        '✅ Session Review Complete'
                                    );
                                } catch (e) {
                                    await showAlert(`Error during auto-review: ${e.message}\n\nPartial results:\n${results.join('\n')}`, '⚠️ Auto-Review Error');
                                    setPendingSessionReturn(null);
                                }
                            }}
                            showAlert={showAlert}
                            firebaseUid={firebaseUid}
                            config={config}
                        />
                    )}
                    
                    {/* Custom Dialog Modal (replaces native alert/confirm/prompt) */}
                    {dialog && (
                        <DialogModal
                            type={dialog.type}
                            title={dialog.title}
                            message={dialog.message}
                            defaultValue={dialog.defaultValue}
                            confirmText={dialog.confirmText}
                            cancelText={dialog.cancelText}
                            onConfirm={(value) => {
                                if (dialog.onConfirm) dialog.onConfirm(value);
                                setDialog(null);
                            }}
                            onCancel={() => {
                                if (dialog.onCancel) dialog.onCancel();
                                setDialog(null);
                            }}
                        />
                    )}
                </main>
            </div>
        );
    }

    // =========================================================================
    // VERSION WARNING MODAL
    // =========================================================================
    
    function VersionWarningModal({ data, onForce, onCancel }) {
        const { currentVersion, newVersion, target } = data;
        const isEqual = compareVersions(newVersion, currentVersion) === 0;
        
        return (
            <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
                <div className="bg-slate-800 rounded-xl border border-red-700 p-6 max-w-md w-full fade-in">
                    <h2 className="text-xl font-bold mb-4 flex items-center gap-2 text-red-400">
                        <Icons.AlertTriangle /> Version Conflict
                    </h2>
                    
                    <div className="mb-4 p-4 bg-red-900/30 rounded-lg">
                        <div className="text-center mb-3">
                            <div className="text-sm text-slate-400">Currently Deployed</div>
                            <div className="text-2xl font-mono text-green-400">{formatVersion(currentVersion)}</div>
                        </div>
                        <div className="text-center text-2xl">↓</div>
                        <div className="text-center mt-3">
                            <div className="text-sm text-slate-400">Trying to Deploy</div>
                            <div className="text-2xl font-mono text-red-400">{formatVersion(newVersion)}</div>
                        </div>
                    </div>
                    
                    <p className="text-slate-300 mb-4">
                        {isEqual 
                            ? `You're deploying the same version that's already on ${target.toUpperCase()}.`
                            : `You're deploying an older version than what's currently on ${target.toUpperCase()}.`
                        }
                    </p>
                    
                    <div className="flex gap-3">
                        <button onClick={onCancel} className="flex-1 p-2 bg-slate-700 rounded">Cancel</button>
                        <button onClick={onForce} className="flex-1 p-2 bg-red-600 rounded flex items-center justify-center gap-2">
                            <Icons.AlertTriangle className="w-4 h-4" /> Force Deploy
                        </button>
                    </div>
                </div>
            </div>
        );
    }

    // =========================================================================
    // DEPLOY ALL MODAL (v8.0)
    // =========================================================================
    
    function DeployAllModal({ stagedFiles, apps, onConfirm, onCancel }) {
        const [selectedFiles, setSelectedFiles] = React.useState(new Set(stagedFiles.map((_, i) => i)));
        const [target, setTarget] = React.useState('test');
        
        const deployFiles = stagedFiles.filter(f => f.fileAction !== 'push-doc');
        const docFiles = stagedFiles.filter(f => f.fileAction === 'push-doc');
        
        const toggleFile = (idx) => {
            setSelectedFiles(prev => {
                const newSet = new Set(prev);
                if (newSet.has(idx)) newSet.delete(idx);
                else newSet.add(idx);
                return newSet;
            });
        };
        
        const handleConfirm = () => {
            const files = stagedFiles.filter((_, i) => selectedFiles.has(i)).map(f => ({ ...f, target }));
            onConfirm(files);
        };
        
        const selectedDeployCount = deployFiles.filter((_, i) => selectedFiles.has(stagedFiles.indexOf(deployFiles[i]))).length;
        const selectedDocCount = docFiles.filter(f => selectedFiles.has(stagedFiles.indexOf(f))).length;
        
        return (
            <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
                <div className="bg-slate-800 rounded-xl border border-green-700 p-6 max-w-lg w-full fade-in">
                    <h2 className="text-xl font-bold mb-4 flex items-center gap-2 text-green-400">
                        🚀 Deploy & Push All Files
                    </h2>
                    
                    <div className="mb-4">
                        <label className="text-sm text-slate-400 block mb-2">Deploy Target Environment</label>
                        <div className="flex gap-2">
                            {['test', 'prod'].map(t => (
                                <button
                                    key={t}
                                    onClick={() => setTarget(t)}
                                    className={`flex-1 py-2 rounded font-medium ${
                                        target === t 
                                            ? t === 'prod' ? 'bg-green-600' : 'bg-blue-600'
                                            : 'bg-slate-700'
                                    }`}
                                >
                                    {t.toUpperCase()}
                                </button>
                            ))}
                        </div>
                    </div>
                    
                    <div className="mb-4 max-h-64 overflow-y-auto bg-slate-900 rounded-lg">
                        {deployFiles.length > 0 && (
                            <div className="px-3 py-1.5 bg-slate-800 text-xs font-medium text-slate-400 border-b border-slate-700 sticky top-0">
                                🚀 Deploy to GitHub Pages ({deployFiles.length})
                            </div>
                        )}
                        {deployFiles.map((file) => {
                            const idx = stagedFiles.indexOf(file);
                            return (
                            <div
                                key={idx}
                                onClick={() => toggleFile(idx)}
                                className={`flex items-center gap-3 p-3 border-b border-slate-800 cursor-pointer hover:bg-slate-800 ${
                                    selectedFiles.has(idx) ? 'bg-slate-800/50' : ''
                                }`}
                            >
                                <input type="checkbox" checked={selectedFiles.has(idx)} readOnly className="w-4 h-4" />
                                <span className="text-lg">{apps[file.suggestedApp]?.icon ? (() => { const icon = apps[file.suggestedApp].icon; return icon === 'gs-logo' ? '🎮' : icon; })() : '📄'}</span>
                                <div className="flex-1 min-w-0">
                                    <div className="font-medium truncate">{file.name}</div>
                                    <div className="text-xs text-slate-500">{apps[file.suggestedApp]?.name || 'Unknown'} • {file.version ? `v${file.version}` : file.targetPath}</div>
                                </div>
                            </div>
                            );
                        })}
                        {docFiles.length > 0 && (
                            <div className="px-3 py-1.5 bg-cyan-900/30 text-xs font-medium text-cyan-400 border-b border-slate-700 sticky top-0">
                                📄 Push docs to repo ({docFiles.length})
                            </div>
                        )}
                        {docFiles.map((file) => {
                            const idx = stagedFiles.indexOf(file);
                            return (
                            <div
                                key={idx}
                                onClick={() => toggleFile(idx)}
                                className={`flex items-center gap-3 p-3 border-b border-slate-800 cursor-pointer hover:bg-slate-800 ${
                                    selectedFiles.has(idx) ? 'bg-cyan-900/20' : ''
                                }`}
                            >
                                <input type="checkbox" checked={selectedFiles.has(idx)} readOnly className="w-4 h-4" />
                                <span className="text-lg">📄</span>
                                <div className="flex-1 min-w-0">
                                    <div className="font-medium truncate">{file.name}</div>
                                    <div className="text-xs text-cyan-400/70">{file.targetPath}</div>
                                </div>
                            </div>
                            );
                        })}
                    </div>
                    
                    <div className="flex gap-3">
                        <button onClick={onCancel} className="flex-1 p-2 bg-slate-700 rounded">Cancel</button>
                        <button
                            onClick={handleConfirm}
                            disabled={selectedFiles.size === 0}
                            className="flex-1 p-2 bg-green-600 hover:bg-green-500 disabled:opacity-50 rounded font-medium"
                        >
                            {selectedDeployCount > 0 && selectedDocCount > 0
                                ? `Deploy ${selectedDeployCount} + Push ${selectedDocCount} Docs`
                                : selectedDocCount > 0
                                    ? `Push ${selectedDocCount} Doc(s) to Repo`
                                    : `Deploy ${selectedDeployCount} File(s) to ${target.toUpperCase()}`
                            }
                        </button>
                    </div>
                </div>
            </div>
        );
    }

    // =========================================================================
    // SYNC ENVIRONMENTS MODAL (v8.0)
    // =========================================================================
    
    function SyncEnvsModal({ apps, github, onConfirm, onCancel, showAlert }) {
        const [selectedApps, setSelectedApps] = React.useState(new Set());
        const [loading, setLoading] = React.useState(false);
        
        // Filter to apps that have both test and prod repos
        const syncableApps = Object.values(apps).filter(app => 
            app.repos?.test && app.repos?.prod && app.versions?.test
        );
        
        const toggleApp = (appId) => {
            setSelectedApps(prev => {
                const newSet = new Set(prev);
                if (newSet.has(appId)) newSet.delete(appId);
                else newSet.add(appId);
                return newSet;
            });
        };
        
        const selectAll = () => {
            setSelectedApps(new Set(syncableApps.map(a => a.id)));
        };
        
        return (
            <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
                <div className="bg-slate-800 rounded-xl border border-blue-700 p-6 max-w-lg w-full fade-in">
                    <h2 className="text-xl font-bold mb-4 flex items-center gap-2 text-blue-400">
                        🔄 Sync TEST → PROD
                    </h2>
                    
                    <p className="text-sm text-slate-400 mb-4">
                        Promote TEST versions to PROD for selected apps.
                    </p>
                    
                    <div className="flex justify-end mb-2">
                        <button onClick={selectAll} className="text-xs text-indigo-400 hover:text-indigo-300">
                            Select All
                        </button>
                    </div>
                    
                    <div className="mb-4 max-h-64 overflow-y-auto bg-slate-900 rounded-lg">
                        {syncableApps.length === 0 ? (
                            <div className="p-4 text-center text-slate-500">
                                No apps with TEST→PROD repos configured
                            </div>
                        ) : (
                            syncableApps.map(app => {
                                const testV = app.versions?.test || '?';
                                const prodV = app.versions?.prod || '?';
                                const needsSync = testV !== prodV;
                                
                                return (
                                    <div
                                        key={app.id}
                                        onClick={() => toggleApp(app.id)}
                                        className={`flex items-center gap-3 p-3 border-b border-slate-800 cursor-pointer hover:bg-slate-800 ${
                                            selectedApps.has(app.id) ? 'bg-slate-800/50' : ''
                                        }`}
                                    >
                                        <input type="checkbox" checked={selectedApps.has(app.id)} readOnly className="w-4 h-4" />
                                        <span className="text-lg">{app.icon}</span>
                                        <div className="flex-1">
                                            <div className="font-medium">{app.name}</div>
                                            <div className="text-xs">
                                                <span className="text-blue-400">TEST: {testV}</span>
                                                <span className="mx-2">→</span>
                                                <span className="text-green-400">PROD: {prodV}</span>
                                                {needsSync && <span className="ml-2 text-amber-400">(out of sync)</span>}
                                            </div>
                                        </div>
                                    </div>
                                );
                            })
                        )}
                    </div>
                    
                    <div className="flex gap-3">
                        <button onClick={onCancel} className="flex-1 p-2 bg-slate-700 rounded">Cancel</button>
                        <button
                            onClick={() => onConfirm(Array.from(selectedApps))}
                            disabled={selectedApps.size === 0 || loading}
                            className="flex-1 p-2 bg-blue-600 hover:bg-blue-500 disabled:opacity-50 rounded font-medium"
                        >
                            Sync {selectedApps.size} App(s)
                        </button>
                    </div>
                </div>
            </div>
        );
    }

    // =========================================================================
    // VERSION BUMP MODAL (v8.0)
    // =========================================================================
    
    function VersionBumpModal({ apps, onConfirm, onCancel }) {
        const [bumpType, setBumpType] = React.useState('patch'); // patch, minor, major
        const [selectedApps, setSelectedApps] = React.useState(new Set());
        
        const bumpableApps = Object.values(apps).filter(app => app.versions?.prod || app.versions?.test);
        
        const toggleApp = (appId) => {
            setSelectedApps(prev => {
                const newSet = new Set(prev);
                if (newSet.has(appId)) newSet.delete(appId);
                else newSet.add(appId);
                return newSet;
            });
        };
        
        const selectAll = () => {
            setSelectedApps(new Set(bumpableApps.map(a => a.id)));
        };
        
        const bumpVersion = (version, type) => {
            if (!version) return '1.0.0';
            const parts = version.split('.').map(Number);
            while (parts.length < 3) parts.push(0);
            
            if (type === 'major') {
                parts[0]++;
                parts[1] = 0;
                parts[2] = 0;
            } else if (type === 'minor') {
                parts[1]++;
                parts[2] = 0;
            } else {
                parts[2]++;
            }
            
            return parts.join('.');
        };
        
        const handleConfirm = () => {
            const bumps = Array.from(selectedApps).map(appId => {
                const app = apps[appId];
                const current = app.versions?.prod || app.versions?.test || '1.0.0';
                return {
                    appId,
                    app: app.name,
                    current,
                    new: bumpVersion(current, bumpType)
                };
            });
            onConfirm(bumps);
        };
        
        return (
            <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
                <div className="bg-slate-800 rounded-xl border border-purple-700 p-6 max-w-lg w-full fade-in">
                    <h2 className="text-xl font-bold mb-4 flex items-center gap-2 text-purple-400">
                        📈 Version Bump
                    </h2>
                    
                    <div className="mb-4">
                        <label className="text-sm text-slate-400 block mb-2">Bump Type</label>
                        <div className="flex gap-2">
                            {[
                                { id: 'patch', label: 'Patch', desc: '1.0.0 → 1.0.1' },
                                { id: 'minor', label: 'Minor', desc: '1.0.0 → 1.1.0' },
                                { id: 'major', label: 'Major', desc: '1.0.0 → 2.0.0' }
                            ].map(t => (
                                <button
                                    key={t.id}
                                    onClick={() => setBumpType(t.id)}
                                    className={`flex-1 py-2 px-3 rounded text-sm ${
                                        bumpType === t.id ? 'bg-purple-600' : 'bg-slate-700'
                                    }`}
                                >
                                    <div className="font-medium">{t.label}</div>
                                    <div className="text-xs opacity-60">{t.desc}</div>
                                </button>
                            ))}
                        </div>
                    </div>
                    
                    <div className="flex justify-end mb-2">
                        <button onClick={selectAll} className="text-xs text-indigo-400 hover:text-indigo-300">
                            Select All
                        </button>
                    </div>
                    
                    <div className="mb-4 max-h-64 overflow-y-auto bg-slate-900 rounded-lg">
                        {bumpableApps.map(app => {
                            const current = app.versions?.prod || app.versions?.test || '1.0.0';
                            const newV = bumpVersion(current, bumpType);
                            
                            return (
                                <div
                                    key={app.id}
                                    onClick={() => toggleApp(app.id)}
                                    className={`flex items-center gap-3 p-3 border-b border-slate-800 cursor-pointer hover:bg-slate-800 ${
                                        selectedApps.has(app.id) ? 'bg-slate-800/50' : ''
                                    }`}
                                >
                                    <input type="checkbox" checked={selectedApps.has(app.id)} readOnly className="w-4 h-4" />
                                    <span className="text-lg">{app.icon}</span>
                                    <div className="flex-1">
                                        <div className="font-medium">{app.name}</div>
                                    </div>
                                    <div className="text-sm font-mono">
                                        <span className="text-slate-400">{current}</span>
                                        <span className="mx-2 text-purple-400">→</span>
                                        <span className="text-purple-300">{newV}</span>
                                    </div>
                                </div>
                            );
                        })}
                    </div>
                    
                    <div className="p-3 bg-amber-900/30 border border-amber-700 rounded-lg mb-4 text-sm">
                        <strong>Note:</strong> This generates a preview. To apply version bumps, 
                        update the source files (index.html, sw.js) and redeploy.
                    </div>
                    
                    <div className="flex gap-3">
                        <button onClick={onCancel} className="flex-1 p-2 bg-slate-700 rounded">Cancel</button>
                        <button
                            onClick={handleConfirm}
                            disabled={selectedApps.size === 0}
                            className="flex-1 p-2 bg-purple-600 hover:bg-purple-500 disabled:opacity-50 rounded font-medium"
                        >
                            Preview Bumps ({selectedApps.size})
                        </button>
                    </div>
                </div>
            </div>
        );
    }

    // =========================================================================
    // ROLLBACK MODAL
    // =========================================================================
    
    function RollbackModal({ deployment, apps, onConfirm, onCancel }) {
        const app = apps[deployment.appId];
        
        return (
            <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
                <div className="bg-slate-800 rounded-xl border border-amber-700 p-6 max-w-md w-full fade-in">
                    <h2 className="text-xl font-bold mb-4 flex items-center gap-2 text-amber-400">
                        <Icons.Rewind /> Rollback
                    </h2>
                    
                    <div className="mb-4 p-4 bg-slate-900 rounded-lg">
                        <div className="flex items-center gap-2 mb-2">
                            <AppIcon icon={app?.icon} size={24} />
                            <span className="font-semibold">{app?.name}</span>
                            <span className={`text-xs px-1.5 rounded ${deployment.target === 'prod' ? 'bg-green-900 text-green-300' : 'bg-blue-900 text-blue-300'}`}>
                                {deployment.target?.toUpperCase()}
                            </span>
                        </div>
                        <div className="text-sm text-slate-400">
                            Rolling back to <span className="text-amber-400 font-mono">{formatVersion(deployment.version)}</span>
                        </div>
                        <div className="text-xs text-slate-500 mt-1">
                            Commit: {deployment.commitSha?.substring(0, 7)} • {formatDate(deployment.completedAt)}
                        </div>
                    </div>
                    
                    <p className="text-slate-300 text-sm mb-4">
                        This will restore the exact code from this deployment. A new commit will be created for audit purposes.
                    </p>
                    
                    <div className="flex gap-3">
                        <button onClick={onCancel} className="flex-1 p-2 bg-slate-700 rounded">Cancel</button>
                        <button onClick={onConfirm} className="flex-1 p-2 bg-amber-600 rounded flex items-center justify-center gap-2">
                            <Icons.Rewind className="w-4 h-4" /> Rollback
                        </button>
                    </div>
                </div>
            </div>
        );
    }

    // =========================================================================
    // PROMOTE MODAL
    // =========================================================================
    
    function PromoteModal({ app, onConfirm, onCancel }) {
        if (!app) return null;
        return (
            <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
                <div className="bg-slate-800 rounded-xl border border-slate-700 p-6 max-w-lg w-full fade-in">
                    <h2 className="text-xl font-bold mb-4">⚡ Promote to Production</h2>
                    
                    <div className="flex items-center justify-center gap-4 mb-4">
                        <div className="p-3 bg-blue-900/30 border border-blue-700 rounded text-center">
                            <div className="text-xs text-blue-400">TEST</div>
                            <div className="font-mono">{app.testRepo?.split('/')[1]}</div>
                            <div className="text-sm text-slate-400">{formatVersion(app.currentTestVersion)}</div>
                        </div>
                        <div className="text-2xl">→</div>
                        <div className="p-3 bg-green-900/30 border border-green-700 rounded text-center">
                            <div className="text-xs text-green-400">PROD</div>
                            <div className="font-mono">{app.prodRepo?.split('/')[1]}</div>
                            <div className="text-sm text-slate-400">{formatVersion(app.currentProdVersion)}</div>
                        </div>
                    </div>
                    
                    <div className="bg-slate-900 rounded p-3 mb-4 text-sm">
                        <strong>This will:</strong>
                        <ol className="list-decimal list-inside mt-2 space-y-1 text-slate-300">
                            <li>Copy {app.targetPath} from TEST to PROD</li>
                            <li>Create release tag {formatVersion(app.currentTestVersion)}</li>
                            <li>GitHub Pages will deploy (~30s)</li>
                        </ol>
                    </div>
                    
                    <div className="flex gap-3">
                        <button onClick={onCancel} className="flex-1 p-2 bg-slate-700 rounded">Cancel</button>
                        <button onClick={onConfirm} className="flex-1 p-2 bg-green-600 rounded">
                            🚀 Promote {formatVersion(app.currentTestVersion)}
                        </button>
                    </div>
                </div>
            </div>
        );
    }

    // =========================================================================
    // CONFIRM DELETE MODAL
    // =========================================================================
    
    
    function DialogModal({ type, title, message, defaultValue, confirmText, cancelText, onConfirm, onCancel }) {
        const [inputValue, setInputValue] = React.useState(defaultValue || '');
        const inputRef = React.useRef(null);
        
        React.useEffect(() => {
            if (type === 'prompt' && inputRef.current) {
                inputRef.current.focus();
                inputRef.current.select();
            }
        }, [type]);
        
        const handleKeyDown = (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                onConfirm(type === 'prompt' ? inputValue : true);
            } else if (e.key === 'Escape') {
                onCancel();
            }
        };
        
        // Determine icon and colors based on message content
        const isError = message?.toLowerCase().includes('error') || message?.toLowerCase().includes('failed');
        const isWarning = message?.toLowerCase().includes('warning') || message?.toLowerCase().includes('⚠');
        const isSuccess = message?.toLowerCase().includes('✓') || message?.toLowerCase().includes('success');
        
        const borderColor = isError ? 'border-red-700' : isWarning ? 'border-amber-700' : isSuccess ? 'border-green-700' : 'border-slate-600';
        const iconColor = isError ? 'text-red-400' : isWarning ? 'text-amber-400' : isSuccess ? 'text-green-400' : 'text-indigo-400';
        
        return (
            <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-[100] p-4" onKeyDown={handleKeyDown}>
                <div className={`bg-slate-800 rounded-xl border ${borderColor} p-6 max-w-md w-full fade-in shadow-2xl`}>
                    {title && (
                        <h2 className={`text-lg font-bold mb-3 flex items-center gap-2 ${iconColor}`}>
                            {isError ? <Icons.AlertTriangle /> : isWarning ? '⚠️' : isSuccess ? '✓' : 'ℹ️'}
                            {title}
                        </h2>
                    )}
                    
                    <div className="text-slate-300 mb-4 whitespace-pre-wrap">{message}</div>
                    
                    {type === 'prompt' && (
                        <input
                            ref={inputRef}
                            type="text"
                            value={inputValue}
                            onChange={(e) => setInputValue(e.target.value)}
                            className="w-full p-3 bg-slate-900 border border-slate-600 rounded-lg mb-4 text-white focus:border-indigo-500 focus:outline-none"
                            placeholder="Enter value..."
                        />
                    )}
                    
                    <div className="flex gap-3">
                        {type !== 'alert' && (
                            <button 
                                onClick={onCancel} 
                                className="flex-1 p-2.5 bg-slate-700 hover:bg-slate-600 rounded-lg transition-colors">
                                {cancelText || 'Cancel'}
                            </button>
                        )}
                        <button 
                            onClick={() => onConfirm(type === 'prompt' ? inputValue : true)} 
                            className={`flex-1 p-2.5 rounded-lg transition-colors ${
                                isError ? 'bg-red-600 hover:bg-red-500' :
                                isWarning ? 'bg-amber-600 hover:bg-amber-500' :
                                'bg-indigo-600 hover:bg-indigo-500'
                            }`}>
                            {confirmText || 'OK'}
                        </button>
                    </div>
                </div>
            </div>
        );
    }

    // =========================================================================
    // DASHBOARD VIEW
    // =========================================================================
    
    function DashboardView({ apps, config, stagedFiles, setStagedFiles, github, onFileDrop, onRemove, onDeploy, onBatchDeploy, onPromote, activeDeployments, removeActiveDeployment, refreshing, onUpdateStagedFile, deployingRepos, showConfirm, showAlert, showPrompt, globalIssues, globalWorkItems, globalStreams, globalSessions, globalActivity, deployments, firebaseUid, setModal, linkIssuesToVersion, setView, rollbackSnapshots, onQuickRollback, pendingSessionReturn, setPendingSessionReturn, pendingOdrcImport, setPendingOdrcImport, updateApp, globalConcepts, globalIdeas, addNotification, setViewPayload }) {
        // v8.65.1: Projects/Apps section collapsed by default
        const [projectsCollapsed, setProjectsCollapsed] = React.useState(true);

        // v8.65.0: Work cards state
        const [workCardContinueIdea, setWorkCardContinueIdea] = React.useState(null);
        const workCardRecentIdeas = getRecentIdeas(globalIdeas, globalConcepts, apps, 5);
        const workCardActiveIdeaCount = (globalIdeas || []).filter(i => i.status === 'active').length;
        const workCardExploreIdea = React.useMemo(() => {
            if (!workCardContinueIdea) return null;
            return (globalIdeas || []).find(i => i.id === workCardContinueIdea.id) || workCardContinueIdea;
        }, [workCardContinueIdea, globalIdeas]);
        const workCardNavigateIdea = (ideaId) => { if (setViewPayload) setViewPayload({ ideaId }); setView('ideas'); };
        const workCardNavigateApp = (appId) => { if (appId) setView('projects'); };
        const workCardContinue = (idea) => { setWorkCardContinueIdea(idea); };

        // v8.68.0: Upload session results — opens file picker, routes through existing drop pipeline
        const workCardUploadResults = async (idea) => {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.zip,.json,.md';
            input.multiple = true;
            input.onchange = (e) => {
                // Route through existing handleFileDrop which expects e.target.files
                onFileDrop(e);
            };
            input.click();
        };

        // v8.68.0: Abandon stale session
        const workCardAbandon = async (idea) => {
            if (!firebaseUid || !idea.activeSession) return;
            try {
                await IdeaManager.abandonSession(firebaseUid, idea.id, idea.activeSessionId);
                await showAlert(`Session ${idea.activeSessionId} abandoned.`, '🗑️ Abandoned');
            } catch (e) {
                await showAlert(`Error: ${e.message}`, '❌ Error');
            }
        };

        const [selectedFileIds, setSelectedFileIds] = React.useState(new Set());
        const [deployTarget, setDeployTarget] = React.useState({ appId: 'command-center', target: 'test' });
        const [isDeploying, setIsDeploying] = React.useState(false);
        const [deployCompleted, setDeployCompleted] = React.useState(false);
        const [lastCompletedDeployId, setLastCompletedDeployId] = React.useState(null);
        const [errorOverride, setErrorOverride] = React.useState(false);
        
        // Multi-app state
        const [multiAppValidation, setMultiAppValidation] = React.useState(null);
        const [multiAppDeployedVersions, setMultiAppDeployedVersions] = React.useState({});
        const [multiAppCheckingVersions, setMultiAppCheckingVersions] = React.useState(false);
        // Track if deploy button was clicked in this session (prevents history-based false positive)
        const deployClickedThisSession = React.useRef(false);
        // Track if the full batch action (deploy + doc push) is still running
        const [batchActionRunning, setBatchActionRunning] = React.useState(false);
        
        // Multi-app: fetch deployed versions and run validation when multi-app files are staged
        const isMultiApp = stagedFiles.length > 0 && stagedFiles[0]?.multiApp;
        React.useEffect(() => {
            if (!isMultiApp || !github) return;
            
            let cancelled = false;
            const checkVersionsAndValidate = async () => {
                setMultiAppCheckingVersions(true);
                const versions = {};
                
                // Build resolved repos structure from staged files for validateMultiAppPackage
                const resolvedRepos = {};
                stagedFiles.forEach(f => {
                    if (!f.repoKey) return;
                    if (!resolvedRepos[f.repoKey]) resolvedRepos[f.repoKey] = { repo: f.repo, target: f.deployTarget, apps: {}, sharedFiles: [] };
                    if (f.suggestedApp === '_shared') {
                        resolvedRepos[f.repoKey].sharedFiles.push({ relativePath: f.name, repoPath: f.repoPath, entry: { async: () => f.content } });
                    } else {
                        if (!resolvedRepos[f.repoKey].apps[f.suggestedApp]) {
                            resolvedRepos[f.repoKey].apps[f.suggestedApp] = { config: apps[f.suggestedApp], files: [], version: f.appVersion };
                        }
                        resolvedRepos[f.repoKey].apps[f.suggestedApp].files.push({ 
                            relativePath: f.name, repoPath: f.repoPath,
                            entry: { async: () => f.content }
                        });
                    }
                });
                
                // Fetch deployed versions
                for (const [repoKey, bucket] of Object.entries(resolvedRepos)) {
                    for (const [appId, appData] of Object.entries(bucket.apps)) {
                        const appConfig = apps[appId];
                        if (!appConfig) continue;
                        const repo = bucket.target === 'prod' ? (appConfig.prodRepo || appConfig.testRepo) : (appConfig.testRepo || appConfig.prodRepo);
                        if (!repo) { versions[appId] = null; continue; }
                        
                        try {
                            const targetPath = appConfig.subPath ? `${appConfig.subPath}/${appConfig.targetPath || 'index.html'}` : (appConfig.targetPath || 'index.html');
                            const fileData = await github.getFileContent(repo, targetPath);
                            versions[appId] = fileData?.textContent ? extractVersionFromHTML(fileData.textContent) : null;
                        } catch (e) { versions[appId] = null; }
                    }
                }
                
                if (cancelled) return;
                setMultiAppDeployedVersions(versions);
                
                // Run validation
                const validationResult = await validateMultiAppPackage(resolvedRepos, apps, versions, github, stagedFiles[0]?.zipDirs);
                if (!cancelled) {
                    console.log(`[SmartDeploy] Validation: ${validationResult.overallSeverity || 'clean'} — ${validationResult.summary}`);
                    if (validationResult.crossAppIssues?.length) {
                        validationResult.crossAppIssues.forEach(i => console.log(`[SmartDeploy]   ${i.severity}: ${i.title}`));
                    }
                    setMultiAppValidation(validationResult);
                    setMultiAppCheckingVersions(false);
                }
            };
            
            checkVersionsAndValidate();
            return () => { cancelled = true; };
        }, [isMultiApp, stagedFiles.length]);
        
        const [otherCollapsed, setOtherCollapsed] = React.useState(true); // v8.3.3: Collapse "Other" by default
        
        // v8.8.0: Project-based grouping with collapse state
        const [collapsedProjects, setCollapsedProjects] = React.useState(() => {
            // Default: all collapsed except first project with active deployments
            const saved = localStorage.getItem('cc_collapsedProjects');
            return saved ? JSON.parse(saved) : {};
        });
        
        const toggleProject = (projId) => {
            setCollapsedProjects(prev => {
                const next = { ...prev, [projId]: !prev[projId] };
                localStorage.setItem('cc_collapsedProjects', JSON.stringify(next));
                return next;
            });
        };
        
        // v8.36.1: Intelligent deploy target selection
        // Two-repo apps → TEST (safe default), prod-only → PROD, test-only → TEST
        const getSmartTarget = (appId) => {
            const app = apps[appId];
            if (!app) return 'test';
            const hasTest = !!(app.testRepo || app.repos?.test || (app.repoPatterns?.test?.length > 0));
            const hasProd = !!(app.prodRepo || app.repos?.prod || (app.repoPatterns?.prod?.length > 0));
            if (hasTest && hasProd) return 'test';   // Two-repo: safe default to TEST
            if (hasProd && !hasTest) return 'prod';   // Prod-only: must be PROD
            if (hasTest && !hasProd) return 'test';   // Test-only: must be TEST
            return 'test'; // Fallback
        };
        
        // Get available environments for an app (for dropdown filtering)
        const getAvailableTargets = (appId) => {
            const app = apps[appId];
            if (!app) return ['test', 'prod'];
            const hasTest = !!(app.testRepo || app.repos?.test || (app.repoPatterns?.test?.length > 0));
            const hasProd = !!(app.prodRepo || app.repos?.prod || (app.repoPatterns?.prod?.length > 0));
            const targets = [];
            if (hasTest) targets.push('test');
            if (hasProd) targets.push('prod');
            return targets.length > 0 ? targets : ['test', 'prod']; // Fallback to both
        };
        
        // Compatibility: get first deployment for legacy code
        const activeDeployment = activeDeployments?.[0] || null;
        
        // v8.8.0: Group configured apps by project
        const configuredApps = Object.values(apps).filter(a => a.testRepo || a.prodRepo);
        const projects = getProjectsWithApps(apps, config?.projects);
        
        // Legacy grouping (still used by some references)
        const publicApps = configuredApps.filter(a => a.appType === 'public' || !a.appType);
        const internalApps = configuredApps.filter(a => a.appType === 'internal');
        const otherApps = configuredApps.filter(a => a.appType === 'other');
        
        // Doc package validation — runs whenever staged files change
        // Unified package validation — runs on selected files (selection-driven)
        // Note: actual validation computed inside deploy controls where selectedFiles is available
        
        // Config ↔ code drift detection — only when deploying CC itself
        const configDrift = React.useMemo(() => {
            const ccFile = stagedFiles.find(f => 
                f.fileAction === 'deploy' && 
                (f.suggestedApp === 'command-center' || f.name === 'index.html') &&
                f.content?.includes('CC_SEED_MANIFEST')
            );
            if (!ccFile) return null;
            return detectConfigDrift(ccFile.content, config);
        }, [stagedFiles, config]);
        
        // v8.8.0: Auto-expand project when deploy is active
        React.useEffect(() => {
            if (!activeDeployments?.length) return;
            for (const dep of activeDeployments) {
                if (dep.status === 'running' && dep.appId) {
                    const app = apps[dep.appId];
                    const projId = app?.project || 'other';
                    if (collapsedProjects[projId]) {
                        setCollapsedProjects(prev => {
                            const next = { ...prev, [projId]: false };
                            localStorage.setItem('cc_collapsedProjects', JSON.stringify(next));
                            return next;
                        });
                    }
                }
            }
        }, [activeDeployments]);
        
        // Auto-select detected app when staging new files
        React.useEffect(() => {
            if (stagedFiles.length === 0) return;
            
            // Find the most recently added file with high-confidence detection
            const filesWithDetection = stagedFiles.filter(f => f.appDetection?.confidence === 'high' || f.appDetection?.confidence === 'definite');
            if (filesWithDetection.length > 0) {
                const detected = filesWithDetection[filesWithDetection.length - 1].suggestedApp;
                if (detected && apps[detected]) {
                    // v8.36.1: Intelligently select target based on app's repo configuration
                    const targetEnv = getSmartTarget(detected);
                    setDeployTarget(prev => ({ ...prev, appId: detected, target: targetEnv }));
                    console.log(`🎯 Auto-selected app: ${detected}, target: ${targetEnv} (smart default)`);
                    
                    // If app has no repo assigned, try to auto-assign from available repos
                    const app = apps[detected];
                    if (!app.prodRepo && github) {
                        console.log('🔍 No prod repo for', detected, '- attempting auto-assignment...');
                        // Find repo matching this app's patterns
                        github.listRepos().then(repos => {
                            const patterns = app.repoPatterns?.prod || [];
                            for (const pattern of patterns) {
                                const found = repos.find(r => r.name.toLowerCase() === pattern.toLowerCase() && !r.name.toLowerCase().includes('test'));
                                if (found) {
                                    console.log('✅ Auto-assigned prod repo:', found.fullName);
                                    updateApp(detected, { prodRepo: found.fullName });
                                    break;
                                }
                            }
                        }).catch(e => console.warn('Could not auto-assign repo:', e));
                    }
                }
            }
        }, [stagedFiles.length]); // Only when file count changes (new file added)
        
        // Keep deploying state while deployment is running, reset when complete
        React.useEffect(() => {
            if (activeDeployment) {
                if (activeDeployment.status === 'running') {
                    // Keep spinner going while deployment is in progress
                    setIsDeploying(true);
                } else if (activeDeployment.status === 'success' || activeDeployment.status === 'failed' || activeDeployment.status === 'error') {
                    // Only stop spinner when deployment finishes (success or failure)
                    setIsDeploying(false);
                    // Only set deployCompleted if deploy was clicked this session
                    if (activeDeployment.status === 'success' &&
                        activeDeployment.id !== lastCompletedDeployId &&
                        deployClickedThisSession.current) {
                        setDeployCompleted(true);
                        setLastCompletedDeployId(activeDeployment.id);
                    }
                }
            } else {
                // v8.69.0: Reset isDeploying when no active deployment exists
                // (e.g., after auto-close removes deployment, or doc-only push with no deploy)
                setIsDeploying(false);
            }
        }, [activeDeployment, activeDeployment?.status, activeDeployment?.id, lastCompletedDeployId]);
        
        // Reset deployCompleted when staging new files or files change
        const stagedFileIds = stagedFiles.map(f => f.id).join(',');
        React.useEffect(() => {
            // Reset whenever staged files change (new files, different files, or cleared)
            setDeployCompleted(false);
        }, [stagedFileIds]);
        
        // Expanded app menus state
        const [expandedApps, setExpandedApps] = React.useState({});
        const [appInfo, setAppInfo] = React.useState({}); // { appId: { test: {...}, prod: {...} } }
        const [loadingAppInfo, setLoadingAppInfo] = React.useState({});
        
        // Toggle app menu expansion
        const toggleAppExpanded = async (appId) => {
            const newExpanded = !expandedApps[appId];
            setExpandedApps(prev => ({ ...prev, [appId]: newExpanded }));
            
            // Fetch app info if expanding and not already loaded
            if (newExpanded && !appInfo[appId] && github) {
                await fetchAppInfo(appId);
            }
        };
        
        // Fetch commit history and info for an app
        const fetchAppInfo = async (appId) => {
            const app = apps[appId];
            if (!app || !github) return;
            
            setLoadingAppInfo(prev => ({ ...prev, [appId]: true }));
            
            const info = { test: null, prod: null };
            
            try {
                if (app.testRepo) {
                    const [owner, repo] = app.testRepo.split('/');
                    const commits = await github.request(`/repos/${owner}/${repo}/commits?per_page=5`);
                    const repoData = await github.request(`/repos/${owner}/${repo}`);
                    info.test = {
                        lastCommit: commits[0],
                        recentCommits: commits,
                        pushedAt: repoData.pushed_at
                    };
                }
            } catch (e) {
                console.error('Error fetching test repo info:', e);
            }
            
            try {
                if (app.prodRepo) {
                    const [owner, repo] = app.prodRepo.split('/');
                    const commits = await github.request(`/repos/${owner}/${repo}/commits?per_page=5`);
                    const repoData = await github.request(`/repos/${owner}/${repo}`);
                    info.prod = {
                        lastCommit: commits[0],
                        recentCommits: commits,
                        pushedAt: repoData.pushed_at
                    };
                }
            } catch (e) {
                console.error('Error fetching prod repo info:', e);
            }
            
            setAppInfo(prev => ({ ...prev, [appId]: info }));
            setLoadingAppInfo(prev => ({ ...prev, [appId]: false }));
        };
        
        // Force GitHub Pages rebuild by creating an empty commit
        const forceRebuild = async (repo, target, silent = false) => {
            if (!github || !repo) return;
            
            if (!silent) {
                const confirmed = await showConfirm(
                    `This creates an empty commit to trigger GitHub Pages deployment.\n\nThe site should update in 30-90 seconds.`,
                    `Force Rebuild ${target.toUpperCase()}?`
                );
                if (!confirmed) return;
            }
            
            try {
                const [owner, repoName] = repo.split('/');
                
                // Get current commit
                const ref = await github.request(`/repos/${owner}/${repoName}/git/ref/heads/main`);
                const currentSha = ref.object.sha;
                
                // Get current commit details
                const commit = await github.request(`/repos/${owner}/${repoName}/git/commits/${currentSha}`);
                
                // Create new commit with same tree (empty commit)
                const newCommit = await github.request(`/repos/${owner}/${repoName}/git/commits`, {
                    method: 'POST',
                    body: JSON.stringify({
                        message: `Force rebuild - ${new Date().toISOString()}`,
                        tree: commit.tree.sha,
                        parents: [currentSha]
                    })
                });
                
                // Update ref (force: true handles non-fast-forward cases)
                await github.request(`/repos/${owner}/${repoName}/git/refs/heads/main`, {
                    method: 'PATCH',
                    body: JSON.stringify({ sha: newCommit.sha, force: true })
                });
                
                if (!silent) {
                    await showAlert(
                        `GitHub Pages should update in 30-90 seconds.`,
                        `✓ Rebuild Triggered for ${target.toUpperCase()}`
                    );
                }
                
                // Refresh app info
                const appId = Object.entries(apps).find(([id, a]) => a.testRepo === repo || a.prodRepo === repo)?.[0];
                if (appId) {
                    setAppInfo(prev => ({ ...prev, [appId]: null }));
                    fetchAppInfo(appId);
                }
                
                return true;
                
            } catch (e) {
                if (!silent) {
                    await showAlert(`Error: ${e.message}`, 'Rebuild Failed');
                }
                return false;
            }
        };
        
        // Format relative time
        const formatRelativeTime = (dateStr) => {
            if (!dateStr) return '—';
            const date = new Date(dateStr);
            const now = new Date();
            const diffMs = now - date;
            const diffMins = Math.floor(diffMs / 60000);
            const diffHours = Math.floor(diffMs / 3600000);
            const diffDays = Math.floor(diffMs / 86400000);
            
            if (diffMins < 1) return 'just now';
            if (diffMins < 60) return `${diffMins}m ago`;
            if (diffHours < 24) return `${diffHours}h ago`;
            if (diffDays < 7) return `${diffDays}d ago`;
            return date.toLocaleDateString();
        };
        
        // Get actual selected files from staged (ensures fresh content)
        const selectedFiles = stagedFiles.filter(f => selectedFileIds.has(f.id));
        
        // Clean up selections when staged files change
        React.useEffect(() => {
            setSelectedFileIds(prev => {
                const validIds = new Set(stagedFiles.map(f => f.id));
                const newSet = new Set([...prev].filter(id => validIds.has(id)));
                return newSet.size !== prev.size ? newSet : prev;
            });
            setErrorOverride(false); // Reset error override when files change
        }, [stagedFiles]);
        
        // Reset error override when selection changes
        React.useEffect(() => {
            setErrorOverride(false);
        }, [selectedFileIds]);
        
        const toggleFileSelection = (file) => {
            setSelectedFileIds(prev => {
                const newSet = new Set(prev);
                if (newSet.has(file.id)) {
                    newSet.delete(file.id);
                } else {
                    newSet.add(file.id);
                }
                return newSet;
            });
        };
        
        const selectAll = () => setSelectedFileIds(new Set(stagedFiles.map(f => f.id)));
        const selectNone = () => setSelectedFileIds(new Set());
        
        // === Phase 4.1: Product Health Metrics ===
        const productMetrics = React.useMemo(() => {
            const items = globalWorkItems || [];
            const sessions = globalSessions || [];
            const deps = deployments || [];
            const now = Date.now();
            const thirtyDaysAgo = now - (30 * 24 * 60 * 60 * 1000);
            
            // Features shipped this month (done items in last 30 days)
            const shippedThisMonth = items.filter(wi => {
                if (wi.status !== 'done') return false;
                const completedAt = wi.completedAt || wi.updatedAt;
                return completedAt && new Date(completedAt).getTime() > thirtyDaysAgo;
            });
            
            // Pipeline health: items in each active stage
            const pipeline = { idea: 0, ready: 0, 'in-progress': 0, review: 0 };
            const staleItems = [];
            items.forEach(wi => {
                if (pipeline.hasOwnProperty(wi.status)) pipeline[wi.status]++;
                if (WorkItemService.isStale && WorkItemService.isStale(wi)) staleItems.push(wi);
            });
            
            // Session readiness: apps with ready items that have acceptance criteria
            const readyByApp = {};
            items.filter(wi => wi.status === 'ready').forEach(wi => {
                if (!readyByApp[wi.appId]) readyByApp[wi.appId] = { count: 0, withCriteria: 0 };
                readyByApp[wi.appId].count++;
                if (wi.acceptanceCriteria?.length > 0) readyByApp[wi.appId].withCriteria++;
            });
            const readyApps = Object.entries(readyByApp)
                .map(([appId, data]) => ({ appId, ...data, app: apps[appId] }))
                .filter(a => a.app)
                .sort((a, b) => b.withCriteria - a.withCriteria || b.count - a.count);
            
            // Cost per feature (sessions in last 30 days)
            const recentSessions = sessions.filter(s => new Date(s.createdAt).getTime() > thirtyDaysAgo);
            let totalCost = 0;
            recentSessions.forEach(s => {
                const tokens = s.packageTokens || 0;
                const engineId = s.engineId || 'claude-sonnet-4.5';
                const engine = EngineRegistryService.ENGINES[engineId];
                if (engine && tokens > 0) {
                    const inputCost = (tokens / 1000000) * engine.cost.input;
                    const outputCost = ((tokens * 0.3) / 1000000) * engine.cost.output;
                    totalCost += inputCost + outputCost;
                }
            });
            const costPerFeature = shippedThisMonth.length > 0 ? totalCost / shippedThisMonth.length : 0;
            
            // Recent deploys count
            const recentDeploys = deps.filter(d => new Date(d.timestamp || d.date).getTime() > thirtyDaysAgo);
            
            // In-progress sessions (sessions without deploy link)
            const activeSessions = sessions.filter(s => s.status === 'prep' || s.status === 'active');
            
            return { 
                shippedThisMonth, pipeline, staleItems, readyApps, 
                recentSessions, totalCost, costPerFeature, 
                recentDeploys, activeSessions,
                totalActive: pipeline.idea + pipeline.ready + pipeline['in-progress'] + pipeline.review
            };
        }, [globalWorkItems, globalSessions, deployments, apps]);
        
        // Most-ready app for quick session action
        const mostReadyApp = productMetrics.readyApps[0];
        
        // v8.54.0: Compute top-level validation for banner above drop zone
        const topValidation = React.useMemo(() => {
            if (stagedFiles.length === 0) return null;
            const files = stagedFiles.filter(f => selectedFileIds.has(f.id));
            if (files.length === 0) return null;
            const valApp = apps[deployTarget.appId] || null;
            const deployedV = deployTarget.target === 'prod' ? valApp?.currentProdVersion : valApp?.currentTestVersion;
            return validatePackage(files, stagedFiles, valApp, deployedV);
        }, [stagedFiles, selectedFileIds, deployTarget, apps]);
        
        // Detection info for banner
        const topDetection = React.useMemo(() => {
            if (stagedFiles.length === 0) return null;
            const files = stagedFiles.filter(f => selectedFileIds.has(f.id) && f.fileAction !== 'push-doc');
            const detected = files.filter(f => f.appDetection).map(f => ({ app: f.suggestedApp, confidence: f.appDetection.confidence }));
            const primary = detected.find(d => d.confidence === 'high')?.app || detected[0]?.app;
            if (!primary) return null;
            const hasMismatch = primary !== deployTarget.appId;
            return { primary, hasMismatch, appName: apps[primary]?.name, appIcon: apps[primary]?.icon };
        }, [stagedFiles, selectedFileIds, deployTarget, apps]);
        
        return (
            <div className="space-y-6">
                {/* v8.54.0: Validation Banner — above everything when files are staged */}
                {stagedFiles.length > 0 && (topValidation || topDetection) && (
                    <div className={`rounded-lg border p-3 ${
                        topValidation?.severity === 'error' ? 'bg-red-900/30 border-red-600' :
                        topValidation?.severity === 'warning' || topDetection?.hasMismatch ? 'bg-amber-900/30 border-amber-600' :
                        'bg-green-900/20 border-green-600/50'
                    }`}>
                        <div className="flex items-center justify-between gap-3">
                            <div className="flex items-center gap-3 flex-1 min-w-0">
                                {/* Detection status */}
                                {topDetection && (
                                    <span className="flex items-center gap-1.5 text-sm">
                                        {topDetection.hasMismatch ? '⚠️' : '🎯'}
                                        <AppIcon icon={topDetection.appIcon} size={18} />
                                        <strong>{topDetection.appName}</strong>
                                        {topDetection.hasMismatch && (
                                            <span className="text-amber-400 text-xs">(deploying to {apps[deployTarget.appId]?.name})</span>
                                        )}
                                    </span>
                                )}
                                {/* Validation messages */}
                                {topValidation && topValidation.severity !== 'info' && (
                                    <span className={`text-sm ${
                                        topValidation.severity === 'error' ? 'text-red-300' : 'text-amber-300'
                                    }`}>
                                        {topValidation.severity === 'error' ? '⛔' : '⚠️'} {topValidation.summary}
                                    </span>
                                )}
                                {!topValidation && !topDetection?.hasMismatch && (
                                    <span className="text-green-400 text-sm">✓ Ready to deploy</span>
                                )}
                            </div>
                            {/* Quick actions */}
                            <div className="flex items-center gap-2 flex-shrink-0">
                                {topDetection?.hasMismatch && (
                                    <button onClick={() => setDeployTarget(p => ({ ...p, appId: topDetection.primary }))}
                                        className="px-2 py-1 bg-green-700 hover:bg-green-600 rounded text-xs whitespace-nowrap">
                                        Use {topDetection.appName}
                                    </button>
                                )}
                                {topValidation?.claudePrompt && (
                                    <button onClick={() => { navigator.clipboard.writeText(topValidation.claudePrompt); showAlert('Fix prompt copied!', '📋'); }}
                                        className="px-2 py-1 bg-slate-700 hover:bg-slate-600 rounded text-xs whitespace-nowrap flex items-center gap-1">
                                        📋 Copy Fix
                                    </button>
                                )}
                                <span className="text-xs text-slate-500">{stagedFiles.length} file{stagedFiles.length !== 1 ? 's' : ''} staged</span>
                            </div>
                        </div>
                    </div>
                )}
                
                {/* v8.69.6: High-visibility drop zone — bold border, session results callout */}
                <div
                    onDrop={e => { e.currentTarget.setAttribute('data-dragging', 'false'); onFileDrop(e); }}
                    onDragOver={e => { e.preventDefault(); e.currentTarget.setAttribute('data-dragging', 'true'); }}
                    onDragLeave={e => { e.currentTarget.setAttribute('data-dragging', 'false'); }}
                    data-dragging="false"
                    className="relative rounded-xl cursor-pointer group transition-all duration-300 data-[dragging=true]:scale-[1.02] data-[dragging=true]:shadow-[0_0_30px_rgba(99,102,241,0.4)]"
                    style={{
                        background: 'linear-gradient(135deg, #1e1b4b 0%, #312e81 50%, #1e1b4b 100%)',
                        border: '2px solid #6366f1',
                        boxShadow: '0 0 15px rgba(99,102,241,0.15), inset 0 1px 0 rgba(255,255,255,0.05)'
                    }}
                >
                    <input type="file" multiple accept=".html,.js,.css,.json,.zip,.yml,.yaml,.md,.txt" onChange={onFileDrop} className="hidden" id="upload" />
                    <label htmlFor="upload" className="cursor-pointer block py-5 px-6">
                        <div className="flex items-center gap-5">
                            {/* Upload icon */}
                            <div className="w-14 h-14 rounded-xl flex items-center justify-center flex-shrink-0 group-hover:scale-110 transition-transform"
                                style={{ background: 'linear-gradient(135deg, #4f46e5, #7c3aed)' }}>
                                <svg className="w-7 h-7 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2">
                                    <path strokeLinecap="round" strokeLinejoin="round" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12" />
                                </svg>
                            </div>

                            {/* Text content */}
                            <div className="flex-1 min-w-0">
                                <div className="text-base font-bold text-white group-hover:text-indigo-100 transition-colors">
                                    Upload Session Results
                                </div>
                                <div className="text-sm text-indigo-200/60 mt-1">
                                    Finished a Claude session? Drop your session package (.zip) here to import ODRC concepts.
                                </div>
                                <div className="flex items-center gap-3 mt-2">
                                    <span className="inline-flex items-center gap-1 text-xs text-indigo-300/50">
                                        <svg className="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M9 12l2 2 4-4" /></svg>
                                        Session packages
                                    </span>
                                    <span className="inline-flex items-center gap-1 text-xs text-indigo-300/50">
                                        <svg className="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M9 12l2 2 4-4" /></svg>
                                        Deploy code
                                    </span>
                                    <span className="inline-flex items-center gap-1 text-xs text-indigo-300/50">
                                        <svg className="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M9 12l2 2 4-4" /></svg>
                                        Specs & docs
                                    </span>
                                </div>
                            </div>

                            {/* Browse button */}
                            <div className="flex-shrink-0 px-5 py-2.5 rounded-lg text-sm font-semibold text-white group-hover:scale-105 transition-all"
                                style={{ background: 'linear-gradient(135deg, #4f46e5, #7c3aed)', boxShadow: '0 2px 8px rgba(79,70,229,0.4)' }}>
                                Browse Files
                            </div>
                        </div>
                    </label>
                </div>

                {/* Phase 3: Pending ODRC Import banner — always visible */}
                {pendingOdrcImport && (
                    <div className="bg-purple-900/30 border border-purple-600/50 rounded-xl p-4 flex items-center justify-between">
                        <div className="flex items-center gap-3">
                            <span className="text-2xl">💡</span>
                            <div>
                                <div className="text-sm font-medium text-purple-200">ODRC Updates detected — {pendingOdrcImport.parsedUpdates.length} item{pendingOdrcImport.parsedUpdates.length !== 1 ? 's' : ''}</div>
                                <div className="text-xs text-purple-400/70 mt-0.5">
                                    From: {pendingOdrcImport.fileName}
                                    {pendingOdrcImport.metadata?.ideaId && ` · IdeaId: ${pendingOdrcImport.metadata.ideaId}`}
                                    {pendingOdrcImport.metadata?.ideaSlug && ` · Idea: ${pendingOdrcImport.metadata.ideaSlug}`}
                                    {pendingOdrcImport.metadata?.sessionNumber && ` · Session: ${pendingOdrcImport.metadata.sessionNumber}`}
                                </div>
                            </div>
                        </div>
                        <div className="flex gap-2">
                            <button onClick={() => setPendingOdrcImport(null)}
                                className="px-3 py-1.5 text-xs font-medium bg-slate-700 hover:bg-slate-600 text-white rounded-lg transition-colors">
                                Dismiss
                            </button>
                            <button onClick={() => setPendingOdrcImport({ ...pendingOdrcImport, showChecklist: true })}
                                className="px-3 py-1.5 text-xs font-medium bg-purple-600 hover:bg-purple-500 text-white rounded-lg transition-colors">
                                Review & Import
                            </button>
                        </div>
                    </div>
                )}

                {/* v8.65.1: Collapsible Projects/Apps toggle */}
                <div
                    onClick={() => setProjectsCollapsed(prev => !prev)}
                    className="flex items-center gap-2 cursor-pointer text-sm text-slate-400 hover:text-slate-200 transition-colors py-2 select-none"
                >
                    <svg className={'w-4 h-4 transition-transform ' + (projectsCollapsed ? '' : 'rotate-90')} fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M9 5l7 7-7 7" /></svg>
                    <span className="font-semibold">Projects / Apps</span>
                    <span className="text-xs text-slate-600">{configuredApps.length} configured</span>
                    {stagedFiles.length > 0 && <span className="text-xs text-green-400 font-mono ml-auto">📦 {stagedFiles.length} staged</span>}
                </div>

                {/* Staged Files + Active Deployments — always visible (outside collapsible) */}
                {(stagedFiles.length > 0 || (activeDeployments && activeDeployments.length > 0)) && (
                <div className="space-y-6">

                    {/* Staged Files — Multi-App or Single-File view */}
                    {stagedFiles.length > 0 && stagedFiles[0]?.multiApp && (() => {
                        // Multi-app grouped view
                        const appGroups = {};
                        const sharedFiles = [];
                        stagedFiles.forEach(f => {
                            if (f.suggestedApp === '_shared') {
                                sharedFiles.push(f);
                            } else {
                                if (!appGroups[f.suggestedApp]) appGroups[f.suggestedApp] = { files: [], version: null, repo: f.repo, target: f.deployTarget, repoKey: f.repoKey };
                                appGroups[f.suggestedApp].files.push(f);
                                if (f.appVersion) appGroups[f.suggestedApp].version = f.appVersion;
                            }
                        });
                        const appIds = Object.keys(appGroups);
                        const totalFiles = stagedFiles.length;
                        const repoKeys = [...new Set(Object.values(appGroups).map(g => g.repoKey))];
                        
                        return (
                            <div className="bg-slate-800 rounded-xl border border-indigo-500/60 p-6 shadow-lg shadow-indigo-900/20">
                                {/* Header */}
                                <div className="flex items-center justify-between mb-4">
                                    <h2 className="text-lg font-semibold flex items-center gap-2">
                                        📦 Package <span className="text-indigo-400">{appIds.length} app{appIds.length !== 1 ? 's' : ''}{(() => {
                                            const td = stagedFiles.filter(f => f.fileAction === 'push-doc').length;
                                            return td > 0 ? ` + ${td} doc${td !== 1 ? 's' : ''}` : '';
                                        })()}</span>
                                        <span className="text-sm text-slate-400 font-normal">{totalFiles} files across {repoKeys.length} repo{repoKeys.length !== 1 ? 's' : ''}</span>
                                    </h2>
                                    <button onClick={() => {
                                        console.log('[SmartDeploy] Cleared staged files');
                                        setStagedFiles([]);
                                    }} className="px-2 py-1 bg-red-700 hover:bg-red-600 rounded text-xs flex items-center gap-1">
                                        <Icons.Trash /> Clear
                                    </button>
                                </div>
                                
                                {/* Validation banner */}
                                {multiAppValidation && multiAppValidation.overallSeverity && (
                                    <div className={`rounded-lg border p-3 mb-4 ${
                                        multiAppValidation.overallSeverity === 'error' ? 'bg-red-900/20 border-red-700' :
                                        multiAppValidation.overallSeverity === 'warning' ? 'bg-amber-900/20 border-amber-700' :
                                        'bg-blue-900/20 border-blue-700'
                                    }`}>
                                        <div className="flex items-center justify-between">
                                            <div className="flex items-center gap-2 text-sm">
                                                <span>{multiAppValidation.overallSeverity === 'error' ? '🛑' : multiAppValidation.overallSeverity === 'warning' ? '⚠️' : '✅'}</span>
                                                <span className="font-medium">{multiAppValidation.summary}</span>
                                            </div>
                                            {multiAppValidation.overallSeverity !== 'info' && (
                                                <button 
                                                    onClick={() => {
                                                        const issues = [];
                                                        for (const [appId, val] of Object.entries(multiAppValidation.appValidations || {})) {
                                                            if (val?.issues?.length > 0) {
                                                                val.issues.forEach(i => issues.push(`${apps[appId]?.name || appId}: ${i.title} — ${i.fix || i.detail}`));
                                                            }
                                                        }
                                                        (multiAppValidation.crossAppIssues || []).forEach(i => issues.push(`${i.title} — ${i.fix || i.detail}`));
                                                        const prompt = `Fix these validation issues in the deploy package:\n\n${issues.join('\n')}`;
                                                        navigator.clipboard.writeText(prompt);
                                                        showAlert('Fix prompt copied to clipboard. Paste into Claude.', '📋 Copied');
                                                    }}
                                                    className="px-3 py-1.5 bg-orange-700 hover:bg-orange-600 rounded text-xs flex items-center gap-1 text-orange-100"
                                                >
                                                    📋 Copy Fix Prompt
                                                </button>
                                            )}
                                        </div>
                                        {multiAppValidation.crossAppIssues.length > 0 && (() => {
                                            const errorWarnings = multiAppValidation.crossAppIssues.filter(i => i.severity === 'error' || i.severity === 'warning');
                                            const infoIssues = multiAppValidation.crossAppIssues.filter(i => i.severity === 'info');
                                            return (
                                                <div className="mt-2 space-y-1 text-xs">
                                                    {errorWarnings.map((issue, i) => (
                                                        <div key={`ew${i}`} className={issue.severity === 'error' ? 'text-red-300' : 'text-amber-300'}>
                                                            {issue.severity === 'error' ? '✗' : '⚠'} {issue.title}: {issue.detail}
                                                        </div>
                                                    ))}
                                                    {infoIssues.length > 0 && (
                                                        <details className="text-slate-400">
                                                            <summary className="cursor-pointer select-none hover:text-slate-300">
                                                                ℹ️ {infoIssues.length} info note{infoIssues.length !== 1 ? 's' : ''}: {infoIssues.map(i => i.title).join('; ')}
                                                            </summary>
                                                            <div className="mt-1 pl-5 space-y-0.5">
                                                                {infoIssues.map((issue, i) => (
                                                                    <div key={`info${i}`} className="text-slate-500">{issue.detail}</div>
                                                                ))}
                                                            </div>
                                                        </details>
                                                    )}
                                                </div>
                                            );
                                        })()}
                                    </div>
                                )}
                                
                                {/* App rows */}
                                <div className="space-y-1">
                                    {appIds.map(appId => {
                                        const group = appGroups[appId];
                                        const appConfig = apps[appId];
                                        const archiveVer = group.version;
                                        const deployedVer = multiAppDeployedVersions?.[appId];
                                        const appVal = multiAppValidation?.appValidations?.[appId];
                                        const isNew = deployedVer === null || deployedVer === undefined;
                                        const isCurrent = archiveVer && archiveVer === deployedVer;
                                        const hasError = appVal?.severity === 'error';
                                        const hasWarning = appVal?.severity === 'warning';
                                        const deployFiles = group.files.filter(f => f.fileAction !== 'push-doc' && f.fileAction !== 'skip');
                                        const docFiles = group.files.filter(f => f.fileAction === 'push-doc');
                                        
                                        return (
                                            <div key={appId} className="px-4 py-3 rounded-lg bg-slate-700/30 border border-slate-600/50">
                                                <div className="flex items-center gap-3">
                                                    <AppIcon icon={appConfig?.icon} size={20} />
                                                    <span className="font-medium min-w-[140px]">{appConfig?.name || appId}</span>
                                                    
                                                    {/* Version comparison */}
                                                    <span className="font-mono text-sm text-slate-400 min-w-[70px] text-right">
                                                        {multiAppCheckingVersions ? '...' : (deployedVer || '—')}
                                                    </span>
                                                    <span className="text-slate-500">→</span>
                                                    <span className="font-mono text-sm text-indigo-300 min-w-[70px]">
                                                        {archiveVer || '?'}
                                                    </span>
                                                    
                                                    {/* Status */}
                                                    <span className={`px-2 py-0.5 rounded text-xs ${
                                                        hasError ? 'bg-red-900/50 text-red-300' :
                                                        isNew ? 'bg-cyan-900/50 text-cyan-300' :
                                                        isCurrent ? 'bg-green-900/50 text-green-300' :
                                                        hasWarning ? 'bg-amber-900/50 text-amber-300' :
                                                        'bg-amber-900/50 text-amber-300'
                                                    }`}>
                                                        {hasError ? '✗ Error' : isNew ? '🆕 New' : isCurrent ? '✓ Current' : '🔄 Update'}
                                                    </span>
                                                    
                                                    <span className="text-xs text-slate-500 ml-auto">
                                                        {deployFiles.length} file{deployFiles.length !== 1 ? 's' : ''}
                                                        {docFiles.length > 0 && <span className="text-cyan-500"> + {docFiles.length} doc{docFiles.length !== 1 ? 's' : ''}</span>}
                                                    </span>
                                                    
                                                    <span className={`px-1.5 py-0.5 rounded text-xs ${group.target === 'prod' ? 'bg-green-900/50 text-green-300' : 'bg-blue-900/50 text-blue-300'}`}>
                                                        {group.target.toUpperCase()}
                                                    </span>
                                                </div>
                                                
                                                {/* Inline validation issues */}
                                                {appVal?.issues?.length > 0 && (
                                                    <div className="mt-2 ml-8 space-y-1">
                                                        {appVal.issues.map((issue, i) => (
                                                            <div key={i} className={`text-xs ${
                                                                issue.severity === 'error' ? 'text-red-400' :
                                                                issue.severity === 'warning' ? 'text-amber-400' : 'text-slate-500'
                                                            }`}>
                                                                {issue.severity === 'error' ? '✗' : '⚠'} {issue.title}{issue.fix ? ` — ${issue.fix}` : ''}
                                                            </div>
                                                        ))}
                                                    </div>
                                                )}
                                                
                                                {/* Doc files to push */}
                                                {docFiles.length > 0 && (
                                                    <div className="mt-2 ml-8 text-xs text-cyan-400 flex items-center gap-1 flex-wrap">
                                                        📄 {docFiles.map(f => f.name).join(', ')}
                                                    </div>
                                                )}
                                            </div>
                                        );
                                    })}
                                    
                                    {/* Shared files row */}
                                    {sharedFiles.length > 0 && (
                                        <div className="px-4 py-2 text-xs text-slate-500 flex items-center gap-2">
                                            📎 {sharedFiles.length} shared: {sharedFiles.map(f => f.name).join(', ')}
                                        </div>
                                    )}
                                </div>
                                
                                {/* Deploy bar */}
                                <div className="mt-4 flex items-center gap-4">
                                    <button
                                        onClick={async () => {
                                            const hasErrors = multiAppValidation?.overallSeverity === 'error';
                                            if (hasErrors) {
                                                await showAlert('Fix validation errors before deploying.\\n\\nCopy the fix prompt below and send to Claude.', '🛑 Blocked');
                                                return;
                                            }
                                            
                                            const appNames = appIds.map(id => `${apps[id]?.name || id} v${appGroups[id].version || '?'}`);
                                            const confirmed = await showConfirm(
                                                `Deploy ${appIds.length} app(s)?\\n\\n${appNames.map(n => '  • ' + n).join('\\n')}${sharedFiles.length > 0 ? `\\n  + ${sharedFiles.length} shared files` : ''}`,
                                                '📦 Deploy All'
                                            );
                                            if (!confirmed) return;
                                            
                                            setBatchActionRunning(true);
                                            try {
                                            console.log('=== DEPLOY ALL START ===');
                                            console.log(`[SmartDeploy] Deploying ${appIds.length} apps:`, appNames);
                                            
                                            // Group by repoKey and batch deploy
                                            const repoBatches = {};
                                            stagedFiles.forEach(f => {
                                                if (!repoBatches[f.repoKey]) repoBatches[f.repoKey] = { files: [], repo: f.repo, target: f.deployTarget };
                                                repoBatches[f.repoKey].files.push(f);
                                            });
                                            
                                            for (const [rk, batch] of Object.entries(repoBatches)) {
                                                console.log(`[SmartDeploy] Batch: ${rk} → ${batch.repo} (${batch.target}) | ${batch.files.length} files`);
                                                const batchFiles = batch.files.map(f => ({
                                                    id: f.id,
                                                    name: f.name,
                                                    targetPath: f.repoPath,
                                                    fullRepoPath: true,
                                                    content: f.content,
                                                    encoding: f.encoding,
                                                    size: f.size,
                                                    appId: f.suggestedApp,
                                                    version: f.appVersion || f.version
                                                }));
                                                
                                                let primaryAppId = batch.files.find(f => f.suggestedApp && f.suggestedApp !== '_shared' && apps[f.suggestedApp])?.suggestedApp;
                                                
                                                // If no app files in this batch (e.g. only docs/shared), find an app that uses this repo
                                                if (!primaryAppId) {
                                                    primaryAppId = Object.keys(apps).find(id => {
                                                        const a = apps[id];
                                                        return (batch.target === 'test' ? a.testRepo : a.prodRepo) === batch.repo
                                                            || (a.repos?.test === batch.repo || a.repos?.prod === batch.repo);
                                                    });
                                                }
                                                
                                                if (!primaryAppId) {
                                                    console.warn(`[SmartDeploy] No valid app for batch ${rk}, skipping (${batch.files.length} files)`);
                                                    continue;
                                                }
                                                
                                                if (batchFiles.length > 1) {
                                                    await onBatchDeploy(batchFiles, primaryAppId, batch.target);
                                                } else if (batchFiles.length === 1) {
                                                    await onDeploy(batchFiles[0], primaryAppId, batch.target);
                                                }
                                                
                                                // Update versions for ALL apps in this batch, not just primary
                                                const versionKey = batch.target === 'prod' ? 'currentProdVersion' : 'currentTestVersion';
                                                const batchAppIds = [...new Set(batch.files.map(f => f.suggestedApp).filter(id => id && id !== '_shared'))];
                                                for (const batchAppId of batchAppIds) {
                                                    if (batchAppId === primaryAppId) continue; // primary already updated by handleBatchDeploy
                                                    const appVersion = appGroups[batchAppId]?.version;
                                                    if (appVersion) {
                                                        updateApp(batchAppId, { [versionKey]: appVersion, updatedAt: Date.now() });
                                                        console.log(`[SmartDeploy] Updated ${batchAppId} ${versionKey}: ${appVersion}`);
                                                    }
                                                }
                                                
                                                // Inter-batch delay: let GitHub settle before next batch commit
                                                const batchKeys = Object.keys(repoBatches);
                                                if (batchKeys.indexOf(rk) < batchKeys.length - 1) {
                                                    console.log('[SmartDeploy] Waiting 1.5s before next batch...');
                                                    await new Promise(r => setTimeout(r, 1500));
                                                }
                                            }
                                            console.log('=== DEPLOY ALL COMPLETE ===');
                                            
                                            // Check deployed docs for concepts
                                            const docFiles = stagedFiles
                                                .filter(f => f.fileAction === 'push-doc' && f.content && typeof f.content === 'string')
                                                .map(f => ({ name: f.name, content: f.content }));
                                            if (docFiles.length > 0 && showPrompt) {
                                                checkPushedDocsForConcepts(docFiles, globalStreams, showConfirm, showPrompt, {
                                                    uid: firebaseUid,
                                                    updateStream: WorkStreamService.update.bind(WorkStreamService)
                                                }).catch(e => console.error('[Concepts] Error during concept check:', e));
                                            }
                                            } catch (e) {
                                                console.error('[SmartDeploy] Deploy All failed:', e);
                                                await showAlert(`Deploy failed: ${e.message}`, '❌ Error');
                                            } finally {
                                                setBatchActionRunning(false);
                                            }
                                        }}
                                        disabled={multiAppValidation?.overallSeverity === 'error' || multiAppCheckingVersions || batchActionRunning}
                                        className={`px-6 py-2 rounded-lg font-medium flex items-center gap-2 ${
                                            batchActionRunning 
                                                ? 'bg-emerald-700 cursor-wait' 
                                                : 'bg-green-600 hover:bg-green-500 disabled:opacity-40 disabled:hover:bg-green-600'
                                        }`}
                                    >
                                        {batchActionRunning ? (
                                            <>
                                                <div className="w-4 h-4 border-2 border-white border-t-transparent rounded-full animate-spin" />
                                                Deploying...
                                            </>
                                        ) : (
                                            <>🚀 Deploy All ({appIds.length} app{appIds.length !== 1 ? 's' : ''}{(() => {
                                            const totalDocs = stagedFiles.filter(f => f.fileAction === 'push-doc').length;
                                            return totalDocs > 0 ? ` + ${totalDocs} doc${totalDocs !== 1 ? 's' : ''}` : '';
                                        })()})</>
                                        )}
                                    </button>
                                    
                                    {multiAppCheckingVersions && (
                                        <span className="text-xs text-slate-400 flex items-center gap-2">
                                            <div className="w-3 h-3 border-2 border-indigo-400 border-t-transparent rounded-full animate-spin" />
                                            Checking deployed versions...
                                        </span>
                                    )}
                                </div>
                            </div>
                        );
                    })()}
                    
                    {/* Staged Files — Single file view (non-multi-app) */}
                    {stagedFiles.length > 0 && !stagedFiles[0]?.multiApp && (
                        <div className="bg-slate-800 rounded-xl border border-indigo-500/60 p-6 shadow-lg shadow-indigo-900/20">
                            <div className="flex items-center justify-between mb-4">
                                <h2 className="text-lg font-semibold flex items-center gap-2">📦 Staged <span className="text-indigo-400">({stagedFiles.length})</span></h2>
                                <div className="flex gap-2 text-xs">
                                    <button onClick={selectAll} className="px-2 py-1 bg-slate-700 rounded hover:bg-slate-600">Select All</button>
                                    <button onClick={selectNone} className="px-2 py-1 bg-slate-700 rounded hover:bg-slate-600">Select None</button>
                                    <button onClick={() => {
                                        setSelectedFileIds(new Set());
                                        stagedFiles.forEach(f => onRemove(f.id));
                                    }} className="px-2 py-1 bg-red-700 hover:bg-red-600 rounded flex items-center gap-1">
                                        <Icons.Trash /> Clear All
                                    </button>
                                </div>
                            </div>
                            
                            {/* Doc validation now handled by unified panel in deploy controls */}
                            
                            {/* Config ↔ Code Drift Banner (CC self-deploy only) */}
                            {configDrift && configDrift.drifts.length > 0 && (() => {
                                const hasCritical = configDrift.errorCount > 0 || configDrift.warnCount > 0;
                                const borderColor = configDrift.errorCount > 0 
                                    ? 'bg-red-900/20 border-red-700/50' 
                                    : configDrift.warnCount > 0 
                                        ? 'bg-orange-900/20 border-orange-700/50'
                                        : 'bg-slate-800/50 border-slate-700/50';
                                const textColor = configDrift.errorCount > 0 ? 'text-red-300' : configDrift.warnCount > 0 ? 'text-orange-300' : 'text-slate-400';
                                
                                return (
                                    <details className={`mb-4 rounded-lg border ${borderColor}`} open={hasCritical || undefined}>
                                        <summary className={`p-3 cursor-pointer select-none flex items-center justify-between ${textColor}`}>
                                            <div className="text-sm font-medium flex items-center gap-2">
                                                {configDrift.errorCount > 0 ? '🔴' : configDrift.warnCount > 0 ? '⚠️' : 'ℹ️'} Config ↔ Code Drift
                                                <span className="text-xs opacity-70">
                                                    ({configDrift.errorCount > 0 ? `${configDrift.errorCount} errors, ` : ''}{configDrift.warnCount > 0 ? `${configDrift.warnCount} mismatches, ` : ''}{configDrift.infoCount} info)
                                                </span>
                                            </div>
                                            {hasCritical && configDrift.claudePrompt && (
                                                <button
                                                    onClick={(e) => {
                                                        e.preventDefault();
                                                        navigator.clipboard.writeText(configDrift.claudePrompt);
                                                        showAlert('Copied to clipboard! Paste this into Claude to fix the seed values.', '📋 Drift Fix Prompt Copied');
                                                    }}
                                                    className={`px-2 py-1 text-xs rounded flex items-center gap-1 ${
                                                        configDrift.errorCount > 0 ? 'bg-red-700 hover:bg-red-600 text-red-100' : 'bg-orange-700 hover:bg-orange-600 text-orange-100'
                                                    }`}
                                                >
                                                    📋 Copy Fix Prompt
                                                </button>
                                            )}
                                        </summary>
                                        
                                        <div className="px-3 pb-3">
                                            <div className="text-xs space-y-0.5 max-h-32 overflow-y-auto">
                                                {configDrift.drifts.filter(d => d.severity === 'error').map((d, i) => (
                                                    <div key={`e${i}`} className="text-red-400">🔴 {d.detail}</div>
                                                ))}
                                                {configDrift.drifts.filter(d => d.severity === 'warn').map((d, i) => (
                                                    <div key={`w${i}`} className="text-orange-400">⚠️ {d.detail}</div>
                                                ))}
                                                {configDrift.drifts.filter(d => d.severity === 'info').map((d, i) => (
                                                    <div key={`i${i}`} className="text-blue-400">ℹ️ {d.detail}</div>
                                                ))}
                                            </div>
                                            
                                            {configDrift.claudePrompt && (
                                                <details className="mt-2">
                                                    <summary className="text-xs text-slate-500 cursor-pointer hover:text-slate-400">Show Claude fix prompt</summary>
                                                    <div className="relative mt-1.5">
                                                        <pre className="p-2 pr-16 bg-slate-900 rounded text-xs text-slate-300 whitespace-pre-wrap overflow-x-auto border border-slate-700">{configDrift.claudePrompt}</pre>
                                                        <button onClick={() => { navigator.clipboard.writeText(configDrift.claudePrompt); showAlert('Copied!', '📋'); }}
                                                            className="absolute top-2 right-2 px-2 py-1 text-xs bg-slate-700 hover:bg-slate-600 rounded text-slate-300">
                                                            📋 Copy
                                                        </button>
                                                    </div>
                                                </details>
                                            )}
                                        </div>
                                    </details>
                                );
                            })()}
                            
                            {/* Batch Deploy Controls - At top for easy access */}
                            {selectedFiles.length > 0 && (() => {
                                // Only show deploy controls for deploy-type files
                                const selectedDeployFiles = selectedFiles.filter(f => f.fileAction !== 'push-doc');
                                const selectedDocFiles = selectedFiles.filter(f => f.fileAction === 'push-doc');
                                
                                if (selectedDeployFiles.length === 0 && selectedDocFiles.length === 0) return null;
                                
                                // Check if selected deploy files have detected apps
                                const detectedApps = selectedDeployFiles
                                    .filter(f => f.appDetection)
                                    .map(f => ({ file: f.name, app: f.suggestedApp, confidence: f.appDetection.confidence }));
                                
                                const uniqueDetected = [...new Set(detectedApps.map(d => d.app))];
                                const primaryDetected = detectedApps.find(d => d.confidence === 'high')?.app || uniqueDetected[0];
                                
                                // Check for mismatch
                                const hasMismatch = primaryDetected && deployTarget.appId !== primaryDetected;
                                const hasConflict = uniqueDetected.length > 1;
                                
                                // Unified validation — computed once, used by panel and deploy button
                                const valAppConfig = apps[deployTarget.appId] || null;
                                const valDeployedVersion = deployTarget.target === 'prod'
                                    ? valAppConfig?.currentProdVersion
                                    : valAppConfig?.currentTestVersion;
                                const validation = validatePackage(selectedFiles, stagedFiles, valAppConfig, valDeployedVersion);
                                
                                return (
                                <div className="mb-4 p-4 bg-slate-900 rounded-lg border border-indigo-500">
                                    <div className="text-sm font-medium mb-3 flex items-center gap-2">
                                        <Icons.Upload /> {selectedDeployFiles.length > 0 ? `Deploy ${selectedDeployFiles.length} file${selectedDeployFiles.length !== 1 ? 's' : ''}` : ''}{selectedDeployFiles.length > 0 && selectedDocFiles.length > 0 ? ' + ' : ''}{selectedDocFiles.length > 0 ? `Push ${selectedDocFiles.length} doc${selectedDocFiles.length !== 1 ? 's' : ''}` : ''}
                                    </div>
                                    
                                    {/* Auto-detected app suggestion */}
                                    {primaryDetected && !hasConflict && (
                                        <div className={`mb-3 p-2 rounded text-sm flex items-center justify-between ${
                                            hasMismatch ? 'bg-amber-900/50 border border-amber-600' : 'bg-green-900/50 border border-green-600'
                                        }`}>
                                            <span className="flex items-center gap-2">
                                                {hasMismatch ? '⚠️' : '🎯'} Detected: <strong className="flex items-center gap-1"><AppIcon icon={apps[primaryDetected]?.icon} size={18} /> {apps[primaryDetected]?.name}</strong>
                                            </span>
                                            {hasMismatch && (
                                                <button 
                                                    onClick={() => setDeployTarget(p => ({ ...p, appId: primaryDetected }))}
                                                    className="px-2 py-1 bg-green-700 hover:bg-green-600 rounded text-xs">
                                                    Use Detected
                                                </button>
                                            )}
                                        </div>
                                    )}
                                    
                                    {/* Conflict warning */}
                                    {hasConflict && (
                                        <div className="mb-3 p-2 bg-red-900/50 border border-red-600 rounded text-sm">
                                            ⚠️ Multiple apps detected in selection: {uniqueDetected.map(a => apps[a]?.name).join(', ')}
                                        </div>
                                    )}
                                    
                                    <div className="grid grid-cols-2 gap-3 mb-3">
                                        <select value={deployTarget.appId} onChange={e => {
                                            const newAppId = e.target.value;
                                            // v8.36.1: Smart default based on app's repo configuration
                                            setDeployTarget({ appId: newAppId, target: getSmartTarget(newAppId) });
                                        }}
                                            className={`p-2 border rounded text-sm ${
                                                hasMismatch 
                                                    ? 'bg-amber-900 border-amber-500' 
                                                    : 'bg-slate-700 border-slate-600'
                                            }`}>
                                            {Object.values(apps).map(a => <option key={a.id} value={a.id}>{getAppEmoji(a.icon)} {a.name}</option>)}
                                        </select>
                                        <select value={deployTarget.target} onChange={e => setDeployTarget(p => ({ ...p, target: e.target.value }))}
                                            className="p-2 bg-slate-700 border border-slate-600 rounded text-sm">
                                            {getAvailableTargets(deployTarget.appId).map(t => (
                                                <option key={t} value={t}>{t === 'test' ? '🧪 TEST' : '🚀 PROD'}</option>
                                            ))}
                                        </select>
                                    </div>
                                    
                                    {/* Mismatch warning on deploy button */}
                                    {hasMismatch && (
                                        <div className="mb-2 text-xs text-amber-400">
                                            ⚠️ You're deploying to {apps[deployTarget.appId]?.name} but file appears to be {apps[primaryDetected]?.name}
                                        </div>
                                    )}
                                    
                                    {/* === UNIFIED VALIDATION PANEL === */}
                                    {(() => {
                                        if (!validation) return null;
                                        
                                        const panelBg = validation.severity === 'error'
                                            ? 'bg-red-900/20 border-red-700/50'
                                            : validation.severity === 'warning'
                                                ? 'bg-amber-900/20 border-amber-700/50'
                                                : 'bg-slate-800/50 border-slate-600/50';
                                        const panelText = validation.severity === 'error'
                                            ? 'text-red-300'
                                            : validation.severity === 'warning'
                                                ? 'text-amber-300'
                                                : 'text-slate-400';
                                        const isInfoOnly = validation.severity === 'info';
                                        
                                        const errorIssues = validation.issues.filter(i => i.severity === 'error');
                                        const warnIssues = validation.issues.filter(i => i.severity === 'warning');
                                        const infoIssues = validation.issues.filter(i => i.severity === 'info');
                                        
                                        
                                        return isInfoOnly ? (
                                            // Info: single collapsed line
                                            <details className={`mb-3 rounded-lg border ${panelBg}`}>
                                                <summary className={`p-2 cursor-pointer select-none text-xs ${panelText} flex items-center gap-1.5`}>
                                                    ℹ️ {infoIssues.map(i => i.detail).join('; ')}
                                                </summary>
                                                {validation.claudePrompt && (
                                                    <div className="px-2 pb-2">
                                                        <pre className="p-2 bg-slate-900 rounded text-xs text-slate-400 whitespace-pre-wrap border border-slate-700">{validation.claudePrompt}</pre>
                                                    </div>
                                                )}
                                            </details>
                                        ) : (
                                            // Warning/Error: expanded panel
                                            <div className={`mb-3 p-3 rounded-lg border ${panelBg}`}>
                                                <div className="flex items-center justify-between mb-2">
                                                    <div className={`text-xs font-medium ${panelText} flex items-center gap-1.5`}>
                                                        {validation.severity === 'error' ? '⛔' : '⚠️'} {validation.summary}
                                                    </div>
                                                    {validation.claudePrompt && (
                                                        <button
                                                            onClick={() => {
                                                                navigator.clipboard.writeText(validation.claudePrompt);
                                                                showAlert('Copied to clipboard! Paste into Claude to fix.', '📋 Fix Prompt Copied');
                                                            }}
                                                            className={`px-2 py-1 text-xs rounded flex items-center gap-1 ${
                                                                validation.severity === 'error' 
                                                                    ? 'bg-red-700 hover:bg-red-600 text-red-100' 
                                                                    : 'bg-amber-700 hover:bg-amber-600 text-amber-100'
                                                            }`}
                                                        >
                                                            📋 Copy Fix Prompt
                                                        </button>
                                                    )}
                                                </div>
                                                
                                                <div className="text-xs space-y-1.5">
                                                    {errorIssues.map((issue, i) => (
                                                        <div key={`e${i}`} className="text-red-400 flex items-start gap-1.5">
                                                            <span className="flex-shrink-0">🔴</span>
                                                            <span>{issue.detail}</span>
                                                        </div>
                                                    ))}
                                                    {warnIssues.map((issue, i) => (
                                                        <div key={`w${i}`}>
                                                            <div className="text-amber-400 flex items-start gap-1.5">
                                                                <span className="flex-shrink-0">🟡</span>
                                                                <span>{issue.detail}</span>
                                                            </div>
                                                            {/* Version bump action (code-only flow) */}
                                                            {issue.action?.type === 'bump-version' && (
                                                                <div className="ml-5 mt-1.5 flex items-center gap-2 flex-wrap">
                                                                    <button
                                                                        onClick={() => {
                                                                            const newV = issue.action.suggested;
                                                                            // Bump index.html
                                                                            const idxFile = stagedFiles.find(f => f.name === 'index.html' && f.fileAction === 'deploy');
                                                                            if (idxFile) {
                                                                                const fixedHtml = fixVersionsInContent(idxFile.content, newV);
                                                                                const newValidation = validateVersions(fixedHtml, idxFile.name);
                                                                                onUpdateStagedFile(idxFile.id, { content: fixedHtml, version: newV, versionValidation: newValidation });
                                                                            }
                                                                            // Bump sw.js
                                                                            const swFile = stagedFiles.find(f => f.name === 'sw.js' && f.fileAction === 'deploy');
                                                                            if (swFile && swFile.content) {
                                                                                const fixedSw = swFile.content.replace(
                                                                                    /(CACHE_VERSION\s*=\s*['"])v?[^'"]*(['"])/g,
                                                                                    `$1v${newV}$2`
                                                                                );
                                                                                onUpdateStagedFile(swFile.id, { content: fixedSw, version: newV });
                                                                            }
                                                                            showAlert(`Bumped to v${newV}`, '✅ Version Updated');
                                                                        }}
                                                                        className="px-2 py-1 bg-green-700 hover:bg-green-600 text-xs rounded text-green-100 flex items-center gap-1"
                                                                    >
                                                                        🔧 Bump to v{issue.action.suggested}
                                                                    </button>
                                                                    <span className="text-slate-500 text-xs">or</span>
                                                                    <input
                                                                        type="text"
                                                                        placeholder="x.x.x"
                                                                        className="w-20 px-2 py-1 bg-slate-900 border border-slate-600 rounded text-xs text-white"
                                                                        onKeyDown={(e) => {
                                                                            if (e.key === 'Enter' && e.target.value.match(/^\d+\.\d+\.\d+$/)) {
                                                                                const newV = e.target.value;
                                                                                const idxFile = stagedFiles.find(f => f.name === 'index.html' && f.fileAction === 'deploy');
                                                                                if (idxFile) {
                                                                                    const fixedHtml = fixVersionsInContent(idxFile.content, newV);
                                                                                    const newValidation = validateVersions(fixedHtml, idxFile.name);
                                                                                    onUpdateStagedFile(idxFile.id, { content: fixedHtml, version: newV, versionValidation: newValidation });
                                                                                }
                                                                                const swFile = stagedFiles.find(f => f.name === 'sw.js' && f.fileAction === 'deploy');
                                                                                if (swFile && swFile.content) {
                                                                                    const fixedSw = swFile.content.replace(
                                                                                        /(CACHE_VERSION\s*=\s*['"])v?[^'"]*(['"])/g,
                                                                                        `$1v${newV}$2`
                                                                                    );
                                                                                    onUpdateStagedFile(swFile.id, { content: fixedSw, version: newV });
                                                                                }
                                                                                showAlert(`Bumped to v${newV}`, '✅ Version Updated');
                                                                                e.target.value = '';
                                                                            }
                                                                        }}
                                                                    />
                                                                    <button
                                                                        onClick={() => {
                                                                            // Mark as dismissed — just deploy as-is
                                                                            // The deploy button already works, this is just UX clarity
                                                                        }}
                                                                        className="px-2 py-1 text-slate-500 hover:text-slate-300 text-xs"
                                                                    >
                                                                        Deploy as-is
                                                                    </button>
                                                                </div>
                                                            )}
                                                        </div>
                                                    ))}
                                                    {infoIssues.map((issue, i) => (
                                                        <div key={`i${i}`} className="text-slate-500 flex items-start gap-1.5">
                                                            <span className="flex-shrink-0">ℹ️</span>
                                                            <span>{issue.detail}</span>
                                                        </div>
                                                    ))}
                                                </div>
                                                
                                                {/* Claude prompt expandable */}
                                                {validation.claudePrompt && (
                                                    <details className="mt-2">
                                                        <summary className={`text-xs cursor-pointer hover:opacity-80 ${
                                                            validation.severity === 'error' ? 'text-red-500' : 'text-amber-500'
                                                        }`}>Show Claude fix prompt</summary>
                                                        <div className="relative mt-1.5">
                                                            <pre className="p-2 pr-16 bg-slate-900 rounded text-xs text-slate-300 whitespace-pre-wrap overflow-x-auto border border-slate-700">{validation.claudePrompt}</pre>
                                                            <button onClick={() => { navigator.clipboard.writeText(validation.claudePrompt); showAlert('Copied!', '📋'); }}
                                                                className="absolute top-2 right-2 px-2 py-1 text-xs bg-slate-700 hover:bg-slate-600 rounded text-slate-300">
                                                                📋 Copy
                                                            </button>
                                                        </div>
                                                    </details>
                                                )}
                                                
                                                {/* Error override checkbox */}
                                                {validation.severity === 'error' && (
                                                    <label className="mt-2 flex items-start gap-2 text-xs text-red-400 cursor-pointer select-none">
                                                        <input type="checkbox" className="mt-0.5"
                                                            checked={errorOverride}
                                                            onChange={e => setErrorOverride(e.target.checked)}
                                                        />
                                                        <span>I understand these issues may break the app for users — deploy anyway</span>
                                                    </label>
                                                )}
                                            </div>
                                        );
                                    })()}
                                    
                                    {/* Deploy Button */}
                                    {(() => {
                                        const hasValidationError = validation?.severity === 'error' && !errorOverride;
                                        
                                        const buttonDisabled = !github || isDeploying || batchActionRunning || hasValidationError;
                                        const buttonStyle = (() => {
                                            if (isDeploying || batchActionRunning) return 'bg-emerald-700 cursor-wait';
                                            if (deployCompleted) return 'bg-orange-500 hover:bg-orange-600';
                                            if (hasValidationError) return 'bg-slate-600 cursor-not-allowed opacity-50';
                                            if (validation?.severity === 'error' && errorOverride) return 'bg-red-600 hover:bg-red-700';
                                            if (validation?.severity === 'warning') return 'bg-amber-600 hover:bg-amber-700';
                                            if (hasMismatch) return 'bg-amber-600 hover:bg-amber-700';
                                            return deployTarget.target === 'prod' ? 'bg-green-600 hover:bg-green-700' : 'bg-blue-600 hover:bg-blue-700';
                                        })();
                                        
                                        const buttonPrefix = (() => {
                                            if (isDeploying || deployCompleted || batchActionRunning) return '';
                                            if (hasValidationError) return '🚫 ';
                                            if (validation?.severity === 'error' && errorOverride) return '⚠️ ';
                                            if (validation?.severity === 'warning') return '⚠️ ';
                                            if (hasMismatch) return '⚠️ ';
                                            return '';
                                        })();
                                        
                                        return (
                                        <button onClick={async () => {
                                            setDeployCompleted(false);
                                            
                                            const executeBatchAction = async () => {
                                                setIsDeploying(true);
                                                setBatchActionRunning(true);
                                                deployClickedThisSession.current = true;
                                                
                                                try {
                                                if (selectedDeployFiles.length > 0) {
                                                    console.log('Deploying files:', selectedDeployFiles.map(f => ({ name: f.name, id: f.id, size: f.content?.length })));
                                                    await onBatchDeploy(selectedDeployFiles, deployTarget.appId, deployTarget.target);
                                                }
                                                
                                                if (selectedDocFiles.length > 0 && github) {
                                                    const app = apps[deployTarget.appId];
                                                    const repo = deployTarget.target === 'prod'
                                                        ? (app?.repos?.prod || app?.prodRepo || app?.repos?.test || app?.testRepo)
                                                        : (app?.repos?.test || app?.testRepo || app?.repos?.prod || app?.prodRepo);
                                                    if (repo) {
                                                        console.log('Pushing docs to:', repo);
                                                        const pushedDocIds = [];
                                                        const actuallyPushedDocs = [];
                                                        for (const doc of selectedDocFiles) {
                                                            try {
                                                                const existing = await github.getFile(repo, doc.targetPath);
                                                                const sha = existing?.sha || null;
                                                                
                                                                // Skip if content is identical to what's in the repo
                                                                if (existing && isDocUnchanged(existing, doc.content)) {
                                                                    console.log(`⏭️ ${doc.name} unchanged, skipping push`);
                                                                    pushedDocIds.push(doc.id);
                                                                    continue;
                                                                }
                                                                
                                                                await github.createOrUpdateFile(
                                                                    repo,
                                                                    doc.targetPath,
                                                                    doc.content,
                                                                    `${sha ? 'Update' : 'Add'} ${doc.name} via Command Center`,
                                                                    sha
                                                                );
                                                                console.log(`✅ Pushed ${doc.name} → ${repo}/${doc.targetPath}`);
                                                                pushedDocIds.push(doc.id);
                                                                actuallyPushedDocs.push({ name: doc.name, content: doc.content });
                                                            } catch (e) {
                                                                console.error(`❌ Failed to push ${doc.name}:`, e.message);
                                                            }
                                                        }
                                                        if (pushedDocIds.length > 0) {
                                                            setStagedFiles(prev => prev.filter(f => !pushedDocIds.includes(f.id)));
                                                            const skipped = pushedDocIds.length - actuallyPushedDocs.length;
                                                            const summary = actuallyPushedDocs.map(d => d.name).join(', ');
                                                            const msg = skipped > 0
                                                                ? `Pushed ${actuallyPushedDocs.length} doc${actuallyPushedDocs.length !== 1 ? 's' : ''} (${skipped} unchanged): ${summary}`
                                                                : `Pushed ${actuallyPushedDocs.length} doc${actuallyPushedDocs.length !== 1 ? 's' : ''}: ${summary}`;
                                                            await showAlert(msg, '📄 Docs Pushed');

                                                            // Check actually-changed docs for concepts (skip unchanged)
                                                            if (actuallyPushedDocs.length > 0) {
                                                                checkPushedDocsForConcepts(actuallyPushedDocs, globalStreams, showConfirm, showPrompt, {
                                                                    uid: firebaseUid,
                                                                    updateStream: WorkStreamService.update.bind(WorkStreamService)
                                                                }).catch(e => console.error('[Concepts] Error during concept check:', e));
                                                            }
                                                        } else if (totalDocs > 0) {
                                                            await showAlert('No docs were pushed — check console for errors.', '⚠️ Doc Push Failed');
                                                        }
                                                    }
                                                }
                                                } finally {
                                                    setBatchActionRunning(false);
                                                    // v8.69.0: Reset isDeploying for doc-only pushes (no activeDeployment created)
                                                    if (selectedDeployFiles.length === 0) {
                                                        setIsDeploying(false);
                                                        setDeployCompleted(true);
                                                    }
                                                }
                                                
                                                // v8.36.1: Smart reset — use app's intelligent default, not always TEST
                                                setDeployTarget(prev => ({ ...prev, target: getSmartTarget(prev.appId) }));
                                            };
                                            
                                            if (hasMismatch) {
                                                const confirmed = await showConfirm(
                                                    `File detected as ${apps[primaryDetected]?.name} but deploying to ${apps[deployTarget.appId]?.name}. Continue anyway?`,
                                                    'Deploy Mismatch Warning'
                                                );
                                                if (confirmed) await executeBatchAction();
                                            } else {
                                                await executeBatchAction();
                                            }
                                        }}
                                            disabled={buttonDisabled}
                                            className={`w-full p-3 rounded font-medium flex items-center justify-center gap-2 transition-all ${buttonStyle}`}>
                                            {isDeploying || batchActionRunning ? (
                                                <>
                                                    <div className="w-4 h-4 border-2 border-white border-t-transparent rounded-full animate-spin" />
                                                    {batchActionRunning && !isDeploying ? 'Pushing docs...' : 'Deploying...'}
                                                </>
                                            ) : deployCompleted ? (
                                                <>
                                                    ✓ Deployed! Click to deploy again
                                                </>
                                            ) : hasValidationError ? (
                                                <>
                                                    🚫 Fix errors to deploy
                                                </>
                                            ) : (
                                                <>
                                                    {buttonPrefix}{selectedDeployFiles.length > 0 
                                                        ? (selectedDeployFiles.length === 1 ? 'Deploy File' : `Batch Deploy ${selectedDeployFiles.length} Files`)
                                                        : ''}{selectedDeployFiles.length > 0 && selectedDocFiles.length > 0 ? ' + ' : ''}{selectedDocFiles.length > 0 ? `Push ${selectedDocFiles.length} Docs` : ''}
                                                    {' → '}{deployTarget.target.toUpperCase()}
                                                </>
                                            )}
                                        </button>
                                        );
                                    })()}
                                </div>
                                );
                            })()}
                            
                            {/* File List */}
                            <div className="space-y-2">
                                {stagedFiles.map(f => {
                                    const isHtml = f.name.endsWith('.html');
                                    const willRename = isHtml && f.targetPath === 'index.html' && f.name !== 'index.html';
                                    
                                    return (
                                    <div key={f.id} className={`p-3 rounded-lg border ${
                                        selectedFileIds.has(f.id) ? 'bg-indigo-900/50 border-indigo-500' : 'bg-slate-700/50 border-slate-600'
                                    }`}>
                                        <div className="flex items-center gap-3">
                                            <input type="checkbox" checked={selectedFileIds.has(f.id)}
                                                onChange={() => toggleFileSelection(f)} className="w-4 h-4" />
                                            <span className="text-xl">{getFileIcon(f.name)}</span>
                                            <div className="flex-1 min-w-0">
                                                {/* Source filename */}
                                                <div className="font-medium truncate text-slate-300">{f.name}</div>
                                                
                                                {/* File info */}
                                                <div className="text-xs text-slate-400 flex items-center gap-2 flex-wrap mt-0.5">
                                                    {formatBytes(f.size)}
                                                    {f.version && (
                                                        <span className="px-1.5 py-0.5 bg-slate-600 rounded">
                                                            {formatVersion(f.version)}
                                                            {f.versionSource === 'html' && <span className="text-green-400 ml-1">✓</span>}
                                                        </span>
                                                    )}
                                                    {/* App detection badge */}
                                                    {f.suggestedApp && apps[f.suggestedApp] && (
                                                        <span className={`px-1.5 py-0.5 rounded flex items-center gap-1 ${
                                                            f.appDetection 
                                                                ? f.appDetection.method === 'gs-app-id'
                                                                    ? 'bg-emerald-700 text-emerald-100'
                                                                    : f.appDetection.confidence === 'high' 
                                                                        ? 'bg-green-700 text-green-100' 
                                                                        : 'bg-yellow-700 text-yellow-100'
                                                                : 'bg-slate-600 text-slate-300'
                                                        }`} title={f.appDetection 
                                                            ? f.appDetection.method === 'gs-app-id'
                                                                ? 'Identified by gs-app-id meta tag (definite)'
                                                                : `Detected by pattern matching (${f.appDetection.matchCount} matches)`
                                                            : 'From filename'}>
                                                            <AppIcon icon={apps[f.suggestedApp].icon} size={16} />
                                                            <span>{apps[f.suggestedApp].name}</span>
                                                            {f.appDetection && (
                                                                <span className="text-xs opacity-75">
                                                                    {f.appDetection.method === 'gs-app-id' ? '✓' : f.appDetection.confidence === 'high' ? '🎯' : '❓'}
                                                                </span>
                                                            )}
                                                        </span>
                                                    )}
                                                    {!f.isText && <span className="text-amber-400">binary</span>}
                                                </div>
                                                
                                                {/* Target path section */}
                                                <div className={`mt-2 p-2 rounded border ${
                                                    f.fileAction === 'push-doc' 
                                                        ? 'bg-cyan-900/20 border-cyan-700/50' 
                                                        : 'bg-slate-800 border-slate-600'
                                                }`}>
                                                    <div className="text-xs text-slate-500 mb-1">
                                                        {f.fileAction === 'push-doc' ? '📄 Push to repo:' : 'Deploy as:'}
                                                    </div>
                                                    <div className="flex items-center gap-2">
                                                        <input type="text" value={f.targetPath} 
                                                            onChange={e => onUpdateStagedFile(f.id, { targetPath: e.target.value })}
                                                            onClick={e => e.stopPropagation()}
                                                            className="flex-1 text-sm bg-slate-900 border border-slate-500 rounded px-2 py-1 font-mono text-white"
                                                            placeholder="index.html" />
                                                        {isHtml && f.name !== 'index.html' && (
                                                            <button 
                                                                onClick={(e) => {
                                                                    e.stopPropagation();
                                                                    onUpdateStagedFile(f.id, { 
                                                                        targetPath: f.targetPath === 'index.html' ? f.name : 'index.html' 
                                                                    });
                                                                }}
                                                                className={`px-2 py-1 text-xs rounded whitespace-nowrap ${
                                                                    f.targetPath === 'index.html' 
                                                                        ? 'bg-green-700 text-green-100' 
                                                                        : 'bg-slate-600 text-slate-300 hover:bg-slate-500'
                                                                }`}>
                                                                {f.targetPath === 'index.html' ? '✓ Replace index.html' : 'Use index.html'}
                                                            </button>
                                                        )}
                                                    </div>
                                                    {willRename && (
                                                        <div className="mt-1.5 text-xs text-green-400 flex items-center gap-1">
                                                            <span>📝</span> Will replace existing index.html
                                                        </div>
                                                    )}
                                                    {isHtml && f.targetPath !== 'index.html' && f.name !== 'index.html' && (
                                                        <div className="mt-1.5 text-xs text-amber-400 flex items-center gap-1">
                                                            <span>⚠️</span> Will create new file (won't replace index.html)
                                                        </div>
                                                    )}
                                                    
                                                    {/* Version warnings */}
                                                    {f.versionValidation && !f.versionValidation.isValid && (
                                                        <div className="mt-2 p-2 bg-red-900/30 border border-red-700 rounded">
                                                            <div className="flex items-center justify-between mb-2">
                                                                <div className="text-xs font-medium text-red-300 flex items-center gap-1">
                                                                    🔴 Version Issues Detected
                                                                </div>
                                                                <button 
                                                                    onClick={async (e) => {
                                                                        e.stopPropagation();
                                                                        let targetVersion = f.version;
                                                                        if (!targetVersion) {
                                                                            targetVersion = await showPrompt(
                                                                                'What version should all version strings be set to?',
                                                                                '1.0.0',
                                                                                'Enter Target Version'
                                                                            );
                                                                        }
                                                                        if (targetVersion) {
                                                                            const fixedContent = fixVersionsInContent(f.content, targetVersion);
                                                                            const newValidation = validateVersions(fixedContent, f.name);
                                                                            onUpdateStagedFile(f.id, { 
                                                                                content: fixedContent,
                                                                                version: targetVersion,
                                                                                versionValidation: newValidation
                                                                            });
                                                                        }
                                                                    }}
                                                                    className="px-2 py-1 bg-green-700 hover:bg-green-600 text-xs rounded flex items-center gap-1">
                                                                    🔧 Fix to v{f.version || '?'}
                                                                </button>
                                                            </div>
                                                            
                                                            {f.versionValidation.missing.length > 0 && (
                                                                <div className="text-xs text-amber-300 mb-1">
                                                                    Missing: {f.versionValidation.missing.join(', ')}
                                                                </div>
                                                            )}
                                                            
                                                            {f.versionValidation.uniqueVersions.length > 1 && (
                                                                <div className="text-xs text-red-300 mb-1">
                                                                    Found {f.versionValidation.uniqueVersions.length} different versions: {f.versionValidation.uniqueVersions.join(', ')}
                                                                </div>
                                                            )}
                                                            
                                                            <div className="text-xs text-slate-400 space-y-0.5 max-h-24 overflow-auto">
                                                                {f.versionValidation.allVersions.map((v, i) => (
                                                                    <div key={i} className={v.value === f.versionValidation.primary ? 'text-green-400' : 'text-red-300'}>
                                                                        {v.value} ← {v.source} (line {v.line})
                                                                    </div>
                                                                ))}
                                                            </div>
                                                        </div>
                                                    )}
                                                    
                                                    {f.versionValidation && f.versionValidation.isValid && (
                                                        <div className="mt-2 text-xs text-green-400 flex items-center gap-1">
                                                            ✓ All {f.versionValidation.allVersions.length} version strings match (v{f.versionValidation.primary})
                                                        </div>
                                                    )}
                                                </div>
                                            </div>
                                            <button onClick={e => { 
                                                e.stopPropagation(); 
                                                setSelectedFileIds(prev => {
                                                    const newSet = new Set(prev);
                                                    newSet.delete(f.id);
                                                    return newSet;
                                                });
                                                onRemove(f.id); 
                                            }} className="px-2 py-1 text-slate-400 hover:text-white hover:bg-red-600 rounded self-start flex items-center gap-1 transition-colors" title="Remove file">
                                                <Icons.X /> <span className="text-xs">Remove</span>
                                            </button>
                                        </div>
                                    </div>
                                    );
                                })}
                            </div>
                        </div>
                    )}

                    {/* Active Deployments - Multiple Status Boxes */}
                    {activeDeployments && activeDeployments.length > 0 && (
                        <div className="space-y-3">
                            {activeDeployments.map(deployment => (
                                <div key={deployment.id} className={`bg-slate-800 rounded-xl border p-4 fade-in ${
                                    deployment.status === 'running' ? 'border-indigo-500' :
                                    deployment.status === 'success' ? 'border-green-500' : 'border-red-500'
                                }`}>
                                    <h2 className="text-sm font-semibold mb-3 flex items-center gap-2">
                                        {deployment.status === 'running' ? (
                                            <div className="w-4 h-4 border-2 border-indigo-500 border-t-transparent rounded-full animate-spin" />
                                        ) : deployment.status === 'success' ? (
                                            <span className="text-green-400">✓</span>
                                        ) : (
                                            <span className="text-red-400">✗</span>
                                        )}
                                        <span className="text-slate-300">{deployment.appName || 'Deploy'}</span>
                                        {deployment.target && <span className="text-xs px-1.5 py-0.5 rounded bg-slate-700 text-slate-400">{deployment.target.toUpperCase()}</span>}
                                        {deployment.status === 'running' 
                                            ? <span className="text-indigo-300">{deployment.isRollback ? 'Rolling back' : deployment.isPromotion ? 'Promoting' : 'Deploying'}...</span>
                                            : deployment.status === 'success' ? <span className="text-green-400">Complete!</span> : <span className="text-red-400">Failed</span>
                                        }
                                        {deployment.fileCount && <span className="text-xs text-slate-500">({deployment.fileCount} files)</span>}
                                        <span className="flex-1" />
                                        {/* Show close button for errors, success auto-closes */}
                                        {deployment.status !== 'running' && deployment.status !== 'success' && (
                                            <button onClick={() => removeActiveDeployment(deployment.id)} className="text-slate-400 hover:text-white">
                                                <Icons.X />
                                            </button>
                                        )}
                                        {/* Show manual close for success too */}
                                        {deployment.status === 'success' && (
                                            <button onClick={() => removeActiveDeployment(deployment.id)} className="text-slate-500 hover:text-white text-xs">
                                                ✕
                                            </button>
                                        )}
                                    </h2>
                                    <div className="space-y-1.5">
                                        {deployment.steps.map((s, i) => (
                                            <div key={i} className="flex items-center gap-2 text-sm">
                                                <div className={`w-4 h-4 rounded-full flex items-center justify-center text-xs ${
                                                    s.status === 'complete' ? 'bg-green-500' :
                                                    s.status === 'running' ? 'bg-indigo-500' :
                                                    s.status === 'error' ? 'bg-red-500' : 'bg-amber-500'
                                                }`}>
                                                    {s.status === 'complete' ? '✓' : s.status === 'running' ? '•' : '!'}
                                                </div>
                                                <span className={s.status === 'error' ? 'text-red-400' : 'text-slate-300'}>{s.name}</span>
                                                {s.details && <span className="text-slate-500 text-xs">({s.details})</span>}
                                            </div>
                                        ))}
                                    </div>
                                    {deployment.status === 'success' && deployment.url && (
                                        <a href={deployment.url} target="_blank" className="mt-2 inline-flex items-center gap-1 text-indigo-400 hover:underline text-sm">
                                            <Icons.ExternalLink /> Open Site
                                        </a>
                                    )}
                                    {deployment.workflowUrl && (
                                        <a href={deployment.workflowUrl} target="_blank" className="mt-2 ml-3 inline-flex items-center gap-1 text-amber-400 hover:underline text-sm">
                                            <Icons.ExternalLink /> View Workflow
                                        </a>
                                    )}
                                </div>
                            ))}
                        </div>
                    )}

                </div>
                )}{/* END staged files + active deployments (always visible) */}

                {/* Projects/Apps content — hidden by default */}
                <div style={{ display: projectsCollapsed ? 'none' : 'block' }}>
                <div className="space-y-6">
                    {/* v8.53.0: App Cards — THE HERO (full-width, by project) */}
                    {projects.filter(proj => {
                        const projDef = config?.projects?.[proj.id];
                        return (projDef?.state || 'active') !== 'hidden';
                    }).map(proj => {
                        const colors = getProjectColor(proj.color);
                        const effectiveCollapsed = collapsedProjects[proj.id] ?? (proj.id !== projects[0]?.id);
                        const hasActiveDeploy = proj.apps.some(a => 
                            activeDeployments?.some(d => d.appId === a.id && d.status === 'running') ||
                            (deployingRepos && Object.keys(deployingRepos).some(k => k.startsWith(a.id + ':')))
                        );
                        const finalCollapsed = hasActiveDeploy ? false : effectiveCollapsed;
                        
                        return (
                            <div key={proj.id} className={`rounded-xl border overflow-hidden ${colors.border} ${finalCollapsed ? '' : colors.bg}`}>
                                <div 
                                    className={`p-3 cursor-pointer hover:bg-white/5 flex items-center gap-3 transition-colors ${hasActiveDeploy && !finalCollapsed ? 'cursor-default' : ''}`}
                                    onClick={() => {
                                        // Don't allow collapsing while a deploy is running in this project
                                        if (hasActiveDeploy && !finalCollapsed) return;
                                        setCollapsedProjects(prev => {
                                            const next = { ...prev, [proj.id]: !finalCollapsed };
                                            localStorage.setItem('cc_collapsedProjects', JSON.stringify(next));
                                            return next;
                                        });
                                    }}
                                >
                                    <span className={`transform transition-transform text-xs ${finalCollapsed ? '' : 'rotate-90'}`}>▶</span>
                                    <AppIcon icon={proj.icon} size={22} />
                                    <div className="flex-1">
                                        <span className={`font-semibold text-sm ${colors.text}`}>{proj.name}</span>
                                        <span className="text-xs text-slate-500 ml-2">{proj.apps.length} app{proj.apps.length !== 1 ? 's' : ''}</span>
                                    </div>
                                    {finalCollapsed && (
                                        <div className="flex items-center gap-2">
                                            {proj.apps.filter(a => a.currentProdVersion).length > 0 && (
                                                <span className="text-xs text-slate-500">{proj.apps.filter(a => a.currentProdVersion).length}/{proj.apps.length} deployed</span>
                                            )}
                                            {hasActiveDeploy && <span className="text-xs text-amber-400 animate-pulse">● deploying</span>}
                                        </div>
                                    )}
                                </div>
                                
                                {!finalCollapsed && (
                                    <div className="px-3 pb-3 space-y-2">
                                        {proj.apps.map(app => {
                                            const isPublicStyle = app.appType === 'public' || !app.appType;
                                            const isInternal = app.appType === 'internal';
                                            const canPromote = app.testRepo && app.prodRepo && app.currentTestVersion && app.currentTestVersion !== app.currentProdVersion;
                                            const testDeploying = deployingRepos && deployingRepos[`${app.id}:test`];
                                            const prodDeploying = deployingRepos && deployingRepos[`${app.id}:prod`];
                                            const effectiveSubPath = getEffectiveSubPath(app, app.id);
                                            const testUrl = getGitHubPagesUrl(app.testRepo, effectiveSubPath);
                                            const prodUrl = getGitHubPagesUrl(app.prodRepo, effectiveSubPath);
                                            const isExpanded = expandedApps[app.id];
                                            const info = appInfo[app.id];
                                            const isLoadingInfo = loadingAppInfo[app.id];
                                            
                                            const activeWI = (globalWorkItems || []).filter(wi => wi.appId === app.id && ['idea','ready','in-progress'].includes(wi.status));
                                            
                                            return (
                                                <div key={app.id} className="bg-slate-700/50 rounded-lg overflow-hidden">
                                                    <div className="p-3 cursor-pointer hover:bg-slate-700/70" onClick={() => toggleAppExpanded(app.id)}>
                                                        <div className="flex items-center gap-2 mb-2">
                                                            <span className={`transform transition-transform text-xs ${isExpanded ? 'rotate-90' : ''}`}>▶</span>
                                                            <AppIcon icon={app.icon} size={20} />
                                                            <span className="font-medium flex-1">{app.name}</span>
                                                            {/* Maturity badge */}
                                                            {app.lifecycle?.currentMaturity && (() => {
                                                                const m = app.lifecycle.currentMaturity;
                                                                const maturityStyles = {
                                                                    seed: 'bg-slate-700 text-slate-300',
                                                                    prototype: 'bg-amber-900/50 text-amber-300',
                                                                    alpha: 'bg-orange-900/50 text-orange-300',
                                                                    beta: 'bg-blue-900/50 text-blue-300',
                                                                    production: 'bg-green-900/50 text-green-300'
                                                                };
                                                                return (
                                                                    <span className={`px-1.5 py-0.5 rounded text-xs font-medium ${maturityStyles[m] || maturityStyles.seed}`} title={`Maturity: ${m}${app.lifecycle.maturityTarget ? ' → ' + app.lifecycle.maturityTarget : ''}`}>
                                                                        {m}
                                                                    </span>
                                                                );
                                                            })()}
                                                            {activeWI.length > 0 && (
                                                                <span className="px-1.5 py-0.5 bg-indigo-900/50 text-indigo-300 rounded text-xs" title={`${activeWI.length} active work items`}>
                                                                    📋 {activeWI.length}
                                                                </span>
                                                            )}
                                                            {(() => {
                                                                const aIds = (globalIdeas || []).filter(i => i.appId === app.id).map(i => i.id);
                                                                const cnt = (globalConcepts || []).filter(c => aIds.includes(c.ideaOrigin) && c.status === 'active').length;
                                                                return cnt > 0 ? <span className="px-1.5 py-0.5 bg-purple-900/50 text-purple-300 rounded text-xs" title={`${cnt} active concepts`}>💡 {cnt}</span> : null;
                                                            })()}
                                                            {/* [v8.63.0] active session badge removed */}
                                                            {isInternal && <span className="text-xs text-slate-500">internal</span>}
                                                            {canPromote && (
                                                                <button onClick={(e) => { e.stopPropagation(); onPromote(app.id); }}
                                                                    className="px-2 py-1 bg-amber-600 text-xs rounded flex items-center gap-1">
                                                                    <Icons.Zap className="w-3 h-3" /> Promote
                                                                </button>
                                                            )}
                                                            {/* [v8.63.0] Session launch button removed */}
                                                        </div>
                                                        {/* Repo info */}
                                                        {isPublicStyle && app.testRepo && (
                                                            <div className="text-xs text-slate-500 mb-2 font-mono ml-6">
                                                                {app.testRepo ? app.testRepo.split('/')[1] : '(no test)'} → {app.prodRepo ? app.prodRepo.split('/')[1] : '(no prod)'}
                                                            </div>
                                                        )}
                                                        {/* Version badges */}
                                                        <div className="flex items-center gap-2 text-xs ml-6">
                                                            {app.testRepo && (
                                                                <div className="flex items-center gap-1">
                                                                    <span className={`px-2 py-0.5 rounded ${app.currentTestVersion ? 'bg-blue-900/50 text-blue-300' : 'bg-slate-600 text-slate-400'}`}>
                                                                        TEST: {formatVersion(app.currentTestVersion)}
                                                                    </span>
                                                                    {testUrl && (
                                                                        <a href={testUrl} target="_blank" onClick={e => e.stopPropagation()}
                                                                            className={`p-1 rounded flex items-center ${testDeploying ? 'bg-red-900/50 text-red-400 animate-pulse' : 'hover:bg-slate-600 text-slate-400'}`}
                                                                            title={testDeploying ? 'Deploying...' : 'Open TEST'}>
                                                                            <Icons.Play />
                                                                        </a>
                                                                    )}
                                                                </div>
                                                            )}
                                                            {app.testRepo && app.prodRepo && <Icons.ArrowRight className="w-4 h-4 text-slate-500" />}
                                                            <div className="flex items-center gap-1">
                                                                <span className={`px-2 py-0.5 rounded ${app.currentProdVersion ? 'bg-green-900/50 text-green-300' : 'bg-slate-600 text-slate-400'}`}>
                                                                    {app.testRepo ? 'PROD' : ''}: {formatVersion(app.currentProdVersion)}
                                                                </span>
                                                                {prodUrl && (
                                                                    <a href={prodUrl} target="_blank" onClick={e => e.stopPropagation()}
                                                                        className={`p-1 rounded flex items-center ${prodDeploying ? 'bg-red-900/50 text-red-400 animate-pulse' : 'hover:bg-slate-600 text-slate-400'}`}
                                                                        title={prodDeploying ? 'Deploying...' : 'Open PROD'}>
                                                                        <Icons.Play />
                                                                    </a>
                                                                )}
                                                            </div>
                                                        </div>
                                                    </div>
                                                    {isExpanded && (
                                                        <div className="px-3 pb-3 border-t border-slate-600 pt-2 ml-6 text-xs space-y-3">
                                                            {isLoadingInfo ? (
                                                                <div className="text-slate-400 flex items-center gap-2">
                                                                    <div className="w-3 h-3 border border-slate-400 border-t-transparent rounded-full animate-spin" />
                                                                    Loading...
                                                                </div>
                                                            ) : info ? (
                                                                <div className="space-y-2">
                                                                    {info.test && <div className="text-slate-400">Test push: {formatRelativeTime(info.test.pushedAt)}</div>}
                                                                    {info.prod && <div className="text-slate-400">Prod push: {formatRelativeTime(info.prod.pushedAt)}</div>}
                                                                </div>
                                                            ) : null}
                                                            <div className="flex items-center gap-2 flex-wrap">
                                                                {app.prodRepo && (
                                                                    <button onClick={() => forceRebuild(app.prodRepo, 'prod')}
                                                                        className="px-2 py-1 bg-green-700 hover:bg-green-600 rounded">🔄 Force Rebuild</button>
                                                                )}
                                                                <button onClick={() => fetchAppInfo(app.id)}
                                                                    className="px-2 py-1 bg-slate-700 hover:bg-slate-600 rounded flex items-center gap-1">
                                                                    <Icons.Refresh className="w-3 h-3" /> Refresh
                                                                </button>
                                                                {rollbackSnapshots[`${app.id}:prod`] && (
                                                                    <button onClick={() => onQuickRollback(app.id, 'prod')}
                                                                        className="px-2 py-1 bg-amber-700 hover:bg-amber-600 rounded">
                                                                        ⏪ Rollback to v{rollbackSnapshots[`${app.id}:prod`].version}
                                                                    </button>
                                                                )}
                                                            </div>
                                                        </div>
                                                    )}
                                                </div>
                                            );
                                        })}
                                    </div>
                                )}
                            </div>
                        );
                    })}
                </div>
                
                {/* v8.53.0: Post-Deploy Summary Panel (Phase C) */}
                {activeDeployments && activeDeployments.filter(d => d.status === 'success').length > 0 && (() => {
                    const successDeploys = activeDeployments.filter(d => d.status === 'success');
                    const latestDeploy = successDeploys[0];
                    const deployApp = latestDeploy?.appId ? apps[latestDeploy.appId] : null;
                    const matchedReturn = pendingSessionReturn;
                    const activeSessions = (globalSessions || []).filter(s => 
                        s.appId === latestDeploy?.appId && (s.status === 'prep' || s.status === 'in-progress')
                    );
                    const matchedSession = activeSessions[0];
                    
                    return (
                        <div className="bg-slate-800 rounded-xl border border-green-600/50 p-4 space-y-3">
                            <div className="flex items-center justify-between">
                                <div className="flex items-center gap-2">
                                    <span className="text-green-400 text-lg">✅</span>
                                    <span className="font-medium">
                                        Deployed {deployApp?.name || latestDeploy?.appName || 'App'}
                                        {latestDeploy?.version ? ` v${latestDeploy.version}` : ''}
                                        {latestDeploy?.target ? ` to ${latestDeploy.target.toUpperCase()}` : ''}
                                    </span>
                                </div>
                                <button onClick={() => removeActiveDeployment(latestDeploy.id)} className="text-slate-400 hover:text-white text-xs">✕ Dismiss</button>
                            </div>
                            
                            {/* Session match */}
                            {matchedSession && (
                                <div className="text-sm text-indigo-300 flex items-center gap-1">
                                    📋 Matches session <span className="font-mono text-xs">{matchedSession.id}</span> ({matchedSession.type})
                                </div>
                            )}
                            
                            {/* SESSION_RETURN.json results — auto-processed */}
                            {matchedReturn && matchedReturn.data && (
                                <div className="bg-slate-900/50 rounded-lg p-3 space-y-2 text-sm">
                                    <div className="text-xs font-medium text-slate-400 mb-1">Session Results (auto-applied)</div>
                                    {matchedReturn.data.summary && (
                                        <div className="text-slate-300">{matchedReturn.data.summary}</div>
                                    )}
                                    {(matchedReturn.data.workItems || []).filter(wi => wi.status === 'completed').map((wi, i) => (
                                        <div key={i} className="text-green-400 text-xs flex items-center gap-1">✅ "{wi.title || wi.id}" — completed</div>
                                    ))}
                                    {(matchedReturn.data.discoveredIssues || []).map((issue, i) => (
                                        <div key={`iss-${i}`} className="text-red-400 text-xs flex items-center gap-1">🐛 Issue: {issue.title}</div>
                                    ))}
                                    {(matchedReturn.data.discoveredIdeas || []).map((idea, i) => (
                                        <div key={`idea-${i}`} className="text-blue-400 text-xs flex items-center gap-1">💡 Idea: {idea.title}</div>
                                    ))}
                                </div>
                            )}
                            
                            {/* Action buttons */}
                            <div className="flex items-center gap-2 text-xs">
                                {latestDeploy?.url && (
                                    <a href={latestDeploy.url} target="_blank" className="px-3 py-1.5 bg-indigo-600 hover:bg-indigo-500 rounded font-medium flex items-center gap-1 no-underline text-white">
                                        <Icons.ExternalLink /> View Site
                                    </a>
                                )}
                                {deployApp?.testRepo && deployApp?.prodRepo && (
                                    <button onClick={() => setModal({ type: 'promote', data: { appId: latestDeploy.appId } })}
                                        className="px-3 py-1.5 bg-green-700 hover:bg-green-600 rounded font-medium">
                                        ⬆ Promote to Prod
                                    </button>
                                )}
                                {/* [v8.63.0] Review session button removed */}
                            </div>
                        </div>
                    );
                })()}
                
                {/* v8.53.0: Pipeline Summary Bar (collapsed) */}
                {productMetrics.totalActive > 0 && (
                    <details className="bg-slate-800 rounded-xl border border-slate-700 overflow-hidden">
                        <summary className="px-4 py-3 cursor-pointer hover:bg-slate-700/50 flex items-center gap-3 text-sm select-none">
                            <span className="text-slate-400">Pipeline:</span>
                            {productMetrics.pipeline.ready > 0 && <span className="text-blue-400">{productMetrics.pipeline.ready} ready</span>}
                            {productMetrics.pipeline['in-progress'] > 0 && <><span className="text-slate-600">│</span><span className="text-amber-400">{productMetrics.pipeline['in-progress']} in-progress</span></>}
                            {productMetrics.shippedThisMonth.length > 0 && <><span className="text-slate-600">│</span><span className="text-green-400">{productMetrics.shippedThisMonth.length} shipped this month</span></>}
                            {productMetrics.staleItems.length > 0 && <><span className="text-slate-600">│</span><span className="text-amber-400">⚠️ {productMetrics.staleItems.length} stale</span></>}
                            <span className="ml-auto text-slate-500 text-xs">expand ▼</span>
                        </summary>
                        <div className="px-4 pb-4 space-y-3">
                            {/* Pipeline bar */}
                            <div className="h-4 rounded-full overflow-hidden flex bg-slate-700">
                                {[
                                    { key: 'idea', label: 'Ideas', count: productMetrics.pipeline.idea, color: '#64748b' },
                                    { key: 'ready', label: 'Ready', count: productMetrics.pipeline.ready, color: '#3b82f6' },
                                    { key: 'in-progress', label: 'In Progress', count: productMetrics.pipeline['in-progress'], color: '#f59e0b' },
                                    { key: 'review', label: 'Review', count: productMetrics.pipeline.review, color: '#a855f7' },
                                ].filter(s => s.count > 0).map(s => (
                                    <div key={s.key} 
                                        style={{ width: `${(s.count / productMetrics.totalActive) * 100}%`, backgroundColor: s.color }}
                                        className="h-full flex items-center justify-center text-[10px] font-medium text-white/90 min-w-[18px]"
                                        title={`${s.label}: ${s.count}`}>
                                        {(s.count / productMetrics.totalActive) > 0.12 ? s.count : ''}
                                    </div>
                                ))}
                            </div>
                            <div className="flex flex-wrap gap-3 text-xs">
                                {Object.entries(productMetrics.pipeline).filter(([_, v]) => v > 0).map(([status, count]) => {
                                    const colors = { idea: 'text-slate-400', ready: 'text-blue-400', 'in-progress': 'text-amber-400', review: 'text-purple-400' };
                                    return (
                                        <span key={status} className={colors[status] || 'text-slate-400'}>
                                            {status === 'in-progress' ? 'WIP' : status.charAt(0).toUpperCase() + status.slice(1)}: {count}
                                        </span>
                                    );
                                })}
                            </div>
                            {productMetrics.staleItems.length > 0 && (
                                <div className="flex items-center gap-2 text-xs text-amber-400 bg-amber-900/20 rounded-lg px-3 py-2">
                                    ⚠️ {productMetrics.staleItems.length} item{productMetrics.staleItems.length !== 1 ? 's' : ''} stale (7+ days in-progress)
                                </div>
                            )}
                            <button onClick={() => setView('ideas')} className="text-xs text-indigo-400 hover:text-indigo-300">View All →</button>
                        </div>
                    </details>
                )}
                </div>{/* END v8.65.1: collapsible Projects/Apps wrapper */}

                {/* ═══ v8.65.0: Recent Work Cards ═══ */}
                {workCardRecentIdeas.length > 0 && (
                    <React.Fragment>
                        <div className="mt-6 mb-2 flex items-center justify-between">
                            <div className="text-xs font-semibold text-slate-600 uppercase tracking-widest">Active Work</div>
                            <div className="flex items-center gap-3">
                                <span onClick={() => setView('ideas')}
                                    className="flex items-center gap-1.5 px-3 py-1.5 rounded-lg bg-slate-800 border border-slate-700 text-sm text-slate-400 cursor-pointer hover:text-slate-200 hover:border-slate-600 transition-colors">
                                    <span className="font-bold font-mono text-indigo-400">{workCardActiveIdeaCount}</span> Active Ideas
                                </span>
                                <button onClick={() => { if (setViewPayload) setViewPayload({ createIdea: true }); setView('ideas'); }}
                                    className="flex items-center gap-1.5 px-4 py-2 rounded-lg text-sm font-semibold text-white"
                                    style={{ background: 'linear-gradient(135deg, #667eea, #764ba2)' }}>
                                    + New Idea
                                </button>
                            </div>
                        </div>
                        <div className="space-y-3">
                            {workCardRecentIdeas.map(idea => (
                                <IdeaWorkCard key={idea.id} idea={idea}
                                    onNavigateIdea={workCardNavigateIdea}
                                    onNavigateApp={workCardNavigateApp}
                                    onContinue={workCardContinue}
                                    onUploadResults={workCardUploadResults}
                                    onAbandon={workCardAbandon} />
                            ))}
                        </div>
                        {workCardExploreIdea && (
                            <ExploreInChatModal
                                idea={workCardExploreIdea}
                                onClose={() => setWorkCardContinueIdea(null)}
                                configuredApps={configuredApps}
                                apps={apps}
                                globalConcepts={globalConcepts}
                                showAlert={showAlert}
                                github={github}
                                firebaseUid={firebaseUid}
                            />
                        )}
                    </React.Fragment>
                )}

                {/* === ODRCImportChecklistModal (v8.64.3 — extracted from IIFE to prevent remount) === */}
                {pendingOdrcImport?.showChecklist && (
                    <ODRCImportChecklistModal
                        pendingOdrcImport={pendingOdrcImport}
                        setPendingOdrcImport={setPendingOdrcImport}
                        globalIdeas={globalIdeas}
                        globalConcepts={globalConcepts}
                        apps={apps}
                        configuredApps={configuredApps}
                        firebaseUid={firebaseUid}
                        github={github}
                        showAlert={showAlert}
                    />
                )}
            </div>
        );
    }

    // ODRCImportChecklistModal — extracted from DashboardView IIFE (v8.64.3 fix: prevent remount on parent re-render)
    // Must be top-level so React keeps a stable component reference across parent re-renders.
    // The IIFE anti-pattern caused remounts that re-ran auto-link cascade and broke Apply button handlers.
    // =========================================================================
    function ODRCImportChecklistModal({ pendingOdrcImport, setPendingOdrcImport, globalIdeas, globalConcepts, apps, configuredApps, firebaseUid, github, showAlert }) {
        const [checkedItems, setCheckedItems] = React.useState(() => {
            const items = pendingOdrcImport.parsedUpdates.map((u, i) => ({
                ...u,
                checked: true,
                index: i,
                duplicates: []
            }));
            return items;
        });
        // v8.64.0 A5: Three-priority auto-link cascade with diagnostic logging
        const [linkedIdeaId, setLinkedIdeaId] = React.useState(() => {
            const meta = pendingOdrcImport.metadata;
            const ideas = globalIdeas || [];

            // Priority 1: Direct Firebase ID match (unambiguous)
            if (meta?.ideaId) {
                const match = ideas.find(i => i.id === meta.ideaId);
                if (match) {
                    console.log('[CC] ODRC auto-link: matched by IdeaId:', meta.ideaId);
                    return match.id;
                }
                console.log('[CC] ODRC auto-link: IdeaId not found:', meta.ideaId);
            }

            // Priority 2: Slug match (stored slug or computed from current name)
            if (meta?.ideaSlug) {
                const match = ideas.find(i =>
                    i.slug === meta.ideaSlug ||
                    IdeaManager.generateSlug(i.name) === meta.ideaSlug
                );
                if (match) {
                    console.log('[CC] ODRC auto-link: matched by slug:', meta.ideaSlug, '→', match.name);
                    return match.id;
                }
                console.log('[CC] ODRC auto-link: slug not found:', meta.ideaSlug);
            }

            // Priority 3: App-scoped fallback — try direct appId, then name/key resolution
            if (meta?.appId) {
                let appIdeas = ideas.filter(i => i.appId === meta.appId && i.status === 'active');

                // If direct appId match fails, try matching metadata against app keys/names
                if (appIdeas.length === 0 && typeof apps === 'object') {
                    const metaAppLower = meta.appId.toLowerCase().trim();
                    const matchedAppId = Object.keys(apps).find(id => {
                        const app = apps[id];
                        return id.toLowerCase() === metaAppLower ||
                            (app.name || '').toLowerCase() === metaAppLower ||
                            (app.project || '').toLowerCase() === metaAppLower;
                    });
                    if (matchedAppId) {
                        appIdeas = ideas.filter(i => i.appId === matchedAppId && i.status === 'active');
                        console.log('[CC] ODRC auto-link: app name resolved:', meta.appId, '→', matchedAppId);
                    }
                }

                if (appIdeas.length > 0) {
                    // v8.64.2: Sort by sequence (desc) then createdAt (desc) to pick most recent idea
                    const sorted = [...appIdeas].sort((a, b) => {
                        const seqDiff = (b.sequence || 0) - (a.sequence || 0);
                        if (seqDiff !== 0) return seqDiff;
                        return (b.createdAt || '').localeCompare(a.createdAt || '');
                    });
                    console.log('[CC] ODRC auto-link: app-scope fallback, picked:', sorted[0].name,
                        `(seq: ${sorted[0].sequence || 0}, ${appIdeas.length} candidates)`);
                    return sorted[0].id;
                }
            }

            console.log('[CC] ODRC auto-link: no match found. metadata:', JSON.stringify(meta));
            return null;
        });
        const [importing, setImporting] = React.useState(false);
        const [results, setResults] = React.useState(null);
        const [pushingDoc, setPushingDoc] = React.useState(false);
        const [advancing, setAdvancing] = React.useState(false); // v8.69.0: phase ratchet state (hoisted to avoid conditional hook)
        // v8.62.0 A7: Inline idea creation state
        const [showInlineCreate, setShowInlineCreate] = React.useState(false);
        const [newIdeaName, setNewIdeaName] = React.useState(() => {
            // Pre-fill from metadata slug: kebab-case → Title Case
            const slug = pendingOdrcImport.metadata?.ideaSlug;
            if (slug) return slug.split('-').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
            return '';
        });
        const [newIdeaDescription, setNewIdeaDescription] = React.useState('');
        const [newIdeaAppId, setNewIdeaAppId] = React.useState(pendingOdrcImport.metadata?.appId || '');
        const [creatingIdea, setCreatingIdea] = React.useState(false);

        const linkedIdea = (globalIdeas || []).find(i => i.id === linkedIdeaId);
        const activeIdeas = (globalIdeas || []).filter(i => i.status === 'active');
        const ideasByApp = React.useMemo(() => {
            const groups = {};
            activeIdeas.forEach(i => {
                const appName = i.appId ? (apps[i.appId]?.name || i.appId) : 'Unlinked';
                if (!groups[appName]) groups[appName] = [];
                groups[appName].push(i);
            });
            return groups;
        }, [activeIdeas, apps]);

        // Run duplicate detection on mount + fuzzy-match OPENs for flex RESOLVE items
        React.useEffect(() => {
            if (!linkedIdea) return;
            const ideaConcepts = (globalConcepts || []).filter(c => c.ideaOrigin === linkedIdea.id && c.status === 'active');
            const activeOpens = ideaConcepts.filter(c => c.type === 'OPEN');
            setCheckedItems(prev => prev.map(item => {
                if (item.action === 'create') {
                    const dupes = findDuplicateConcepts(item.description, ideaConcepts);
                    return { ...item, duplicates: dupes };
                }
                // v8.61.1: For flex RESOLVE items (no conceptId), fuzzy-match against active OPENs
                if (item.action === 'resolve' && !item.conceptId) {
                    const matches = findDuplicateConcepts(item.description, activeOpens);
                    const bestMatch = matches.length > 0 ? matches[0].existingConcept.id : null;
                    return { ...item, matchingOpens: activeOpens, overrideConceptId: item.overrideConceptId || bestMatch };
                }
                return item;
            }));
        }, [linkedIdeaId]);

        // Also check RESOLVE items for already-resolved
        React.useEffect(() => {
            setCheckedItems(prev => prev.map(item => {
                if (item.action === 'resolve' && item.conceptId) {
                    const target = (globalConcepts || []).find(c => c.id === item.conceptId);
                    if (target && target.status === 'resolved') {
                        return { ...item, checked: false, alreadyResolved: true };
                    }
                }
                return item;
            }));
        }, [globalConcepts]);

        const updateItem = (index, updates) => {
            setCheckedItems(prev => prev.map((item, i) => i === index ? { ...item, ...updates } : item));
        };

        const selectedCount = checkedItems.filter(i => i.checked).length;

        const handleApply = async () => {
            if (!firebaseUid || !linkedIdea) {
                console.warn('[CC] ODRC handleApply: blocked —', !firebaseUid ? 'no firebaseUid' : 'no linkedIdea (linkedIdeaId=' + linkedIdeaId + ')');
                return;
            }
            console.log('[CC] ODRC handleApply: starting import for', linkedIdea.name, 'with', checkedItems.filter(i => i.checked).length, 'items');
            setImporting(true);
            try {
                const selected = checkedItems.filter(i => i.checked);
                // v8.62.0 B2: Detect session type from full content
                const sessionType = pendingOdrcImport.fullContent ? detectSessionType(pendingOdrcImport.fullContent) : 'exploration';
                const importResults = await executeODRCImport(
                    firebaseUid, linkedIdea, selected, globalIdeas || [], github, linkedIdea.appId ? apps[linkedIdea.appId] : null, sessionType, pendingOdrcImport
                );

                // Dual-track: push full doc to repo if it has full content
                if (github && linkedIdea.appId && pendingOdrcImport.fullContent) {
                    const app = apps[linkedIdea.appId];
                    const repo = app?.repos?.test || app?.testRepo || app?.repos?.prod || app?.prodRepo;
                    if (repo) {
                        setPushingDoc(true);
                        try {
                            const slug = linkedIdea.slug || IdeaManager.generateSlug(linkedIdea.name);
                            const docPath = `docs/sessions/${slug}/${importResults.sessionId}.md`;
                            const existing = await github.getFile(repo, docPath).catch(() => null);
                            await github.createOrUpdateFile(repo, docPath, pendingOdrcImport.fullContent,
                                `Add session doc: ${linkedIdea.name} ${importResults.sessionId}`, existing?.sha || null);
                            console.log('[CC] Pushed session doc to', repo, docPath);
                        } catch (e) {
                            console.warn('[CC] Doc push failed:', e.message);
                        }
                        setPushingDoc(false);
                    }
                }

                setResults(importResults);
            } catch (e) {
                console.error('[CC] ODRC handleApply error:', e);
                await showAlert(`Import failed: ${e.message}`, '❌ Error');
            }
            setImporting(false);
        };

        const close = () => setPendingOdrcImport(null);

        // Phase display for results
        const prevPhase = linkedIdea ? computeIdeaPhase((globalConcepts || []).filter(c => c.ideaOrigin === linkedIdea.id)) : null;

        if (results) {
            const currentConcepts = (globalConcepts || []).filter(c => c.ideaOrigin === linkedIdea?.id);
            const computedPhase = linkedIdea ? computeIdeaPhase(currentConcepts) : null;
            const storedPhase = linkedIdea?.phase || 'exploring';
            const phaseAdvanceCandidate = computedPhase && PHASE_ORDER.indexOf(computedPhase) > PHASE_ORDER.indexOf(storedPhase);

            const handleAdvancePhase = async () => {
                if (!firebaseUid || !linkedIdea) return;
                setAdvancing(true);
                try {
                    await IdeaManager.advancePhase(firebaseUid, linkedIdea.id, computedPhase);
                    await showAlert(`Phase advanced to ${computedPhase}`, '✅ Phase Updated');
                } catch (e) {
                    await showAlert('Phase advance failed: ' + e.message, '❌ Error');
                }
                setAdvancing(false);
            };

            return (
                <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50 p-4" onClick={close}>
                    <div className="bg-slate-800 rounded-xl border border-slate-700 w-full max-w-lg p-6" onClick={e => e.stopPropagation()}>
                        <div className="text-center">
                            <div className="text-4xl mb-3">✅</div>
                            <h2 className="text-lg font-bold mb-2">Session {results.sessionId} imported</h2>
                            <p className="text-slate-300 mb-1">
                                {results.created} concept{results.created !== 1 ? 's' : ''} created,{' '}
                                {results.resolved} OPEN{results.resolved !== 1 ? 's' : ''} resolved
                                {results.tangentCreated > 0 && (
                                    <>, {results.tangentCreated} tangent{results.tangentCreated !== 1 ? 's' : ''} routed</>
                                )}
                            </p>
                            <p className="text-xs text-slate-500 mt-2">{results.summary}</p>
                        </div>

                        {/* v8.69.0: Phase Ratchet Prompt */}
                        {phaseAdvanceCandidate && (
                            <div className="mt-4 bg-amber-900/20 border border-amber-800/50 rounded-lg p-4">
                                <div className="text-sm text-amber-200 mb-2">
                                    <span className="font-medium">Phase Check:</span>{' '}
                                    Stored: <span className="font-mono">{storedPhase}</span> →{' '}
                                    Computed: <span className="font-mono">{computedPhase}</span>
                                </div>
                                <p className="text-xs text-amber-300/70 mb-3">
                                    The ODRC distribution suggests this idea has matured. Advance phase?
                                </p>
                                <div className="flex gap-2 justify-center">
                                    <button onClick={close}
                                        className="px-3 py-1.5 rounded text-xs bg-slate-700 hover:bg-slate-600">
                                        Keep {storedPhase}
                                    </button>
                                    <button onClick={handleAdvancePhase} disabled={advancing}
                                        className="px-3 py-1.5 rounded text-xs bg-amber-700 hover:bg-amber-600 font-medium disabled:opacity-50">
                                        {advancing ? '⏳...' : `Advance to ${computedPhase}`}
                                    </button>
                                </div>
                            </div>
                        )}

                        {/* v8.69.0: Debrief & Next Session */}
                        {pendingOdrcImport?.sessionData?.debrief_summary && (
                            <div className="mt-3 text-xs text-slate-400">
                                📋 {pendingOdrcImport.sessionData.debrief_summary}
                            </div>
                        )}
                        {pendingOdrcImport?.sessionData?.next_session && (
                            <div className="mt-1 text-xs text-slate-500">
                                📎 Next: {typeof pendingOdrcImport.sessionData.next_session === 'string'
                                    ? pendingOdrcImport.sessionData.next_session
                                    : pendingOdrcImport.sessionData.next_session.focus || 'See session data'}
                            </div>
                        )}

                        {pushingDoc && <p className="text-xs text-slate-400 mt-2 animate-pulse">Pushing session doc to repo...</p>}

                        <div className="flex justify-center mt-4">
                            <button onClick={close} className="px-4 py-2 rounded text-sm bg-indigo-600 hover:bg-indigo-500 font-medium">Done</button>
                        </div>
                    </div>
                </div>
            );
        }

        return (
            <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50 p-4" onClick={close}>
                <div className="bg-slate-800 rounded-xl border border-slate-700 w-full max-w-3xl max-h-[85vh] flex flex-col" onClick={e => e.stopPropagation()}>
                    {/* Header */}
                    <div className="flex items-center justify-between p-4 border-b border-slate-700">
                        <div>
                            <h2 className="text-lg font-bold">💡 ODRC Import — {linkedIdea?.name || 'Select Idea'}</h2>
                            <div className="text-xs text-slate-400 mt-0.5">
                                {pendingOdrcImport.parsedUpdates.length} item{pendingOdrcImport.parsedUpdates.length !== 1 ? 's' : ''} parsed from {pendingOdrcImport.fileName}
                            </div>
                        </div>
                        <button onClick={close} className="text-slate-400 hover:text-white text-xl">✕</button>
                    </div>

                    {/* Idea Picker — v8.62.0 A7: includes Create New Idea option */}
                    <div className="px-4 pt-3 pb-2 border-b border-slate-700/50">
                        <div className="flex items-center gap-2">
                            <span className="text-sm text-slate-400">Linked Idea:</span>
                            <select value={linkedIdeaId || (showInlineCreate ? '__create__' : '')}
                                onChange={e => {
                                    if (e.target.value === '__create__') {
                                        setShowInlineCreate(true);
                                        setLinkedIdeaId(null);
                                    } else {
                                        setShowInlineCreate(false);
                                        setLinkedIdeaId(e.target.value || null);
                                    }
                                }}
                                className="bg-slate-700 border border-slate-600 rounded px-2 py-1 text-sm flex-1">
                                <option value="">— Select Idea —</option>
                                {Object.entries(ideasByApp).map(([appName, ideas]) => (
                                    <optgroup key={appName} label={appName}>
                                        {ideas.map(i => <option key={i.id} value={i.id}>{i.name} {i.slug ? `(${i.slug})` : ''}</option>)}
                                    </optgroup>
                                ))}
                                <option value="__create__">+ Create New Idea...</option>
                            </select>
                        </div>
                        {/* Inline Create Idea form */}
                        {showInlineCreate && (
                            <div className="mt-2 bg-slate-700/50 border border-slate-600 rounded-lg p-3 space-y-2">
                                <input value={newIdeaName} onChange={e => setNewIdeaName(e.target.value)}
                                    className="w-full bg-slate-800 border border-slate-600 rounded px-2 py-1.5 text-sm"
                                    placeholder="Idea name (short title)" autoFocus />
                                <textarea value={newIdeaDescription} onChange={e => setNewIdeaDescription(e.target.value)}
                                    rows={2} className="w-full bg-slate-800 border border-slate-600 rounded px-2 py-1.5 text-sm resize-y"
                                    placeholder="Description (optional)" />
                                <select value={newIdeaAppId} onChange={e => setNewIdeaAppId(e.target.value)}
                                    className="w-full bg-slate-800 border border-slate-600 rounded px-2 py-1.5 text-sm">
                                    <option value="">— App (optional) —</option>
                                    {configuredApps.map(a => <option key={a.id} value={a.id}>{a.name}</option>)}
                                </select>
                                <div className="flex gap-2 justify-end">
                                    <button onClick={() => setShowInlineCreate(false)}
                                        className="px-3 py-1 text-xs bg-slate-700 hover:bg-slate-600 rounded">Cancel</button>
                                    <button disabled={creatingIdea || !newIdeaName.trim()}
                                        onClick={async () => {
                                            setCreatingIdea(true);
                                            try {
                                                const appId = newIdeaAppId || null;
                                                const parentIdeas = appId ? (globalIdeas || []).filter(i => i.appId === appId) : [];
                                                const parentIdeaId = parentIdeas.length > 0 ? parentIdeas[parentIdeas.length - 1].id : null;
                                                const newIdea = await IdeaManager.create(firebaseUid, {
                                                    name: newIdeaName.trim(),
                                                    description: newIdeaDescription.trim(),
                                                    type: parentIdeaId ? 'addon' : 'base',
                                                    appId, parentIdeaId
                                                });
                                                // newIdea might be undefined since create() may not return the ID;
                                                // wait for listener to pick up the new idea
                                                setTimeout(() => {
                                                    const found = (globalIdeas || []).find(i => i.name === newIdeaName.trim() && i.status === 'active');
                                                    if (found) setLinkedIdeaId(found.id);
                                                    setShowInlineCreate(false);
                                                }, 1500);
                                            } catch (e) {
                                                await showAlert(`Error: ${e.message}`, '❌ Error');
                                            }
                                            setCreatingIdea(false);
                                        }}
                                        className="px-3 py-1 text-xs bg-indigo-600 hover:bg-indigo-500 rounded font-medium disabled:opacity-50">
                                        {creatingIdea ? '⏳ Creating...' : 'Create & Link'}
                                    </button>
                                </div>
                            </div>
                        )}
                    </div>

                    {/* v8.69.0: Session Package Header */}
                    {pendingOdrcImport.artifactType === 'session-json' && pendingOdrcImport.sessionData && (
                        <div className="mx-4 mt-3 bg-slate-900/50 rounded-lg p-3 border border-slate-700">
                            <div className="flex items-center gap-2 mb-2">
                                <span className="text-lg">📦</span>
                                <span className="font-medium text-slate-200">
                                    Session Package — {pendingOdrcImport.sessionData.session_id}
                                </span>
                            </div>
                            <div className="text-xs text-slate-400 space-y-1">
                                <div>Schema: {pendingOdrcImport.sessionData.schema_version} ·
                                    Mode: {pendingOdrcImport.sessionData.session_config?.mode || 'exploration'} ·
                                    Chain: {pendingOdrcImport.sessionData.chain?.link_count || 1} link(s)
                                </div>
                                <div className="text-slate-300">{pendingOdrcImport.sessionData.context_summary}</div>
                                {pendingOdrcImport.validationWarnings?.length > 0 && (
                                    <div className="text-amber-400 mt-1">
                                        ⚠️ {pendingOdrcImport.validationWarnings.length} warning(s):
                                        {pendingOdrcImport.validationWarnings.map((w, i) => (
                                            <div key={i} className="ml-4">· {w}</div>
                                        ))}
                                    </div>
                                )}
                            </div>
                        </div>
                    )}

                    {/* Checklist */}
                    <div className="flex-1 overflow-y-auto p-4 space-y-3">
                        {checkedItems.map((item, idx) => (
                            <div key={idx} className={`rounded-lg border p-3 ${item.checked ? 'border-slate-600 bg-slate-800' : 'border-slate-700/50 bg-slate-800/50 opacity-60'}`}>
                                <div className="flex items-start gap-3">
                                    <input type="checkbox" checked={item.checked} onChange={e => updateItem(idx, { checked: e.target.checked })}
                                        className="mt-1 rounded bg-slate-700 border-slate-600" />
                                    <div className="flex-1 min-w-0">
                                        <div className="flex items-center gap-2 mb-1">
                                            <select value={item.action} onChange={e => updateItem(idx, { action: e.target.value })}
                                                className="bg-slate-700 border border-slate-600 rounded px-1.5 py-0.5 text-xs">
                                                <option value="create">NEW</option>
                                                <option value="resolve">RESOLVE</option>
                                            </select>
                                            <select value={item.type} onChange={e => updateItem(idx, { type: e.target.value })}
                                                className="bg-slate-700 border border-slate-600 rounded px-1.5 py-0.5 text-xs">
                                                {ODRC_TYPES.map(t => <option key={t} value={t}>{t}</option>)}
                                            </select>
                                        </div>
                                        <textarea value={item.description} onChange={e => updateItem(idx, { description: e.target.value })}
                                            rows={2} className="w-full bg-slate-900 border border-slate-700 rounded px-2 py-1 text-sm text-slate-300 resize-y" />
                                        {/* v8.69.0: Tangent item indicator */}
                                        {item.isTangent && (
                                            <span className="text-xs px-1.5 py-0.5 rounded bg-orange-900/50 text-orange-300 mt-1 inline-block">
                                                tangent{item.affinity ? ` → ${item.affinity}` : ' — orphan'}
                                            </span>
                                        )}
                                        {/* v8.61.1: Resolution text display for flex RESOLVE items */}
                                        {item.action === 'resolve' && item.resolution && (
                                            <div className="text-xs text-slate-400 mt-1">
                                                <span className="text-slate-500">Resolution:</span> {item.resolution}
                                            </div>
                                        )}
                                        {/* v8.61.1: OPEN picker dropdown for flex RESOLVE items (no conceptId) */}
                                        {item.action === 'resolve' && !item.conceptId && item.matchingOpens && (
                                            <div className="mt-2 bg-purple-900/20 border border-purple-800/50 rounded p-2">
                                                <div className="text-xs text-purple-300 mb-1">Resolves which OPEN?</div>
                                                <select value={item.overrideConceptId || ''} onChange={e => updateItem(idx, { overrideConceptId: e.target.value || null })}
                                                    className="w-full bg-slate-900 border border-slate-700 rounded px-2 py-1 text-xs text-slate-300">
                                                    <option value="">— Select OPEN to resolve —</option>
                                                    {item.matchingOpens.map(c => (
                                                        <option key={c.id} value={c.id}>
                                                            {c.content.length > 80 ? c.content.slice(0, 80) + '…' : c.content}
                                                        </option>
                                                    ))}
                                                </select>
                                                {!item.overrideConceptId && item.checked && (
                                                    <div className="text-xs text-amber-400 mt-1">⚠ No OPEN selected — will be skipped on apply</div>
                                                )}
                                            </div>
                                        )}
                                        {item.alreadyResolved && (
                                            <div className="text-xs text-amber-400 mt-1">⚠ Already resolved — auto-unchecked</div>
                                        )}
                                        {item.duplicates?.length > 0 && (
                                            <div className="mt-2 bg-amber-900/20 border border-amber-800/50 rounded p-2">
                                                <div className="text-xs text-amber-300 mb-1">⚠ Similar to existing ({item.duplicates[0].overlapPercent}% overlap):</div>
                                                <div className="text-xs text-slate-400 italic">"{item.duplicates[0].existingConcept.content.slice(0, 100)}"</div>
                                                <div className="flex gap-2 mt-1.5">
                                                    <button onClick={() => updateItem(idx, { checked: true, duplicates: [] })}
                                                        className="text-xs px-2 py-0.5 bg-slate-700 hover:bg-slate-600 rounded">Create Anyway</button>
                                                    <button onClick={() => updateItem(idx, { checked: false })}
                                                        className="text-xs px-2 py-0.5 bg-slate-700 hover:bg-slate-600 rounded">Skip</button>
                                                </div>
                                            </div>
                                        )}
                                    </div>
                                </div>
                            </div>
                        ))}
                    </div>

                    {/* v8.69.0: Debrief Preview */}
                    {pendingOdrcImport.debriefContent && (
                        <details className="mx-4 mb-2 bg-slate-900/50 rounded-lg border border-slate-700">
                            <summary className="p-3 cursor-pointer text-sm text-slate-300 hover:text-white">
                                📋 Session Debrief
                                {pendingOdrcImport.sessionData?.debrief_summary && (
                                    <span className="text-xs text-slate-500 ml-2">
                                        — {pendingOdrcImport.sessionData.debrief_summary.substring(0, 80)}
                                        {pendingOdrcImport.sessionData.debrief_summary.length > 80 ? '…' : ''}
                                    </span>
                                )}
                            </summary>
                            <div className="p-3 border-t border-slate-700 text-xs text-slate-400 max-h-48 overflow-y-auto whitespace-pre-wrap font-mono">
                                {pendingOdrcImport.debriefContent}
                            </div>
                        </details>
                    )}

                    {/* v8.69.0: Artifact Inventory */}
                    {pendingOdrcImport.artifactFiles?.length > 0 && (
                        <div className="mx-4 mb-2 text-xs text-slate-500">
                            📎 {pendingOdrcImport.artifactFiles.length} artifact(s):
                            {pendingOdrcImport.artifactFiles.map((f, i) => (
                                <span key={i} className="ml-2">{f.split('/').pop()}</span>
                            ))}
                        </div>
                    )}

                    {/* Footer */}
                    <div className="flex items-center justify-between p-4 border-t border-slate-700">
                        <button onClick={close} className="px-4 py-2 rounded text-sm bg-slate-700 hover:bg-slate-600">Cancel</button>
                        <button onClick={handleApply} disabled={importing || selectedCount === 0 || !linkedIdeaId}
                            className="px-4 py-2 rounded text-sm bg-indigo-600 hover:bg-indigo-500 font-medium disabled:opacity-50">
                            {importing ? '⏳ Importing...' : `Apply ${selectedCount} Update${selectedCount !== 1 ? 's' : ''}`}
                        </button>
                    </div>
                </div>
            </div>
        );
    }

    // (Views extracted to satellites: Repo Files → Infrastructure, Environment Optimization → Analytics,
    //  Users → Analytics, Beta Analytics → Analytics)

    function AppsView({ apps, repos, onUpdate, github }) {
        const [repoDirectories, setRepoDirectories] = React.useState({});
        const [loadingDirs, setLoadingDirs] = React.useState({});
        
        // Fetch directories for a repo
        const fetchDirectories = async (repoFullName) => {
            if (!github || !repoFullName || repoDirectories[repoFullName]) return;
            
            setLoadingDirs(prev => ({ ...prev, [repoFullName]: true }));
            try {
                const contents = await github.listRepoContents(repoFullName, '');
                const dirs = contents
                    .filter(item => item.type === 'dir')
                    .map(item => item.name)
                    .sort();
                setRepoDirectories(prev => ({ ...prev, [repoFullName]: dirs }));
            } catch (e) {
                console.error('Failed to fetch directories for', repoFullName, e);
                setRepoDirectories(prev => ({ ...prev, [repoFullName]: [] }));
            }
            setLoadingDirs(prev => ({ ...prev, [repoFullName]: false }));
        };
        
        // Fetch directories when prod repo changes
        React.useEffect(() => {
            Object.values(apps).forEach(app => {
                if (app.prodRepo && !repoDirectories[app.prodRepo]) {
                    fetchDirectories(app.prodRepo);
                }
            });
        }, [apps, github]);
        
        // Get directories for a given app's prod repo
        const getDirsForApp = (app) => {
            return repoDirectories[app.prodRepo] || [];
        };
        
        return (
            <div className="space-y-6">
                <h2 className="text-xl font-bold">App Configuration</h2>
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                    {Object.values(apps).map(app => (
                        <div key={app.id} className="bg-slate-800 rounded-xl border border-slate-700 p-4">
                            <div className="flex items-center gap-2 mb-3">
                                <AppIcon icon={app.icon} size={28} />
                                <span className="font-semibold">{app.name}</span>
                            </div>
                            <div className="space-y-2">
                                <div>
                                    <label className="text-xs text-blue-400">🧪 TEST</label>
                                    <select value={app.testRepo || ''} onChange={e => onUpdate(app.id, { testRepo: e.target.value })}
                                        className="w-full p-1.5 bg-slate-700 border border-slate-600 rounded text-sm">
                                        <option value="">Select...</option>
                                        {repos.map(r => <option key={r.fullName} value={r.fullName}>{r.name}</option>)}
                                    </select>
                                </div>
                                <div>
                                    <label className="text-xs text-green-400">🚀 PROD</label>
                                    <select value={app.prodRepo || ''} onChange={e => {
                                        onUpdate(app.id, { prodRepo: e.target.value });
                                        if (e.target.value) fetchDirectories(e.target.value);
                                    }}
                                        className="w-full p-1.5 bg-slate-700 border border-slate-600 rounded text-sm">
                                        <option value="">Select...</option>
                                        {repos.map(r => <option key={r.fullName} value={r.fullName}>{r.name}</option>)}
                                    </select>
                                </div>
                                <div>
                                    <label className="text-xs text-slate-400">Sub Path</label>
                                    <select value={app.subPath || ''} onChange={e => onUpdate(app.id, { subPath: e.target.value })}
                                        className="w-full p-1.5 bg-slate-700 border border-slate-600 rounded text-sm font-mono">
                                        <option value="">(root)</option>
                                        {loadingDirs[app.prodRepo] && <option disabled>Loading...</option>}
                                        {getDirsForApp(app).map(dir => (
                                            <option key={dir} value={dir}>{dir}/</option>
                                        ))}
                                    </select>
                                </div>
                                <div>
                                    <label className="text-xs text-slate-400">Target Path</label>
                                    <input type="text" value={app.targetPath} onChange={e => onUpdate(app.id, { targetPath: e.target.value })}
                                        className="w-full p-1.5 bg-slate-700 border border-slate-600 rounded text-sm font-mono" />
                                </div>
                            </div>
                        </div>
                    ))}
                </div>
            </div>
        );
    }

    // =========================================================================
    // HISTORY VIEW
    // =========================================================================
    
    function HistoryView({ deployments, apps, onRollback, globalWorkItems, globalSessions }) {
        // Helper: find session linked to a deploy
        const findLinkedSession = (deploy) => {
            if (deploy.sessionId) {
                return (globalSessions || []).find(s => s.id === deploy.sessionId);
            }
            // Try to find by deployId match
            return (globalSessions || []).find(s => s.deployId === `deploy-${deploy.id}`);
        };
        
        // Helper: find completed work items for a deploy
        const findCompletedWIs = (deploy) => {
            if (deploy.workItemsCompleted && deploy.workItemsCompleted.length > 0) {
                return (globalWorkItems || []).filter(wi => deploy.workItemsCompleted.includes(wi.id));
            }
            return [];
        };
        
        return (
            <div className="bg-slate-800 rounded-xl border border-slate-700 p-6">
                <h2 className="text-lg font-semibold mb-4 flex items-center gap-2">
                    <Icons.History /> History ({deployments.length})
                </h2>
                {deployments.length === 0 ? (
                    <div className="text-slate-400 text-center py-8">No deployments yet</div>
                ) : (
                    <div className="space-y-2">
                        {deployments.map(d => {
                            const linkedSession = findLinkedSession(d);
                            const completedWIs = findCompletedWIs(d);
                            
                            return (
                            <div key={d.id} className={`p-3 rounded-lg border ${
                                d.status === 'success' ? 'bg-green-900/20 border-green-800' :
                                d.status === 'failed' ? 'bg-red-900/20 border-red-800' : 'border-slate-600'
                            }`}>
                                <div className="flex items-center gap-2">
                                    <AppIcon icon={apps[d.appId]?.icon} size={18} />
                                    <span className="font-medium">{d.appName}</span>
                                    <span className="font-mono text-sm text-slate-400">{formatVersion(d.version)}</span>
                                    {d.fileCount && <span className="text-xs text-slate-500">({d.fileCount} files)</span>}
                                    <span className={`text-xs px-1.5 rounded ${d.target === 'prod' ? 'bg-green-900 text-green-300' : 'bg-blue-900 text-blue-300'}`}>
                                        {d.target?.toUpperCase()}
                                    </span>
                                    {d.isPromotion && <span className="text-xs text-amber-400">↑ promoted</span>}
                                    {d.isRollback && <span className="text-xs text-amber-400">↩ rollback</span>}
                                    <span className="flex-1" />
                                    {d.status === 'success' && d.commitSha && !d.fileCount && (
                                        <button onClick={() => onRollback(d)}
                                            className="px-2 py-1 text-xs bg-slate-700 hover:bg-amber-900/50 rounded flex items-center gap-1">
                                            <Icons.Rewind className="w-3 h-3" /> Rollback
                                        </button>
                                    )}
                                </div>
                                <div className="text-xs text-slate-500 mt-1 flex items-center gap-2 flex-wrap">
                                    {formatDate(d.completedAt || d.startedAt)}
                                    {d.commitSha && <span className="font-mono">• {d.commitSha.substring(0, 7)}</span>}
                                    {d.previousVersion && <span>• was {formatVersion(d.previousVersion)}</span>}
                                    {linkedSession && (
                                        <span className="text-indigo-400">• {linkedSession.type} session</span>
                                    )}
                                </div>
                                {/* Work Items completed in this deploy (v8.27.0) */}
                                {completedWIs.length > 0 && (
                                    <div className="flex flex-wrap gap-1 mt-1.5">
                                        {completedWIs.map(wi => (
                                            <span key={wi.id} className="text-xs px-1.5 py-0.5 bg-green-900/30 text-green-300 rounded border border-green-800/30">
                                                ✓ {wi.id}: {wi.title}
                                            </span>
                                        ))}
                                    </div>
                                )}
                                {d.url && d.status === 'success' && (
                                    <a href={d.url} target="_blank" className="text-xs text-indigo-400 hover:underline">View ↗</a>
                                )}
                            </div>
                            );
                        })}
                    </div>
                )}
            </div>
        );
    }

    // =========================================================================
    // SMART DEPLOY — Dynamic Zip Resolution Engine (v8.55.0)
    // Replaces hardcoded GS_ACTIVE_FOLDER_MAP with config-driven resolution.
    // Any zip → resolve files → group by repo → validate per-app → deploy.
    // =========================================================================

    /**
     * resolveZipContents(zip, apps)
     * 
     * The core resolution engine. Takes a JSZip instance and the apps config,
     * maps every file in the zip to its target app and repo.
     * 
     * Returns: {
     *   repos: { [repoKey]: { repo, target, apps: { [appId]: { config, files, version, indexContent } }, sharedFiles: [] } },
     *   unmatched: [{ path, reason }],
     *   rootStripped: string|null   // root folder that was stripped, if any
     * }
     */
    async function resolveZipContents(zip, apps) {
        // === Phase 1: Inventory ===
        const allPaths = [];
        zip.forEach((path, entry) => {
            if (!entry.dir && !path.includes('__MACOSX') && !path.startsWith('.')) allPaths.push(path);
        });

        // Strip one root wrapper folder if all files share it
        let rootPrefix = '';
        if (allPaths.length > 0) {
            const firstSlash = allPaths[0].indexOf('/');
            if (firstSlash > 0) {
                const candidate = allPaths[0].substring(0, firstSlash + 1);
                if (allPaths.every(p => p.startsWith(candidate))) rootPrefix = candidate;
            }
        }

        const files = allPaths.map(p => ({
            zipPath: p,
            relativePath: rootPrefix ? p.substring(rootPrefix.length) : p,
            entry: zip.file(p)
        }));

        // === Phase 2: Build subPath index ===
        // Include ALL configured apps for path matching (not just those with repos assigned)
        const allApps = Object.values(apps).filter(a => a.subPath !== undefined);
        const subPathIndex = []; // [{ subPath, appId, repo, project }] sorted longest-first
        const projectRepos = {}; // { projectId: repoName }

        // First pass: collect repos by project from apps that have them
        for (const app of allApps) {
            const repo = app.prodRepo || app.testRepo;
            if (repo && app.project) projectRepos[app.project] = repo;
        }

        // Second pass: build index, inheriting repo from project if app doesn't have one
        for (const app of allApps) {
            const repo = app.prodRepo || app.testRepo || (app.project ? projectRepos[app.project] : '') || '';
            if (!repo) continue; // Skip apps with no repo AND no project repo
            subPathIndex.push({ subPath: app.subPath || '', appId: app.id, repo, project: app.project || '' });
            if (app.project) projectRepos[app.project] = repo;
        }
        subPathIndex.sort((a, b) => b.subPath.length - a.subPath.length);

        // Helper: find the best app match for a given relative path
        const getDefaultTarget = (appId) => {
            const app = apps[appId];
            if (!app) return 'test';
            // Default to test — deploy to test first, promote to prod later
            return app.testRepo ? 'test' : (app.prodRepo ? 'prod' : 'test');
        };

        // === Phase 3: Match files to apps by path ===
        const repoResults = {}; // { repoKey: { repo, target, apps: {}, sharedFiles: [] } }
        const unmatched = [];
        
        // Determine which project this package is for (by counting subPath hits)
        const projectHits = {};
        for (const file of files) {
            const relPath = file.relativePath;
            for (const entry of subPathIndex) {
                if (entry.subPath === '') continue; // skip root apps for project detection
                if (relPath.startsWith(entry.subPath + '/') || relPath === entry.subPath) {
                    projectHits[entry.project] = (projectHits[entry.project] || 0) + 1;
                }
            }
        }
        const primaryProject = Object.entries(projectHits).sort((a, b) => b[1] - a[1])[0]?.[0] || null;

        for (const file of files) {
            let relPath = file.relativePath;
            // Detect CLAUDE.md by content if filename is a .md file that isn't already CLAUDE.md
            const baseName = relPath.split('/').pop();
            if (/\.md$/i.test(baseName) && baseName !== 'CLAUDE.md') {
                try {
                    const peek = await file.entry.async('string');
                    const detected = detectClaudeMd(relPath, peek);
                    if (detected !== relPath) {
                        file.relativePath = detected;
                        relPath = detected;
                    }
                } catch (e) { /* binary or unreadable, skip detection */ }
            }
            const fileAction = classifyFileAction(relPath);
            if (fileAction === 'skip') continue;

            // Find matching app: longest subPath that matches the start of relPath
            let match = null;
            for (const entry of subPathIndex) {
                const sub = entry.subPath;
                if (sub === '') {
                    // Root app: only match root-level files, and only for the primary project
                    if (!relPath.includes('/') && (!primaryProject || entry.project === primaryProject)) {
                        match = entry;
                        break;
                    }
                } else {
                    if (relPath.startsWith(sub + '/') || relPath === sub) {
                        match = entry;
                        break;
                    }
                }
            }

            if (!match) {
                // Check if it's a shared directory (e.g. shared/cc-shared.css)
                if (primaryProject && projectRepos[primaryProject]) {
                    const repo = projectRepos[primaryProject];
                    const target = getDefaultTarget(Object.keys(apps).find(id => apps[id].project === primaryProject && (apps[id].prodRepo === repo || apps[id].testRepo === repo)) || '');
                    const repoKey = `${repo}:${target}`;
                    if (!repoResults[repoKey]) repoResults[repoKey] = { repo, target, apps: {}, sharedFiles: [] };
                    repoResults[repoKey].sharedFiles.push({
                        zipPath: file.zipPath,
                        relativePath: relPath,
                        repoPath: relPath,
                        entry: file.entry
                    });
                } else {
                    unmatched.push({ path: relPath, reason: 'No matching subPath' });
                }
                continue;
            }

            const appConfig = apps[match.appId];
            const target = getDefaultTarget(match.appId);
            const repo = target === 'prod' ? (appConfig.prodRepo || appConfig.testRepo) : (appConfig.testRepo || appConfig.prodRepo);
            if (!repo) { unmatched.push({ path: relPath, reason: `No ${target} repo for ${match.appId}` }); continue; }

            const repoKey = `${repo}:${target}`;
            if (!repoResults[repoKey]) repoResults[repoKey] = { repo, target, apps: {}, sharedFiles: [] };
            if (!repoResults[repoKey].apps[match.appId]) repoResults[repoKey].apps[match.appId] = { config: appConfig, files: [], version: null };

            // Compute paths
            const appSubPath = match.subPath;
            const fileRelPath = appSubPath ? relPath.substring(appSubPath.length + 1) : relPath;

            const fileEntry = {
                zipPath: file.zipPath,
                relativePath: fileRelPath,
                repoPath: relPath, // path in zip = path in repo
                entry: file.entry
            };

            repoResults[repoKey].apps[match.appId].files.push(fileEntry);

            // Extract version from primary target file
            const expectedTarget = appConfig.targetPath || 'index.html';
            if (fileRelPath === expectedTarget) {
                try {
                    const content = await file.entry.async('string');
                    const version = extractVersionFromHTML(content);
                    if (version) repoResults[repoKey].apps[match.appId].version = version;
                } catch (e) { /* skip */ }
            }
        }

        // Collect top-level directories for structure validation
        const zipDirs = new Set();
        files.forEach(f => {
            const firstSlash = f.relativePath.indexOf('/');
            if (firstSlash > 0) zipDirs.add(f.relativePath.substring(0, firstSlash));
        });

        return {
            repos: repoResults,
            unmatched,
            rootStripped: rootPrefix || null,
            zipDirs: [...zipDirs]
        };
    }

    /**
     * validateMultiAppPackage(resolvedRepos, apps, deployedVersions, github)
     * 
     * Runs validatePackage() per-app and adds cross-app validation rules.
     * Returns: {
     *   appValidations: { [appId]: validationResult },
     *   crossAppIssues: [...],
     *   overallSeverity: 'error'|'warning'|'info'|null,
     *   summary: string
     * }
     */
    async function validateMultiAppPackage(resolvedRepos, apps, deployedVersions, github, zipDirs) {
        const appValidations = {};
        const crossAppIssues = [];
        const allAppIds = [];

        // Rule: zip-structure — check that zip directories match expected subPaths
        if (zipDirs && zipDirs.length > 0) {
            const knownSubPaths = new Set();
            const appIdToSubPath = {};
            const appList = Object.values(apps).filter(a => a.subPath !== undefined);
            for (const app of appList) {
                const sub = app.subPath || '';
                if (sub) knownSubPaths.add(sub);
                appIdToSubPath[app.id] = sub;
            }

            for (const dir of zipDirs) {
                if (knownSubPaths.has(dir)) continue;
                if (['shared', 'docs', 'skills-proposed', 'migration-tool'].includes(dir)) continue;

                // Check if this dir matches an app ID but uses wrong folder name
                const matchedApp = appList.find(a => a.id === dir);
                if (matchedApp) {
                    const expectedPath = matchedApp.subPath || '(root)';
                    crossAppIssues.push({
                        id: 'zip-structure-mismatch',
                        severity: 'error',
                        title: `Wrong folder: "${dir}/"`,
                        detail: `Found "${dir}/" but ${matchedApp.name} expects "${expectedPath}/"`,
                        fix: `Rename "${dir}/" to "${matchedApp.subPath}/" in the package`
                    });
                } else {
                    crossAppIssues.push({
                        id: 'zip-structure-unknown',
                        severity: 'info',
                        title: `Unknown folder: "${dir}/"`,
                        detail: `"${dir}/" does not match any configured app subPath`,
                        fix: 'Files in this folder will be unmatched'
                    });
                }
            }
        }

        for (const [repoKey, bucket] of Object.entries(resolvedRepos)) {
            for (const [appId, appData] of Object.entries(bucket.apps)) {
                allAppIds.push(appId);
                const appConfig = appData.config || apps[appId];
                const deployedVersion = deployedVersions?.[appId] || null;

                // Build file objects in the shape validatePackage expects
                const selectedFiles = [];
                for (const file of appData.files) {
                    const fileName = file.relativePath;
                    const fileAction = classifyFileAction(fileName);
                    let content = null;
                    let version = null;
                    
                    try {
                        content = await file.entry.async('string');
                        if (fileName.endsWith('.html') || fileName === 'sw.js') {
                            version = extractVersionFromHTML(content);
                        }
                    } catch (e) { /* binary file */ }
                    
                    // Compute targetPath: how this file would appear in the repo relative to subPath
                    const targetPath = file.relativePath;
                    
                    selectedFiles.push({
                        id: `${appId}-${fileName}`,
                        name: fileName,
                        content,
                        size: content?.length || 0,
                        version,
                        fileAction,
                        targetPath,
                        appId
                    });
                }

                // Run per-app validation (passing app-scoped files for both selected and staged)
                // For primary app (subPath ''), also include shared files so docs/ are found
                const isPrimaryApp = (apps[appId]?.subPath === '' || apps[appId]?.subPath === undefined);
                const sharedForValidation = isPrimaryApp ? (bucket.sharedFiles || []).map(sf => ({
                    id: `shared-${sf.relativePath}`,
                    name: sf.relativePath,
                    content: null,
                    size: 0,
                    version: null,
                    fileAction: classifyFileAction(sf.relativePath),
                    targetPath: sf.relativePath,
                    appId: '_shared'
                })) : [];
                const validation = validatePackage(selectedFiles, [...selectedFiles, ...sharedForValidation], appConfig, deployedVersion);
                appValidations[appId] = validation;
            }
        }

        // Cross-app validation rules
        // Rule: detection conflict — check for apps claiming same subPath
        const subPathClaims = {};
        for (const appId of allAppIds) {
            const app = apps[appId];
            const sub = app?.subPath || '';
            if (!subPathClaims[sub]) subPathClaims[sub] = [];
            subPathClaims[sub].push(appId);
        }
        for (const [sub, claimants] of Object.entries(subPathClaims)) {
            if (claimants.length > 1) {
                crossAppIssues.push({
                    id: 'multi-app-detection-conflict',
                    severity: 'error',
                    title: `Path conflict at "${sub || '/'}"`,
                    detail: `Multiple apps resolved to the same subPath: ${claimants.join(', ')}`,
                    fix: 'Check zip contents — files may be in the wrong directory'
                });
            }
        }

        // Rule: cross-app-version-consistency — warn if apps in the same project have divergent version schemes
        const projectVersions = {}; // { project: [{ appId, version, majorMinor }] }
        for (const [repoKey, bucket] of Object.entries(resolvedRepos)) {
            for (const [appId, appData] of Object.entries(bucket.apps)) {
                const appConfig = appData.config || apps[appId];
                const project = appConfig?.project;
                const version = appData.version;
                if (!project || !version) continue;
                if (!projectVersions[project]) projectVersions[project] = [];
                const parts = version.replace(/^v/i, '').split('.').map(Number);
                projectVersions[project].push({ 
                    appId, 
                    version, 
                    major: parts[0] || 0,
                    name: appConfig?.name || appId 
                });
            }
        }
        for (const [project, entries] of Object.entries(projectVersions)) {
            if (entries.length < 2) continue;
            const majors = [...new Set(entries.map(e => e.major))];
            if (majors.length > 1) {
                const versionList = entries.map(e => `${e.name} v${e.version}`).join(', ');
                crossAppIssues.push({
                    id: 'cross-app-version-consistency',
                    severity: 'info',
                    title: `Version scheme mismatch in "${project}"`,
                    detail: `Apps have different major versions: ${versionList}`,
                    fix: 'This is acceptable for satellite apps — just noting the difference'
                });
            }
        }

        // Rule: shared-file-new-to-repo — warn when shared files don't exist in the repo yet
        // Docs (docs/*.md, docs/*.txt) are info-level, NO API call needed — just count them.
        // Actual shared files (shared/*) get an API check and show as warning.
        if (github) {
            const newDocFiles = [];
            for (const [repoKey, bucket] of Object.entries(resolvedRepos)) {
                for (const file of (bucket.sharedFiles || [])) {
                    const isDoc = /^docs\//.test(file.relativePath) && /\.(md|txt)$/i.test(file.relativePath);
                    if (isDoc) {
                        // Doc files: just collect the name, no API call
                        newDocFiles.push(file.relativePath);
                    } else {
                        // Non-doc shared files: check if they exist in repo
                        // Known CC infrastructure paths (shared/*) are expected — downgrade to info after first deploy
                        const isKnownSharedPath = /^shared\/cc-shared\.(js|css)$/.test(file.relativePath);
                        try {
                            const exists = await github.fileExists(bucket.repo, file.repoPath);
                            if (!exists) {
                                crossAppIssues.push({
                                    id: 'shared-file-new',
                                    severity: isKnownSharedPath ? 'info' : 'warning',
                                    title: isKnownSharedPath
                                        ? `Shared file: ${file.relativePath}`
                                        : `New shared file: ${file.relativePath}`,
                                    detail: `${file.repoPath} does not exist in ${bucket.repo.split('/').pop()} yet`,
                                    fix: isKnownSharedPath
                                        ? 'CC infrastructure file — will be created on first deploy'
                                        : 'File will be created on deploy — verify the path is correct'
                                });
                            }
                        } catch (e) {
                            // Skip check on error — don't block validation
                        }
                    }
                }
            }
            // Collapse all doc files into a single info issue (no API calls made)
            if (newDocFiles.length > 0) {
                crossAppIssues.push({
                    id: 'new-docs-info',
                    severity: 'info',
                    title: `${newDocFiles.length} new doc${newDocFiles.length !== 1 ? 's' : ''} will be created`,
                    detail: newDocFiles.join(', '),
                    fix: 'Files will be created on deploy'
                });
            }
        }

        // Rule: repo-access-check — verify push access to all target repos
        if (github) {
            const checkedRepos = new Set();
            for (const [repoKey, bucket] of Object.entries(resolvedRepos)) {
                if (checkedRepos.has(bucket.repo)) continue;
                checkedRepos.add(bucket.repo);
                try {
                    const hasPush = await github.checkPushAccess(bucket.repo);
                    if (!hasPush) {
                        crossAppIssues.push({
                            id: 'repo-access-check',
                            severity: 'error',
                            title: `No push access: ${bucket.repo.split('/').pop()}`,
                            detail: `Cannot deploy to ${bucket.repo} — push permission required`,
                            fix: 'Check your GitHub token permissions or request repo access'
                        });
                    }
                } catch (e) {
                    crossAppIssues.push({
                        id: 'repo-access-check',
                        severity: 'error',
                        title: `Cannot verify access: ${bucket.repo.split('/').pop()}`,
                        detail: `Failed to check permissions for ${bucket.repo}: ${e.message}`,
                        fix: 'Check your GitHub token and network connection'
                    });
                }
            }
        }

        // Rule: unmatched files warning is handled by the caller (from resolvedRepos.unmatched)

        // Aggregate severity
        const allValidations = Object.values(appValidations).filter(Boolean);
        const hasCrossErrors = crossAppIssues.some(i => i.severity === 'error');
        const hasAppErrors = allValidations.some(v => v?.severity === 'error');
        const hasAppWarnings = allValidations.some(v => v?.severity === 'warning');
        const hasCrossWarnings = crossAppIssues.some(i => i.severity === 'warning');

        const overallSeverity = (hasCrossErrors || hasAppErrors) ? 'error'
            : (hasCrossWarnings || hasAppWarnings) ? 'warning'
            : allValidations.length > 0 ? 'info' : null;

        // Build summary
        const readyCount = allAppIds.filter(id => !appValidations[id] || appValidations[id].severity !== 'error').length;
        const errorCount = allAppIds.filter(id => appValidations[id]?.severity === 'error').length;
        const warnCount = allAppIds.filter(id => appValidations[id]?.severity === 'warning').length;
        
        const parts = [];
        if (readyCount > 0) parts.push(`${readyCount} ready`);
        if (warnCount > 0) parts.push(`${warnCount} warning${warnCount !== 1 ? 's' : ''}`);
        if (errorCount > 0) parts.push(`${errorCount} error${errorCount !== 1 ? 's' : ''}`);

        return {
            appValidations,
            crossAppIssues,
            overallSeverity,
            summary: parts.join(', ')
        };
    }

    /**
     * isMultiAppZip(zip, apps)
     * 
     * Quick check: does this zip contain files for more than one app?
     * Used by Dashboard drop zone to decide whether to route to Smart Deploy.
     */
    function isMultiAppZip(zip, apps) {
        const appList = Object.values(apps).filter(a => a.subPath !== undefined && (a.prodRepo || a.testRepo || a.project));
        const allPaths = [];
        zip.forEach((path, entry) => { if (!entry.dir) allPaths.push(path); });

        // Strip root wrapper
        let rootPrefix = '';
        if (allPaths.length > 0) {
            const firstSlash = allPaths[0].indexOf('/');
            if (firstSlash > 0) {
                const candidate = allPaths[0].substring(0, firstSlash + 1);
                if (allPaths.every(p => p.startsWith(candidate))) rootPrefix = candidate;
            }
        }
        const normalized = allPaths.map(p => rootPrefix ? p.substring(rootPrefix.length) : p);

        // Count distinct apps matched by subPath
        const matchedApps = new Set();
        for (const relPath of normalized) {
            for (const app of appList) {
                const sub = app.subPath || '';
                if (sub === '') {
                    if (!relPath.includes('/')) matchedApps.add(app.id);
                } else {
                    if (relPath.startsWith(sub + '/')) matchedApps.add(app.id);
                }
            }
            if (matchedApps.size >= 2) return true;
        }
        return matchedApps.size >= 2;
    }


    // =========================================================================
    // [v8.63.0] SessionLogView, PostSessionReviewModal, SessionHistoryPanel removed
    // Replaced by Ideation Pipeline (ExploreInChatModal, IdeationBriefGenerator)
    // =========================================================================


    // =========================================================================
    // PROJECT SCOPING — Category-Driven Scoping Flow (v8.23.0 / Phase 1.2)
    // =========================================================================
    
    // Category question definitions — static data, no AI dependency
    // Built-in scope categories (Phase 5.1: extensible — custom categories can override or extend)
    const SCOPE_CATEGORIES = {
        game: { label: 'Game', icon: '🎮', description: 'Puzzle, word game, or interactive game' },
        tool: { label: 'Tool', icon: '🔧', description: 'Utility or productivity tool' },
        dashboard: { label: 'Dashboard', icon: '📊', description: 'Data display or monitoring' },
        content: { label: 'Content', icon: '📄', description: 'Content site or documentation' },
        admin: { label: 'Admin', icon: '🔐', description: 'Administration or management panel' }
    };
    
    // Helper: get all categories (built-in + custom from config)
    function getAllCategories(config) {
        const custom = config?.customCategories || {};
        return { ...SCOPE_CATEGORIES, ...custom };
    }
    
    // v8.38.0: PM-first intent questions (Phase 2.1 + 2.4)
    // Questions capture INTENT. The package engine translates intent into technology.
    // Removed: tool.settingsPersistence (redundant with dataPersistence)
    // Merged: dashboard.autoRefresh + dashboard.realtime → dashboard.dataUpdates
    const CATEGORY_QUESTIONS = {
        game: [
            { id: 'dailyReset', label: 'Does the game reset daily with a new puzzle?', type: 'toggle', default: true, drives: 'Daily reset logic, streak tracking, puzzle number' },
            { id: 'difficultyModes', label: 'How many difficulty levels?', type: 'select', options: ['none', 'easy-hard', 'multiple'], optionLabels: ['None', 'Two modes (e.g. Easy/Hard)', 'Multiple levels'], default: 'easy-hard', drives: 'Mode selector, separate stats per mode' },
            { id: 'scoringSystem', label: 'How are players scored?', type: 'select', options: ['none', 'points', 'tries', 'time'], optionLabels: ['No scoring', 'Points earned', 'Number of attempts', 'Time to complete'], default: 'points', drives: 'Score display, personal best tracking' },
            { id: 'shareResults', label: 'Can players share their results?', type: 'toggle', default: true, drives: 'Share button with clipboard fallback' },
            { id: 'multiplayer', label: 'Will players interact with each other?', type: 'toggle', default: false, drives: 'User accounts, friend system, battles or leaderboard' },
            { id: 'streaks', label: 'Track daily play streaks?', type: 'toggle', default: true, drives: 'Streak counter, daily play detection' },
            { id: 'achievements', label: 'Reward milestones with achievements?', type: 'toggle', default: false, drives: 'Achievement system, unlock notifications' },
            { id: 'soundEffects', label: 'Include sound effects?', type: 'toggle', default: false, drives: 'Audio on key events, mute toggle' },
            { id: 'tutorial', label: 'Guide new players through the game?', type: 'toggle', default: true, drives: 'Welcome walkthrough, replayable from menu' }
        ],
        tool: [
            { id: 'dataPersistence', label: 'Should data save between sessions?', type: 'select', options: ['none', 'localStorage', 'Firebase'], optionLabels: ['No — starts fresh each time', 'Yes — on this device', 'Yes — synced across devices'], default: 'localStorage', drives: 'Storage strategy and data migration' },
            { id: 'primaryDataType', label: 'What does the user work with?', type: 'text', placeholder: 'e.g. label sheets, expense records, recipes', default: '', drives: 'Data model and CRUD scaffolding' },
            { id: 'multiItem', label: 'Work with a list of items or a single item?', type: 'select', options: [true, false], optionLabels: ['A list of items (browse, select, manage)', 'A single item at a time'], default: true, drives: 'List view, item cards, bulk actions' },
            { id: 'searchFilter', label: 'Will users need to search or filter?', type: 'toggle', default: true, drives: 'Search input, filter controls' },
            { id: 'importExport', label: 'Import or export data?', type: 'toggle', default: true, drives: 'File input, download as JSON/CSV' },
            { id: 'printSupport', label: 'Does anything need to be printed?', type: 'toggle', default: false, drives: 'Print-friendly layout, page breaks' },
            { id: 'undoRedo', label: 'Should users be able to undo mistakes?', type: 'toggle', default: false, drives: 'Undo/redo with Ctrl+Z support' },
            { id: 'keyboardShortcuts', label: 'Power-user keyboard shortcuts?', type: 'toggle', default: false, drives: 'Key bindings, shortcut reference' }
        ],
        dashboard: [
            { id: 'dataSources', label: 'Where does the data come from?', type: 'multi-select', options: ['Firebase', 'API', 'localStorage', 'manual'], optionLabels: ['Database', 'External service', 'Browser storage', 'User input'], default: ['Firebase'], drives: 'Data fetching and refresh strategy' },
            { id: 'layout', label: 'How should data be displayed?', type: 'select', options: ['cards', 'table', 'mixed'], optionLabels: ['Visual cards', 'Data table', 'Mix of both'], default: 'cards', drives: 'Layout pattern and component structure' },
            { id: 'dataUpdates', label: 'How should data stay current?', type: 'select', options: ['manual', 'periodic', 'realtime'], optionLabels: ['Manual refresh only', 'Auto-refresh periodically', 'Live — updates instantly'], default: 'periodic', drives: 'Refresh interval or live listeners' },
            { id: 'filtering', label: 'Can users filter what they see?', type: 'toggle', default: true, drives: 'Filter controls, active filter display' },
            { id: 'dateRange', label: 'Filter by date range?', type: 'toggle', default: true, drives: 'Date picker, preset ranges' },
            { id: 'exportData', label: 'Download data as a file?', type: 'toggle', default: false, drives: 'Export to CSV or JSON' }
        ],
        content: [
            { id: 'contentType', label: 'Does the content change?', type: 'select', options: ['static', 'dynamic'], optionLabels: ['Same every time', 'Updates regularly'], default: 'static', drives: 'Static vs runtime content strategy' },
            { id: 'contentSource', label: 'Where does content come from?', type: 'select', options: ['hardcoded', 'Firebase', 'API', 'CMS'], optionLabels: ['Built into the app', 'Database', 'External service', 'Content management system'], default: 'hardcoded', drives: 'Data loading pattern' },
            { id: 'seo', label: 'Should search engines find this?', type: 'toggle', default: false, drives: 'SEO meta tags, Open Graph, semantic HTML' },
            { id: 'mediaTypes', label: 'What types of content?', type: 'multi-select', options: ['text', 'images', 'video', 'audio'], default: ['text'], drives: 'Media handling and optimization' },
            { id: 'navPattern', label: 'How much content?', type: 'select', options: ['single-page', 'multi-section', 'paginated'], optionLabels: ['One page', 'Multiple sections', 'Many pages'], default: 'single-page', drives: 'Navigation structure, scroll behavior' }
        ],
        admin: [
            { id: 'authRequired', label: 'Must users sign in?', type: 'toggle', default: true, drives: 'Login flow, session management' },
            { id: 'roleAccess', label: 'Different permission levels?', type: 'toggle', default: false, drives: 'Role definitions, permission checks' },
            { id: 'crudOps', label: 'Can users create, edit, and delete records?', type: 'toggle', default: true, drives: 'Data tables, edit forms, delete confirmation' },
            { id: 'auditLog', label: 'Track who changed what?', type: 'toggle', default: false, drives: 'Action log with timestamps and attribution' },
            { id: 'bulkOps', label: 'Act on multiple items at once?', type: 'toggle', default: true, drives: 'Multi-select, batch operations' },
            { id: 'dataViz', label: 'Charts or visual summaries?', type: 'toggle', default: false, drives: 'Charts, summary cards, trend indicators' }
        ]
    };
    
    // Universal starting standards (always on by default)
    const UNIVERSAL_STANDARDS = [
        { id: 'css-variables', label: 'CSS variables for all colors — :root and [data-theme="dark"]', group: 'theme' },
        { id: 'dark-light-toggle', label: 'Dark mode default with light mode toggle', group: 'theme' },
        { id: 'theme-persistence', label: 'Theme persistence in localStorage', group: 'theme' },
        { id: 'mobile-first', label: 'Mobile-first responsive design', group: 'layout' },
        { id: 'safe-areas', label: 'Safe area support for notched devices', group: 'layout' },
        { id: 'toast-system', label: 'Toast notification system (replaces native alert/confirm/prompt)', group: 'feedback' },
        { id: 'confirm-dialog', label: 'Custom confirm dialog', group: 'feedback' },
        { id: 'hamburger-menu', label: 'Hamburger menu (☰) with settings panel', group: 'nav' },
        { id: 'meta-tags', label: 'Meta tags: version and gs-app-id', group: 'infra' },
        { id: 'version-display', label: 'Version display in settings/footer', group: 'infra' },
        { id: 'loading-spinner', label: 'Loading spinner for async operations', group: 'feedback' },
        { id: 'empty-states', label: 'Empty state pattern (icon + message + action)', group: 'feedback' }
    ];
    
    // Category-driven standards (selected based on answers)
    const CATEGORY_STANDARDS = {
        'daily-reset': { label: 'Daily reset at midnight UTC', group: 'game', condition: (cat, ans) => cat === 'game' && ans.dailyReset },
        'streak-tracking': { label: 'Streak tracking with localStorage persistence', group: 'game', condition: (cat, ans) => cat === 'game' && ans.streaks },
        'share-results': { label: 'Share results (navigator.share → clipboard fallback)', group: 'game', condition: (cat, ans) => cat === 'game' && ans.shareResults },
        'difficulty-modes': { label: 'Difficulty mode selector in settings', group: 'game', condition: (cat, ans) => cat === 'game' && ans.difficultyModes !== 'none' },
        'stats-tracking': { label: 'Stats tracking object in localStorage', group: 'game', condition: (cat, ans) => cat === 'game' && ans.scoringSystem !== 'none' },
        'celebration-effects': { label: 'Celebration effects on special achievements', group: 'game', condition: (cat, ans) => cat === 'game' && ans.achievements },
        'tutorial-onboarding': { label: 'Tutorial: welcome modal → guided steps → replay from menu', group: 'game', condition: (cat, ans) => cat === 'game' && ans.tutorial },
        'sound-manager': { label: 'Audio manager with mute toggle', group: 'game', condition: (cat, ans) => cat === 'game' && ans.soundEffects },
        'tab-nav': { label: 'Tab navigation pattern', group: 'tool', condition: (cat, ans) => cat === 'tool' && (ans.multiItem === true || ans.multiItem === 'true') },
        'settings-storage': { label: 'Settings persistence (single localStorage key with JSON)', group: 'tool', condition: (cat, ans) => cat === 'tool' && ans.dataPersistence !== 'none' },
        'import-export': { label: 'Import/export functions', group: 'tool', condition: (cat, ans) => cat === 'tool' && ans.importExport },
        'print-css': { label: 'Print-friendly CSS', group: 'tool', condition: (cat, ans) => cat === 'tool' && ans.printSupport },
        'keyboard-shortcuts': { label: 'Keyboard shortcuts with reference panel', group: 'tool', condition: (cat, ans) => cat === 'tool' && ans.keyboardShortcuts },
        'undo-redo': { label: 'Undo/redo with state history', group: 'tool', condition: (cat, ans) => cat === 'tool' && ans.undoRedo },
        'firebase-auth': { label: 'Firebase Auth: Google sign-in flow with auth state listener', group: 'firebase', condition: (cat, ans) => (cat === 'game' && ans.multiplayer) || (cat === 'admin' && ans.authRequired) || (cat === 'dashboard' && ans.dataSources?.includes('Firebase')) },
        'firebase-rtdb': { label: 'Firebase RTDB: read/write helpers at specified paths', group: 'firebase', condition: (cat, ans) => (cat === 'game' && ans.multiplayer) || (cat === 'admin') || (cat === 'dashboard' && ans.dataSources?.includes('Firebase')) || (cat === 'tool' && ans.dataPersistence === 'Firebase') },
        'firebase-connection': { label: 'Connection status indicator', group: 'firebase', condition: (cat, ans) => (cat === 'game' && ans.multiplayer) || (cat === 'dashboard' && ans.dataUpdates === 'realtime') },
        'auto-refresh': { label: 'Auto-refresh with last-updated display', group: 'dashboard', condition: (cat, ans) => cat === 'dashboard' && ans.dataUpdates === 'periodic' },
        'date-range': { label: 'Date range selector for time-scoped queries', group: 'dashboard', condition: (cat, ans) => cat === 'dashboard' && ans.dateRange },
        'data-export': { label: 'CSV/JSON data export', group: 'dashboard', condition: (cat, ans) => cat === 'dashboard' && ans.exportData },
        'realtime-updates': { label: 'Real-time Firebase listeners with live indicators', group: 'dashboard', condition: (cat, ans) => cat === 'dashboard' && ans.dataUpdates === 'realtime' },
        'seo-tags': { label: 'SEO meta tags, semantic HTML, OG tags', group: 'content', condition: (cat, ans) => cat === 'content' && ans.seo },
        'role-access': { label: 'Role-based access control with UI permission gating', group: 'admin', condition: (cat, ans) => cat === 'admin' && ans.roleAccess },
        'audit-logging': { label: 'Audit logging with timestamps', group: 'admin', condition: (cat, ans) => cat === 'admin' && ans.auditLog },
        'bulk-actions': { label: 'Multi-select with batch operations', group: 'admin', condition: (cat, ans) => cat === 'admin' && ans.bulkOps },
        'data-charts': { label: 'Charts and summary cards', group: 'admin', condition: (cat, ans) => cat === 'admin' && ans.dataViz }
    };
    
    // Feature generation from category answers
    function generateFeaturesFromScope(category, answers) {
        const features = [];
        
        if (category === 'game') {
            if (answers.dailyReset) features.push({ title: 'Daily puzzle generation with midnight UTC reset', description: 'New puzzle each day, puzzle number tracking, automatic reset at midnight UTC', priority: 'core', effort: 'session' });
            if (answers.scoringSystem !== 'none') features.push({ title: `${answers.scoringSystem === 'points' ? 'Points-based' : answers.scoringSystem === 'tries' ? 'Attempts-based' : 'Time-based'} scoring with personal best tracking`, description: `Track ${answers.scoringSystem} per game with historical best`, priority: 'core', effort: 'quick' });
            if (answers.shareResults) features.push({ title: 'Share results with emoji grid', description: 'Navigator.share with clipboard fallback, generates share text with emoji representation', priority: 'core', effort: 'session' });
            if (answers.difficultyModes !== 'none') features.push({ title: `${answers.difficultyModes === 'easy-hard' ? 'Easy/Hard' : 'Multiple'} difficulty modes with separate stats`, description: 'Mode selector in menu/settings with independent statistics tracking', priority: 'core', effort: 'session' });
            if (answers.streaks) features.push({ title: 'Streak tracking with daily play detection', description: 'Current streak, max streak, daily check against localStorage', priority: 'core', effort: 'quick' });
            if (answers.tutorial) features.push({ title: 'Tutorial / onboarding flow', description: 'Welcome modal for first visit, guided walkthrough, replayable from menu', priority: 'nice-to-have', effort: 'session' });
            if (answers.achievements) features.push({ title: 'Achievement system', description: 'Achievement definitions, unlock tracking, celebration notification', priority: 'nice-to-have', effort: 'multi-session' });
            if (answers.soundEffects) features.push({ title: 'Sound effects with mute toggle', description: 'Audio manager, sound triggers on key events, mute in settings', priority: 'nice-to-have', effort: 'session' });
            if (answers.multiplayer) features.push({ title: 'Multiplayer / social features', description: 'Firebase auth, friend connections, battles or shared leaderboard', priority: 'nice-to-have', effort: 'multi-session' });
        }
        
        if (category === 'tool') {
            if (answers.multiItem === true || answers.multiItem === 'true') features.push({ title: 'Multi-item list with CRUD', description: 'List view, item cards, create/edit/delete with confirmation', priority: 'core', effort: 'session' });
            if (answers.searchFilter) features.push({ title: 'Search and filter controls', description: 'Text search, filter dropdowns, clear filters action', priority: 'core', effort: 'quick' });
            if (answers.importExport) features.push({ title: 'Import/export functionality', description: 'File input for import, export to JSON/CSV, format validation', priority: 'core', effort: 'session' });
            if (answers.printSupport) features.push({ title: 'Print support with preview', description: 'Print-friendly CSS, print preview, page break handling', priority: 'core', effort: 'session' });
            if (answers.dataPersistence !== 'none') features.push({ title: 'Persistent settings', description: 'Settings object in localStorage, settings UI in menu', priority: 'core', effort: 'quick' });
            if (answers.undoRedo) features.push({ title: 'Undo/redo system', description: 'State history stack, keyboard shortcuts Ctrl+Z/Y', priority: 'nice-to-have', effort: 'session' });
            if (answers.keyboardShortcuts) features.push({ title: 'Keyboard shortcuts', description: 'Key bindings for common actions, shortcut reference panel', priority: 'nice-to-have', effort: 'quick' });
            if (answers.dataPersistence === 'Firebase') features.push({ title: 'Firebase data persistence', description: 'Firebase RTDB storage with auth, sync status indicator', priority: 'core', effort: 'session' });
        }
        
        if (category === 'dashboard') {
            features.push({ title: `${answers.layout === 'cards' ? 'Card grid' : answers.layout === 'table' ? 'Data table' : 'Mixed'} layout`, description: `Primary data display using ${answers.layout} pattern`, priority: 'core', effort: 'session' });
            if (answers.filtering) features.push({ title: 'Filter controls', description: 'Filter dropdowns, active filter display, clear all action', priority: 'core', effort: 'quick' });
            if (answers.dataUpdates === 'periodic') features.push({ title: 'Auto-refresh with interval', description: 'Configurable refresh interval, last-updated timestamp display', priority: 'core', effort: 'quick' });
            if (answers.dataUpdates === 'realtime') features.push({ title: 'Real-time live updates', description: 'Firebase listeners, live update indicators, connection status', priority: 'core', effort: 'session' });
            if (answers.dateRange) features.push({ title: 'Date range selector', description: 'Date picker for time-scoped data queries, preset ranges', priority: 'core', effort: 'session' });
            if (answers.exportData) features.push({ title: 'Data export (CSV/JSON)', description: 'Export current view to CSV or JSON format', priority: 'nice-to-have', effort: 'quick' });
        }
        
        if (category === 'content') {
            features.push({ title: `${answers.contentType === 'static' ? 'Static' : 'Dynamic'} content display`, description: `Content loaded from ${answers.contentSource}`, priority: 'core', effort: 'session' });
            if (answers.navPattern !== 'single-page') features.push({ title: `${answers.navPattern === 'multi-section' ? 'Section-based' : 'Paginated'} navigation`, description: `${answers.navPattern} navigation with smooth transitions`, priority: 'core', effort: 'session' });
            if (answers.seo) features.push({ title: 'SEO optimization', description: 'Meta tags, OG tags, semantic HTML, structured data', priority: 'core', effort: 'quick' });
            if (answers.mediaTypes?.includes('images')) features.push({ title: 'Image handling', description: 'Responsive images, lazy loading, lightbox', priority: 'core', effort: 'session' });
            if (answers.mediaTypes?.includes('video')) features.push({ title: 'Video embedding', description: 'Video player, responsive embeds', priority: 'core', effort: 'quick' });
        }
        
        if (category === 'admin') {
            if (answers.authRequired) features.push({ title: 'Authentication gate', description: 'Firebase auth, login/logout flow, session management', priority: 'core', effort: 'session' });
            if (answers.crudOps) features.push({ title: 'CRUD data management', description: 'Data tables, edit modals, create/update/delete with confirmation', priority: 'core', effort: 'session' });
            if (answers.bulkOps) features.push({ title: 'Bulk operations', description: 'Multi-select, batch status changes, bulk delete with confirmation', priority: 'core', effort: 'session' });
            if (answers.roleAccess) features.push({ title: 'Role-based access control', description: 'Role definitions, permission checks, UI gating by role', priority: 'core', effort: 'multi-session' });
            if (answers.auditLog) features.push({ title: 'Audit logging', description: 'Action log with timestamps, user attribution, log viewer', priority: 'nice-to-have', effort: 'session' });
            if (answers.dataViz) features.push({ title: 'Data visualization', description: 'Charts, summary cards, trend indicators', priority: 'nice-to-have', effort: 'session' });
        }
        
        return features;
    }
    
    // Assemble starting standards from category + answers
    function assembleStartingStandards(category, answers) {
        const standards = UNIVERSAL_STANDARDS.map(s => s.id);
        Object.entries(CATEGORY_STANDARDS).forEach(([id, spec]) => {
            if (spec.condition(category, answers)) {
                standards.push(id);
            }
        });
        return standards;
    }
    
    // =========================================================================
    // [v8.63.0] CLAUDE_INSTRUCTIONS.md GENERATOR removed — replaced by pipeline CLAUDE.md generation
    // Stub retained for ClaudePrepModal backward compatibility
    // =========================================================================
    
    function generateClaudeInstructions(app, scopeData, config) { return ""; }
    
    
    // =========================================================================
    // PRODUCT BRIEF GENERATOR (Phase 5.5)
    // Auto-generated living document in PM language describing the product.
    // Included in Claude Prep packages so any stream owner gets product context
    // without needing another stream's source code.
    // =========================================================================
    
    const ProductBriefGenerator = {
        
        /**
         * Generate PRODUCT_BRIEF.md from existing CC data sources.
         * @param {Object} app - App definition from CC config
         * @param {Object} scopeData - Scope data from Firebase appScopes/{appId} (nullable)
         * @param {Object} config - CC config (for project info)
         * @param {Array} workItems - All work items (will be filtered to this app)
         * @param {Array} deployments - Deploy history
         * @param {Array} streams - Work streams (nullable)
         * @returns {string} Markdown content for PRODUCT_BRIEF.md
         */
        generate(app, scopeData, config, workItems, deployments, streams) {
            const now = new Date();
            const projectDef = config?.projects?.[app.project] || {};
            const appItems = (workItems || []).filter(wi => wi.appId === app.id);
            const appStreams = (streams || []).filter(s => s.appId === app.id);
            const appDeploys = (deployments || []).filter(d => d.appId === app.id && d.status === 'success');
            const cat = scopeData?.category ? (SCOPE_CATEGORIES[scopeData.category] || {}) : {};
            
            let md = '';
            
            // === Header ===
            md += `# ${app.name} — Product Brief\n\n`;
            md += `> Living document auto-generated from Command Center project data.\n`;
            md += `> Describes what the product does in PM language — not how it's built.\n`;
            md += `> Updated: ${now.toLocaleDateString()}\n\n`;
            
            // === Product Identity ===
            md += `## Product Identity\n\n`;
            const description = scopeData?.description || app.lifecycle?.problemStatement || '';
            if (description) {
                md += `${description}\n\n`;
            }
            md += `- **Category:** ${cat.icon || app.icon || '📦'} ${cat.label || scopeData?.category || app.lifecycle?.category || 'Application'}\n`;
            if (projectDef.name) md += `- **Project:** ${projectDef.name}\n`;
            md += `- **Maturity:** ${app.lifecycle?.currentMaturity || 'unknown'}`;
            if (app.lifecycle?.maturityTarget && app.lifecycle.maturityTarget !== app.lifecycle.currentMaturity) {
                md += ` → ${app.lifecycle.maturityTarget}`;
            }
            md += `\n`;
            if (app.lifecycle?.targetAudience) md += `- **Audience:** ${app.lifecycle.targetAudience}\n`;
            if (app.lifecycle?.userGoal) md += `- **User Goal:** ${app.lifecycle.userGoal}\n`;
            if (app.lifecycle?.successMetric) md += `- **Success Metric:** ${app.lifecycle.successMetric}\n`;
            
            const prodVer = app.versions?.prod || app.versions?.test || '—';
            const lastDeploy = appDeploys[0];
            md += `- **Current Version:** ${prodVer}`;
            if (lastDeploy) {
                md += ` (deployed ${new Date(lastDeploy.completedAt || lastDeploy.startedAt).toLocaleDateString()})`;
            }
            md += `\n\n`;
            
            // === Key Product Decisions ===
            if (scopeData?.categoryAnswers && Object.keys(scopeData.categoryAnswers).length > 0) {
                md += `## Key Product Decisions\n\n`;
                md += this._formatProductDecisions(scopeData, cat);
                md += '\n';
            }
            
            // === Feature Inventory ===
            md += this._generateFeatureInventory(appItems, scopeData);
            
            // === Work Streams (if any) ===
            if (appStreams.length > 0) {
                md += this._generateStreamOverview(appStreams, appItems);
            }
            
            // === Recent Activity ===
            if (appDeploys.length > 0) {
                md += `## Recent Releases\n\n`;
                const recent = appDeploys.slice(0, 5);
                recent.forEach(d => {
                    const date = new Date(d.completedAt || d.startedAt).toLocaleDateString();
                    const env = (d.target || 'prod').toUpperCase();
                    md += `- **v${d.version || '?'}** (${date}, ${env})`;
                    if (d.workItemsCompleted) md += ` — ${d.workItemsCompleted} item${d.workItemsCompleted !== 1 ? 's' : ''} shipped`;
                    md += `\n`;
                });
                md += '\n';
            }
            
            // === Decisions from Scoping ===
            if (scopeData?.decisions && scopeData.decisions.length > 0) {
                md += `## Open Decisions\n\n`;
                scopeData.decisions.forEach(d => {
                    md += `- ${d.title || d}`;
                    if (d.status === 'resolved') md += ` ✅`;
                    md += `\n`;
                });
                md += '\n';
            }
            
            md += `---\n`;
            md += `*Generated ${now.toLocaleDateString()} by Command Center v${document.querySelector('meta[name="version"]')?.content || '?'}*\n`;
            
            return md;
        },
        
        /**
         * Format scoping category answers as human-readable product decisions.
         */
        _formatProductDecisions(scopeData, cat) {
            const answers = scopeData.categoryAnswers || {};
            let md = '';
            
            // Map technical scope answers to PM-language decisions
            const decisionMap = {
                // Game
                difficulty: { label: 'Difficulty', format: v => v === 'easy-hard' ? 'Two modes (Easy & Hard)' : v === 'multiple' ? 'Multiple levels' : 'No difficulty modes' },
                scoring: { label: 'Scoring', format: v => v === 'points' ? 'Point-based scoring' : v === 'stars' ? 'Star rating' : v === 'streaks' ? 'Streak-based' : v || 'None' },
                dailyPuzzle: { label: 'Daily Content', format: v => v ? 'Yes — daily puzzle/challenge' : 'No — play anytime' },
                multiplayer: { label: 'Multiplayer', format: v => v ? 'Yes' : 'No — single player' },
                sharing: { label: 'Share Results', format: v => v ? 'Yes — shareable results' : 'No sharing' },
                
                // Tool
                multiItem: { label: 'Item Model', format: v => v === 'list' ? 'Works with a list of items' : v === 'single' ? 'Single item at a time' : v || 'Unknown' },
                dataPersistence: { label: 'Data Persistence', format: v => v === 'firebase' ? 'Saves to cloud (syncs across devices)' : v === 'localStorage' ? 'Saves locally (this device only)' : v === 'none' ? 'No save — session only' : v || 'Unknown' },
                exportImport: { label: 'Import/Export', format: v => v ? 'Yes' : 'No' },
                
                // Dashboard
                dataSource: { label: 'Data Source', format: v => v === 'firebase' ? 'Database' : v === 'api' ? 'External service' : v === 'manual' ? 'User input' : v || 'Unknown' },
                dataUpdates: { label: 'Data Updates', format: v => v === 'realtime' ? 'Instant (real-time)' : v === 'periodic' ? 'Periodic auto-refresh' : 'Manual refresh' },
                
                // Content
                contentType: { label: 'Content Updates', format: v => v === 'dynamic' ? 'Updates regularly' : 'Same every time' },
                navigation: { label: 'Content Size', format: v => v === 'paginated' ? 'Many pages' : v === 'multi-section' ? 'Multiple sections' : 'Single page' },
                
                // Admin
                crudOperations: { label: 'CRUD', format: v => v ? 'Create, edit, and delete records' : 'Read-only' },
                authRequired: { label: 'Authentication', format: v => v ? 'Login required' : 'No auth' }
            };
            
            for (const [key, value] of Object.entries(answers)) {
                const mapper = decisionMap[key];
                if (mapper && value !== undefined && value !== null && value !== '') {
                    md += `- **${mapper.label}:** ${mapper.format(value)}\n`;
                }
            }
            
            return md;
        },
        
        /**
         * Generate the feature inventory section from work items and scope data.
         */
        _generateFeatureInventory(appItems, scopeData) {
            let md = `## Feature Inventory\n\n`;
            
            // Shipped features (done work items)
            const shipped = appItems.filter(wi => wi.status === 'done' && (wi.type === 'feature' || wi.type === 'enhancement'));
            // In-progress
            const inProgress = appItems.filter(wi => (wi.status === 'in-progress' || wi.status === 'review') && (wi.type === 'feature' || wi.type === 'enhancement'));
            // Planned (ready)
            const planned = appItems.filter(wi => wi.status === 'ready' && (wi.type === 'feature' || wi.type === 'enhancement'));
            // Ideas
            const ideas = appItems.filter(wi => wi.status === 'idea' && (wi.type === 'feature' || wi.type === 'enhancement'));
            
            if (shipped.length > 0) {
                md += `### Shipped (${shipped.length})\n`;
                shipped.forEach(wi => {
                    md += `- ✅ ${wi.title}`;
                    if (wi.milestone) md += ` (${wi.milestone})`;
                    md += `\n`;
                });
                md += '\n';
            }
            
            if (inProgress.length > 0) {
                md += `### In Progress (${inProgress.length})\n`;
                inProgress.forEach(wi => {
                    md += `- 🔄 ${wi.title}`;
                    if (wi.status === 'review') md += ` — in review`;
                    md += `\n`;
                });
                md += '\n';
            }
            
            if (planned.length > 0) {
                md += `### Planned (${planned.length})\n`;
                planned.forEach(wi => {
                    md += `- 📋 ${wi.title}`;
                    if (wi.priority === 'must-have' || wi.priority === 'core') md += ` ⭐`;
                    md += `\n`;
                });
                md += '\n';
            }
            
            if (ideas.length > 0) {
                md += `### Ideas (${ideas.length})\n`;
                ideas.slice(0, 10).forEach(wi => {
                    md += `- 💡 ${wi.title}\n`;
                });
                if (ideas.length > 10) md += `- *...and ${ideas.length - 10} more ideas*\n`;
                md += '\n';
            }
            
            // Also pull from scope's future features if no work items exist yet
            if (shipped.length === 0 && inProgress.length === 0 && planned.length === 0 && scopeData?.v1Features) {
                md += `### Launch Features (from scope)\n`;
                (scopeData.v1Features || []).filter(f => f.priority !== 'out-of-scope').forEach(f => {
                    md += `- ${f.title}`;
                    if (f.priority === 'core' || f.priority === 'must-have') md += ` ⭐`;
                    md += `\n`;
                });
                md += '\n';
            }
            
            if (shipped.length === 0 && inProgress.length === 0 && planned.length === 0 && !scopeData?.v1Features) {
                md += `*No features tracked yet. Use the Scoping flow or Backlog to define features.*\n\n`;
            }
            
            // Known bugs count
            const bugs = appItems.filter(wi => wi.type === 'bugfix' && wi.status !== 'done' && wi.status !== 'deferred');
            if (bugs.length > 0) {
                md += `### Known Issues (${bugs.length})\n`;
                bugs.forEach(wi => {
                    md += `- 🐛 ${wi.title}`;
                    if (wi.priority === 'must-have' || wi.priority === 'critical') md += ` ❗`;
                    md += `\n`;
                });
                md += '\n';
            }
            
            return md;
        },
        
        /**
         * Generate stream overview section.
         */
        _generateStreamOverview(appStreams, appItems) {
            let md = `## Work Streams\n\n`;
            
            appStreams.forEach(stream => {
                const streamItems = appItems.filter(wi => wi.streamId === stream.id);
                const done = streamItems.filter(wi => wi.status === 'done').length;
                const total = streamItems.length;
                const pct = total > 0 ? Math.round(done / total * 100) : 0;
                
                md += `### ${stream.name}`;
                if (stream.status === 'complete') md += ` ✅`;
                else if (stream.status === 'blocked') md += ` 🚫`;
                md += `\n`;
                if (stream.owner) md += `- **Owner:** ${stream.owner}\n`;
                if (stream.goal) md += `- **Goal:** ${stream.goal}\n`;
                md += `- **Progress:** ${done}/${total} items (${pct}%)\n`;
                if (stream.status !== 'active' && stream.status !== 'complete') md += `- **Status:** ${stream.status}\n`;
                md += '\n';
            });
            
            return md;
        },
        
        /**
         * Check if enough data exists to generate a useful brief.
         */
        hasData(app, scopeData, workItems) {
            const appItems = (workItems || []).filter(wi => wi.appId === app.id);
            return !!(scopeData || appItems.length > 0 || app.lifecycle?.problemStatement || app.lifecycle?.category);
        }
    };
    
    // =========================================================================
    // WORKSTREAM BRIEF GENERATOR (Streams Evolution — Session 2)
    // =========================================================================
    
    const WorkstreamBriefGenerator = {
        
        /**
         * Generate a focused workstream brief — a ~30-line context block
         * designed to be pasted into a Claude session for continuity.
         * 
         * @param {Object} stream - Stream object from WorkStreamService
         * @param {Object} apps - Apps map {id: appDef} from config
         * @param {Object} versions - Map of appId → {test, prod} version strings
         * @returns {string} Markdown brief
         */
        generate(stream, apps, versions) {
            if (!stream) return '# Error\n\nNo stream data provided.';
            
            const now = new Date();
            let md = '';
            
            // === Header: Identity ===
            md += `# Stream: ${stream.name}\n`;
            md += `Status: ${stream.status || 'active'}`;
            if (stream.project) md += ` | Project: ${stream.project}`;
            
            // App names with versions
            const appIds = stream.appIds?.length > 0 ? stream.appIds : (stream.appId ? [stream.appId] : []);
            if (appIds.length > 0) {
                const appLabels = appIds.map(id => {
                    const appDef = apps?.[id];
                    const name = appDef?.name || id;
                    const ver = versions?.[id];
                    const verStr = ver?.prod || ver?.test;
                    return verStr ? `${name} v${verStr}` : name;
                });
                md += ` | Apps: ${appLabels.join(', ')}`;
            }
            md += '\n';
            
            if (stream.owner) md += `Owner: ${stream.owner}`;
            if (stream.goal) md += ` | Goal: ${stream.goal}`;
            if (stream.owner || stream.goal) md += '\n';
            if (stream.targetRelease) md += `Target: ${stream.targetRelease}\n`;
            md += '\n';
            
            // === Active Concepts ===
            const activeConcepts = (stream.concepts || []).filter(c => c.status === 'active');
            if (activeConcepts.length > 0) {
                md += `## Active Concepts\n`;
                activeConcepts.forEach(c => {
                    md += `- ${c.type.toUpperCase()}: ${c.text}`;
                    if (c.scope?.length > 0) md += ` [${c.scope.join(', ')}]`;
                    md += '\n';
                });
                md += '\n';
            }
            
            // === Open Items ===
            if (stream.openItems?.length > 0) {
                md += `## Open Items\n`;
                stream.openItems.forEach(item => {
                    md += `- ${item}\n`;
                });
                md += '\n';
            }
            
            // === Test Status ===
            if (stream.tests?.coverage) {
                const cov = stream.tests.coverage;
                const parts = [];
                if (cov.pass > 0) parts.push(`${cov.pass} pass`);
                if (cov.fail > 0) parts.push(`${cov.fail} FAIL`);
                if (cov.untested > 0) parts.push(`${cov.untested} untested`);
                md += `## Test Status: ${parts.join(', ')} (${cov.total || 0} total)\n`;
                
                // List failing scenarios if any
                if (stream.tests.scenarios?.length > 0) {
                    const failing = stream.tests.scenarios.filter(s => s.status === 'fail');
                    if (failing.length > 0) {
                        failing.forEach(s => {
                            md += `- ❌ ${s.name}\n`;
                        });
                    }
                }
                md += '\n';
            }
            
            // === Code Review ===
            if (stream.codeReview) {
                md += `## Code Review: ${stream.codeReview.status || 'pending'}\n`;
                if (stream.codeReview.lastReview) md += `Last: ${stream.codeReview.lastReview}\n`;
                if (stream.codeReview.techniques) md += `Techniques: ${stream.codeReview.techniques}\n`;
                if (stream.codeReview.issuesFound != null) {
                    md += `Issues: ${stream.codeReview.issuesFound} found, ${stream.codeReview.issuesFixed || 0} fixed\n`;
                }
                md += '\n';
            }
            
            // === Last Session ===
            if (stream.sessions?.length > 0) {
                const last = stream.sessions[stream.sessions.length - 1];
                md += `## Last Session (${last.date || 'unknown'})\n`;
                if (last.summary) md += `${last.summary}\n`;
                if (last.conceptsAdded > 0) md += `Concepts added: ${last.conceptsAdded}\n`;
                if (last.testsRun > 0) md += `Tests run: ${last.testsRun}\n`;
                md += '\n';
            }
            
            // === Next ===
            if (stream.next) {
                md += `## Next\n`;
                md += `${stream.next}\n\n`;
            }
            
            // === Footer ===
            md += `---\n`;
            md += `*Generated ${now.toLocaleDateString()} by Command Center v${document.querySelector('meta[name="version"]')?.content || '?'}*\n`;
            
            console.log(`[StreamBrief] Generated brief for "${stream.name}" (${activeConcepts.length} concepts, ${stream.openItems?.length || 0} open items)`);
            return md;
        },
        
        /**
         * Check if a stream has enough data for a useful brief.
         */
        hasData(stream) {
            if (!stream) return false;
            return !!(
                stream.name &&
                (stream.concepts?.length > 0 ||
                 stream.openItems?.length > 0 ||
                 stream.sessions?.length > 0 ||
                 stream.tests?.coverage ||
                 stream.codeReview ||
                 stream.next ||
                 stream.goal)
            );
        }
    };
    
    // =========================================================================
    // CONTEXT.md GENERATOR (Phase 3.2)
    // =========================================================================
    
    function generateContextMd(app, scopeData, config) {
        const cat = SCOPE_CATEGORIES[scopeData?.category];
        const answers = scopeData?.categoryAnswers || {};
        const standards = scopeData?.startingStandards || [];
        const prodRepo = app.repos?.prod || '';
        const testRepo = app.repos?.test || '';
        const ccVersion = document.querySelector('meta[name="version"]')?.content || '?';
        
        let md = `# ${app.name} — CONTEXT.md\n\n`;
        md += `> **Read this first** at the start of every session.\n\n`;
        
        // Current Version
        md += `## Current Version\n\n`;
        md += `**v0.1.0** — Released ${new Date().toLocaleDateString()}\n\n`;
        
        // What It Is
        md += `## What ${app.name} Is\n\n`;
        md += `${scopeData?.description || app.description || app.name + ' is a web application.'}\n\n`;
        
        // Architecture
        md += `## Architecture\n\n`;
        md += `- **Single-file HTML app**: All CSS/JS inline in ${app.targetPath || 'index.html'}\n`;
        
        // Framework from category
        if (scopeData?.category === 'game' || scopeData?.category === 'dashboard') {
            md += `- **Framework**: React via CDN (development recommended, switch to production for deploy)\n`;
        } else {
            md += `- **Framework**: Vanilla JS (or React via CDN if complexity warrants)\n`;
        }
        
        // Data layer from answers
        const hasFirebase = standards.some(s => s.startsWith('firebase-'));
        const usesLocalStorage = (answers.dataPersistence === 'localStorage') || 
            (scopeData?.category === 'game' && !answers.multiplayer);
        if (hasFirebase && usesLocalStorage) {
            md += `- **Data**: Firebase RTDB + localStorage (Firebase for shared/social data, localStorage for local settings/stats)\n`;
        } else if (hasFirebase) {
            md += `- **Data**: Firebase RTDB\n`;
        } else if (usesLocalStorage || scopeData?.category === 'game') {
            md += `- **Data**: localStorage\n`;
        } else {
            md += `- **Data**: localStorage (or Firebase if persistence scope expands)\n`;
        }
        
        // PWA
        md += `- **PWA**: ${app.hasServiceWorker ? 'Yes — sw.js + manifest.json' : 'No'}\n`;
        
        // Deploy target
        if (testRepo) {
            md += `- **Deploy target**: Test: https://${(testRepo).split('/')[0]}.github.io/${(testRepo).split('/')[1]}/ → Prod: https://${(prodRepo).split('/')[0]}.github.io/${(prodRepo).split('/')[1]}/\n`;
        } else if (prodRepo) {
            md += `- **Deploy target**: https://${(prodRepo).split('/')[0]}.github.io/${(prodRepo).split('/')[1]}/\n`;
        }
        md += `\n`;
        
        // Key Technical Details
        md += `## Key Technical Details\n\n`;
        
        // Meta Tags
        md += `### Meta Tags (Required)\n`;
        md += `\`\`\`html\n`;
        md += `<meta name="version" content="X.Y.Z">\n`;
        md += `<meta name="gs-app-id" content="${app.id}">\n`;
        md += `\`\`\`\n\n`;
        
        // Data Schema stubs
        md += `### Data Schema\n\n`;
        if (hasFirebase) {
            md += `Firebase paths (under \`word-boxing-default-rtdb\`):\n`;
            md += `\`\`\`\n`;
            if (standards.includes('firebase-auth')) {
                md += `users/{uid}/\n`;
                md += `  └── profile: { displayName, photoURL, lastLogin }\n`;
            }
            if (scopeData?.category === 'game') {
                md += `${app.id}/\n`;
                md += `  ├── puzzles/ (if server-driven puzzles)\n`;
                if (answers.multiplayer) {
                    md += `  ├── battles/ (matchmaking, results)\n`;
                    md += `  ├── leaderboard/ (rankings)\n`;
                }
                md += `  └── stats/{uid}/ (per-user stats)\n`;
            } else {
                md += `${app.id}/\n`;
                md += `  └── data/{uid}/ (per-user data)\n`;
            }
            md += `\`\`\`\n\n`;
        }
        
        if (usesLocalStorage || scopeData?.category === 'game') {
            md += `localStorage keys:\n`;
            md += `\`\`\`\n`;
            md += `${app.id}-settings    → { theme, ... }\n`;
            if (scopeData?.category === 'game') {
                md += `${app.id}-stats       → { gamesPlayed, gamesWon, streak, maxStreak, ... }\n`;
                md += `${app.id}-gameState   → { puzzleNumber, guesses, status, ... }\n`;
            } else {
                md += `${app.id}-data        → { ... }\n`;
            }
            md += `\`\`\`\n\n`;
        }
        
        // Key Components placeholder
        md += `### Key Components / Functions\n\n`;
        md += `*Update this section as the codebase develops. Map major components and what they do so Claude can navigate the code.*\n\n`;
        
        // Deployment
        md += `## Deployment\n\n`;
        md += `- **Prod Repo:** ${prodRepo || 'TBD'}\n`;
        if (testRepo) md += `- **Test Repo:** ${testRepo}\n`;
        if (app.subPath) md += `- **SubPath:** ${app.subPath}\n`;
        md += `- **Structure:** ${testRepo ? 'Dual (test → prod)' : 'Single repo'}\n`;
        md += `- **Deploy type:** ${app.hasServiceWorker ? 'PWA package (index.html + sw.js + manifest.json + icons/)' : 'Single HTML file'}\n`;
        md += `- **Deploy tool:** Command Center — deploy to test, verify, promote to prod\n\n`;
        
        // Conventions from standards
        md += `## Conventions\n\n`;
        
        // Pull key conventions from the starting standards
        const themeStds = standards.filter(s => ['css-variables', 'dark-light-toggle', 'theme-persistence'].includes(s));
        if (themeStds.length > 0) {
            md += `- **Theming:** CSS variables on \`:root\` and \`[data-theme="dark"]\`. Dark mode default, light mode toggle. Theme persisted in localStorage.\n`;
        }
        
        if (standards.includes('hamburger-menu')) {
            md += `- **Navigation:** Hamburger menu (☰) with settings panel\n`;
        }
        
        if (standards.includes('toast-system')) {
            md += `- **Notifications:** Custom toast system — no native alert/confirm/prompt\n`;
        }
        
        if (standards.includes('mobile-first')) {
            md += `- **Layout:** Mobile-first responsive design\n`;
        }
        
        // Category-specific conventions
        if (scopeData?.category === 'game') {
            md += `- **Game data:** Stats and game state in localStorage with daily reset at midnight UTC\n`;
            if (answers.shareResults) md += `- **Sharing:** navigator.share with clipboard fallback, emoji grid format\n`;
        }
        
        if (scopeData?.category === 'tool') {
            if (answers.primaryDataType) md += `- **Primary data:** ${answers.primaryDataType}\n`;
        }
        
        md += `\n`;
        
        // Recent Changes
        md += `## Recent Changes\n\n`;
        md += `**v0.1.0** — Initial seed generated by Command Center. App shell with placeholder content.\n`;
        
        md += `\n---\n`;
        md += `*Generated ${new Date().toLocaleDateString()} by Command Center v${ccVersion}*\n`;
        
        return md;
    }
    
    // =========================================================================
    // PROJECT_PLAN.md GENERATOR (Phase 3.2)
    // =========================================================================
    
    function generateProjectPlanMd(app, scopeData) {
        const ccVersion = document.querySelector('meta[name="version"]')?.content || '?';
        const coreFeatures = (scopeData?.v1Features || []).filter(f => f.priority === 'core');
        const niceFeatures = (scopeData?.v1Features || []).filter(f => f.priority === 'nice-to-have');
        const futureFeatures = scopeData?.futureFeatures || [];
        const unresolvedDecisions = (scopeData?.keyDecisions || []).filter(d => !d.resolved);
        const resolvedDecisions = (scopeData?.keyDecisions || []).filter(d => d.resolved);
        const answers = scopeData?.categoryAnswers || {};
        const cat = SCOPE_CATEGORIES[scopeData?.category];
        
        let md = `# ${app.name} — Project Plan\n\n`;
        
        // Mission
        md += `## Mission\n\n`;
        md += `${scopeData?.description || app.description || app.name + ' — purpose to be defined.'}\n\n`;
        
        // Completed Features
        md += `## Completed Features\n\n`;
        md += `*Nothing yet — this is a new project.*\n\n`;
        
        // In Progress
        md += `## In Progress\n\n`;
        md += `- [ ] Initial build from seed — implement core features from V1 scope below\n\n`;
        
        // Planned Features
        md += `## Planned Features\n\n`;
        
        if (coreFeatures.length > 0) {
            md += `### Phase 1: Core (Must Build)\n\n`;
            coreFeatures.forEach(f => {
                md += `- [ ] **${f.title}**`;
                if (f.description) md += ` — ${f.description}`;
                if (f.effort) md += ` _(${f.effort})_`;
                md += `\n`;
            });
            md += `\n`;
        }
        
        if (niceFeatures.length > 0) {
            md += `### Phase 2: Nice to Have\n\n`;
            niceFeatures.forEach(f => {
                md += `- [ ] **${f.title}**`;
                if (f.description) md += ` — ${f.description}`;
                md += `\n`;
            });
            md += `\n`;
        }
        
        if (futureFeatures.length > 0) {
            md += `### Future / Ideas\n\n`;
            futureFeatures.forEach(f => {
                md += `- [ ] **${f.title}**`;
                if (f.description) md += ` — ${f.description}`;
                md += `\n`;
            });
            md += `\n`;
        }
        
        // Architecture Decisions
        md += `## Architecture Decisions\n\n`;
        
        // Always-present decisions from the ecosystem
        md += `- **Single-file HTML**: All CSS/JS inline — no build step, no bundler. This is a Game Shelf ecosystem convention.\n`;
        md += `- **Deploy via Command Center**: GitHub Pages repos managed through CC. Test → prod promotion workflow.\n`;
        
        // Category-driven decisions
        if (scopeData?.category === 'game') {
            md += `- **Category: Game**: ${cat?.description || 'Game application'}\n`;
            if (answers.dailyReset) md += `- **Daily reset**: Midnight UTC, puzzle number derived from epoch date\n`;
            if (answers.scoringSystem && answers.scoringSystem !== 'none') md += `- **Scoring**: ${answers.scoringSystem}-based scoring with personal best tracking\n`;
            if (answers.difficultyModes && answers.difficultyModes !== 'none') md += `- **Difficulty**: ${answers.difficultyModes === 'easy-hard' ? 'Easy/Hard' : 'Multiple'} modes with separate statistics\n`;
        } else if (scopeData?.category === 'tool') {
            md += `- **Category: Tool**: ${cat?.description || 'Utility application'}\n`;
            if (answers.dataPersistence) md += `- **Data persistence**: ${answers.dataPersistence}\n`;
        } else if (scopeData?.category === 'dashboard') {
            md += `- **Category: Dashboard**: ${cat?.description || 'Data display application'}\n`;
            if (answers.layout) md += `- **Layout**: ${answers.layout} pattern\n`;
        } else if (scopeData?.category) {
            md += `- **Category: ${cat?.label || scopeData.category}**: ${cat?.description || ''}\n`;
        }
        
        // Resolved decisions from scoping
        if (resolvedDecisions.length > 0) {
            resolvedDecisions.forEach(d => {
                md += `- **${d.title}**`;
                if (d.description) md += ` — ${d.description}`;
                md += ` ✅\n`;
            });
        }
        
        md += `\n`;
        
        // Open Questions
        md += `## Open Questions\n\n`;
        if (unresolvedDecisions.length > 0) {
            unresolvedDecisions.forEach(d => {
                md += `- **${d.title}**`;
                if (d.description) md += ` — ${d.description}`;
                md += `\n`;
            });
        } else {
            md += `*No open questions from scoping. Add questions here as they arise during development.*\n`;
        }
        
        md += `\n---\n`;
        md += `*Generated ${new Date().toLocaleDateString()} by Command Center v${ccVersion}*\n`;
        
        return md;
    }
    
    // ProjectScopeModal — 3-step scoping flow (v8.37.0: removed Step 4 Standards)
    function ProjectScopeModal({ app, apps, onSave, onCancel, showAlert, config }) {
        const [step, setStep] = React.useState(1);
        
        // Step 1: Describe
        const [description, setDescription] = React.useState(app?.lifecycle?.scope?.description || '');
        const [category, setCategory] = React.useState(app?.lifecycle?.scope?.category || '');
        
        // Step 2: Category answers
        const [categoryAnswers, setCategoryAnswers] = React.useState(() => {
            if (app?.lifecycle?.scope?.categoryAnswers) return { ...app.lifecycle.scope.categoryAnswers };
            // Initialize defaults from category questions
            const defaults = {};
            if (category && CATEGORY_QUESTIONS[category]) {
                CATEGORY_QUESTIONS[category].forEach(q => {
                    defaults[q.id] = q.default;
                });
            }
            return defaults;
        });
        
        // Step 3: Features
        const [v1Features, setV1Features] = React.useState(app?.lifecycle?.scope?.v1Features || []);
        const [futureFeatures, setFutureFeatures] = React.useState(app?.lifecycle?.scope?.futureFeatures || []);
        const [keyDecisions, setKeyDecisions] = React.useState(app?.lifecycle?.scope?.keyDecisions || []);
        const [featuresGenerated, setFeaturesGenerated] = React.useState(false);
        
        // Standards (auto-assembled silently — no user step)
        const [startingStandards, setStartingStandards] = React.useState(app?.lifecycle?.scope?.startingStandards || []);
        
        // New feature/decision forms
        const [newFeatureTitle, setNewFeatureTitle] = React.useState('');
        const [newFutureTitle, setNewFutureTitle] = React.useState('');
        const [newDecisionTitle, setNewDecisionTitle] = React.useState('');
        
        // Re-initialize defaults when category changes
        React.useEffect(() => {
            if (category && CATEGORY_QUESTIONS[category]) {
                const existingAnswers = app?.lifecycle?.scope?.categoryAnswers || {};
                const defaults = {};
                CATEGORY_QUESTIONS[category].forEach(q => {
                    defaults[q.id] = existingAnswers[q.id] !== undefined ? existingAnswers[q.id] : q.default;
                });
                // Migrate old dashboard questions: autoRefresh + realtime → dataUpdates
                if (category === 'dashboard' && !existingAnswers.dataUpdates) {
                    if (existingAnswers.realtime) defaults.dataUpdates = 'realtime';
                    else if (existingAnswers.autoRefresh) defaults.dataUpdates = 'periodic';
                    else defaults.dataUpdates = 'manual';
                }
                // Migrate old tool.settingsPersistence → derived from dataPersistence
                setCategoryAnswers(defaults);
            }
        }, [category]);
        
        // Auto-generate features when moving from step 2 → 3
        // Auto-assemble standards when moving from step 2 → 3
        const handleStep2Next = () => {
            if (!featuresGenerated) {
                const generated = generateFeaturesFromScope(category, categoryAnswers);
                if (v1Features.length === 0) {
                    setV1Features(generated);
                }
                setFeaturesGenerated(true);
            }
            setStep(3);
        };
        
        // Add feature
        const addV1Feature = () => {
            if (!newFeatureTitle.trim()) return;
            setV1Features(prev => [...prev, { title: newFeatureTitle.trim(), description: '', priority: 'core', effort: 'session' }]);
            setNewFeatureTitle('');
        };
        
        const addFutureFeature = () => {
            if (!newFutureTitle.trim()) return;
            setFutureFeatures(prev => [...prev, { title: newFutureTitle.trim(), description: '' }]);
            setNewFutureTitle('');
        };
        
        const addKeyDecision = () => {
            if (!newDecisionTitle.trim()) return;
            setKeyDecisions(prev => [...prev, { title: newDecisionTitle.trim(), description: '', resolved: false }]);
            setNewDecisionTitle('');
        };
        
        const removeV1Feature = (idx) => setV1Features(prev => prev.filter((_, i) => i !== idx));
        const removeFutureFeature = (idx) => setFutureFeatures(prev => prev.filter((_, i) => i !== idx));
        const removeKeyDecision = (idx) => setKeyDecisions(prev => prev.filter((_, i) => i !== idx));
        
        const updateV1Feature = (idx, field, value) => {
            setV1Features(prev => prev.map((f, i) => i === idx ? { ...f, [field]: value } : f));
        };
        
        // Final save — standards auto-assembled silently
        const handleSave = () => {
            const autoStandards = assembleStartingStandards(category, categoryAnswers);
            const scope = {
                description,
                category,
                categoryAnswers,
                v1Features,
                futureFeatures,
                keyDecisions,
                startingStandards: autoStandards,
                scopedAt: new Date().toISOString(),
                scopedBy: config?.ownerName || 'Owner',
                source: 'manual'
            };
            onSave(scope);
        };
        
        // Render question input based on type
        const renderQuestion = (q) => {
            const value = categoryAnswers[q.id];
            
            if (q.type === 'toggle') {
                return (
                    <label key={q.id} className="flex items-center justify-between p-3 bg-slate-700/50 rounded-lg hover:bg-slate-700 cursor-pointer">
                        <div className="flex-1 pr-4">
                            <div className="text-sm font-medium flex items-center gap-1.5">
                                {q.label}
                                {q.drives && (
                                    <span className="relative group inline-flex">
                                        <span className="text-slate-500 hover:text-slate-300 cursor-help text-xs">ⓘ</span>
                                        <span className="absolute bottom-full left-1/2 -translate-x-1/2 mb-1.5 px-2.5 py-1.5 bg-slate-900 border border-slate-600 rounded text-[11px] text-slate-300 whitespace-nowrap opacity-0 group-hover:opacity-100 pointer-events-none transition-opacity z-10 shadow-lg">{q.drives}</span>
                                    </span>
                                )}
                            </div>
                        </div>
                        <div className="relative">
                            <input type="checkbox" className="sr-only" checked={!!value}
                                onChange={e => setCategoryAnswers(prev => ({ ...prev, [q.id]: e.target.checked }))} />
                            <div className={`w-11 h-6 rounded-full transition-colors ${value ? 'bg-indigo-600' : 'bg-slate-600'}`}>
                                <div className={`w-5 h-5 bg-white rounded-full shadow transform transition-transform mt-0.5 ${value ? 'translate-x-5.5 ml-[22px]' : 'translate-x-0.5 ml-[2px]'}`} />
                            </div>
                        </div>
                    </label>
                );
            }
            
            if (q.type === 'select') {
                return (
                    <div key={q.id} className="p-3 bg-slate-700/50 rounded-lg">
                        <div className="text-sm font-medium mb-1 flex items-center gap-1.5">
                            {q.label}
                            {q.drives && (
                                <span className="relative group inline-flex">
                                    <span className="text-slate-500 hover:text-slate-300 cursor-help text-xs">ⓘ</span>
                                    <span className="absolute bottom-full left-1/2 -translate-x-1/2 mb-1.5 px-2.5 py-1.5 bg-slate-900 border border-slate-600 rounded text-[11px] text-slate-300 whitespace-nowrap opacity-0 group-hover:opacity-100 pointer-events-none transition-opacity z-10 shadow-lg">{q.drives}</span>
                                </span>
                            )}
                        </div>
                        <select value={value !== undefined ? value : q.default}
                            onChange={e => {
                                let val = e.target.value;
                                // Handle boolean selects (multiItem)
                                if (val === 'true') val = true;
                                if (val === 'false') val = false;
                                setCategoryAnswers(prev => ({ ...prev, [q.id]: val }));
                            }}
                            className="w-full bg-slate-800 border border-slate-600 rounded px-3 py-1.5 text-sm">
                            {q.options.map((opt, oi) => <option key={String(opt)} value={opt}>{q.optionLabels?.[oi] || opt}</option>)}
                        </select>
                    </div>
                );
            }
            
            if (q.type === 'multi-select') {
                const selected = value || q.default || [];
                return (
                    <div key={q.id} className="p-3 bg-slate-700/50 rounded-lg">
                        <div className="text-sm font-medium mb-1 flex items-center gap-1.5">
                            {q.label}
                            {q.drives && (
                                <span className="relative group inline-flex">
                                    <span className="text-slate-500 hover:text-slate-300 cursor-help text-xs">ⓘ</span>
                                    <span className="absolute bottom-full left-1/2 -translate-x-1/2 mb-1.5 px-2.5 py-1.5 bg-slate-900 border border-slate-600 rounded text-[11px] text-slate-300 whitespace-nowrap opacity-0 group-hover:opacity-100 pointer-events-none transition-opacity z-10 shadow-lg">{q.drives}</span>
                                </span>
                            )}
                        </div>
                        <div className="flex flex-wrap gap-2">
                            {q.options.map((opt, oi) => (
                                <button key={opt}
                                    onClick={() => {
                                        const next = selected.includes(opt) ? selected.filter(s => s !== opt) : [...selected, opt];
                                        setCategoryAnswers(prev => ({ ...prev, [q.id]: next }));
                                    }}
                                    className={`px-3 py-1 rounded text-xs font-medium transition-colors ${
                                        selected.includes(opt) ? 'bg-indigo-600 text-white' : 'bg-slate-800 text-slate-400 hover:bg-slate-600'
                                    }`}>
                                    {q.optionLabels?.[oi] || opt}
                                </button>
                            ))}
                        </div>
                    </div>
                );
            }
            
            if (q.type === 'text') {
                return (
                    <div key={q.id} className="p-3 bg-slate-700/50 rounded-lg">
                        <div className="text-sm font-medium mb-1 flex items-center gap-1.5">
                            {q.label}
                            {q.drives && (
                                <span className="relative group inline-flex">
                                    <span className="text-slate-500 hover:text-slate-300 cursor-help text-xs">ⓘ</span>
                                    <span className="absolute bottom-full left-1/2 -translate-x-1/2 mb-1.5 px-2.5 py-1.5 bg-slate-900 border border-slate-600 rounded text-[11px] text-slate-300 whitespace-nowrap opacity-0 group-hover:opacity-100 pointer-events-none transition-opacity z-10 shadow-lg">{q.drives}</span>
                                </span>
                            )}
                        </div>
                        <input value={value || ''}
                            onChange={e => setCategoryAnswers(prev => ({ ...prev, [q.id]: e.target.value }))}
                            placeholder={q.placeholder}
                            className="w-full bg-slate-800 border border-slate-600 rounded px-3 py-1.5 text-sm" />
                    </div>
                );
            }
            
            return null;
        };
        
        return (
            <div className="fixed inset-0 bg-black/70 flex items-start justify-center z-50 overflow-y-auto p-4 pt-8">
                <div className="bg-slate-800 rounded-xl border border-slate-700 w-full max-w-3xl shadow-2xl">
                    {/* Header */}
                    <div className="flex items-center justify-between p-5 border-b border-slate-700">
                        <div>
                            <h2 className="text-lg font-bold flex items-center gap-2">
                                🎯 Project Scoping {app?.name ? `— ${app.icon || ''} ${app.name}` : ''}
                            </h2>
                            <p className="text-xs text-slate-400 mt-1">Define what to build → get a prioritized feature list and work items ready for Claude.</p>
                        </div>
                        <button onClick={onCancel} className="text-slate-400 hover:text-white text-xl">✕</button>
                    </div>
                    
                    {/* Progress Steps */}
                    <div className="flex items-center gap-2 px-5 py-3 bg-slate-900/50">
                        {[
                            { n: 1, label: 'Describe' },
                            { n: 2, label: 'Clarify' },
                            { n: 3, label: 'Features' }
                        ].map((s, i) => (
                            <React.Fragment key={s.n}>
                                <button onClick={() => { if (s.n < step) setStep(s.n); }}
                                    className={`flex items-center gap-1.5 px-3 py-1.5 rounded-lg text-xs font-medium transition-colors ${
                                        step === s.n ? 'bg-indigo-600 text-white' : step > s.n ? 'bg-green-600/20 text-green-400 cursor-pointer hover:bg-green-600/30' : 'bg-slate-800 text-slate-500'
                                    }`}>
                                    {step > s.n ? '✓' : s.n} {s.label}
                                </button>
                                {i < 2 && <div className={`flex-1 h-px ${step > s.n ? 'bg-green-600' : 'bg-slate-700'}`} />}
                            </React.Fragment>
                        ))}
                    </div>
                    
                    {/* Content */}
                    <div className="p-5 max-h-[60vh] overflow-y-auto">
                        
                        {/* Step 1: Describe */}
                        {step === 1 && (
                            <div className="space-y-4">
                                <div>
                                    <label className="block text-sm font-medium mb-2">What does this app do? Who is it for? What problem does it solve?</label>
                                    <textarea value={description} onChange={e => setDescription(e.target.value)}
                                        rows={4} placeholder="A daily word puzzle where players uncover a hidden quote by guessing letters..."
                                        className="w-full bg-slate-900 border border-slate-600 rounded-lg px-4 py-3 text-sm focus:border-indigo-500 focus:outline-none resize-none" />
                                    <p className="text-xs text-slate-500 mt-1">3-5 sentences describing purpose, audience, and core concept</p>
                                </div>
                                
                                <div>
                                    <label className="block text-sm font-medium mb-2">App Category</label>
                                    <div className="grid grid-cols-5 gap-2">
                                        {Object.entries(SCOPE_CATEGORIES).map(([id, cat]) => (
                                            <button key={id}
                                                onClick={() => setCategory(id)}
                                                className={`p-3 rounded-lg border text-center transition-all ${
                                                    category === id 
                                                        ? 'border-indigo-500 bg-indigo-500/15 ring-1 ring-indigo-500/50' 
                                                        : 'border-slate-600 hover:border-slate-500 bg-slate-700/30'
                                                }`}>
                                                <div className="text-2xl mb-1">{cat.icon}</div>
                                                <div className="text-xs font-medium">{cat.label}</div>
                                            </button>
                                        ))}
                                    </div>
                                </div>
                            </div>
                        )}
                        
                        {/* Step 2: Clarify */}
                        {step === 2 && (
                            <div>
                                <div className="flex items-center gap-2 mb-4">
                                    <span className="text-xl">{SCOPE_CATEGORIES[category]?.icon}</span>
                                    <h3 className="font-semibold">{SCOPE_CATEGORIES[category]?.label} Questions</h3>
                                </div>
                                <div className="space-y-2">
                                    {(CATEGORY_QUESTIONS[category] || []).map(q => renderQuestion(q))}
                                </div>
                            </div>
                        )}
                        
                        {/* Step 3: Features */}
                        {step === 3 && (
                            <div className="space-y-6">
                                {/* Launch Features */}
                                <div>
                                    <h3 className="font-semibold text-sm mb-2 flex items-center gap-2">
                                        🎯 Launch Features <span className="text-xs font-normal text-slate-400">must ship</span>
                                        <span className="text-xs px-2 py-0.5 bg-slate-700 rounded-full">{v1Features.length}</span>
                                    </h3>
                                    <div className="space-y-2 mb-3">
                                        {v1Features.map((f, idx) => (
                                            <div key={idx} className="bg-slate-700/50 rounded-lg p-3">
                                                <div className="flex items-start justify-between gap-2">
                                                    <div className="flex-1">
                                                        <input value={f.title} onChange={e => updateV1Feature(idx, 'title', e.target.value)}
                                                            className="w-full bg-transparent text-sm font-medium border-none outline-none" />
                                                        <input value={f.description || ''} onChange={e => updateV1Feature(idx, 'description', e.target.value)}
                                                            placeholder="Brief description..."
                                                            className="w-full bg-transparent text-xs text-slate-400 border-none outline-none mt-1" />
                                                    </div>
                                                    <div className="flex items-center gap-2 shrink-0">
                                                        <select value={f.priority} onChange={e => updateV1Feature(idx, 'priority', e.target.value)}
                                                            className="bg-slate-800 border border-slate-600 rounded px-2 py-1 text-xs">
                                                            <option value="core">Must have</option>
                                                            <option value="nice-to-have">Nice to have</option>
                                                            <option value="out-of-scope">Not now</option>
                                                        </select>
                                                        <select value={f.effort} onChange={e => updateV1Feature(idx, 'effort', e.target.value)}
                                                            className="bg-slate-800 border border-slate-600 rounded px-2 py-1 text-xs">
                                                            <option value="quick">Quick</option>
                                                            <option value="session">Session</option>
                                                            <option value="multi-session">Multi-session</option>
                                                            <option value="epic">Epic</option>
                                                        </select>
                                                        <button onClick={() => removeV1Feature(idx)} className="text-slate-500 hover:text-red-400 text-xs">✕</button>
                                                    </div>
                                                </div>
                                            </div>
                                        ))}
                                    </div>
                                    <div className="flex gap-2">
                                        <input value={newFeatureTitle} onChange={e => setNewFeatureTitle(e.target.value)}
                                            onKeyDown={e => e.key === 'Enter' && addV1Feature()}
                                            placeholder="Add a V1 feature..."
                                            className="flex-1 bg-slate-700 border border-slate-600 rounded px-3 py-1.5 text-sm" />
                                        <button onClick={addV1Feature} disabled={!newFeatureTitle.trim()}
                                            className="px-3 py-1.5 bg-indigo-600 hover:bg-indigo-500 disabled:bg-slate-700 disabled:text-slate-500 rounded text-sm">
                                            Add
                                        </button>
                                    </div>
                                </div>
                                
                                {/* Future Features */}
                                <div>
                                    <h3 className="font-semibold text-sm mb-2 flex items-center gap-2">
                                        🔮 Future Features <span className="text-xs font-normal text-slate-400">V2+ — inform architecture, don't build yet</span>
                                        <span className="text-xs px-2 py-0.5 bg-slate-700 rounded-full">{futureFeatures.length}</span>
                                    </h3>
                                    <div className="space-y-1 mb-3">
                                        {futureFeatures.map((f, idx) => (
                                            <div key={idx} className="flex items-center gap-2 bg-slate-700/30 rounded px-3 py-2">
                                                <span className="flex-1 text-sm text-slate-300">{f.title}</span>
                                                <button onClick={() => removeFutureFeature(idx)} className="text-slate-500 hover:text-red-400 text-xs">✕</button>
                                            </div>
                                        ))}
                                    </div>
                                    <div className="flex gap-2">
                                        <input value={newFutureTitle} onChange={e => setNewFutureTitle(e.target.value)}
                                            onKeyDown={e => e.key === 'Enter' && addFutureFeature()}
                                            placeholder="Add a future feature idea..."
                                            className="flex-1 bg-slate-700 border border-slate-600 rounded px-3 py-1.5 text-sm" />
                                        <button onClick={addFutureFeature} disabled={!newFutureTitle.trim()}
                                            className="px-3 py-1.5 bg-slate-600 hover:bg-slate-500 disabled:bg-slate-700 disabled:text-slate-500 rounded text-sm">
                                            Add
                                        </button>
                                    </div>
                                </div>
                                
                                {/* Key Decisions */}
                                <div>
                                    <h3 className="font-semibold text-sm mb-2 flex items-center gap-2">
                                        🤔 Key Decisions <span className="text-xs font-normal text-slate-400">resolve before or during Session 1</span>
                                        <span className="text-xs px-2 py-0.5 bg-slate-700 rounded-full">{keyDecisions.length}</span>
                                    </h3>
                                    <div className="space-y-1 mb-3">
                                        {keyDecisions.map((d, idx) => (
                                            <div key={idx} className="flex items-center gap-2 bg-amber-900/10 border border-amber-800/30 rounded px-3 py-2">
                                                <span className="text-amber-400 text-xs">❓</span>
                                                <span className="flex-1 text-sm text-slate-300">{d.title}</span>
                                                <button onClick={() => removeKeyDecision(idx)} className="text-slate-500 hover:text-red-400 text-xs">✕</button>
                                            </div>
                                        ))}
                                    </div>
                                    <div className="flex gap-2">
                                        <input value={newDecisionTitle} onChange={e => setNewDecisionTitle(e.target.value)}
                                            onKeyDown={e => e.key === 'Enter' && addKeyDecision()}
                                            placeholder="Add a key decision to resolve..."
                                            className="flex-1 bg-slate-700 border border-slate-600 rounded px-3 py-1.5 text-sm" />
                                        <button onClick={addKeyDecision} disabled={!newDecisionTitle.trim()}
                                            className="px-3 py-1.5 bg-amber-700 hover:bg-amber-600 disabled:bg-slate-700 disabled:text-slate-500 rounded text-sm">
                                            Add
                                        </button>
                                    </div>
                                </div>
                            </div>
                        )}
                    </div>
                    
                    {/* Footer */}
                    <div className="flex items-center justify-between p-5 border-t border-slate-700">
                        <button onClick={() => step > 1 ? setStep(step - 1) : onCancel()}
                            className="px-4 py-2 text-sm text-slate-400 hover:text-white transition-colors">
                            {step > 1 ? '← Back' : 'Cancel'}
                        </button>
                        
                        <div className="flex items-center gap-3">
                            {step === 3 && (
                                <span className="text-xs text-slate-400">
                                    Will generate {v1Features.length + futureFeatures.length + keyDecisions.length} work items
                                </span>
                            )}
                            
                            {step < 3 ? (
                                <button onClick={() => {
                                        if (step === 1) { if (!description.trim() || !category) return; setStep(2); }
                                        else if (step === 2) handleStep2Next();
                                    }}
                                    disabled={step === 1 && (!description.trim() || !category)}
                                    className="px-6 py-2 bg-indigo-600 hover:bg-indigo-500 disabled:bg-slate-700 disabled:text-slate-500 rounded-lg text-sm font-medium transition-colors">
                                    Next →
                                </button>
                            ) : (
                                <button onClick={handleSave}
                                    className="px-6 py-2 bg-green-600 hover:bg-green-500 rounded-lg text-sm font-medium transition-colors flex items-center gap-2">
                                    ✅ Save Scope & Generate Work Items
                                </button>
                            )}
                        </div>
                    </div>
                </div>
            </div>
        );
    }
    
    // =========================================================================
    // BACKLOG VIEW - Work Item Tracking & Project Planning (v8.22.0)
    // =========================================================================
    
    function WorkItemEditModal({ item, apps, isNew, onSave, onCancel, globalStreams }) {
        const configuredApps = Object.values(apps).filter(a => a.testRepo || a.prodRepo);
        
        const [formData, setFormData] = React.useState({
            appId: item?.appId || configuredApps[0]?.id || '',
            streamId: item?.streamId || null,  // Phase 5.3: stream assignment
            title: item?.title || '',
            description: item?.description || '',
            type: item?.type || 'feature',
            priority: item?.priority || 'core',
            status: item?.status || 'idea',
            effort: item?.effort || 'session',
            criteria: item?.criteria || [],
            context: {
                filesAffected: item?.context?.filesAffected || [],
                sections: item?.context?.sections || [],
                dependencies: item?.context?.dependencies || [],
                notes: item?.context?.notes || '',
                relatedItems: item?.context?.relatedItems || []
            },
            tags: item?.tags || [],
            source: item?.source || 'manual'
        });
        
        const [newCriterion, setNewCriterion] = React.useState('');
        const [newTag, setNewTag] = React.useState('');
        const [showContext, setShowContext] = React.useState(false);
        
        const update = (field, value) => setFormData(prev => ({ ...prev, [field]: value }));
        
        const addCriterion = () => {
            if (!newCriterion.trim()) return;
            update('criteria', [...formData.criteria, newCriterion.trim()]);
            setNewCriterion('');
        };
        
        const removeCriterion = (idx) => {
            update('criteria', formData.criteria.filter((_, i) => i !== idx));
        };
        
        const addTag = () => {
            if (!newTag.trim()) return;
            update('tags', [...formData.tags, newTag.trim()]);
            setNewTag('');
        };
        
        const removeTag = (idx) => {
            update('tags', formData.tags.filter((_, i) => i !== idx));
        };
        
        const handleSave = () => {
            if (!formData.title.trim()) return;
            if (!formData.appId) return;
            onSave(formData);
        };
        
        const typeOptions = [
            { value: 'feature', label: '✨ Feature', color: 'bg-indigo-900/50 text-indigo-300' },
            { value: 'bugfix', label: '🐛 Bugfix', color: 'bg-red-900/50 text-red-300' },
            { value: 'enhancement', label: '💎 Enhancement', color: 'bg-purple-900/50 text-purple-300' },
            { value: 'chore', label: '🔧 Chore', color: 'bg-slate-700 text-slate-300' },
            { value: 'research', label: '🔍 Research', color: 'bg-amber-900/50 text-amber-300' }
        ];
        
        const priorityOptions = [
            { value: 'core', label: 'Must Have', color: 'bg-red-900/50 text-red-300' },
            { value: 'nice-to-have', label: 'Nice to Have', color: 'bg-amber-900/50 text-amber-300' }
        ];
        
        const statusOptions = [
            { value: 'idea', label: '💡 Idea' },
            { value: 'ready', label: '📋 Ready' },
            { value: 'in-progress', label: '🔨 In Progress' },
            { value: 'review', label: '📝 In Review' },
            { value: 'done', label: '✅ Done' },
            { value: 'deferred', label: '⏸️ Deferred' }
        ];
        
        const effortOptions = [
            { value: 'quick', label: '⚡ Quick (<30 min)' },
            { value: 'session', label: '🕐 Session (1–2 hrs, one Claude chat)' },
            { value: 'multi-session', label: '📅 Multi-Session' },
            { value: 'epic', label: '🏔️ Epic' }
        ];
        
        return (
            <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50 p-4" onClick={onCancel}>
                <div className="bg-slate-800 rounded-xl border border-slate-700 w-full max-w-2xl max-h-[90vh] overflow-y-auto" onClick={e => e.stopPropagation()}>
                    <div className="p-6">
                        <div className="flex items-center justify-between mb-6">
                            <h2 className="text-xl font-bold">{isNew ? '➕ New Work Item' : `✏️ Edit ${item?.id || ''}`}</h2>
                            <button onClick={onCancel} className="text-slate-400 hover:text-white text-xl">✕</button>
                        </div>
                        
                        {/* App + Title */}
                        <div className="grid grid-cols-[200px_1fr] gap-3 mb-4">
                            <div>
                                <label className="text-xs text-slate-400 block mb-1">App</label>
                                <select value={formData.appId} onChange={e => { update('appId', e.target.value); update('streamId', null); }}
                                    className="w-full bg-slate-700 border border-slate-600 rounded px-3 py-2 text-sm">
                                    {configuredApps.map(a => (
                                        <option key={a.id} value={a.id}>{a.icon} {a.name}</option>
                                    ))}
                                </select>
                            </div>
                            <div>
                                <label className="text-xs text-slate-400 block mb-1">Title *</label>
                                <input value={formData.title} onChange={e => update('title', e.target.value)}
                                    placeholder="What needs to be done?"
                                    className="w-full bg-slate-700 border border-slate-600 rounded px-3 py-2 text-sm"
                                    autoFocus />
                            </div>
                        </div>
                        
                        {/* Stream assignment (Phase 5.3) */}
                        {globalStreams && (() => {
                            const appStreams = (globalStreams || []).filter(s => s.appId === formData.appId);
                            if (appStreams.length === 0) return null;
                            return (
                                <div className="mb-4">
                                    <label className="text-xs text-slate-400 block mb-1">Work Stream</label>
                                    <select value={formData.streamId || ''} onChange={e => update('streamId', e.target.value || null)}
                                        className="w-full bg-slate-700 border border-slate-600 rounded px-3 py-2 text-sm">
                                        <option value="">No stream (unassigned)</option>
                                        {appStreams.map(s => (
                                            <option key={s.id} value={s.id}>🔀 {s.name} ({s.status})</option>
                                        ))}
                                    </select>
                                </div>
                            );
                        })()}
                        
                        {/* Description */}
                        <div className="mb-4">
                            <label className="text-xs text-slate-400 block mb-1">Description</label>
                            <textarea value={formData.description} onChange={e => update('description', e.target.value)}
                                placeholder="Detailed description of the work..."
                                rows={3}
                                className="w-full bg-slate-700 border border-slate-600 rounded px-3 py-2 text-sm resize-y" />
                        </div>
                        
                        {/* Type + Priority + Status + Effort */}
                        <div className="grid grid-cols-2 sm:grid-cols-4 gap-3 mb-4">
                            <div>
                                <label className="text-xs text-slate-400 block mb-1">Type</label>
                                <select value={formData.type} onChange={e => update('type', e.target.value)}
                                    className="w-full bg-slate-700 border border-slate-600 rounded px-3 py-2 text-sm">
                                    {typeOptions.map(o => <option key={o.value} value={o.value}>{o.label}</option>)}
                                </select>
                            </div>
                            <div>
                                <label className="text-xs text-slate-400 block mb-1">Priority</label>
                                <select value={formData.priority} onChange={e => update('priority', e.target.value)}
                                    className="w-full bg-slate-700 border border-slate-600 rounded px-3 py-2 text-sm">
                                    {priorityOptions.map(o => <option key={o.value} value={o.value}>{o.label}</option>)}
                                </select>
                            </div>
                            <div>
                                <label className="text-xs text-slate-400 block mb-1">Status</label>
                                <select value={formData.status} onChange={e => update('status', e.target.value)}
                                    className="w-full bg-slate-700 border border-slate-600 rounded px-3 py-2 text-sm">
                                    {statusOptions.map(o => <option key={o.value} value={o.value}>{o.label}</option>)}
                                </select>
                            </div>
                            <div>
                                <label className="text-xs text-slate-400 block mb-1">Effort</label>
                                <select value={formData.effort} onChange={e => update('effort', e.target.value)}
                                    className="w-full bg-slate-700 border border-slate-600 rounded px-3 py-2 text-sm">
                                    {effortOptions.map(o => <option key={o.value} value={o.value}>{o.label}</option>)}
                                </select>
                            </div>
                        </div>
                        
                        {/* Acceptance Criteria */}
                        <div className="mb-4">
                            <label className="text-xs text-slate-400 block mb-1">Acceptance Criteria <span className="text-slate-600">— describe what a user should experience</span></label>
                            {formData.criteria.length > 0 && (
                                <div className="space-y-1 mb-2">
                                    {formData.criteria.map((c, i) => (
                                        <div key={i} className="flex items-center gap-2 text-sm bg-slate-700/50 rounded px-3 py-1.5">
                                            <span className="text-slate-500">☐</span>
                                            <span className="flex-1">{c}</span>
                                            <button onClick={() => removeCriterion(i)} className="text-slate-500 hover:text-red-400 text-xs">✕</button>
                                        </div>
                                    ))}
                                </div>
                            )}
                            <div className="flex gap-2">
                                <input value={newCriterion} onChange={e => setNewCriterion(e.target.value)}
                                    onKeyDown={e => e.key === 'Enter' && addCriterion()}
                                    placeholder="What should a user see or be able to do? e.g. 'Score updates immediately after each guess, displayed as ★ 450'"
                                    className="flex-1 bg-slate-700 border border-slate-600 rounded px-3 py-1.5 text-sm" />
                                <button onClick={addCriterion} className="px-3 py-1.5 bg-slate-600 hover:bg-slate-500 rounded text-sm">+</button>
                            </div>
                        </div>
                        
                        {/* Tags */}
                        <div className="mb-4">
                            <label className="text-xs text-slate-400 block mb-1">Tags</label>
                            <div className="flex flex-wrap gap-1 mb-2">
                                {formData.tags.map((t, i) => (
                                    <span key={i} className="inline-flex items-center gap-1 px-2 py-0.5 bg-slate-600 rounded text-xs">
                                        {t}
                                        <button onClick={() => removeTag(i)} className="text-slate-400 hover:text-red-400">✕</button>
                                    </span>
                                ))}
                            </div>
                            <div className="flex gap-2">
                                <input value={newTag} onChange={e => setNewTag(e.target.value)}
                                    onKeyDown={e => e.key === 'Enter' && addTag()}
                                    placeholder="Add tag..."
                                    className="flex-1 bg-slate-700 border border-slate-600 rounded px-3 py-1.5 text-sm" />
                                <button onClick={addTag} className="px-3 py-1.5 bg-slate-600 hover:bg-slate-500 rounded text-sm">+</button>
                            </div>
                        </div>
                        
                        {/* Context (collapsible) */}
                        <div className="mb-6">
                            <button onClick={() => setShowContext(!showContext)}
                                className="text-xs text-slate-400 hover:text-white flex items-center gap-1">
                                <span className={`transform transition-transform ${showContext ? 'rotate-90' : ''}`}>▶</span>
                                Context & Dependencies
                            </button>
                            {showContext && (
                                <div className="mt-2 space-y-3 pl-4 border-l border-slate-700">
                                    <div>
                                        <label className="text-xs text-slate-400 block mb-1">Files Affected (comma-separated)</label>
                                        <input value={formData.context.filesAffected.join(', ')}
                                            onChange={e => setFormData(prev => ({
                                                ...prev,
                                                context: { ...prev.context, filesAffected: e.target.value.split(',').map(s => s.trim()).filter(Boolean) }
                                            }))}
                                            placeholder="index.html, sw.js"
                                            className="w-full bg-slate-700 border border-slate-600 rounded px-3 py-1.5 text-sm" />
                                    </div>
                                    <div>
                                        <label className="text-xs text-slate-400 block mb-1">Sections (comma-separated)</label>
                                        <input value={formData.context.sections.join(', ')}
                                            onChange={e => setFormData(prev => ({
                                                ...prev,
                                                context: { ...prev.context, sections: e.target.value.split(',').map(s => s.trim()).filter(Boolean) }
                                            }))}
                                            placeholder="DashboardView, WorkItemService"
                                            className="w-full bg-slate-700 border border-slate-600 rounded px-3 py-1.5 text-sm" />
                                    </div>
                                    <div>
                                        <label className="text-xs text-slate-400 block mb-1">Dependencies (comma-separated)</label>
                                        <input value={formData.context.dependencies.join(', ')}
                                            onChange={e => setFormData(prev => ({
                                                ...prev,
                                                context: { ...prev.context, dependencies: e.target.value.split(',').map(s => s.trim()).filter(Boolean) }
                                            }))}
                                            placeholder="WI-001, WI-003"
                                            className="w-full bg-slate-700 border border-slate-600 rounded px-3 py-1.5 text-sm" />
                                    </div>
                                    <div>
                                        <label className="text-xs text-slate-400 block mb-1">Notes</label>
                                        <textarea value={formData.context.notes}
                                            onChange={e => setFormData(prev => ({
                                                ...prev,
                                                context: { ...prev.context, notes: e.target.value }
                                            }))}
                                            rows={2}
                                            placeholder="Additional context..."
                                            className="w-full bg-slate-700 border border-slate-600 rounded px-3 py-1.5 text-sm resize-y" />
                                    </div>
                                </div>
                            )}
                        </div>
                        
                        {/* Actions */}
                        <div className="flex justify-end gap-3">
                            <button onClick={onCancel} className="px-4 py-2 text-sm text-slate-400 hover:text-white">Cancel</button>
                            <button onClick={handleSave} disabled={!formData.title.trim() || !formData.appId}
                                className="px-6 py-2 bg-indigo-600 hover:bg-indigo-500 disabled:opacity-40 rounded-lg text-sm font-medium">
                                {isNew ? 'Create Work Item' : 'Save Changes'}
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        );
    }
    
    function BacklogView({ apps, showAlert, showConfirm, showPrompt, setView, config, globalStreams }) {
        const [workItems, setWorkItems] = React.useState([]);
        const [firebaseUser, setFirebaseUser] = React.useState(null);
        const [loading, setLoading] = React.useState(true);
        const [showEditModal, setShowEditModal] = React.useState(null); // null | { item, isNew }
        const [showScopeModal, setShowScopeModal] = React.useState(null); // null | { app }
        const [statusFilter, setStatusFilter] = React.useState('active'); // 'all', 'active', 'idea', 'ready', 'in-progress', 'done', 'deferred'
        const [typeFilter, setTypeFilter] = React.useState('all');
        const [appFilter, setAppFilter] = React.useState('all');
        const [searchQuery, setSearchQuery] = React.useState('');
        const [sortBy, setSortBy] = React.useState('priority'); // 'priority', 'status', 'created', 'effort', 'type'
        const [groupBy, setGroupBy] = React.useState('app'); // 'app', 'status', 'type', 'stream', 'none'
        const [selectedItems, setSelectedItems] = React.useState(new Set());
        
        const configuredApps = Object.values(apps).filter(a => a.testRepo || a.prodRepo);
        
        // Firebase listener
        React.useEffect(() => {
            if (!firebaseAuth) return;
            let unsub = () => {};
            const authUnsub = firebaseAuth.onAuthStateChanged((u) => {
                setFirebaseUser(u);
                if (u) {
                    setLoading(true);
                    unsub = WorkItemService.listen(u.uid, (list) => {
                        setWorkItems(list);
                        setLoading(false);
                    });
                }
            });
            return () => { authUnsub(); unsub(); };
        }, []);
        
        // Generate next ID
        const getNextId = () => WorkItemService.getNextId(workItems);
        
        // CRUD operations
        const createItem = async (data) => {
            if (!firebaseUser) return;
            const id = getNextId();
            await WorkItemService.create(firebaseUser.uid, { ...data, id });
            setShowEditModal(null);
            showAlert(`Created ${id}: ${data.title}`, 'success');
        };
        
        const updateItem = async (data) => {
            if (!firebaseUser || !showEditModal?.item?.id) return;
            const id = showEditModal.item.id;
            const originalItem = showEditModal.item;
            
            // === Phase 3.3: Idea → Ready auto-suggest ===
            // When criteria are added to an idea-status item, suggest promoting to ready
            const hadCriteria = originalItem.criteria && originalItem.criteria.length > 0 && originalItem.criteria.some(c => c.trim());
            const hasCriteriaNow = data.criteria && data.criteria.length > 0 && data.criteria.some(c => c.trim());
            const isIdea = originalItem.status === 'idea';
            const statusUnchanged = data.status === 'idea' || data.status === originalItem.status;
            
            if (isIdea && !hadCriteria && hasCriteriaNow && statusUnchanged) {
                await WorkItemService.update(firebaseUser.uid, id, data);
                setShowEditModal(null);
                // Ask about promotion after modal closes
                setTimeout(async () => {
                    const confirmed = await showConfirm(
                        `${id} now has acceptance criteria.\n\nPromote from Idea → Ready?`,
                        '📋 Ready for Work?'
                    );
                    if (confirmed) {
                        await WorkItemService.updateStatus(firebaseUser.uid, id, 'ready');
                        const actor = config?.ownerName || 'Owner';
                        ActivityLogService.logItemTransition(firebaseUser.uid, actor, '', id, data.title, 'idea', 'ready').catch(() => {});
                        showAlert(`${id} promoted to Ready`, 'success');
                    }
                }, 300);
            } else {
                await WorkItemService.update(firebaseUser.uid, id, data);
                setShowEditModal(null);
                showAlert(`Updated ${id}`, 'success');
            }
        };
        
        const deleteItem = async (item) => {
            if (!firebaseUser) return;
            const confirmed = await showConfirm(`Delete ${item.id}: ${item.title}?`);
            if (!confirmed) return;
            await WorkItemService.delete(firebaseUser.uid, item.id);
            showAlert(`Deleted ${item.id}`, 'success');
        };
        
        const transitionStatus = async (item, newStatus) => {
            if (!firebaseUser) return;
            await WorkItemService.updateStatus(firebaseUser.uid, item.id, newStatus);
        };
        
        const bulkUpdateStatus = async (newStatus) => {
            if (!firebaseUser || selectedItems.size === 0) return;
            const confirmed = await showConfirm(`Change ${selectedItems.size} item(s) to "${newStatus}"?`);
            if (!confirmed) return;
            for (const id of selectedItems) {
                await WorkItemService.updateStatus(firebaseUser.uid, id, newStatus);
            }
            setSelectedItems(new Set());
            showAlert(`Updated ${selectedItems.size} items`, 'success');
        };
        
        // Copy for Claude
        const copyForClaude = (item) => {
            const app = configuredApps.find(a => a.id === item.appId);
            const text = `## Work Item ${item.id}: ${item.title}

**App:** ${app?.name || item.appId}
**Type:** ${item.type} | **Priority:** ${item.priority} | **Effort:** ${item.effort}
**Status:** ${item.status}

### Description
${item.description || 'N/A'}

### Acceptance Criteria
${item.criteria?.length > 0 ? item.criteria.map((c, i) => `${i + 1}. ${c}`).join('\n') : 'None specified'}
${item.context?.filesAffected?.length > 0 ? `\n### Files Affected\n${item.context.filesAffected.join(', ')}` : ''}
${item.context?.notes ? `\n### Notes\n${item.context.notes}` : ''}
---
When complete, note: "Completes ${item.id}" in deploy notes.`;
            
            navigator.clipboard.writeText(text);
            showAlert(`Copied ${item.id} for Claude`, 'success');
        };
        
        // Handle scope save — store scope on app and generate work items
        const handleScopeSave = async (scope) => {
            if (!firebaseUser || !showScopeModal?.app) return;
            const appId = showScopeModal.app.id;
            
            try {
                // Store scope data at app.lifecycle.scope in Firebase
                const scopeRef = firebaseDb.ref(`command-center/${firebaseUser.uid}/appScopes/${appId}`);
                await scopeRef.set(scope);
                
                // Generate work items from scope
                const itemsToCreate = [];
                const existingIds = workItems.map(i => parseInt(i.id?.replace('WI-', '') || '0'));
                let nextNum = Math.max(0, ...existingIds) + 1;
                
                // V1 features → work items
                scope.v1Features.forEach(f => {
                    itemsToCreate.push({
                        id: `WI-${String(nextNum++).padStart(3, '0')}`,
                        appId: appId,
                        title: f.title,
                        description: f.description || '',
                        type: 'feature',
                        priority: f.priority || 'core',
                        status: f.priority === 'out-of-scope' ? 'deferred' : 'ready',
                        effort: f.effort || 'session',
                        source: 'scoped',
                        tags: ['scoped', `v1-${f.priority}`]
                    });
                });
                
                // Future features → idea work items
                scope.futureFeatures.forEach(f => {
                    itemsToCreate.push({
                        id: `WI-${String(nextNum++).padStart(3, '0')}`,
                        appId: appId,
                        title: f.title,
                        description: f.description || '',
                        type: 'feature',
                        priority: 'nice-to-have',
                        status: 'idea',
                        effort: 'multi-session',
                        source: 'scoped',
                        tags: ['scoped', 'v2-future']
                    });
                });
                
                // Key decisions → research work items
                scope.keyDecisions.forEach(d => {
                    if (!d.resolved) {
                        itemsToCreate.push({
                            id: `WI-${String(nextNum++).padStart(3, '0')}`,
                            appId: appId,
                            title: `Decision: ${d.title}`,
                            description: d.description || 'Resolve before or during Session 1',
                            type: 'research',
                            priority: 'core',
                            status: 'ready',
                            effort: 'quick',
                            source: 'scoped',
                            tags: ['scoped', 'decision']
                        });
                    }
                });
                
                if (itemsToCreate.length > 0) {
                    await WorkItemService.createBatch(firebaseUser.uid, itemsToCreate);
                }
                
                setShowScopeModal(null);
                showAlert(`Scope saved for ${showScopeModal.app.name} — created ${itemsToCreate.length} work items`, 'success');
            } catch (e) {
                showAlert(`Error saving scope: ${e.message}`, 'error');
            }
        };
        
        // Filtering & sorting
        const priorityOrder = { 'core': 0, 'nice-to-have': 1, 'out-of-scope': 2 };
        const statusOrder = { 'in-progress': 0, 'ready': 1, 'idea': 2, 'deferred': 3, 'done': 4 };
        const effortOrder = { 'quick': 0, 'session': 1, 'multi-session': 2, 'epic': 3 };
        
        const filteredItems = React.useMemo(() => {
            let items = [...workItems];
            
            // Status filter
            if (statusFilter === 'active') {
                items = items.filter(i => ['idea', 'ready', 'in-progress', 'review'].includes(i.status));
            } else if (statusFilter !== 'all') {
                items = items.filter(i => i.status === statusFilter);
            }
            
            // Type filter
            if (typeFilter !== 'all') {
                items = items.filter(i => i.type === typeFilter);
            }
            
            // App filter
            if (appFilter !== 'all') {
                items = items.filter(i => i.appId === appFilter);
            }
            
            // Search
            if (searchQuery.trim()) {
                const q = searchQuery.toLowerCase();
                items = items.filter(i =>
                    i.title?.toLowerCase().includes(q) ||
                    i.description?.toLowerCase().includes(q) ||
                    i.id?.toLowerCase().includes(q) ||
                    i.tags?.some(t => t.toLowerCase().includes(q))
                );
            }
            
            // Sort
            items.sort((a, b) => {
                switch (sortBy) {
                    case 'priority': return (priorityOrder[a.priority] || 9) - (priorityOrder[b.priority] || 9);
                    case 'status': return (statusOrder[a.status] || 9) - (statusOrder[b.status] || 9);
                    case 'effort': return (effortOrder[a.effort] || 9) - (effortOrder[b.effort] || 9);
                    case 'type': return (a.type || '').localeCompare(b.type || '');
                    case 'created': return new Date(b.createdAt || 0) - new Date(a.createdAt || 0);
                    default: return 0;
                }
            });
            
            return items;
        }, [workItems, statusFilter, typeFilter, appFilter, searchQuery, sortBy]);
        
        // Grouping
        const groupedItems = React.useMemo(() => {
            if (groupBy === 'none') return { 'All Items': filteredItems };
            
            const groups = {};
            filteredItems.forEach(item => {
                let key;
                switch (groupBy) {
                    case 'app': {
                        const app = configuredApps.find(a => a.id === item.appId);
                        key = app ? `${app.icon} ${app.name}` : item.appId || 'Unassigned';
                        break;
                    }
                    case 'status': key = item.status || 'unknown'; break;
                    case 'type': key = item.type || 'unknown'; break;
                    case 'stream': {
                        const stream = (globalStreams || []).find(s => s.id === item.streamId);
                        key = stream ? `🔀 ${stream.name}` : '📋 Unassigned';
                        break;
                    }
                    default: key = 'All';
                }
                if (!groups[key]) groups[key] = [];
                groups[key].push(item);
            });
            return groups;
        }, [filteredItems, groupBy, configuredApps, globalStreams]);
        
        // Stats
        const stats = React.useMemo(() => {
            const all = workItems;
            return {
                total: all.length,
                idea: all.filter(i => i.status === 'idea').length,
                ready: all.filter(i => i.status === 'ready').length,
                inProgress: all.filter(i => i.status === 'in-progress').length,
                review: all.filter(i => i.status === 'review').length,
                done: all.filter(i => i.status === 'done').length,
                deferred: all.filter(i => i.status === 'deferred').length,
                stale: all.filter(i => WorkItemService.isStale(i)).length,
            };
        }, [workItems]);
        
        // Toggle selection
        const toggleSelect = (id) => {
            setSelectedItems(prev => {
                const next = new Set(prev);
                if (next.has(id)) next.delete(id); else next.add(id);
                return next;
            });
        };
        
        const selectAll = () => {
            if (selectedItems.size === filteredItems.length) {
                setSelectedItems(new Set());
            } else {
                setSelectedItems(new Set(filteredItems.map(i => i.id)));
            }
        };
        
        // Status badge component
        const StatusBadge = ({ status }) => {
            const styles = {
                'idea': 'bg-slate-600 text-slate-300',
                'ready': 'bg-blue-900/50 text-blue-300',
                'in-progress': 'bg-amber-900/50 text-amber-300',
                'review': 'bg-purple-900/50 text-purple-300',
                'done': 'bg-green-900/50 text-green-300',
                'deferred': 'bg-slate-700 text-slate-400'
            };
            const icons = { 'idea': '💡', 'ready': '📋', 'in-progress': '🔨', 'review': '📝', 'done': '✅', 'deferred': '⏸️' };
            return (
                <span className={`px-2 py-0.5 rounded text-xs ${styles[status] || 'bg-slate-600 text-slate-300'}`}>
                    {icons[status] || ''} {status}
                </span>
            );
        };
        
        const TypeBadge = ({ type }) => {
            const styles = {
                'feature': 'bg-indigo-900/50 text-indigo-300',
                'bugfix': 'bg-red-900/50 text-red-300',
                'enhancement': 'bg-purple-900/50 text-purple-300',
                'chore': 'bg-slate-700 text-slate-300',
                'research': 'bg-amber-900/50 text-amber-300'
            };
            const icons = { 'feature': '✨', 'bugfix': '🐛', 'enhancement': '💎', 'chore': '🔧', 'research': '🔍' };
            return (
                <span className={`px-2 py-0.5 rounded text-xs ${styles[type] || 'bg-slate-600'}`}>
                    {icons[type] || ''} {type}
                </span>
            );
        };
        
        const PriorityBadge = ({ priority }) => {
            const styles = {
                'core': 'bg-red-900/30 text-red-300 border border-red-800/50',
                'nice-to-have': 'bg-amber-900/30 text-amber-300 border border-amber-800/50',
                'out-of-scope': 'bg-slate-700/50 text-slate-400 border border-slate-600'
            };
            const labels = { 'core': 'Must have', 'nice-to-have': 'Nice to have', 'out-of-scope': 'Not now' };
            return <span className={`px-2 py-0.5 rounded text-xs ${styles[priority] || ''}`}>{labels[priority] || priority}</span>;
        };
        
        const EffortBadge = ({ effort }) => {
            const icons = { 'quick': '⚡', 'session': '🕐', 'multi-session': '📅', 'epic': '🏔️' };
            return <span className="text-xs text-slate-500">{icons[effort] || ''} {effort}</span>;
        };
        
        // Quick status transitions
        const getNextStatuses = (current) => {
            const transitions = {
                'idea': ['ready', 'deferred'],
                'ready': ['in-progress', 'deferred'],
                'in-progress': ['review', 'done', 'deferred'],
                'review': ['done', 'in-progress'],
                'done': ['ready'],
                'deferred': ['idea', 'ready']
            };
            return transitions[current] || [];
        };
        
        if (!firebaseUser && !loading) {
            return (
                <div className="text-center py-20">
                    <div className="text-4xl mb-4">🔐</div>
                    <h2 className="text-xl font-bold mb-2">Sign in Required</h2>
                    <p className="text-slate-400 text-sm">Backlog requires Firebase authentication. Sign in via Settings.</p>
                    <button onClick={() => setView('settings')} className="mt-4 px-4 py-2 bg-indigo-600 rounded-lg text-sm">
                        Go to Settings
                    </button>
                </div>
            );
        }
        
        return (
            <div>
                {/* Header */}
                <div className="flex items-center justify-between mb-6">
                    <div>
                        <h1 className="text-2xl font-bold flex items-center gap-2">📋 Backlog</h1>
                        <p className="text-sm text-slate-400 mt-1">
                            {stats.total} items — {stats.inProgress} in progress, {stats.review > 0 ? `${stats.review} in review, ` : ''}{stats.ready} ready, {stats.idea} ideas
                        </p>
                    </div>
                    <div className="flex gap-2">
                        <div className="relative group">
                            <button className="px-4 py-2 bg-slate-700 hover:bg-slate-600 rounded-lg text-sm font-medium flex items-center gap-2">
                                🎯 Scope Work ▾
                            </button>
                            <div className="absolute right-0 top-full mt-1 bg-slate-800 border border-slate-700 rounded-lg shadow-xl opacity-0 invisible group-hover:opacity-100 group-hover:visible transition-all z-50 min-w-[200px]">
                                {configuredApps.map(a => (
                                    <button key={a.id} onClick={() => setShowScopeModal({ app: a })}
                                        className="w-full text-left px-4 py-2 text-sm text-slate-300 hover:bg-slate-700 first:rounded-t-lg last:rounded-b-lg flex items-center gap-2">
                                        <span>{a.icon || '📦'}</span> {a.name}
                                    </button>
                                ))}
                                {configuredApps.length === 0 && (
                                    <div className="px-4 py-2 text-xs text-slate-500">No apps configured</div>
                                )}
                            </div>
                        </div>
                        <button onClick={() => setShowEditModal({ item: null, isNew: true })}
                            className="px-4 py-2 bg-indigo-600 hover:bg-indigo-500 rounded-lg text-sm font-medium flex items-center gap-2">
                            ➕ New Work Item
                        </button>
                    </div>
                </div>
                
                {/* Stats Bar */}
                {stats.total > 0 && (
                    <div className="flex gap-2 mb-4 flex-wrap">
                        {[
                            { label: 'Active', value: stats.idea + stats.ready + stats.inProgress + stats.review, filter: 'active', color: 'bg-indigo-600' },
                            { label: 'Ideas', value: stats.idea, filter: 'idea', color: 'bg-slate-600' },
                            { label: 'Ready', value: stats.ready, filter: 'ready', color: 'bg-blue-600' },
                            { label: 'In Progress', value: stats.inProgress, filter: 'in-progress', color: 'bg-amber-600' },
                            { label: 'In Review', value: stats.review, filter: 'review', color: 'bg-purple-600' },
                            { label: 'Done', value: stats.done, filter: 'done', color: 'bg-green-600' },
                            { label: 'Deferred', value: stats.deferred, filter: 'deferred', color: 'bg-slate-500' },
                        ].map(s => (
                            <button key={s.filter} onClick={() => setStatusFilter(statusFilter === s.filter ? 'all' : s.filter)}
                                className={`px-3 py-1.5 rounded-lg text-xs font-medium flex items-center gap-2 transition-colors ${
                                    statusFilter === s.filter ? `${s.color} text-white` : 'bg-slate-800 text-slate-400 hover:bg-slate-700'
                                }`}>
                                {s.label} <span className="font-bold">{s.value}</span>
                            </button>
                        ))}
                    </div>
                )}
                
                {/* Filters Bar */}
                <div className="flex flex-wrap items-center gap-3 mb-4 bg-slate-800/50 rounded-lg p-3">
                    <div className="flex-1 min-w-[200px]">
                        <input value={searchQuery} onChange={e => setSearchQuery(e.target.value)}
                            placeholder="🔍 Search items..."
                            className="w-full bg-slate-700 border border-slate-600 rounded px-3 py-1.5 text-sm" />
                    </div>
                    <select value={appFilter} onChange={e => setAppFilter(e.target.value)}
                        className="bg-slate-700 border border-slate-600 rounded px-3 py-1.5 text-sm">
                        <option value="all">All Apps</option>
                        {configuredApps.map(a => <option key={a.id} value={a.id}>{a.icon} {a.name}</option>)}
                    </select>
                    <select value={typeFilter} onChange={e => setTypeFilter(e.target.value)}
                        className="bg-slate-700 border border-slate-600 rounded px-3 py-1.5 text-sm">
                        <option value="all">All Types</option>
                        <option value="feature">✨ Feature</option>
                        <option value="bugfix">🐛 Bugfix</option>
                        <option value="enhancement">💎 Enhancement</option>
                        <option value="chore">🔧 Chore</option>
                        <option value="research">🔍 Research</option>
                    </select>
                    <select value={sortBy} onChange={e => setSortBy(e.target.value)}
                        className="bg-slate-700 border border-slate-600 rounded px-3 py-1.5 text-sm">
                        <option value="priority">Sort: Priority</option>
                        <option value="status">Sort: Status</option>
                        <option value="effort">Sort: Effort</option>
                        <option value="type">Sort: Type</option>
                        <option value="created">Sort: Newest</option>
                    </select>
                    <select value={groupBy} onChange={e => setGroupBy(e.target.value)}
                        className="bg-slate-700 border border-slate-600 rounded px-3 py-1.5 text-sm">
                        <option value="app">Group: App</option>
                        <option value="stream">Group: Stream</option>
                        <option value="status">Group: Status</option>
                        <option value="type">Group: Type</option>
                        <option value="none">No Grouping</option>
                    </select>
                </div>
                
                {/* Bulk Actions */}
                {selectedItems.size > 0 && (
                    <div className="flex items-center gap-3 mb-4 bg-indigo-900/20 border border-indigo-700/50 rounded-lg p-3">
                        <span className="text-sm font-medium">{selectedItems.size} selected</span>
                        <div className="flex gap-2">
                            <button onClick={() => bulkUpdateStatus('ready')} className="px-3 py-1 bg-blue-600 rounded text-xs">→ Ready</button>
                            <button onClick={() => bulkUpdateStatus('in-progress')} className="px-3 py-1 bg-amber-600 rounded text-xs">→ In Progress</button>
                            <button onClick={() => bulkUpdateStatus('done')} className="px-3 py-1 bg-green-600 rounded text-xs">→ Done</button>
                            <button onClick={() => bulkUpdateStatus('deferred')} className="px-3 py-1 bg-slate-600 rounded text-xs">→ Deferred</button>
                        </div>
                        <button onClick={() => setSelectedItems(new Set())} className="text-xs text-slate-400 hover:text-white ml-auto">Clear</button>
                    </div>
                )}
                
                {/* Content */}
                {loading ? (
                    <div className="text-center py-20">
                        <div className="w-8 h-8 border-2 border-indigo-500 border-t-transparent rounded-full animate-spin mx-auto mb-4" />
                        <p className="text-slate-400">Loading backlog...</p>
                    </div>
                ) : filteredItems.length === 0 ? (
                    <div className="text-center py-20">
                        <div className="text-4xl mb-4">{workItems.length === 0 ? '📋' : '🔍'}</div>
                        <h2 className="text-lg font-bold mb-2">{workItems.length === 0 ? 'Backlog is empty' : 'No items match filters'}</h2>
                        <p className="text-slate-400 text-sm mb-4">
                            {workItems.length === 0 ? 'Create your first work item to start tracking.' : 'Try adjusting your filters.'}
                        </p>
                        {workItems.length === 0 && (
                            <button onClick={() => setShowEditModal({ item: null, isNew: true })}
                                className="px-4 py-2 bg-indigo-600 hover:bg-indigo-500 rounded-lg text-sm">
                                ➕ Create First Item
                            </button>
                        )}
                    </div>
                ) : (
                    <div className="space-y-6">
                        {Object.entries(groupedItems).map(([groupName, items]) => (
                            <div key={groupName}>
                                {groupBy !== 'none' && (
                                    <div className="flex items-center gap-2 mb-3">
                                        <h3 className="text-sm font-bold text-slate-300 capitalize">{groupName}</h3>
                                        <span className="text-xs text-slate-500 bg-slate-700 px-2 py-0.5 rounded-full">{items.length}</span>
                                        <button onClick={() => setView('ideas')} className="text-xs text-indigo-400 hover:text-indigo-300 ml-auto">💡 Ideas</button>
                                    </div>
                                )}
                                <div className="space-y-2">
                                    {items.map(item => {
                                        const app = configuredApps.find(a => a.id === item.appId);
                                        const isSelected = selectedItems.has(item.id);
                                        const nextStatuses = getNextStatuses(item.status);
                                        
                                        return (
                                            <div key={item.id} className={`bg-slate-800 rounded-lg border transition-colors ${
                                                isSelected ? 'border-indigo-500 bg-indigo-900/10' : 'border-slate-700 hover:border-slate-600'
                                            }`}>
                                                <div className="p-3">
                                                    <div className="flex items-start gap-3">
                                                        {/* Checkbox */}
                                                        <button onClick={() => toggleSelect(item.id)}
                                                            className={`mt-1 w-4 h-4 rounded border flex-shrink-0 flex items-center justify-center text-xs ${
                                                                isSelected ? 'bg-indigo-600 border-indigo-500 text-white' : 'border-slate-500 hover:border-slate-400'
                                                            }`}>
                                                            {isSelected && '✓'}
                                                        </button>
                                                        
                                                        {/* Main content */}
                                                        <div className="flex-1 min-w-0">
                                                            <div className="flex items-center gap-2 mb-1 flex-wrap">
                                                                <span className="text-xs text-slate-500 font-mono">{item.id}</span>
                                                                <TypeBadge type={item.type} />
                                                                <PriorityBadge priority={item.priority} />
                                                                <StatusBadge status={item.status} />
                                                                <EffortBadge effort={item.effort} />
                                                                {WorkItemService.isStale(item) && (
                                                                    <span className="px-1.5 py-0.5 rounded text-xs bg-red-900/40 text-red-400 border border-red-800/50" title={`${WorkItemService.getStaleDays(item)} days in ${item.status}`}>
                                                                        ⚠ {WorkItemService.getStaleDays(item)}d stale
                                                                    </span>
                                                                )}
                                                                {groupBy !== 'app' && app && (
                                                                    <span className="text-xs text-slate-500">{app.icon} {app.name}</span>
                                                                )}
                                                                {groupBy !== 'stream' && item.streamId && (() => {
                                                                    const stream = (globalStreams || []).find(s => s.id === item.streamId);
                                                                    return stream ? <span className="text-xs text-indigo-400/70">🔀 {stream.name}</span> : null;
                                                                })()}
                                                                {item.source && item.source !== 'manual' && (
                                                                    <span className="text-xs text-slate-600 italic">{item.source}</span>
                                                                )}
                                                            </div>
                                                            <h4 className="font-medium text-sm">{item.title}</h4>
                                                            {item.description && (
                                                                <p className="text-xs text-slate-400 mt-1 line-clamp-2">{item.description}</p>
                                                            )}
                                                            {item.criteria?.length > 0 && (
                                                                <div className="text-xs text-slate-500 mt-1">
                                                                    ☐ {item.criteria.length} acceptance criteria
                                                                </div>
                                                            )}
                                                            {item.tags?.length > 0 && (
                                                                <div className="flex gap-1 mt-1">
                                                                    {item.tags.map((t, i) => (
                                                                        <span key={i} className="text-xs px-1.5 py-0.5 bg-slate-700 rounded text-slate-400">{t}</span>
                                                                    ))}
                                                                </div>
                                                            )}
                                                        </div>
                                                        
                                                        {/* Actions */}
                                                        <div className="flex items-center gap-1 flex-shrink-0">
                                                            {/* Quick status transitions */}
                                                            {nextStatuses.map(ns => (
                                                                <button key={ns} onClick={() => transitionStatus(item, ns)}
                                                                    title={`→ ${ns}`}
                                                                    className="p-1.5 rounded hover:bg-slate-700 text-xs text-slate-400 hover:text-white">
                                                                    {ns === 'ready' && '📋'}
                                                                    {ns === 'in-progress' && '🔨'}
                                                                    {ns === 'done' && '✅'}
                                                                    {ns === 'deferred' && '⏸️'}
                                                                    {ns === 'idea' && '💡'}
                                                                </button>
                                                            ))}
                                                            <div className="w-px h-4 bg-slate-700 mx-1" />
                                                            <button onClick={() => copyForClaude(item)} title="Copy for Claude"
                                                                className="p-1.5 rounded hover:bg-slate-700 text-xs text-slate-400 hover:text-white">📋</button>
                                                            <button onClick={() => setShowEditModal({ item, isNew: false })} title="Edit"
                                                                className="p-1.5 rounded hover:bg-slate-700 text-xs text-slate-400 hover:text-white">✏️</button>
                                                            <button onClick={() => deleteItem(item)} title="Delete"
                                                                className="p-1.5 rounded hover:bg-slate-700 text-xs text-slate-400 hover:text-red-400">🗑️</button>
                                                        </div>
                                                    </div>
                                                </div>
                                            </div>
                                        );
                                    })}
                                </div>
                            </div>
                        ))}
                    </div>
                )}
                
                {/* Select all shortcut */}
                {filteredItems.length > 0 && (
                    <div className="mt-4 text-center">
                        <button onClick={selectAll} className="text-xs text-slate-500 hover:text-slate-300">
                            {selectedItems.size === filteredItems.length ? 'Deselect all' : `Select all ${filteredItems.length} items`}
                        </button>
                    </div>
                )}
                
                {/* Edit Modal */}
                {showEditModal && (
                    <WorkItemEditModal
                        item={showEditModal.item}
                        apps={apps}
                        isNew={showEditModal.isNew}
                        onSave={showEditModal.isNew ? createItem : updateItem}
                        onCancel={() => setShowEditModal(null)}
                        globalStreams={globalStreams || []}
                    />
                )}
                
                {/* Scope Modal */}
                {showScopeModal && (
                    <ProjectScopeModal
                        app={showScopeModal.app}
                        apps={apps}
                        onSave={handleScopeSave}
                        onCancel={() => setShowScopeModal(null)}
                        showAlert={showAlert}
                        config={config}
                    />
                )}
            </div>
        );
    }

    // =========================================================================
    // IdeaWorkCard — v8.65.0 Developer Landing Page card component
    // =========================================================================
    const PHASE_COLORS = {
        inception:    { stripe: '#94a3b8', bg: 'rgba(148,163,184,0.15)', text: '#94a3b8' },
        exploring:    { stripe: '#3b82f6', bg: 'rgba(59,130,246,0.15)',  text: '#3b82f6' },
        converging:   { stripe: '#f59e0b', bg: 'rgba(245,158,11,0.15)', text: '#f59e0b' },
        'spec-ready': { stripe: '#f093fb', bg: 'rgba(240,147,251,0.15)', text: '#f093fb' },
        complete:     { stripe: '#22c55e', bg: 'rgba(34,197,94,0.15)',   text: '#22c55e' }
    };

    // v8.68.0: Staleness thresholds for active sessions
    const STALE_WARNING_DAYS = 7;
    const STALE_ESCALATED_DAYS = 14;
    const PHASE_ORDER = ['inception', 'exploring', 'converging', 'spec-ready', 'complete'];

    // v8.68.0: Dual-state session card (active/pending)
    function IdeaWorkCard({ idea, onNavigateIdea, onNavigateApp, onContinue, onUploadResults, onAbandon }) {
        const isActive = idea.sessionState === 'active';
        const isStale = idea.staleDays >= STALE_WARNING_DAYS;
        const isEscalated = idea.staleDays >= STALE_ESCALATED_DAYS;
        const phase = PHASE_COLORS[idea.phase] || PHASE_COLORS.exploring;

        const cardBorder = isEscalated
            ? 'border-amber-600/60 shadow-[0_0_12px_rgba(245,158,11,0.15)]'
            : isActive
                ? 'border-green-600/60 shadow-[0_0_12px_rgba(34,197,94,0.15)]'
                : 'border-slate-700/50';

        const stripeColor = isActive ? '#22c55e' : phase.stripe;

        const sessionLabel = idea.lastSession ? `Session ${idea.sessionCount}` : 'No sessions';
        const dateLabel = idea.lastSession
            ? new Date(idea.lastSession.date).toLocaleString('en-US', { month: 'short', day: 'numeric', year: 'numeric', hour: 'numeric', minute: '2-digit' })
            : idea.updatedAt
                ? new Date(idea.updatedAt).toLocaleString('en-US', { month: 'short', day: 'numeric', year: 'numeric', hour: 'numeric', minute: '2-digit' })
                : '';

        return (
            <div
                onClick={() => onNavigateIdea(idea.id)}
                className={`flex items-center gap-4 p-4 rounded-xl border bg-slate-800/50 cursor-pointer transition-all hover:shadow-lg hover:-translate-y-0.5 ${cardBorder}`}
                title="Go to Idea"
            >
                <div className="w-1 h-12 rounded-full flex-shrink-0" style={{ background: stripeColor }} />
                <div className="flex-1 min-w-0">
                    <div className="flex items-center gap-2 mb-1">
                        <span className="text-sm font-semibold text-slate-100 truncate">{idea.name}</span>
                        <span
                            onClick={e => { e.stopPropagation(); onNavigateApp(idea.appId); }}
                            className="text-xs font-mono px-2 py-0.5 rounded bg-indigo-500/15 text-indigo-400 cursor-pointer hover:bg-indigo-500/25 flex-shrink-0"
                            title="Go to App"
                        >{idea.appName}</span>
                    </div>
                    <div className="flex items-center gap-2 text-xs text-slate-500 flex-wrap">
                        <span className="px-2 py-0.5 rounded font-semibold uppercase tracking-wider"
                              style={{ background: phase.bg, color: phase.text, fontSize: '10px' }}>{idea.phase}</span>
                        {isActive ? (
                            <React.Fragment>
                                <span className="px-2 py-0.5 rounded bg-green-900/50 text-green-400 font-semibold uppercase tracking-wider" style={{ fontSize: '10px' }}>active</span>
                                <span className="opacity-40">·</span>
                                <span>{idea.activeSessionId}</span>
                                <span className="opacity-40">·</span>
                                <span>dispatched {formatTimeAgo(idea.activeSessionCreatedAt)}</span>
                                {isStale && (
                                    <span className={`font-medium ${isEscalated ? 'text-red-400' : 'text-amber-400'}`}>
                                        ⚠️ {idea.staleDays}d
                                    </span>
                                )}
                            </React.Fragment>
                        ) : (
                            <React.Fragment>
                                <span>{sessionLabel}</span>
                                {dateLabel && (<React.Fragment><span className="opacity-40">·</span><span>{dateLabel}</span></React.Fragment>)}
                                <span className="opacity-40">·</span>
                                <span className={`font-mono font-semibold ${idea.openCount > 0 ? 'text-amber-400' : 'text-slate-600'}`}>{idea.openCount} OPENs</span>
                            </React.Fragment>
                        )}
                    </div>
                </div>
                {isActive && isStale && onAbandon && (
                    <button
                        onClick={e => { e.stopPropagation(); if (window.confirm(`Abandon session ${idea.activeSessionId}? This cannot be undone.`)) onAbandon(idea); }}
                        className="text-xs text-slate-500 hover:text-red-400 px-2 py-1 rounded transition-colors flex-shrink-0"
                        title="Abandon this session"
                    >✕ Abandon</button>
                )}
                <button
                    onClick={e => { e.stopPropagation(); isActive ? (onUploadResults && onUploadResults(idea)) : onContinue(idea); }}
                    className="flex items-center gap-1.5 px-4 py-2 rounded-lg text-sm font-semibold text-white flex-shrink-0 transition-all hover:-translate-y-0.5 hover:shadow-md"
                    style={{ background: isActive
                        ? (isEscalated ? 'linear-gradient(135deg, #f59e0b, #d97706)' : 'linear-gradient(135deg, #22c55e, #16a34a)')
                        : 'linear-gradient(135deg, #667eea, #764ba2)' }}
                    title={isActive ? 'Upload session results' : 'Generate session brief'}
                >
                    {isActive ? 'Upload Results' : 'Continue'}
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round">
                        {isActive
                            ? <path d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"/>
                            : <path d="M5 12h14M12 5l7 7-7 7"/>}
                    </svg>
                </button>
            </div>
        );
    }

    // =========================================================================
    // ExploreInChatModal — extracted from IdeasView (v8.63.4 fix: prevent remount flicker)
    // Must be top-level so React keeps a stable component reference across parent re-renders
    // =========================================================================
    function ExploreInChatModal({ idea, onClose, configuredApps, apps, globalConcepts, showAlert, github, firebaseUid }) {
        const app = idea.appId ? (configuredApps.find(a => a.id === idea.appId) || apps[idea.appId]) : null;
        const concepts = globalConcepts.filter(c => c.ideaOrigin === idea.id);
        const sessionNum = (idea.sessionLog?.length || 0) + 1;
        const slug = idea.slug || IdeaManager.generateSlug(idea.name);
        const computed = computeIdeaPhase(concepts);
        const phase = idea.phase || computed;

        const [briefText, setBriefText] = React.useState(null);
        const [generating, setGenerating] = React.useState(false);
        const [pushing, setPushing] = React.useState(false);
        const [error, setError] = React.useState(null);
        const [includeCodebase, setIncludeCodebase] = React.useState(phase === 'converging' || phase === 'spec-ready');

        // v8.65.2 B8: Lens/Mode state for skills-based briefs
        const sessionType = IdeationBriefGenerator.getSessionType(idea, concepts);
        const [selectedLens, setSelectedLens] = React.useState(null);
        const [selectedMode, setSelectedMode] = React.useState(
            IdeationBriefGenerator.getDefaultMode(sessionType)
        );

        const sizeThreshold = 8000;
        const isLargeBrief = briefText && briefText.length >= sizeThreshold;

        // Auto-generate brief on mount and when lens/mode change
        React.useEffect(() => {
            let cancelled = false;
            (async () => {
                setGenerating(true);
                setError(null);
                try {
                    const result = await IdeationBriefGenerator.generate(
                        idea, app, concepts, globalConcepts, selectedLens, selectedMode
                    );
                    if (!cancelled) setBriefText(result);
                } catch (e) {
                    if (!cancelled) setError(e.message);
                }
                if (!cancelled) setGenerating(false);
            })();
            return () => { cancelled = true; };
        }, [idea.id, selectedLens, selectedMode]);

        const handshakePrompt = IdeationBriefGenerator.getHandshakePrompt(
            idea.name, sessionNum, app?.name || 'Unknown', sessionType, selectedLens, selectedMode
        );

        const copyPrompt = async () => {
            try {
                await navigator.clipboard.writeText(handshakePrompt);
                await showAlert('Handshake prompt copied to clipboard', '📋 Copied');
            } catch (e) { await showAlert('Copy failed: ' + e.message, '❌ Error'); }
        };

        const copyBrief = async () => {
            if (!briefText) return;
            try {
                await navigator.clipboard.writeText(briefText);
                await showAlert('Session brief copied to clipboard', '📋 Copied');
            } catch (e) { await showAlert('Copy failed: ' + e.message, '❌ Error'); }
        };

        const downloadZip = async () => {
            if (!briefText) return;
            // v8.67.0: Guard against duplicate sessions
            if (idea.activeSession) {
                await showAlert(`Session ${idea.activeSession.sessionId} is already active for this idea. Complete or abandon it before starting a new session.`, '⚠️ Active Session');
                return;
            }
            try {
                const zip = new JSZip();
                const briefFilename = `CC-Session-Brief-${idea.name.replace(/[^a-zA-Z0-9]/g, '-')}-S${String(sessionNum).padStart(3, '0')}.md`;
                zip.file(briefFilename, briefText);

                // Include previous session's ODRC output if exists
                if (idea.sessionLog?.length > 0 && github) {
                    const latestSession = idea.sessionLog[idea.sessionLog.length - 1];
                    if (latestSession.docPath) {
                        const repo = app?.repos?.test || app?.testRepo || app?.repos?.prod || app?.prodRepo;
                        if (repo) {
                            try {
                                const file = await github.getFile(repo, latestSession.docPath);
                                if (file?.content) {
                                    zip.file(`ODRC-Updates-${slug}-latest.md`, atob(file.content));
                                }
                            } catch (e) {
                                console.log('[CC] Could not fetch previous session doc:', e.message);
                            }
                        }
                    }
                }

                const blob = await zip.generateAsync({ type: 'blob' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `session-brief-${slug}-S${String(sessionNum).padStart(3, '0')}.zip`;
                a.click();
                URL.revokeObjectURL(url);
                console.log('[CC] Downloaded session brief zip for', idea.name);

                // v8.67.0: Activate session on idea after brief download
                if (firebaseUid) {
                    try {
                        await IdeaManager.activateSession(firebaseUid, idea.id, {
                            sessionId: generateSessionId(sessionNum),
                            ideaPhaseAtStart: phase
                        });
                    } catch (e) {
                        console.warn('[CC] Session activation failed:', e.message);
                        if (e.message.includes('already has an active session')) {
                            showAlert(`Session already active for this idea. Complete or abandon it first.`, '⚠️ Active Session');
                        }
                    }
                }
            } catch (e) { await showAlert('Download failed: ' + e.message, '❌ Error'); }
        };

        const pushToRepo = async () => {
            if (!briefText || !github || !app) return;
            const repo = app.repos?.test || app.testRepo || app.repos?.prod || app.prodRepo;
            if (!repo) { await showAlert('No repo configured for this app', '⚠️ No Repo'); return; }
            setPushing(true);
            try {
                const sessionId = generateSessionId(sessionNum);
                const path = `docs/sessions/${slug}/${sessionId}.md`;
                const existing = await github.getFile(repo, path).catch(() => null);
                await github.createOrUpdateFile(repo, path, briefText,
                    `Add session brief: ${idea.name} ${sessionId}`, existing?.sha || null);
                await showAlert(`Brief pushed to ${repo}/${path}`, '✅ Pushed');
                console.log('[CC] Pushed session brief to', repo, path);
            } catch (e) { await showAlert(`Push failed: ${e.message}`, '❌ Error'); }
            setPushing(false);
        };

        // v8.69.0: Download context package (codebase + specs + ODRC state)
        const downloadContextPackage = async () => {
            try {
                const ctxZip = new JSZip();

                // 1. Codebase from GitHub
                if (app && github) {
                    const repo = app.repos?.test || app.testRepo || app.repos?.prod || app.prodRepo;
                    if (repo) {
                        for (const path of ['index.html', 'sw.js', 'manifest.json', 'CLAUDE.md']) {
                            try {
                                const f = await github.getFile(repo, path);
                                if (f?.content) ctxZip.file(`codebase/${path}`, atob(f.content));
                            } catch {} // Skip if not found
                        }
                    }
                }

                // 2. Existing spec docs from prior spec sessions
                const specSessions = (idea.sessionLog || []).filter(s => s.type === 'spec' && s.docPath);
                if (specSessions.length > 0 && github && app) {
                    const repo = app.repos?.test || app.testRepo || app.repos?.prod || app.prodRepo;
                    if (repo) {
                        for (const specSession of specSessions) {
                            try {
                                const f = await github.getFile(repo, specSession.docPath);
                                if (f?.content) {
                                    ctxZip.file(`specs/${specSession.docPath.split('/').pop()}`, atob(f.content));
                                }
                            } catch {} // Skip if not found
                        }
                    }
                }

                // 3. Current ODRC state snapshot
                const activeConcepts = globalConcepts.filter(c => c.ideaOrigin === idea.id && c.status === 'active');
                const odrcSnapshot = activeConcepts.map(c => ({
                    type: c.type,
                    content: c.content,
                    status: c.status,
                    createdAt: c.createdAt
                }));
                ctxZip.file('context/odrc-state.json', JSON.stringify(odrcSnapshot, null, 2));

                // 4. Session history summary
                const sessionSummary = (idea.sessionLog || []).map(s => ({
                    sessionId: s.sessionId,
                    date: s.date,
                    type: s.type,
                    summary: s.summary,
                    conceptsCreated: s.conceptsCreated,
                    conceptsResolved: s.conceptsResolved
                }));
                ctxZip.file('context/session-history.json', JSON.stringify(sessionSummary, null, 2));

                // Generate and download
                const blob = await ctxZip.generateAsync({ type: 'blob' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `context-package-${slug}-S${String(sessionNum).padStart(3, '0')}.zip`;
                a.click();
                URL.revokeObjectURL(url);

                // Update active session activity if exists
                if (firebaseUid && idea.activeSession) {
                    try {
                        await IdeaManager.updateSessionActivity(firebaseUid, idea.id, {
                            contextPackageDownloaded: true
                        });
                    } catch {} // Best-effort
                }

                console.log('[CC] Downloaded context package for', idea.name);
                await showAlert('Context package downloaded', '📦 Downloaded');
            } catch (e) {
                await showAlert('Context package download failed: ' + e.message, '❌ Error');
            }
        };

        const briefSizeKB = briefText ? (briefText.length / 1024).toFixed(1) : '...';

        return (
            <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50 p-4" onClick={onClose}>
                <div className="bg-slate-800 rounded-xl border border-slate-700 w-full max-w-3xl max-h-[85vh] flex flex-col" onClick={e => e.stopPropagation()}>
                    <div className="flex items-center justify-between p-4 border-b border-slate-700">
                        <h2 className="text-lg font-bold">{
                            sessionType === 'spec' ? '📋 Generate Spec' :
                            sessionType === 'claude-md' ? '📄 Generate CLAUDE.md' :
                            '🗣️ Explore in Chat'
                        } — {idea.name.substring(0, 50)}{idea.name.length > 50 ? '…' : ''} (Session {sessionNum})</h2>
                        <button onClick={onClose} className="text-slate-400 hover:text-white text-xl">✕</button>
                    </div>
                    {/* v8.65.2 B8: Lens/Mode config panel */}
                    <div className="p-4 border-b border-slate-700 space-y-3">
                        <div className="flex gap-4">
                            <div className="flex-1">
                                <label className="text-xs text-slate-400 mb-1 block">Lens (what to examine)</label>
                                <select value={selectedLens || ''} onChange={e => setSelectedLens(e.target.value || null)}
                                    className="w-full bg-slate-700 border border-slate-600 rounded px-3 py-1.5 text-sm text-white">
                                    <option value="">General (no specific lens)</option>
                                    {Object.entries(LENS_OPTIONS).map(([key, desc]) =>
                                        <option key={key} value={key}>{desc}</option>
                                    )}
                                </select>
                            </div>
                            <div className="flex-1">
                                <label className="text-xs text-slate-400 mb-1 block">Mode (how to examine)</label>
                                <select value={selectedMode || ''} onChange={e => setSelectedMode(e.target.value || null)}
                                    className="w-full bg-slate-700 border border-slate-600 rounded px-3 py-1.5 text-sm text-white">
                                    <option value="">Default</option>
                                    {Object.entries(MODE_OPTIONS).map(([key, desc]) =>
                                        <option key={key} value={key}>{desc}</option>
                                    )}
                                </select>
                            </div>
                        </div>
                        {(selectedLens || selectedMode) && (
                            <div className="text-xs text-slate-500">
                                Brief will include Skills Directive for: {[
                                    selectedLens && `cc-lens-${selectedLens}`,
                                    selectedMode && `cc-mode-${selectedMode}`
                                ].filter(Boolean).join(', ')}
                            </div>
                        )}
                    </div>
                    <div className="flex-1 overflow-y-auto p-4">
                        {generating && (
                            <div className="text-center py-8">
                                <div className="text-3xl mb-3 animate-pulse">🧠</div>
                                <p className="text-slate-400">Generating session brief...</p>
                            </div>
                        )}
                        {error && (
                            <div className="bg-red-900/30 border border-red-800 rounded-lg p-3 mb-4 text-sm text-red-300">
                                ❌ {error}
                            </div>
                        )}
                        {briefText && (
                            <pre className="text-sm text-slate-300 whitespace-pre-wrap font-mono bg-slate-900 rounded-lg p-4 border border-slate-700 max-h-[40vh] overflow-y-auto">{briefText}</pre>
                        )}

                        {/* Package contents */}
                        <div className="mt-4 bg-slate-900/50 rounded-lg p-3 border border-slate-700">
                            <h3 className="text-sm font-medium text-slate-300 mb-2">Included in package:</h3>
                            <div className="space-y-1 text-sm">
                                <div className="flex items-center gap-2">
                                    <span className="text-green-400">✓</span>
                                    <span className="text-slate-300">Session brief ({briefSizeKB} KB)</span>
                                </div>
                                {idea.sessionLog?.length > 0 ? (
                                    <div className="flex items-center gap-2">
                                        <span className="text-green-400">✓</span>
                                        <span className="text-slate-300">Previous ODRC updates</span>
                                    </div>
                                ) : (
                                    <div className="flex items-center gap-2">
                                        <span className="text-slate-500">○</span>
                                        <span className="text-slate-500">No prior sessions</span>
                                    </div>
                                )}
                                <div className="flex items-center gap-2">
                                    <label className="flex items-center gap-2 cursor-pointer">
                                        <input type="checkbox" checked={includeCodebase} onChange={e => setIncludeCodebase(e.target.checked)}
                                            className="rounded bg-slate-700 border-slate-600" />
                                        <span className={includeCodebase ? 'text-slate-300' : 'text-slate-500'}>
                                            CC codebase {!includeCodebase && `(not included — phase: ${phase})`}
                                        </span>
                                    </label>
                                </div>
                            </div>
                        </div>

                        {/* Phase info */}
                        <div className="mt-3 flex items-center gap-2 text-xs text-slate-500">
                            <span>Phase:</span>
                            <span className={`px-1.5 py-0.5 rounded ${
                                phase === 'exploring' ? 'bg-blue-900/50 text-blue-300' :
                                phase === 'converging' ? 'bg-amber-900/50 text-amber-300' :
                                'bg-green-900/50 text-green-300'
                            }`}>{phase}</span>
                            {idea.phase && idea.phase !== computed && (
                                <span className="text-amber-400" title={`Computed: ${computed}, Manual override: ${idea.phase}`}>⚠ phase mismatch</span>
                            )}
                        </div>
                    </div>
                    <div className="flex gap-2 p-4 border-t border-slate-700 justify-end flex-wrap">
                        <button onClick={copyPrompt}
                            className="px-4 py-2 rounded text-sm bg-slate-700 hover:bg-slate-600 font-medium">📋 Copy Prompt</button>
                        {isLargeBrief || idea.sessionLog?.length > 0 ? (
                            <button onClick={downloadZip} disabled={!briefText}
                                className="px-4 py-2 rounded text-sm bg-indigo-600 hover:bg-indigo-500 font-medium disabled:opacity-50">📦 Download Zip</button>
                        ) : (
                            <button onClick={copyBrief} disabled={!briefText}
                                className="px-4 py-2 rounded text-sm bg-indigo-600 hover:bg-indigo-500 font-medium disabled:opacity-50">📋 Copy Brief</button>
                        )}
                        {/* v8.69.0: Context Package — always visible */}
                        <button onClick={downloadContextPackage}
                            className="px-4 py-2 rounded text-sm bg-amber-700 hover:bg-amber-600 font-medium"
                            title="Download codebase + specs + ODRC state for spec/CLAUDE.md sessions">
                            📦 Context Package
                        </button>
                        <button onClick={pushToRepo} disabled={pushing || !briefText}
                            className="px-4 py-2 rounded text-sm bg-green-700 hover:bg-green-600 font-medium disabled:opacity-50">
                            {pushing ? '⏳ Pushing...' : '🚀 Push to Repo'}
                        </button>
                    </div>
                </div>
            </div>
        );
    }

    // =========================================================================
    // IDEAS VIEW — ODRC Concept Management + CLAUDE.md Generation + Idea-to-Chat (v8.61.0)
    // =========================================================================

    function IdeasView({ apps, globalIdeas, globalConcepts, firebaseUid, showAlert, showConfirm, showPrompt, config, setView, github, viewPayload, setViewPayload }) {
        const [mode, setMode] = React.useState('all'); // 'all' | 'app-aggregate' | 'idea-detail'
        const [selectedAppId, setSelectedAppId] = React.useState(null);
        const [selectedIdeaId, setSelectedIdeaId] = React.useState(null);
        const [showEditModal, setShowEditModal] = React.useState(null); // null | { concept, isNew, defaultIdeaId }
        const [showTransitionModal, setShowTransitionModal] = React.useState(null); // null | { concept, targetType }
        // [v8.63.0] showGenerateModal removed — GenerateCLAUDEModal replaced by pipeline
        const [showExploreModal, setShowExploreModal] = React.useState(null); // null | { ideaId }
        const [showCreateIdeaModal, setShowCreateIdeaModal] = React.useState(false); // v8.62.0: two-field idea creation
        const [sessionHistoryExpanded, setSessionHistoryExpanded] = React.useState(false);
        const [typeFilter, setTypeFilter] = React.useState('all');
        const [statusFilter, setStatusFilter] = React.useState('active');
        const [appFilter, setAppFilter] = React.useState('all');
        const [activeConceptTab, setActiveConceptTab] = React.useState('OPEN'); // v8.64.2: Mode 3 ODRC tabs
        const [conceptSearchFilter, setConceptSearchFilter] = React.useState(''); // v8.64.2: cross-mode text search
        const [conceptStatusFilter, setConceptStatusFilter] = React.useState('all'); // v8.64.2: Mode 3 status filter

        const configuredApps = React.useMemo(() => Object.values(apps).filter(a => a.testRepo || a.prodRepo || a.repos), [apps]);

        // v8.65.0: Deep-link from DashboardView work cards
        React.useEffect(() => {
            if (!viewPayload) return;
            if (viewPayload.ideaId) {
                const idea = globalIdeas.find(i => i.id === viewPayload.ideaId);
                if (idea) {
                    if (idea.appId) { setSelectedAppId(idea.appId); setSelectedIdeaId(idea.id); setMode('idea-detail'); }
                    else { setSelectedIdeaId(idea.id); setMode('idea-detail'); }
                }
            }
            if (viewPayload.createIdea) { setShowCreateIdeaModal(true); }
            if (setViewPayload) setViewPayload(null);
        }, [viewPayload]);

        // Stable reference for ExploreInChatModal idea — prevents remount on parent re-render
        const exploreIdea = React.useMemo(() => {
            if (!showExploreModal) return null;
            return globalIdeas.find(i => i.id === showExploreModal.ideaId) || null;
        }, [showExploreModal, globalIdeas]);

        // === Type/Status styling constants ===
        const TYPE_STYLES = {
            'RULE':       { color: 'bg-red-900/50 text-red-300 border-red-800/50', icon: '📏' },
            'CONSTRAINT': { color: 'bg-amber-900/50 text-amber-300 border-amber-800/50', icon: '🔒' },
            'DECISION':   { color: 'bg-blue-900/50 text-blue-300 border-blue-800/50', icon: '🎯' },
            'OPEN':       { color: 'bg-purple-900/50 text-purple-300 border-purple-800/50', icon: '❓' }
        };
        const STATUS_STYLES = {
            'active': 'bg-green-900/50 text-green-300',
            'superseded': 'bg-slate-700 text-slate-400 line-through',
            'resolved': 'bg-emerald-900/50 text-emerald-300',
            'transitioned': 'bg-indigo-900/50 text-indigo-300'
        };

        // === Computed data ===
        const filteredConcepts = React.useMemo(() => {
            let list = globalConcepts;
            if (typeFilter !== 'all') list = list.filter(c => c.type === typeFilter);
            if (statusFilter !== 'all') list = list.filter(c => c.status === statusFilter);
            if (appFilter !== 'all') {
                const ideaIds = globalIdeas.filter(i => i.appId === appFilter).map(i => i.id);
                list = list.filter(c => ideaIds.includes(c.ideaOrigin));
            }
            if (conceptSearchFilter) {
                const q = conceptSearchFilter.toLowerCase();
                list = list.filter(c => c.content.toLowerCase().includes(q));
            }
            return list;
        }, [globalConcepts, typeFilter, statusFilter, appFilter, globalIdeas, conceptSearchFilter]);

        const appIdeas = React.useMemo(() => {
            if (!selectedAppId) return [];
            return globalIdeas.filter(i => i.appId === selectedAppId).sort((a, b) => (a.sequence || 0) - (b.sequence || 0));
        }, [globalIdeas, selectedAppId]);

        const appActiveConcepts = React.useMemo(() => {
            if (!selectedAppId) return [];
            const ideaIds = appIdeas.map(i => i.id);
            return globalConcepts.filter(c => ideaIds.includes(c.ideaOrigin) && c.status === 'active');
        }, [globalConcepts, appIdeas, selectedAppId]);

        const ideaConcepts = React.useMemo(() => {
            if (!selectedIdeaId) return [];
            return globalConcepts.filter(c => c.ideaOrigin === selectedIdeaId);
        }, [globalConcepts, selectedIdeaId]);

        // v8.64.2: Filtered views for text search + status filter
        const filteredAppConcepts = React.useMemo(() => {
            let list = appActiveConcepts;
            if (conceptSearchFilter) {
                const q = conceptSearchFilter.toLowerCase();
                list = list.filter(c => c.content.toLowerCase().includes(q));
            }
            return list;
        }, [appActiveConcepts, conceptSearchFilter]);

        const filteredIdeaConcepts = React.useMemo(() => {
            let list = ideaConcepts;
            if (conceptStatusFilter !== 'all') list = list.filter(c => c.status === conceptStatusFilter);
            if (conceptSearchFilter) {
                const q = conceptSearchFilter.toLowerCase();
                list = list.filter(c => c.content.toLowerCase().includes(q));
            }
            return list;
        }, [ideaConcepts, conceptStatusFilter, conceptSearchFilter]);

        // v8.64.2: Auto-switch tab if OPEN has 0 items but another tab has items
        React.useEffect(() => {
            if (mode !== 'idea-detail' || !selectedIdeaId || filteredIdeaConcepts.length === 0) return;
            const currentCount = filteredIdeaConcepts.filter(c => c.type === activeConceptTab).length;
            if (currentCount === 0) {
                const best = ODRC_TYPES.reduce((max, t) => {
                    const count = filteredIdeaConcepts.filter(c => c.type === t).length;
                    return count > max.count ? { type: t, count } : max;
                }, { type: 'OPEN', count: 0 });
                if (best.count > 0) setActiveConceptTab(best.type);
            }
        }, [mode, selectedIdeaId, filteredIdeaConcepts, activeConceptTab]);

        const stats = React.useMemo(() => ({
            total: globalConcepts.length,
            active: globalConcepts.filter(c => c.status === 'active').length,
            byType: ODRC_TYPES.reduce((acc, t) => { acc[t] = globalConcepts.filter(c => c.type === t && c.status === 'active').length; return acc; }, {})
        }), [globalConcepts]);

        // === CRUD operations ===
        const createConcept = async (data) => {
            if (!firebaseUid) return;
            try {
                await ConceptManager.create(firebaseUid, data);
                setShowEditModal(null);
                await showAlert('Concept created', '✅ Success');
                console.log('[CC] Created concept:', data.type, data.content.slice(0, 50));
            } catch (e) { await showAlert(`Error: ${e.message}`, '❌ Error'); }
        };

        const updateConcept = async (conceptId, updates) => {
            if (!firebaseUid) return;
            try {
                await ConceptManager.update(firebaseUid, conceptId, updates);
                setShowEditModal(null);
                await showAlert('Concept updated', '✅ Success');
            } catch (e) { await showAlert(`Error: ${e.message}`, '❌ Error'); }
        };

        const deleteConcept = async (concept) => {
            const confirmed = await showConfirm(`Delete this ${concept.type}?\n\n"${concept.content.slice(0, 100)}..."`, '🗑️ Delete Concept');
            if (!confirmed) return;
            try {
                await ConceptManager.remove(firebaseUid, concept.id);
                await showAlert('Concept deleted', '✅ Deleted');
            } catch (e) { await showAlert(`Error: ${e.message}`, '❌ Error'); }
        };

        const transitionConcept = async (conceptId, newType) => {
            if (!firebaseUid) return;
            try {
                const result = await ConceptManager.transition(firebaseUid, conceptId, newType);
                setShowTransitionModal(null);
                let msg = `Transitioned to ${newType}`;
                if (result?.flaggedConcepts?.length > 0) {
                    msg += `\n\n⚠️ ${result.flaggedConcepts.length} related concept(s) flagged for review (shared scope tags with transitioning CONSTRAINT)`;
                }
                await showAlert(msg, '✅ Transitioned');
                console.log('[CC] Transitioned concept to', newType);
            } catch (e) { await showAlert(`Error: ${e.message}`, '❌ Error'); }
        };

        // v8.62.0: Opens the two-field Create Idea modal instead of sequential prompts
        const createIdea = () => setShowCreateIdeaModal(true);

        const graduateIdea = async (ideaId) => {
            if (!selectedAppId) {
                await showAlert('Select an app first', '⚠️ No App');
                return;
            }
            const confirmed = await showConfirm('Graduate this idea? It will be linked to the app and marked as graduated.', '🎓 Graduate Idea');
            if (!confirmed) return;
            try {
                await IdeaManager.graduate(firebaseUid, ideaId, selectedAppId);
                await showAlert('Idea graduated', '✅ Success');
            } catch (e) { await showAlert(`Error: ${e.message}`, '❌ Error'); }
        };

        const archiveIdea = async (ideaId) => {
            const confirmed = await showConfirm('Archive this idea?', '📦 Archive Idea');
            if (!confirmed) return;
            try {
                await IdeaManager.archive(firebaseUid, ideaId);
                await showAlert('Idea archived', '✅ Archived');
            } catch (e) { await showAlert(`Error: ${e.message}`, '❌ Error'); }
        };

        // === CreateIdeaModal (v8.62.0 — A2: Separate name/description) ===
        const CreateIdeaModal = ({ onClose }) => {
            const [ideaName, setIdeaName] = React.useState('');
            const [ideaDescription, setIdeaDescription] = React.useState('');
            const [creating, setCreating] = React.useState(false);
            // v8.69.2: App picker state — when not in app-aggregate mode, user must pick an app
            const [pickedAppId, setPickedAppId] = React.useState(mode === 'app-aggregate' ? selectedAppId : '');
            const NAME_MAX = 80;
            const nameLen = ideaName.length;

            const handleCreate = async () => {
                if (!ideaName.trim()) return;
                setCreating(true);
                const appId = mode === 'app-aggregate' ? selectedAppId : (pickedAppId || null);
                const parentIdeas = appId ? (globalIdeas || []).filter(i => i.appId === appId && i.status === 'active') : [];
                const parentIdeaId = parentIdeas.length > 0 ? parentIdeas[parentIdeas.length - 1].id : null;
                try {
                    await IdeaManager.create(firebaseUid, {
                        name: ideaName.trim(),
                        description: ideaDescription.trim(),
                        type: parentIdeaId ? 'addon' : 'base',
                        appId, parentIdeaId
                    });
                    await showAlert('Idea created', '✅ Success');
                    console.log('[CC] Created idea:', ideaName.trim());
                    onClose();
                } catch (e) {
                    await showAlert(`Error: ${e.message}`, '❌ Error');
                }
                setCreating(false);
            };

            return (
                <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50 p-4" onClick={onClose}>
                    <div className="bg-slate-800 rounded-xl border border-slate-700 w-full max-w-md p-6" onClick={e => e.stopPropagation()}>
                        <h2 className="text-lg font-bold mb-4">💡 New Idea</h2>

                        <div className="mb-4">
                            <label className="text-xs text-slate-400 block mb-1">
                                Name <span className="text-slate-500">(short title)</span>
                            </label>
                            <input value={ideaName} onChange={e => setIdeaName(e.target.value)}
                                maxLength={NAME_MAX + 10}
                                className="w-full bg-slate-700 border border-slate-600 rounded px-3 py-2 text-sm"
                                placeholder="e.g. Smart Intake for ODRC Concepts"
                                autoFocus />
                            <div className="flex justify-between mt-1">
                                {nameLen > 60 && (
                                    <span className="text-xs text-amber-400">Consider moving details to Description</span>
                                )}
                                {nameLen <= 60 && <span />}
                                <span className={`text-xs ${
                                    nameLen > NAME_MAX ? 'text-red-400' :
                                    nameLen > 60 ? 'text-amber-400' :
                                    'text-slate-500'
                                }`}>{NAME_MAX - nameLen}</span>
                            </div>
                        </div>

                        <div className="mb-4">
                            <label className="text-xs text-slate-400 block mb-1">
                                Description <span className="text-slate-500">(optional — what this idea is about)</span>
                            </label>
                            <textarea value={ideaDescription} onChange={e => setIdeaDescription(e.target.value)}
                                rows={4}
                                className="w-full bg-slate-700 border border-slate-600 rounded px-3 py-2 text-sm resize-y"
                                placeholder="Detailed description of the idea, goals, context..." />
                        </div>

                        {mode === 'app-aggregate' && selectedAppId ? (
                            <div className="text-xs text-slate-400 mb-4 bg-slate-700/50 rounded px-3 py-2">
                                Will be linked to: <span className="text-slate-300 font-medium">{apps[selectedAppId]?.name || selectedAppId}</span>
                                {appIdeas.length > 0 && <span> (add-on to idea #{appIdeas.length})</span>}
                            </div>
                        ) : (
                            <div className="mb-4">
                                <label className="text-xs text-slate-400 block mb-1">
                                    App / Project <span className="text-red-400">*</span>
                                </label>
                                <select value={pickedAppId} onChange={e => setPickedAppId(e.target.value)}
                                    className="w-full bg-slate-700 border border-slate-600 rounded px-3 py-2 text-sm">
                                    <option value="">— Select an app —</option>
                                    {configuredApps.map(a => {
                                        const ideaCount = (globalIdeas || []).filter(i => i.appId === a.id).length;
                                        return (
                                            <option key={a.id} value={a.id}>
                                                {a.name}{ideaCount > 0 ? ` (${ideaCount} idea${ideaCount !== 1 ? 's' : ''})` : ''}
                                            </option>
                                        );
                                    })}
                                </select>
                                {!pickedAppId && (
                                    <div className="text-xs text-amber-400 mt-1">
                                        Every idea must be linked to an app. Select an existing app or create one in Projects first.
                                    </div>
                                )}
                            </div>
                        )}

                        <div className="flex gap-2 justify-end">
                            <button onClick={onClose} className="px-4 py-2 rounded text-sm bg-slate-700 hover:bg-slate-600">Cancel</button>
                            <button onClick={handleCreate} disabled={creating || !ideaName.trim() || nameLen > NAME_MAX || (mode !== 'app-aggregate' && !pickedAppId)}
                                className="px-4 py-2 rounded text-sm bg-indigo-600 hover:bg-indigo-500 font-medium disabled:opacity-50">
                                {creating ? '⏳ Creating...' : 'Create Idea'}
                            </button>
                        </div>
                    </div>
                </div>
            );
        };

        // === Navigation helpers ===
        const navigateToApp = (appId) => { setSelectedAppId(appId); setSelectedIdeaId(null); setConceptSearchFilter(''); setConceptStatusFilter('all'); setMode('app-aggregate'); };
        const navigateToIdea = (ideaId) => {
            setSelectedIdeaId(ideaId);
            const idea = globalIdeas.find(i => i.id === ideaId);
            if (idea?.appId && !selectedAppId) setSelectedAppId(idea.appId);
            setConceptSearchFilter(''); setConceptStatusFilter('all'); setActiveConceptTab('OPEN');
            setMode('idea-detail');
        };
        const goBack = () => {
            setConceptSearchFilter(''); setConceptStatusFilter('all');
            if (mode === 'idea-detail') { setMode('app-aggregate'); setSelectedIdeaId(null); }
            else if (mode === 'app-aggregate') { setMode('all'); setSelectedAppId(null); }
        };

        // === ConceptCard sub-component ===
        const ConceptCard = ({ concept, showOrigin = true }) => {
            const originIdea = globalIdeas.find(i => i.id === concept.ideaOrigin);
            const style = TYPE_STYLES[concept.type] || {};
            const validTransitions = ODRC_TRANSITIONS[concept.type] || [];

            return (
                <div className={`border rounded-lg p-3 mb-2 ${style.color}`}>
                    <div className="flex items-center justify-between mb-1">
                        <div className="flex items-center gap-2">
                            <span className="text-sm">{style.icon}</span>
                            <span className={`px-2 py-0.5 rounded text-xs font-medium ${style.color}`}>{concept.type}</span>
                            <span className={`px-2 py-0.5 rounded text-xs ${STATUS_STYLES[concept.status] || ''}`}>{concept.status}</span>
                        </div>
                        <div className="flex items-center gap-1">
                            {validTransitions.length > 0 && concept.status === 'active' && (
                                <select
                                    className="bg-slate-700 border border-slate-600 rounded px-1 py-0.5 text-xs"
                                    value=""
                                    onChange={(e) => {
                                        if (e.target.value) setShowTransitionModal({ concept, targetType: e.target.value });
                                    }}
                                >
                                    <option value="">→ Transition...</option>
                                    {validTransitions.map(t => <option key={t} value={t}>{t}</option>)}
                                </select>
                            )}
                            <button onClick={() => setShowEditModal({ concept, isNew: false })}
                                className="px-2 py-0.5 rounded text-xs hover:bg-slate-600 text-slate-300">✏️</button>
                            <button onClick={() => deleteConcept(concept)}
                                className="px-2 py-0.5 rounded text-xs hover:bg-red-900/50 text-red-400">🗑️</button>
                        </div>
                    </div>
                    <p className="text-sm text-slate-200 mb-1">{concept.content}</p>
                    <div className="flex items-center gap-2 flex-wrap">
                        {(concept.scopeTags || []).map(tag => (
                            <span key={tag} className="px-1.5 py-0.5 bg-slate-700 rounded text-xs text-slate-400">{tag}</span>
                        ))}
                        {showOrigin && originIdea && (
                            <button onClick={() => navigateToIdea(concept.ideaOrigin)}
                                className="text-xs text-indigo-400 hover:text-indigo-300 ml-auto">
                                from: {originIdea.name}
                            </button>
                        )}
                    </div>
                </div>
            );
        };

        // === ConceptEditModal ===
        const ConceptEditModal = ({ concept, isNew, defaultIdeaId, onClose }) => {
            const [formData, setFormData] = React.useState({
                type: concept?.type || 'OPEN',
                content: concept?.content || '',
                scopeTags: (concept?.scopeTags || []).join(', '),
                ideaOrigin: concept?.ideaOrigin || defaultIdeaId || ''
            });
            const update = (field, value) => setFormData(prev => ({ ...prev, [field]: value }));

            const handleSave = () => {
                if (!formData.content.trim()) return;
                if (!formData.ideaOrigin) { showAlert('Select an idea', '⚠️ Required'); return; }
                const tags = formData.scopeTags.split(',').map(t => t.trim()).filter(Boolean);
                if (isNew) {
                    createConcept({ type: formData.type, content: formData.content.trim(), ideaOrigin: formData.ideaOrigin, scopeTags: tags });
                } else {
                    updateConcept(concept.id, { content: formData.content.trim(), scopeTags: tags });
                }
            };

            return (
                <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50 p-4" onClick={onClose}>
                    <div className="bg-slate-800 rounded-xl border border-slate-700 w-full max-w-lg p-6" onClick={e => e.stopPropagation()}>
                        <div className="flex items-center justify-between mb-4">
                            <h2 className="text-lg font-bold">{isNew ? '➕ New Concept' : '✏️ Edit Concept'}</h2>
                            <button onClick={onClose} className="text-slate-400 hover:text-white text-xl">✕</button>
                        </div>
                        <div className="space-y-3">
                            {isNew && (
                                <div>
                                    <label className="text-xs text-slate-400 block mb-1">Type</label>
                                    <div className="flex gap-2">
                                        {ODRC_TYPES.map(t => (
                                            <button key={t} onClick={() => update('type', t)}
                                                className={`px-3 py-1.5 rounded text-xs font-medium ${formData.type === t ? TYPE_STYLES[t].color : 'bg-slate-700 text-slate-400'}`}>
                                                {TYPE_STYLES[t].icon} {t}
                                            </button>
                                        ))}
                                    </div>
                                </div>
                            )}
                            <div>
                                <label className="text-xs text-slate-400 block mb-1">Content</label>
                                <textarea value={formData.content} onChange={e => update('content', e.target.value)}
                                    className="w-full bg-slate-700 border border-slate-600 rounded px-3 py-2 text-sm min-h-[80px]"
                                    placeholder="Describe the concept..." />
                            </div>
                            <div>
                                <label className="text-xs text-slate-400 block mb-1">Scope Tags (comma-separated)</label>
                                <input value={formData.scopeTags} onChange={e => update('scopeTags', e.target.value)}
                                    className="w-full bg-slate-700 border border-slate-600 rounded px-3 py-2 text-sm"
                                    placeholder="architecture, data-model, ux" />
                            </div>
                            {isNew && (
                                <div>
                                    <label className="text-xs text-slate-400 block mb-1">Origin Idea</label>
                                    <select value={formData.ideaOrigin} onChange={e => update('ideaOrigin', e.target.value)}
                                        className="w-full bg-slate-700 border border-slate-600 rounded px-3 py-2 text-sm">
                                        <option value="">Select idea...</option>
                                        {globalIdeas.filter(i => i.status === 'active').map(i => (
                                            <option key={i.id} value={i.id}>{i.name} ({apps[i.appId]?.name || 'unlinked'})</option>
                                        ))}
                                    </select>
                                </div>
                            )}
                        </div>
                        <div className="flex gap-2 mt-4 justify-end">
                            <button onClick={onClose} className="px-4 py-2 rounded text-sm bg-slate-700 hover:bg-slate-600">Cancel</button>
                            <button onClick={handleSave} className="px-4 py-2 rounded text-sm bg-indigo-600 hover:bg-indigo-500 font-medium">
                                {isNew ? 'Create' : 'Save'}
                            </button>
                        </div>
                    </div>
                </div>
            );
        };

        // === TransitionConfirmationModal ===
        const TransitionConfirmationModal = ({ concept, targetType, onClose }) => {
            const sharedTagConcepts = targetType && concept.type === 'CONSTRAINT'
                ? globalConcepts.filter(c => c.id !== concept.id && c.status === 'active'
                    && ['DECISION', 'RULE'].includes(c.type)
                    && (concept.scopeTags || []).some(tag => (c.scopeTags || []).includes(tag)))
                : [];

            return (
                <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50 p-4" onClick={onClose}>
                    <div className="bg-slate-800 rounded-xl border border-slate-700 w-full max-w-md p-6" onClick={e => e.stopPropagation()}>
                        <h2 className="text-lg font-bold mb-3">Transition Concept</h2>
                        <div className="flex items-center gap-3 mb-3">
                            <span className={`px-2 py-1 rounded text-sm ${TYPE_STYLES[concept.type]?.color || ''}`}>{concept.type}</span>
                            <span className="text-slate-400">→</span>
                            <span className={`px-2 py-1 rounded text-sm ${TYPE_STYLES[targetType]?.color || ''}`}>{targetType}</span>
                        </div>
                        <p className="text-sm text-slate-300 mb-3">"{concept.content.slice(0, 120)}{concept.content.length > 120 ? '...' : ''}"</p>
                        <p className="text-xs text-slate-400 mb-3">The original {concept.type} will be marked as "transitioned" and a new {targetType} will be created.</p>
                        {sharedTagConcepts.length > 0 && (
                            <div className="bg-amber-900/30 border border-amber-700/50 rounded p-3 mb-3">
                                <p className="text-sm text-amber-300 font-medium">⚠️ {sharedTagConcepts.length} related concept(s) will be flagged for review:</p>
                                <ul className="text-xs text-amber-200 mt-1 ml-4 list-disc">
                                    {sharedTagConcepts.slice(0, 5).map(c => <li key={c.id}>{c.type}: {c.content.slice(0, 60)}...</li>)}
                                    {sharedTagConcepts.length > 5 && <li>...and {sharedTagConcepts.length - 5} more</li>}
                                </ul>
                            </div>
                        )}
                        <div className="flex gap-2 justify-end">
                            <button onClick={onClose} className="px-4 py-2 rounded text-sm bg-slate-700 hover:bg-slate-600">Cancel</button>
                            <button onClick={() => transitionConcept(concept.id, targetType)}
                                className="px-4 py-2 rounded text-sm bg-indigo-600 hover:bg-indigo-500 font-medium">Confirm Transition</button>
                        </div>
                    </div>
                </div>
            );
        };

        // [v8.63.0] GenerateCLAUDEModal removed — replaced by pipeline CLAUDE.md generation


        // === ExploreInChatModal — extracted to top-level (v8.63.4 fix: prevent remount loop) ===
        // See ExploreInChatModal definition above IdeasView

        // === Auth guard ===
        if (!firebaseUid) {
            return (
                <div className="text-center py-20">
                    <div className="text-4xl mb-4">💡</div>
                    <h2 className="text-xl font-bold mb-2">Sign in Required</h2>
                    <p className="text-slate-400 mb-4">Sign in to manage ideas and concepts.</p>
                    <button onClick={() => setView('settings')} className="px-4 py-2 bg-indigo-600 hover:bg-indigo-500 rounded text-sm font-medium">Go to Settings</button>
                </div>
            );
        }

        const selectedApp = apps[selectedAppId];
        const selectedIdea = globalIdeas.find(i => i.id === selectedIdeaId);

        // === Render helper: grouped concept list ===
        const renderConceptGroup = (type, concepts, showOrigin = true) => {
            const items = concepts.filter(c => c.type === type);
            if (items.length === 0) return null;
            const style = TYPE_STYLES[type];
            return (
                <div key={type} className="mb-4">
                    <h3 className="text-sm font-medium text-slate-300 mb-2 flex items-center gap-2">
                        <span>{style.icon}</span> {type}s
                        <span className="px-1.5 py-0.5 bg-slate-700 rounded text-xs text-slate-400">{items.length}</span>
                    </h3>
                    {items.map(c => <ConceptCard key={c.id} concept={c} showOrigin={showOrigin} />)}
                </div>
            );
        };

        return (
            <div className="max-w-5xl mx-auto">
                {/* Breadcrumbs */}
                {mode !== 'all' && (
                    <div className="flex items-center gap-2 mb-3 text-sm">
                        <button onClick={() => { setMode('all'); setSelectedAppId(null); setSelectedIdeaId(null); }}
                            className="text-indigo-400 hover:text-indigo-300">All Concepts</button>
                        {mode === 'app-aggregate' && selectedApp && (
                            <><span className="text-slate-600">/</span><span className="text-slate-300">{selectedApp.name}</span></>
                        )}
                        {mode === 'idea-detail' && (
                            <>
                                <span className="text-slate-600">/</span>
                                <button onClick={goBack} className="text-indigo-400 hover:text-indigo-300">{selectedApp?.name || '...'}</button>
                                <span className="text-slate-600">/</span>
                                <span className="text-slate-300">{selectedIdea?.name || '...'}</span>
                            </>
                        )}
                    </div>
                )}

                {/* === MODE 1: All Concepts === */}
                {mode === 'all' && (
                    <div>
                        <div className="flex items-center justify-between mb-4">
                            <h1 className="text-xl font-bold flex items-center gap-2">💡 Ideas & Concepts
                                <span className="text-sm font-normal text-slate-400">{stats.active} active / {stats.total} total</span>
                            </h1>
                            <div className="flex gap-2">
                                <button onClick={createIdea} className="px-3 py-1.5 rounded text-sm bg-slate-700 hover:bg-slate-600">+ New Idea</button>
                                <button onClick={() => setShowEditModal({ concept: null, isNew: true })}
                                    className="px-3 py-1.5 rounded text-sm bg-indigo-600 hover:bg-indigo-500 font-medium">+ New Concept</button>
                            </div>
                        </div>

                        {/* Filter bar */}
                        <div className="flex gap-2 mb-4 flex-wrap">
                            <div className="relative flex-1 min-w-48">
                                <input type="text" value={conceptSearchFilter}
                                    onChange={e => setConceptSearchFilter(e.target.value)}
                                    placeholder="Search concepts..."
                                    className="w-full bg-slate-700 border border-slate-600 rounded px-3 py-1 text-sm pr-7" />
                                {conceptSearchFilter && (
                                    <button onClick={() => setConceptSearchFilter('')}
                                        className="absolute right-2 top-1/2 -translate-y-1/2 text-slate-400 hover:text-slate-200 text-sm">×</button>
                                )}
                            </div>
                            <select value={typeFilter} onChange={e => setTypeFilter(e.target.value)}
                                className="bg-slate-700 border border-slate-600 rounded px-2 py-1 text-sm">
                                <option value="all">All Types</option>
                                {ODRC_TYPES.map(t => <option key={t} value={t}>{TYPE_STYLES[t].icon} {t} ({stats.byType[t] || 0})</option>)}
                            </select>
                            <select value={statusFilter} onChange={e => setStatusFilter(e.target.value)}
                                className="bg-slate-700 border border-slate-600 rounded px-2 py-1 text-sm">
                                <option value="all">All Statuses</option>
                                {CONCEPT_STATUSES.map(s => <option key={s} value={s}>{s}</option>)}
                            </select>
                            <select value={appFilter} onChange={e => setAppFilter(e.target.value)}
                                className="bg-slate-700 border border-slate-600 rounded px-2 py-1 text-sm">
                                <option value="all">All Apps</option>
                                {configuredApps.map(a => <option key={a.id} value={a.id}>{a.name}</option>)}
                            </select>
                        </div>

                        {/* Apps with concepts — v8.62.0 A4: sort active first, collapse empties */}
                        {configuredApps.length > 0 && (() => {
                            const appsWithContent = configuredApps.filter(app => {
                                const hasIdeas = globalIdeas.some(i => i.appId === app.id);
                                const appIdeaIds = globalIdeas.filter(i => i.appId === app.id).map(i => i.id);
                                const hasConcepts = globalConcepts.some(c => appIdeaIds.includes(c.ideaOrigin) && c.status === 'active');
                                return hasIdeas || hasConcepts;
                            });
                            const emptyApps = configuredApps.filter(app => !appsWithContent.includes(app));

                            return (
                                <div className="mb-6">
                                    <h2 className="text-sm font-medium text-slate-400 mb-2">Apps</h2>
                                    <div className="grid grid-cols-2 sm:grid-cols-3 gap-2">
                                        {appsWithContent.map(app => {
                                            const appIdeaIds = globalIdeas.filter(i => i.appId === app.id).map(i => i.id);
                                            const count = globalConcepts.filter(c => appIdeaIds.includes(c.ideaOrigin) && c.status === 'active').length;
                                            const ideaCount = globalIdeas.filter(i => i.appId === app.id).length;
                                            return (
                                                <button key={app.id} onClick={() => navigateToApp(app.id)}
                                                    className="bg-slate-800 border border-slate-700 rounded-lg p-3 text-left hover:border-indigo-600 transition-colors">
                                                    <div className="font-medium text-sm">{app.name}</div>
                                                    <div className="text-xs text-slate-400 mt-1">
                                                        {count > 0 ? `${count} active concept${count !== 1 ? 's' : ''}` : 'No concepts'}
                                                        {' · '}{ideaCount > 0 ? `${ideaCount} idea${ideaCount !== 1 ? 's' : ''}` : 'No ideas'}
                                                    </div>
                                                </button>
                                            );
                                        })}
                                    </div>
                                    {emptyApps.length > 0 && (
                                        <details className="mt-2">
                                            <summary className="text-xs text-slate-500 cursor-pointer hover:text-slate-400">
                                                {emptyApps.length} app{emptyApps.length !== 1 ? 's' : ''} with no active concepts
                                            </summary>
                                            <div className="grid grid-cols-2 sm:grid-cols-3 gap-2 mt-2">
                                                {emptyApps.map(app => (
                                                    <button key={app.id} onClick={() => navigateToApp(app.id)}
                                                        className="bg-slate-800/50 border border-slate-700/50 rounded-lg p-3 text-left hover:border-indigo-600 transition-colors opacity-60">
                                                        <div className="font-medium text-sm text-slate-400">{app.name}</div>
                                                        <div className="text-xs text-slate-500 mt-1">No concepts · No ideas</div>
                                                    </button>
                                                ))}
                                            </div>
                                        </details>
                                    )}
                                </div>
                            );
                        })()}

                        {/* v8.69.2: Unlinked Ideas — ideas with no appId */}
                        {(() => {
                            const unlinkedIdeas = (globalIdeas || []).filter(i => !i.appId && i.status === 'active');
                            if (unlinkedIdeas.length === 0) return null;
                            return (
                                <div className="mb-6 bg-amber-900/10 border border-amber-800/30 rounded-lg p-4">
                                    <h2 className="text-sm font-medium text-amber-400 mb-2">
                                        ⚠ Unlinked Ideas ({unlinkedIdeas.length})
                                    </h2>
                                    <p className="text-xs text-amber-400/60 mb-3">
                                        These ideas are not linked to any app. Link them to start working.
                                    </p>
                                    <div className="space-y-2">
                                        {unlinkedIdeas.map(idea => (
                                            <div key={idea.id}
                                                className="flex items-center justify-between bg-slate-800/70 rounded-lg px-3 py-2 border border-slate-700">
                                                <div className="flex-1 min-w-0 cursor-pointer" onClick={() => navigateToIdea(idea.id)}>
                                                    <div className="font-medium text-sm truncate">{idea.name}</div>
                                                    {idea.description && (
                                                        <div className="text-xs text-slate-400 truncate">{idea.description}</div>
                                                    )}
                                                </div>
                                                <select
                                                    defaultValue=""
                                                    onChange={async (e) => {
                                                        if (!e.target.value) return;
                                                        try {
                                                            await IdeaManager.update(firebaseUid, idea.id, { appId: e.target.value });
                                                            await showAlert(`Linked "${idea.name}" to ${apps[e.target.value]?.name || e.target.value}`, '✅ Linked');
                                                        } catch (err) {
                                                            await showAlert(`Error: ${err.message}`, '❌ Error');
                                                        }
                                                    }}
                                                    className="ml-3 bg-slate-700 border border-slate-600 rounded px-2 py-1 text-xs flex-shrink-0">
                                                    <option value="">Link to app...</option>
                                                    {configuredApps.map(a => (
                                                        <option key={a.id} value={a.id}>{a.name}</option>
                                                    ))}
                                                </select>
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            );
                        })()}

                        {/* Concepts grouped by type */}
                        {filteredConcepts.length === 0 ? (
                            <div className="text-center py-12">
                                <div className="text-4xl mb-4">{globalConcepts.length === 0 ? '💡' : '🔍'}</div>
                                <h2 className="text-lg font-bold mb-2">{globalConcepts.length === 0 ? 'No concepts yet' : 'No concepts match filters'}</h2>
                                <p className="text-slate-400">{globalConcepts.length === 0 ? 'Create your first concept to get started.' : 'Try adjusting your filters.'}</p>
                            </div>
                        ) : (
                            <div>
                                {ODRC_TYPES.map(type => renderConceptGroup(type, filteredConcepts))}
                            </div>
                        )}
                    </div>
                )}

                {/* === MODE 2: App Aggregate === */}
                {mode === 'app-aggregate' && selectedApp && (
                    <div>
                        <div className="flex items-center justify-between mb-4">
                            <h1 className="text-xl font-bold flex items-center gap-2">
                                {selectedApp.name}
                                <span className="text-sm font-normal text-slate-400">{appActiveConcepts.length} active concepts</span>
                            </h1>
                            <div className="flex gap-2">
                                <button onClick={createIdea} className="px-3 py-1.5 rounded text-sm bg-slate-700 hover:bg-slate-600">+ New Idea</button>
                                <button onClick={() => setShowEditModal({ concept: null, isNew: true, defaultIdeaId: appIdeas.find(i => i.status === 'active')?.id })}
                                    className="px-3 py-1.5 rounded text-sm bg-slate-700 hover:bg-slate-600">+ New Concept</button>
                                {/* [v8.63.0] Generate CLAUDE.md button removed — use pipeline instead */}
                            </div>
                        </div>

                        {/* v8.65.3: Idea History — vertical list layout */}
                        {appIdeas.length > 0 && (
                            <div className="mb-4">
                                <h2 className="text-sm font-medium text-slate-400 mb-2">Idea History</h2>
                                <div className="space-y-1">
                                    {appIdeas.map((idea, idx) => {
                                        const ideaCpts = globalConcepts.filter(c => c.ideaOrigin === idea.id);
                                        const activeCpts = ideaCpts.filter(c => c.status === 'active');
                                        const phase = idea.phase || computeIdeaPhase(ideaCpts);
                                        const st = idea.status === 'active' ? IdeationBriefGenerator.getSessionType(idea, ideaCpts) : null;
                                        const borderColor = idea.status === 'active' ? 'border-l-indigo-500' :
                                            idea.status === 'graduated' ? 'border-l-green-500' : 'border-l-slate-600';
                                        return (
                                            <div key={idea.id}
                                                className={`flex items-center gap-3 px-3 py-2 rounded-r-lg border-l-2 ${borderColor} bg-slate-800/50 hover:bg-slate-700/50 cursor-pointer transition-colors`}
                                                onClick={() => navigateToIdea(idea.id)}
                                                title="Click to view idea details">
                                                <span className="text-xs text-slate-500 w-5 text-right flex-shrink-0">{idx + 1}</span>
                                                <span className={`flex-1 text-sm truncate ${
                                                    idea.status === 'active' ? 'text-slate-200' :
                                                    idea.status === 'graduated' ? 'text-green-400/70' :
                                                    'text-slate-500'
                                                }`}>{idea.name}</span>
                                                <span className={`text-[10px] px-1.5 py-0.5 rounded flex-shrink-0 ${
                                                    idea.status === 'active' ? 'bg-indigo-900/40 text-indigo-300' :
                                                    idea.status === 'graduated' ? 'bg-green-900/30 text-green-400/70' :
                                                    'bg-slate-700 text-slate-500'
                                                }`}>{idea.status}</span>
                                                <span className={`text-[10px] px-1.5 py-0.5 rounded flex-shrink-0 ${
                                                    phase === 'exploring' ? 'bg-blue-900/50 text-blue-300' :
                                                    phase === 'converging' ? 'bg-amber-900/50 text-amber-300' :
                                                    'bg-green-900/50 text-green-300'
                                                }`}>{phase}</span>
                                                <span className="text-[10px] text-slate-500 w-12 text-right flex-shrink-0">{activeCpts.length} cpts</span>
                                                {idea.status === 'active' && st ? (
                                                    <button onClick={e => { e.stopPropagation(); setShowExploreModal({ ideaId: idea.id }); }}
                                                        className="px-2 py-1 rounded text-xs bg-purple-700 hover:bg-purple-600 transition-colors flex-shrink-0"
                                                        title={st === 'spec' ? 'Generate Spec' : st === 'claude-md' ? 'Generate CLAUDE.md' : 'Explore in Chat'}>
                                                        {st === 'spec' ? '📋' : st === 'claude-md' ? '📄' : '🗣️'}
                                                    </button>
                                                ) : <span className="w-8 flex-shrink-0"></span>}
                                            </div>
                                        );
                                    })}
                                </div>
                            </div>
                        )}

                        {/* Current truth: active concepts grouped by type */}
                        {appActiveConcepts.length === 0 ? (
                            <div className="text-center py-12">
                                <div className="text-4xl mb-4">📋</div>
                                <h2 className="text-lg font-bold mb-2">No active concepts</h2>
                                <p className="text-slate-400">Create an idea and add concepts to build the app's specification.</p>
                            </div>
                        ) : (
                            <div>
                                <h2 className="text-sm font-medium text-slate-400 mb-2">Current Active State</h2>
                                {/* v8.64.2: Text search for Mode 2 */}
                                <div className="relative mb-3">
                                    <input type="text" value={conceptSearchFilter}
                                        onChange={e => setConceptSearchFilter(e.target.value)}
                                        placeholder="Search concepts..."
                                        className="w-full bg-slate-700 border border-slate-600 rounded px-3 py-1.5 text-sm pr-7" />
                                    {conceptSearchFilter && (
                                        <button onClick={() => setConceptSearchFilter('')}
                                            className="absolute right-2 top-1/2 -translate-y-1/2 text-slate-400 hover:text-slate-200 text-sm">×</button>
                                    )}
                                </div>
                                {ODRC_TYPES.map(type => renderConceptGroup(type, filteredAppConcepts))}
                            </div>
                        )}
                    </div>
                )}

                {/* === MODE 3: Idea Detail === */}
                {mode === 'idea-detail' && selectedIdea && (
                    <div>
                        <div className="flex items-center justify-between mb-4">
                            <div>
                                <h1 className="text-xl font-bold flex items-center gap-2">
                                    {selectedIdea.name}
                                    <span className={`px-2 py-0.5 rounded text-xs ${
                                        selectedIdea.status === 'active' ? 'bg-green-900/50 text-green-300' :
                                        selectedIdea.status === 'graduated' ? 'bg-emerald-900/50 text-emerald-300' :
                                        'bg-slate-700 text-slate-400'
                                    }`}>{selectedIdea.status}</span>
                                    <span className="px-2 py-0.5 bg-slate-700 rounded text-xs text-slate-400">{selectedIdea.type}</span>
                                    {(() => {
                                        const ideaConceptsForPhase = globalConcepts.filter(c => c.ideaOrigin === selectedIdea.id);
                                        const computed = computeIdeaPhase(ideaConceptsForPhase);
                                        const phase = selectedIdea.phase || computed;
                                        const mismatch = selectedIdea.phase && selectedIdea.phase !== computed;
                                        return (
                                            <React.Fragment>
                                                <span className={`px-2 py-0.5 rounded text-xs ${
                                                    phase === 'exploring' ? 'bg-blue-900/50 text-blue-300' :
                                                    phase === 'converging' ? 'bg-amber-900/50 text-amber-300' :
                                                    'bg-green-900/50 text-green-300'
                                                }`}>{phase}</span>
                                                {mismatch && <span className="text-amber-400 text-xs" title={`Computed: ${computed}, Override: ${selectedIdea.phase}`}>⚠</span>}
                                            </React.Fragment>
                                        );
                                    })()}
                                </h1>
                                <div className="flex items-center gap-3 mt-1">
                                    {selectedIdea.description && <p className="text-sm text-slate-400">{selectedIdea.description}</p>}
                                    {selectedIdea.slug && <span className="text-xs text-slate-500 font-mono">slug: {selectedIdea.slug}</span>}
                                    {selectedIdea.lastSessionDate && (
                                        <span className={`text-xs ${
                                            Date.now() - new Date(selectedIdea.lastSessionDate).getTime() > 14 * 24 * 60 * 60 * 1000 ? 'text-amber-400' : 'text-slate-500'
                                        }`}>
                                            Last session: {new Date(selectedIdea.lastSessionDate).toLocaleDateString()}
                                            {Date.now() - new Date(selectedIdea.lastSessionDate).getTime() > 14 * 24 * 60 * 60 * 1000 &&
                                                globalConcepts.filter(c => c.ideaOrigin === selectedIdea.id && c.type === 'OPEN' && c.status === 'active').length > 0 &&
                                                ' ⚠ stale'}
                                        </span>
                                    )}
                                </div>
                            </div>
                            <div className="flex gap-2">
                                <button onClick={() => setShowEditModal({ concept: null, isNew: true, defaultIdeaId: selectedIdea.id })}
                                    className="px-3 py-1.5 rounded text-sm bg-indigo-600 hover:bg-indigo-500 font-medium">+ Add Concept</button>
                                {selectedIdea.status === 'active' && (() => {
                                    const st = IdeationBriefGenerator.getSessionType(selectedIdea, ideaConcepts);
                                    const label = st === 'spec' ? '📋 Generate Spec'
                                        : st === 'claude-md' ? '📄 Generate CLAUDE.md in Chat'
                                        : '🗣️ Explore in Chat';
                                    return (
                                        <button onClick={() => setShowExploreModal({ ideaId: selectedIdea.id })}
                                            className="px-3 py-1.5 rounded text-sm bg-purple-700 hover:bg-purple-600 font-medium">{label}</button>
                                    );
                                })()}
                                {selectedIdea.status === 'active' && !selectedIdea.appId && (
                                    <button onClick={() => graduateIdea(selectedIdea.id)}
                                        className="px-3 py-1.5 rounded text-sm bg-green-700 hover:bg-green-600">🎓 Graduate</button>
                                )}
                                {selectedIdea.status === 'active' && (
                                    <button onClick={() => archiveIdea(selectedIdea.id)}
                                        className="px-3 py-1.5 rounded text-sm bg-slate-700 hover:bg-slate-600">📦 Archive</button>
                                )}
                            </div>
                        </div>

                        {/* Session History (collapsible) */}
                        {selectedIdea.sessionLog?.length > 0 && (
                            <div className="mb-4 bg-slate-800/50 rounded-lg border border-slate-700 p-3">
                                <button onClick={() => setSessionHistoryExpanded(!sessionHistoryExpanded)}
                                    className="flex items-center gap-2 w-full text-left text-sm font-medium text-slate-300">
                                    <span>{sessionHistoryExpanded ? '▾' : '▸'}</span>
                                    📋 Session History ({selectedIdea.sessionLog.length} session{selectedIdea.sessionLog.length !== 1 ? 's' : ''})
                                </button>
                                {sessionHistoryExpanded && (
                                    <div className="mt-2 space-y-1">
                                        {selectedIdea.sessionLog.map((s, i) => (
                                            <div key={i} className="py-1.5 border-t border-slate-700/50">
                                                <div className="flex items-center gap-3 text-xs">
                                                    <span className="text-indigo-400 font-mono">{s.sessionId}</span>
                                                    <span className="text-slate-500">{new Date(s.date).toLocaleDateString()}</span>
                                                    <span className="text-slate-400 flex-1">{s.summary}</span>
                                                    <span className="text-green-400">+{s.conceptsCreated}</span>
                                                    <span className="text-amber-400">-{s.conceptsResolved}</span>
                                                    {s.status === 'abandoned' && (
                                                        <span className="text-red-400 font-medium">abandoned</span>
                                                    )}
                                                </div>
                                                {s.chain && (
                                                    <div className="text-xs text-slate-500 mt-1 ml-0.5">
                                                        {s.chain.linkCount} link{s.chain.linkCount !== 1 ? 's' : ''} · {s.chain.totalConceptBlocks || 0} concept blocks · {s.chain.totalElapsedMinutes || 0}min
                                                    </div>
                                                )}
                                                {s.debriefSummary && (
                                                    <details className="mt-1.5">
                                                        <summary className="text-xs text-indigo-400 cursor-pointer hover:text-indigo-300">
                                                            View debrief summary
                                                        </summary>
                                                        <p className="text-xs text-slate-400 mt-1 pl-3 border-l-2 border-slate-700 whitespace-pre-wrap">
                                                            {s.debriefSummary}
                                                        </p>
                                                    </details>
                                                )}
                                                {s.nextSession && (
                                                    <div className="text-xs text-slate-500 mt-1 italic">
                                                        Next: {s.nextSession}
                                                    </div>
                                                )}
                                                {s.ideaPhaseAtStart && s.ideaPhaseAtEnd &&
                                                 s.ideaPhaseAtStart !== s.ideaPhaseAtEnd && (
                                                    <div className="text-xs mt-1">
                                                        Phase: <span className="text-slate-400">{s.ideaPhaseAtStart}</span>
                                                        {' → '}<span className="text-green-400">{s.ideaPhaseAtEnd}</span>
                                                    </div>
                                                )}
                                            </div>
                                        ))}
                                    </div>
                                )}
                            </div>
                        )}

                        {ideaConcepts.length === 0 ? (
                            <div className="text-center py-12">
                                <div className="text-4xl mb-4">📝</div>
                                <h2 className="text-lg font-bold mb-2">No concepts in this idea</h2>
                                <p className="text-slate-400">Add concepts to define the scope of this idea.</p>
                            </div>
                        ) : (
                            <div>
                                {/* v8.64.2 T2: Concept summary bar */}
                                <div className="text-sm text-slate-400 mb-3 flex flex-wrap gap-x-2">
                                    <span>📊 {ideaConcepts.length} concept{ideaConcepts.length !== 1 ? 's' : ''}:</span>
                                    {ODRC_TYPES.map(type => {
                                        const total = ideaConcepts.filter(c => c.type === type).length;
                                        const resolved = type === 'OPEN' ? ideaConcepts.filter(c => c.type === 'OPEN' && c.status === 'resolved').length : 0;
                                        const style = TYPE_STYLES[type];
                                        if (total === 0) return <span key={type} className="text-slate-600">{total} {type.toLowerCase()}s</span>;
                                        return <span key={type}>
                                            <span style={{color: type === 'OPEN' ? '#c084fc' : type === 'DECISION' ? '#93c5fd' : type === 'RULE' ? '#fca5a5' : '#fcd34d'}}>
                                                {total} {type.toLowerCase()}{total !== 1 ? 's' : ''}{resolved > 0 ? ` (${resolved} resolved)` : ''}
                                            </span>
                                            {type !== 'CONSTRAINT' ? ' · ' : ''}
                                        </span>;
                                    })}
                                </div>

                                {/* v8.64.2 T5: Filter bar — text search + status filter */}
                                <div className="flex gap-2 mb-3 flex-wrap">
                                    <div className="relative flex-1 min-w-48">
                                        <input type="text" value={conceptSearchFilter}
                                            onChange={e => setConceptSearchFilter(e.target.value)}
                                            placeholder="Search concepts..."
                                            className="w-full bg-slate-700 border border-slate-600 rounded px-3 py-1.5 text-sm pr-7" />
                                        {conceptSearchFilter && (
                                            <button onClick={() => setConceptSearchFilter('')}
                                                className="absolute right-2 top-1/2 -translate-y-1/2 text-slate-400 hover:text-slate-200 text-sm">×</button>
                                        )}
                                    </div>
                                    <select value={conceptStatusFilter} onChange={e => setConceptStatusFilter(e.target.value)}
                                        className="bg-slate-700 border border-slate-600 rounded px-2 py-1.5 text-sm">
                                        <option value="all">All Statuses</option>
                                        {CONCEPT_STATUSES.map(s => <option key={s} value={s}>{s}</option>)}
                                    </select>
                                </div>

                                {/* v8.64.2 T3: Tab bar */}
                                <div className="flex gap-1 border-b border-slate-700 mb-3">
                                    {ODRC_TYPES.map(type => {
                                        const count = filteredIdeaConcepts.filter(c => c.type === type).length;
                                        const style = TYPE_STYLES[type];
                                        return (
                                            <button key={type}
                                                onClick={() => setActiveConceptTab(type)}
                                                className={`px-4 py-2 text-sm font-medium border-b-2 transition-colors ${
                                                    activeConceptTab === type
                                                        ? 'border-indigo-400 text-white'
                                                        : count > 0
                                                            ? 'border-transparent text-slate-400 hover:text-slate-200'
                                                            : 'border-transparent text-slate-600'
                                                }`}>
                                                <span>{style.icon}</span> {type}s
                                                <span className="ml-1.5 px-1.5 py-0.5 bg-slate-700 rounded text-xs">{count}</span>
                                            </button>
                                        );
                                    })}
                                </div>

                                {/* v8.64.2 T4: Tab panel */}
                                {renderConceptGroup(activeConceptTab, filteredIdeaConcepts, false) || (
                                    <div className="text-center py-8 text-slate-500">
                                        No {activeConceptTab.toLowerCase()}s {conceptSearchFilter || conceptStatusFilter !== 'all' ? 'match filters' : 'in this idea'}
                                    </div>
                                )}
                            </div>
                        )}
                    </div>
                )}

                {/* Modals */}
                {showEditModal && (
                    <ConceptEditModal
                        concept={showEditModal.concept}
                        isNew={showEditModal.isNew}
                        defaultIdeaId={showEditModal.defaultIdeaId}
                        onClose={() => setShowEditModal(null)}
                    />
                )}
                {showTransitionModal && (
                    <TransitionConfirmationModal
                        concept={showTransitionModal.concept}
                        targetType={showTransitionModal.targetType}
                        onClose={() => setShowTransitionModal(null)}
                    />
                )}
                {/* [v8.63.0] GenerateCLAUDEModal removed */}
                {exploreIdea && (
                    <ExploreInChatModal idea={exploreIdea} onClose={() => setShowExploreModal(null)}
                        configuredApps={configuredApps} apps={apps} globalConcepts={globalConcepts}
                        showAlert={showAlert} github={github} firebaseUid={firebaseUid} />
                )}
                {showCreateIdeaModal && (
                    <CreateIdeaModal onClose={() => setShowCreateIdeaModal(false)} />
                )}
            </div>
        );
    }

    // =========================================================================
    // JOB HISTORY VIEW (v8.58.0 — Ingestion Pipeline Phase 1)
    // =========================================================================

    function JobHistoryView({ globalCompletionJobs, firebaseUid, github, apps, showAlert, showConfirm, config, completionFileSettings, globalConcepts, globalIdeas, showPrompt, globalOrphanCommits }) {
        const [stateFilter, setStateFilter] = React.useState('all');
        const [repoFilter, setRepoFilter] = React.useState('all');
        const [expandedJobId, setExpandedJobId] = React.useState(null);
        const [polling, setPolling] = React.useState(false);

        // Bundle assembly modal state
        const [bundleModal, setBundleModal] = React.useState(null);
        // Mark as Checked state
        const [checkingJobId, setCheckingJobId] = React.useState(null);
        const [checkOutcome, setCheckOutcome] = React.useState('confirmed');
        const [checkNotes, setCheckNotes] = React.useState('');
        // Phase 3: ODRC Update Modal state
        const [odrcModal, setOdrcModal] = React.useState(null); // { jobId, inputText, parsedUpdates, confirmedIndexes, results, phase: 'input'|'review'|'done' }
        // Phase 3: Orphan section expanded
        const [orphanExpanded, setOrphanExpanded] = React.useState(false);
        // Phase 3: Batch classification modal
        const [batchModal, setBatchModal] = React.useState(null); // { jobs, selectedIds, phase: 'select'|'assembling'|'done', steps, result, errors }

        const STATE_STYLES = {
            'new': 'bg-blue-900/50 text-blue-300',
            'acknowledged': 'bg-slate-700 text-slate-400',
            'reviewed': 'bg-amber-900/50 text-amber-300',
            'checked': 'bg-green-900/50 text-green-300'
        };
        const STATUS_STYLES = {
            'complete': 'bg-green-900/50 text-green-300',
            'partial': 'bg-amber-900/50 text-amber-300',
            'blocked': 'bg-red-900/50 text-red-300'
        };
        const OUTCOME_STYLES = {
            'confirmed': 'bg-green-900/50 text-green-300',
            'challenged': 'bg-amber-900/50 text-amber-300',
            'escalated': 'bg-red-900/50 text-red-300'
        };
        const BUNDLE_STEPS = [
            { key: 'fetching-completion', label: 'Fetching completion file' },
            { key: 'fetching-spec', label: 'Fetching spec archive' },
            { key: 'fetching-files', label: 'Fetching changed files' },
            { key: 'generating-summary', label: 'Generating ODRC summary' },
            { key: 'generating-prompt', label: 'Generating review prompt' },
            { key: 'building-zip', label: 'Building zip' },
            { key: 'done', label: 'Complete' }
        ];

        // Unique repos from jobs
        const repos = React.useMemo(() => {
            const set = new Set(globalCompletionJobs.map(j => j.repoFullName).filter(Boolean));
            return Array.from(set).sort();
        }, [globalCompletionJobs]);

        // Filtered jobs
        const filteredJobs = React.useMemo(() => {
            let list = globalCompletionJobs;
            if (stateFilter !== 'all') list = list.filter(j => j.state === stateFilter);
            if (repoFilter !== 'all') list = list.filter(j => j.repoFullName === repoFilter);
            return list;
        }, [globalCompletionJobs, stateFilter, repoFilter]);

        // Stats
        const stats = React.useMemo(() => ({
            total: globalCompletionJobs.length,
            new: globalCompletionJobs.filter(j => j.state === 'new').length,
            acknowledged: globalCompletionJobs.filter(j => j.state === 'acknowledged').length,
            reviewed: globalCompletionJobs.filter(j => j.state === 'reviewed').length,
            checked: globalCompletionJobs.filter(j => j.state === 'checked').length,
            unclassified: globalCompletionJobs.filter(j => !j.classified).length
        }), [globalCompletionJobs]);

        // Orphan stats
        const orphanStats = React.useMemo(() => ({
            total: (globalOrphanCommits || []).length,
            detected: (globalOrphanCommits || []).filter(o => o.state === 'detected').length,
            dismissed: (globalOrphanCommits || []).filter(o => o.state === 'dismissed').length,
            reconstructed: (globalOrphanCommits || []).filter(o => o.state === 'reconstructed').length
        }), [globalOrphanCommits]);

        const ORPHAN_STATE_STYLES = {
            'detected': 'bg-red-900/50 text-red-300',
            'dismissed': 'bg-slate-700 text-slate-400',
            'reconstructed': 'bg-green-900/50 text-green-300',
            'ignored': 'bg-slate-800 text-slate-500'
        };

        // Manual poll trigger
        const handlePoll = async () => {
            if (!github || !firebaseUid) return;
            setPolling(true);
            let totalNew = 0;
            let totalOrphans = 0;
            try {
                const configuredApps = Object.values(apps).filter(a => a.testRepo || a.prodRepo || a.repos);
                const checkedRepos = new Set();
                for (const app of configuredApps) {
                    const repoNames = [app.testRepo, app.prodRepo, app.repos?.test, app.repos?.prod].filter(Boolean);
                    for (const repo of repoNames) {
                        if (checkedRepos.has(repo)) continue;
                        checkedRepos.add(repo);
                        const newJobs = await pollCompletionFiles(github, repo, firebaseUid, globalCompletionJobs, globalOrphanCommits);
                        totalNew += newJobs.length;
                        try {
                            const newOrphans = await pollOrphanCommits(github, repo, firebaseUid, globalCompletionJobs, globalOrphanCommits || [], completionFileSettings);
                            totalOrphans += newOrphans.length;
                        } catch (e) { console.warn('[CC] Orphan poll error:', e.message); }
                    }
                }
                const parts = [];
                if (totalNew > 0) parts.push(`${totalNew} new completion file${totalNew !== 1 ? 's' : ''}`);
                if (totalOrphans > 0) parts.push(`${totalOrphans} orphaned commit${totalOrphans !== 1 ? 's' : ''}`);
                if (parts.length > 0) {
                    await showAlert(`Found ${parts.join(' and ')}`, '📦 Scan Results');
                } else {
                    await showAlert('No new completion files or orphaned commits found', '📦 Up to Date');
                }
            } catch (e) {
                await showAlert(`Poll error: ${e.message}`, '❌ Error');
            }
            setPolling(false);
        };

        // Actions
        const dismissJob = async (jobId) => {
            await CompletionFileService.updateState(firebaseUid, jobId, 'acknowledged');
        };
        const reviewJob = (jobId) => {
            CompletionFileService.updateState(firebaseUid, jobId, 'reviewed');
            setExpandedJobId(jobId);
        };

        // Package for Check — opens bundle assembly modal
        const handlePackageForCheck = async (job) => {
            if (!ClaudeAPIService.isConfigured()) {
                await showAlert('Anthropic API key not configured. Go to Settings → Anthropic API Key to add your key from console.anthropic.com.', '🔑 API Key Required');
                return;
            }
            if (!github) {
                await showAlert('GitHub not connected. Configure GitHub in Settings.', '⚠️ GitHub Required');
                return;
            }

            // Initialize modal with steps
            const initialSteps = BUNDLE_STEPS.map(s => ({ ...s, status: 'pending', detail: '' }));
            setBundleModal({ jobId: job.id, steps: initialSteps, errors: [], excluded: [], result: null, active: true });

            try {
                const bundleSizeLimit = completionFileSettings?.bundleSizeLimit || (5 * 1024 * 1024);
                const result = await ValidationBundleAssembler.assemble({
                    completionJob: job,
                    github,
                    repoFullName: job.repoFullName,
                    globalConcepts: globalConcepts || [],
                    globalIdeas: globalIdeas || [],
                    bundleSizeLimit,
                    onProgress: (step, detail) => {
                        setBundleModal(prev => {
                            if (!prev) return prev;
                            const newSteps = prev.steps.map(s => {
                                if (s.key === step) return { ...s, status: step === 'done' ? 'done' : 'active', detail };
                                if (s.status === 'active' && s.key !== step) return { ...s, status: 'done' };
                                return s;
                            });
                            return { ...prev, steps: newSteps };
                        });
                    }
                });

                // Update modal with result
                setBundleModal(prev => {
                    if (!prev) return prev;
                    const finalSteps = prev.steps.map(s => ({ ...s, status: 'done' }));
                    return {
                        ...prev,
                        steps: finalSteps,
                        errors: result.manifest.errors || [],
                        excluded: result.manifest.filesExcluded || [],
                        result,
                        active: false
                    };
                });

                // Move to reviewed state if currently new/acknowledged
                if (job.state === 'new' || job.state === 'acknowledged') {
                    await CompletionFileService.updateState(firebaseUid, job.id, 'reviewed');
                }
            } catch (e) {
                setBundleModal(prev => {
                    if (!prev) return prev;
                    const errorSteps = prev.steps.map(s =>
                        s.status === 'active' ? { ...s, status: 'error', detail: e.message } : s
                    );
                    return { ...prev, steps: errorSteps, errors: [...prev.errors, e.message], active: false };
                });
            }
        };

        // Download the assembled bundle
        const handleDownloadBundle = () => {
            if (bundleModal?.result) {
                ValidationBundleAssembler.download(bundleModal.result.blob, bundleModal.result.bundleName);
            }
        };

        // Mark as Checked flow
        const handleMarkAsChecked = async () => {
            if (!checkingJobId || !firebaseUid) return;
            try {
                await CompletionFileService.updateCheckOutcome(firebaseUid, checkingJobId, checkOutcome, checkNotes);
                await CompletionFileService.updateState(firebaseUid, checkingJobId, 'checked');
                setCheckingJobId(null);
                setCheckOutcome('confirmed');
                setCheckNotes('');
            } catch (e) {
                await showAlert(`Error marking as checked: ${e.message}`, '❌ Error');
            }
        };

        // Phase 3: ODRC Update Import
        const openOdrcModal = (jobId) => {
            setOdrcModal({ jobId, inputText: '', parsedUpdates: [], confirmedIndexes: new Set(), results: null, phase: 'input' });
        };
        const parseOdrcInput = () => {
            if (!odrcModal) return;
            const updates = ODRCUpdateIngestionService.parse(odrcModal.inputText);
            const allIndexes = new Set(updates.map((_, i) => i));
            setOdrcModal(prev => ({ ...prev, parsedUpdates: updates, confirmedIndexes: allIndexes, phase: updates.length > 0 ? 'review' : 'input' }));
            if (updates.length === 0) {
                showAlert('No ODRC updates could be parsed from the input. Check the format matches the expected pattern.', '⚠️ Parse Result');
            }
        };
        const executeOdrcUpdates = async () => {
            if (!odrcModal || !firebaseUid) return;
            const selected = odrcModal.parsedUpdates.filter((_, i) => odrcModal.confirmedIndexes.has(i));
            const results = await ODRCUpdateIngestionService.execute(firebaseUid, selected, globalIdeas || []);
            // Mark job as classified if it has create/resolve actions
            if (odrcModal.jobId) {
                const job = globalCompletionJobs.find(j => j.id === odrcModal.jobId);
                if (job && !job.classified) {
                    try {
                        await CompletionFileService._ref(firebaseUid).child(odrcModal.jobId).update({ classified: true });
                    } catch (e) { console.warn('[CC] Could not mark job as classified:', e.message); }
                }
            }
            setOdrcModal(prev => ({ ...prev, results, phase: 'done' }));
        };

        // Phase 3: Orphan actions
        const dismissOrphan = async (orphanId) => {
            await OrphanDetectionService.updateState(firebaseUid, orphanId, 'dismissed');
        };
        const ignoreOrphan = async (orphanId) => {
            await OrphanDetectionService.updateState(firebaseUid, orphanId, 'ignored');
        };
        const handleReconstructOrphans = (orphans) => {
            const detectedOrphans = orphans.filter(o => o.state === 'detected' || o.state === 'dismissed');
            if (detectedOrphans.length === 0) {
                showAlert('No orphaned commits to reconstruct.', '📍 Orphans');
                return;
            }
            const markdown = generateOrphanReconstructionPackage(detectedOrphans);
            navigator.clipboard.writeText(markdown).then(() => {
                showAlert(`Reconstruction task for ${detectedOrphans.length} orphan commit${detectedOrphans.length !== 1 ? 's' : ''} copied to clipboard. Paste into a Claude Code session to reconstruct completion files.`, '📋 Copied');
            }).catch(() => {
                // Fallback: download as file
                const blob = new Blob([markdown], { type: 'text/markdown' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `reconstruct-orphans-${new Date().toISOString().replace(/[:.]/g, '-')}.md`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                showAlert('Reconstruction task downloaded as file.', '📥 Downloaded');
            });
        };

        // Phase 3: Batch Classification
        const openBatchClassification = () => {
            const unclassifiedJobs = globalCompletionJobs.filter(j => !j.classified);
            const selectedIds = new Set(unclassifiedJobs.map(j => j.id));
            setBatchModal({ jobs: unclassifiedJobs, selectedIds, phase: 'select', steps: [], result: null, errors: [] });
        };
        const executeBatchClassification = async () => {
            if (!batchModal || !github) return;
            if (!ClaudeAPIService.isConfigured()) {
                await showAlert('Anthropic API key not configured. Go to Settings → Anthropic API Key to add your key from console.anthropic.com.', '🔑 API Key Required');
                return;
            }
            const selectedJobs = batchModal.jobs.filter(j => batchModal.selectedIds.has(j.id));
            if (selectedJobs.length === 0) return;

            const steps = [
                { key: 'fetching', label: 'Fetching completion files', status: 'active' },
                { key: 'odrc', label: 'Generating ODRC summary', status: 'pending' },
                { key: 'prompt', label: 'Generating classification prompt', status: 'pending' },
                { key: 'zip', label: 'Building zip', status: 'pending' },
                { key: 'done', label: 'Complete', status: 'pending' }
            ];
            setBatchModal(prev => ({ ...prev, phase: 'assembling', steps }));

            try {
                const zip = new JSZip();
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                const bundleName = `classification-bundle-${timestamp}`;
                const errors = [];

                // Step 1: Add completion files
                for (const job of selectedJobs) {
                    try {
                        const fileData = await github.getFileContent(job.repoFullName, `cc/completions/${job.fileName}`);
                        if (fileData?.textContent) {
                            zip.file(`completion-files/${job.fileName}`, fileData.textContent);
                        }
                    } catch (e) { errors.push(`Could not fetch ${job.fileName}: ${e.message}`); }
                }
                setBatchModal(prev => ({ ...prev, steps: prev.steps.map(s => s.key === 'fetching' ? { ...s, status: 'done' } : s.key === 'odrc' ? { ...s, status: 'active' } : s) }));

                // Step 2: ODRC summary
                const odrcSummary = ODRCSummaryGenerator.generateFull(globalConcepts || [], globalIdeas || []);
                zip.file('odrc-summary.md', odrcSummary);
                setBatchModal(prev => ({ ...prev, steps: prev.steps.map(s => s.key === 'odrc' ? { ...s, status: 'done' } : s.key === 'prompt' ? { ...s, status: 'active' } : s) }));

                // Step 3: Classification prompt
                try {
                    const prompt = await ReviewPromptGenerator.generateBatchClassificationPrompt(selectedJobs, odrcSummary);
                    zip.file('classification-prompt.md', prompt);
                } catch (e) {
                    errors.push(`Classification prompt generation failed: ${e.message}`);
                    zip.file('classification-prompt.md', '# Classification Prompt\n\n*Static fallback — Claude API call failed.*\n\nPlease classify each completion file in this bundle against the ODRC landscape in odrc-summary.md.');
                }
                setBatchModal(prev => ({ ...prev, steps: prev.steps.map(s => s.key === 'prompt' ? { ...s, status: 'done' } : s.key === 'zip' ? { ...s, status: 'active' } : s) }));

                // Step 4: Manifest + zip
                const manifest = { bundleName, createdAt: new Date().toISOString(), mode: 'batch-classification', jobCount: selectedJobs.length, jobs: selectedJobs.map(j => ({ id: j.id, task: j.task, fileName: j.fileName })), errors };
                zip.file('manifest.json', JSON.stringify(manifest, null, 2));
                const blob = await zip.generateAsync({ type: 'blob' });
                setBatchModal(prev => ({
                    ...prev,
                    phase: 'done',
                    steps: prev.steps.map(s => ({ ...s, status: 'done' })),
                    result: { blob, bundleName, manifest },
                    errors
                }));
            } catch (e) {
                setBatchModal(prev => ({ ...prev, errors: [...prev.errors, e.message], phase: 'done' }));
            }
        };
        const handleDownloadBatchBundle = () => {
            if (batchModal?.result) {
                ValidationBundleAssembler.download(batchModal.result.blob, batchModal.result.bundleName);
            }
        };

        // Auth guard
        if (!firebaseUid) {
            return (
                <div className="text-center py-20">
                    <div className="text-4xl mb-4">📦</div>
                    <h2 className="text-xl font-bold mb-2">Sign in Required</h2>
                    <p className="text-slate-400">Sign in to view job history.</p>
                </div>
            );
        }

        return (
            <div className="max-w-5xl mx-auto">
                {/* Header */}
                <div className="flex items-center justify-between mb-4">
                    <div>
                        <h1 className="text-xl font-bold flex items-center gap-2">📦 Job History
                            <span className="text-sm font-normal text-slate-400">Completion files from Claude Code sessions</span>
                        </h1>
                        <div className="flex gap-3 mt-1 text-xs text-slate-400">
                            <span>{stats.total} total</span>
                            {stats.new > 0 && <span className="text-blue-300">{stats.new} new</span>}
                            {stats.reviewed > 0 && <span className="text-amber-300">{stats.reviewed} reviewed</span>}
                            {stats.checked > 0 && <span className="text-green-300">{stats.checked} checked</span>}
                        </div>
                    </div>
                    <button onClick={handlePoll} disabled={polling}
                        className="px-3 py-1.5 rounded text-sm bg-indigo-600 hover:bg-indigo-500 font-medium disabled:opacity-50">
                        {polling ? '⏳ Scanning...' : '🔍 Scan Repos'}
                    </button>
                </div>

                {/* Unclassified nudge */}
                {stats.unclassified >= (completionFileSettings?.unclassifiedNudgeThreshold || 5) && (
                    <div className="bg-amber-900/20 border border-amber-700/50 rounded-lg p-3 mb-4 flex items-center justify-between">
                        <span className="text-sm text-amber-300">You have {stats.unclassified} unclassified jobs. Package them for classification?</span>
                        <button onClick={openBatchClassification}
                            className="px-3 py-1.5 rounded text-xs bg-amber-700 hover:bg-amber-600 font-medium">
                            📦 Classify Batch
                        </button>
                    </div>
                )}

                {/* Orphan nudge */}
                {orphanStats.detected >= (completionFileSettings?.orphanNudgeThreshold || 5) && (
                    <div className="bg-red-900/20 border border-red-700/50 rounded-lg p-3 mb-4 flex items-center justify-between">
                        <span className="text-sm text-red-300">You have {orphanStats.detected} orphaned commits with no completion files. Review them?</span>
                        <button onClick={() => setOrphanExpanded(true)}
                            className="px-3 py-1.5 rounded text-xs bg-red-700 hover:bg-red-600 font-medium">
                            📍 View Orphans
                        </button>
                    </div>
                )}

                {/* Filter bar */}
                <div className="flex gap-2 mb-4 flex-wrap">
                    <select value={stateFilter} onChange={e => setStateFilter(e.target.value)} data-testid="state-filter"
                        className="bg-slate-700 border border-slate-600 rounded px-2 py-1 text-sm">
                        <option value="all">All States ({stats.total})</option>
                        <option value="new">New ({stats.new})</option>
                        <option value="acknowledged">Acknowledged ({stats.acknowledged})</option>
                        <option value="reviewed">Reviewed ({stats.reviewed})</option>
                        <option value="checked">Checked ({stats.checked})</option>
                    </select>
                    <select value={repoFilter} onChange={e => setRepoFilter(e.target.value)} data-testid="repo-filter"
                        className="bg-slate-700 border border-slate-600 rounded px-2 py-1 text-sm">
                        <option value="all">All Repos</option>
                        {repos.map(r => <option key={r} value={r}>{r.split('/').pop()}</option>)}
                    </select>
                </div>

                {/* Job cards */}
                {filteredJobs.length === 0 ? (
                    <div className="text-center py-12">
                        <div className="text-4xl mb-4">📦</div>
                        <h2 className="text-lg font-bold mb-2">{globalCompletionJobs.length === 0 ? 'No completion files detected yet' : 'No jobs match filters'}</h2>
                        <p className="text-slate-400">{globalCompletionJobs.length === 0 ? 'When Claude Code produces completion files in cc/completions/, they\'ll appear here.' : 'Try adjusting your filters.'}</p>
                        {globalCompletionJobs.length === 0 && (
                            <button onClick={handlePoll} disabled={polling}
                                className="mt-4 px-4 py-2 bg-indigo-600 hover:bg-indigo-500 rounded text-sm font-medium disabled:opacity-50">
                                {polling ? '⏳ Scanning...' : '🔍 Scan Repos Now'}
                            </button>
                        )}
                    </div>
                ) : (
                    <div className="space-y-2">
                        {filteredJobs.map(job => {
                            const isExpanded = expandedJobId === job.id;
                            return (
                                <div key={job.id} data-testid={`job-card-${job.id}`} className="bg-slate-800/50 border border-slate-700 rounded-lg overflow-hidden">
                                    {/* Card header */}
                                    <div className="p-3 cursor-pointer hover:bg-slate-700/30" onClick={() => setExpandedJobId(isExpanded ? null : job.id)}>
                                        <div className="flex items-center gap-2 mb-1">
                                            <span className={`transform transition-transform text-xs ${isExpanded ? 'rotate-90' : ''}`}>▶</span>
                                            <span className={`px-2 py-0.5 rounded text-xs ${STATE_STYLES[job.state] || ''}`}>{job.state}</span>
                                            {job.validationStatus === 'warning' && <span title={job.validationErrors?.join(', ')}>⚠️</span>}
                                            {job.status && <span className={`px-2 py-0.5 rounded text-xs ${STATUS_STYLES[job.status] || ''}`}>{job.status}</span>}
                                            {!job.classified && <span className="px-1.5 py-0.5 bg-slate-600 rounded text-xs text-slate-400">unclassified</span>}
                                            {job.specId && <span className="px-1.5 py-0.5 bg-indigo-900/50 rounded text-xs text-indigo-300">{job.specId}</span>}
                                        </div>
                                        <p className="text-sm font-medium text-slate-200">{job.task || job.fileName}</p>
                                        <div className="flex items-center gap-3 mt-1 text-xs text-slate-400">
                                            <span>{job.repoFullName?.split('/').pop()}</span>
                                            <span>{job.files?.length || 0} files</span>
                                            <span>{job.commits?.length || 0} commits</span>
                                            <span>{new Date(job.detectedAt).toLocaleDateString()}</span>
                                        </div>
                                    </div>

                                    {/* Expanded detail */}
                                    {isExpanded && (
                                        <div className="border-t border-slate-700 p-4 space-y-3">
                                            {/* Action buttons */}
                                            <div className="flex gap-2 mb-3 flex-wrap">
                                                {(job.state === 'new') && (
                                                    <>
                                                        <button onClick={(e) => { e.stopPropagation(); reviewJob(job.id); }}
                                                            className="px-3 py-1 rounded text-xs bg-amber-700 hover:bg-amber-600">📖 Review</button>
                                                        <button onClick={(e) => { e.stopPropagation(); dismissJob(job.id); }}
                                                            className="px-3 py-1 rounded text-xs bg-slate-700 hover:bg-slate-600">Dismiss</button>
                                                    </>
                                                )}
                                                {(job.state === 'acknowledged') && (
                                                    <button onClick={(e) => { e.stopPropagation(); reviewJob(job.id); }}
                                                        className="px-3 py-1 rounded text-xs bg-amber-700 hover:bg-amber-600">📖 Review</button>
                                                )}
                                                {(job.state === 'new' || job.state === 'acknowledged' || job.state === 'reviewed') && (
                                                    <button onClick={(e) => { e.stopPropagation(); handlePackageForCheck(job); }}
                                                        className="px-3 py-1 rounded text-xs bg-indigo-700 hover:bg-indigo-600">
                                                        📦 Package for Check
                                                    </button>
                                                )}
                                                {(job.state === 'reviewed') && (
                                                    <button onClick={(e) => { e.stopPropagation(); setCheckingJobId(job.id); setCheckOutcome('confirmed'); setCheckNotes(''); }}
                                                        className="px-3 py-1 rounded text-xs bg-green-700 hover:bg-green-600">
                                                        ✅ Mark as Checked
                                                    </button>
                                                )}
                                                {(job.state === 'reviewed' || job.state === 'checked') && (
                                                    <button onClick={(e) => { e.stopPropagation(); openOdrcModal(job.id); }}
                                                        className="px-3 py-1 rounded text-xs bg-purple-700 hover:bg-purple-600">
                                                        📥 Import ODRC Updates
                                                    </button>
                                                )}
                                            </div>

                                            {/* Mark as Checked inline form */}
                                            {checkingJobId === job.id && (
                                                <div className="bg-slate-700/50 border border-slate-600 rounded-lg p-3 space-y-2">
                                                    <h4 className="text-xs font-bold text-slate-300">Mark as Checked</h4>
                                                    <div className="flex items-center gap-2">
                                                        <label className="text-xs text-slate-400">Outcome:</label>
                                                        <select value={checkOutcome} onChange={e => setCheckOutcome(e.target.value)}
                                                            className="bg-slate-800 border border-slate-600 rounded px-2 py-1 text-xs">
                                                            <option value="confirmed">✅ Confirmed</option>
                                                            <option value="challenged">⚠️ Challenged</option>
                                                            <option value="escalated">🔴 Escalated</option>
                                                        </select>
                                                    </div>
                                                    <textarea value={checkNotes} onChange={e => setCheckNotes(e.target.value)}
                                                        placeholder="Optional notes — what did the review find?"
                                                        className="w-full bg-slate-800 border border-slate-600 rounded px-2 py-1 text-xs h-16 resize-none" />
                                                    <div className="flex gap-2">
                                                        <button onClick={handleMarkAsChecked}
                                                            className="px-3 py-1 rounded text-xs bg-green-700 hover:bg-green-600">Confirm</button>
                                                        <button onClick={() => setCheckingJobId(null)}
                                                            className="px-3 py-1 rounded text-xs bg-slate-700 hover:bg-slate-600">Cancel</button>
                                                    </div>
                                                </div>
                                            )}

                                            {/* Task description */}
                                            <div>
                                                <h4 className="text-xs font-bold text-slate-400 mb-1">Task</h4>
                                                <p className="text-sm text-slate-200">{job.task}</p>
                                            </div>

                                            {/* Files */}
                                            {job.files?.length > 0 && (
                                                <div>
                                                    <h4 className="text-xs font-bold text-slate-400 mb-1">Files Changed ({job.files.length})</h4>
                                                    <div className="space-y-1">
                                                        {job.files.map((f, i) => (
                                                            <div key={i} className="flex items-center gap-2 text-xs">
                                                                <span className={`px-1.5 py-0.5 rounded ${
                                                                    f.action === 'created' ? 'bg-green-900/50 text-green-300' :
                                                                    f.action === 'deleted' ? 'bg-red-900/50 text-red-300' :
                                                                    'bg-blue-900/50 text-blue-300'
                                                                }`}>{f.action}</span>
                                                                <span className="text-slate-300 font-mono">{f.path}</span>
                                                            </div>
                                                        ))}
                                                    </div>
                                                </div>
                                            )}

                                            {/* Commits */}
                                            {job.commits?.length > 0 && (
                                                <div>
                                                    <h4 className="text-xs font-bold text-slate-400 mb-1">Commits ({job.commits.length})</h4>
                                                    <div className="space-y-1">
                                                        {job.commits.map((c, i) => (
                                                            <div key={i} className="text-xs flex items-center gap-2">
                                                                <span className="text-indigo-400 font-mono">{c.sha?.slice(0, 7)}</span>
                                                                <span className="text-slate-300">{c.message}</span>
                                                            </div>
                                                        ))}
                                                    </div>
                                                </div>
                                            )}

                                            {/* ODRC references */}
                                            {job.odrc && (
                                                <div>
                                                    <h4 className="text-xs font-bold text-slate-400 mb-1">ODRC References</h4>
                                                    {job.odrc.resolved_opens?.length > 0 && (
                                                        <div className="mb-2">
                                                            <span className="text-xs text-green-400">Resolved OPENs:</span>
                                                            <ul className="ml-4 text-xs text-slate-300 list-disc">{job.odrc.resolved_opens.map((o, i) => <li key={i}>{o}</li>)}</ul>
                                                        </div>
                                                    )}
                                                    {job.odrc.applied_decisions?.length > 0 && (
                                                        <div className="mb-2">
                                                            <span className="text-xs text-blue-400">Applied DECISIONs:</span>
                                                            <ul className="ml-4 text-xs text-slate-300 list-disc">{job.odrc.applied_decisions.map((d, i) => <li key={i}>{d}</li>)}</ul>
                                                        </div>
                                                    )}
                                                    {job.odrc.new_opens?.length > 0 && (
                                                        <div className="mb-2">
                                                            <span className="text-xs text-purple-400">New OPENs:</span>
                                                            <ul className="ml-4 text-xs text-slate-300 list-disc">{job.odrc.new_opens.map((o, i) => <li key={i}>{o}</li>)}</ul>
                                                        </div>
                                                    )}
                                                </div>
                                            )}

                                            {/* Unexpected findings */}
                                            {job.unexpectedFindings?.length > 0 && (
                                                <div>
                                                    <h4 className="text-xs font-bold text-slate-400 mb-1">Unexpected Findings</h4>
                                                    <ul className="ml-4 text-xs text-slate-300 list-disc">{job.unexpectedFindings.map((f, i) => <li key={i}>{f}</li>)}</ul>
                                                </div>
                                            )}

                                            {/* Unresolved */}
                                            {job.unresolved?.length > 0 && (
                                                <div>
                                                    <h4 className="text-xs font-bold text-slate-400 mb-1">Unresolved</h4>
                                                    {job.unresolved.map((u, i) => (
                                                        <div key={i} className="text-xs mb-1">
                                                            <span className="text-slate-300">{u.item}</span>
                                                            {u.reason && <span className="text-slate-500 ml-2">— {u.reason}</span>}
                                                        </div>
                                                    ))}
                                                </div>
                                            )}

                                            {/* Validation errors */}
                                            {job.validationErrors?.length > 0 && (
                                                <div className="bg-amber-900/20 border border-amber-700/50 rounded p-2">
                                                    <h4 className="text-xs font-bold text-amber-400 mb-1">Validation Warnings</h4>
                                                    <ul className="ml-4 text-xs text-amber-300 list-disc">{job.validationErrors.map((e, i) => <li key={i}>{e}</li>)}</ul>
                                                </div>
                                            )}

                                            {/* Check outcome (for checked jobs) */}
                                            {job.state === 'checked' && job.checkOutcome && (
                                                <div className="bg-slate-700/50 rounded p-2">
                                                    <h4 className="text-xs font-bold text-slate-400 mb-1">Check Outcome:
                                                        <span className={`ml-2 px-2 py-0.5 rounded ${OUTCOME_STYLES[job.checkOutcome] || ''}`}>{job.checkOutcome}</span>
                                                    </h4>
                                                    {job.checkNotes && <p className="text-xs text-slate-300 mt-1">{job.checkNotes}</p>}
                                                </div>
                                            )}
                                        </div>
                                    )}
                                </div>
                            );
                        })}
                    </div>
                )}

                {/* Phase 3: Orphan Commits Section */}
                {(globalOrphanCommits || []).length > 0 && (
                    <div className="mt-6">
                        <button onClick={() => setOrphanExpanded(!orphanExpanded)}
                            className="flex items-center gap-2 text-sm font-bold text-slate-300 hover:text-slate-100 mb-2">
                            <span className={`transform transition-transform text-xs ${orphanExpanded ? 'rotate-90' : ''}`}>▶</span>
                            📍 Orphaned Commits ({orphanStats.detected > 0 ? `${orphanStats.detected} active` : orphanStats.total})
                        </button>
                        {orphanExpanded && (
                            <div className="space-y-2">
                                {orphanStats.detected > 0 && (
                                    <div className="flex gap-2 mb-2">
                                        <button onClick={() => handleReconstructOrphans(globalOrphanCommits)}
                                            className="px-3 py-1 rounded text-xs bg-indigo-700 hover:bg-indigo-600">
                                            🔄 Reconstruct All ({orphanStats.detected})
                                        </button>
                                    </div>
                                )}
                                {(globalOrphanCommits || []).filter(o => o.state !== 'ignored').map(orphan => (
                                    <div key={orphan.id} className="bg-slate-800/50 border border-slate-700 rounded-lg p-3">
                                        <div className="flex items-center gap-2 mb-1">
                                            <span className={`px-2 py-0.5 rounded text-xs ${ORPHAN_STATE_STYLES[orphan.state] || ''}`}>{orphan.state}</span>
                                            <span className="text-indigo-400 font-mono text-xs">{orphan.commitSha?.slice(0, 7)}</span>
                                            <span className="text-xs text-slate-400">{orphan.repoFullName?.split('/').pop()}</span>
                                            <span className="text-xs text-slate-500">{new Date(orphan.commitDate).toLocaleDateString()}</span>
                                        </div>
                                        <p className="text-sm text-slate-200 mb-1">{orphan.commitMessage?.split('\n')[0] || 'No message'}</p>
                                        {orphan.filesChanged?.length > 0 && (
                                            <div className="text-xs text-slate-400 mb-2">{orphan.filesChanged.length} files changed</div>
                                        )}
                                        <div className="flex gap-2">
                                            {(orphan.state === 'detected' || orphan.state === 'dismissed') && (
                                                <>
                                                    <button onClick={() => handleReconstructOrphans([orphan])}
                                                        className="px-2 py-0.5 rounded text-xs bg-indigo-700 hover:bg-indigo-600">🔄 Reconstruct</button>
                                                    {orphan.state === 'detected' && (
                                                        <button onClick={() => dismissOrphan(orphan.id)}
                                                            className="px-2 py-0.5 rounded text-xs bg-slate-700 hover:bg-slate-600">Dismiss</button>
                                                    )}
                                                    <button onClick={() => ignoreOrphan(orphan.id)}
                                                        className="px-2 py-0.5 rounded text-xs bg-slate-800 hover:bg-slate-700 text-slate-500">Ignore</button>
                                                </>
                                            )}
                                        </div>
                                    </div>
                                ))}
                            </div>
                        )}
                    </div>
                )}

                {/* Bundle Assembly Modal */}
                {bundleModal && (
                    <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50" onClick={() => !bundleModal.active && setBundleModal(null)}>
                        <div data-testid="bundle-progress" className="bg-slate-800 border border-slate-600 rounded-lg p-6 max-w-lg w-full mx-4" onClick={e => e.stopPropagation()}>
                            <h3 className="text-lg font-bold mb-4 flex items-center gap-2">
                                📦 Bundle Assembly
                                {bundleModal.active && <span className="text-xs text-slate-400 animate-pulse">Processing...</span>}
                            </h3>
                            <div className="space-y-2 mb-4">
                                {bundleModal.steps.map(step => (
                                    <div key={step.key} className="flex items-center gap-2 text-sm">
                                        <span className="w-5 text-center">
                                            {step.status === 'pending' && <span className="text-slate-500">○</span>}
                                            {step.status === 'active' && <span className="text-blue-400 animate-spin inline-block">⟳</span>}
                                            {step.status === 'done' && <span className="text-green-400">✓</span>}
                                            {step.status === 'error' && <span className="text-red-400">✗</span>}
                                        </span>
                                        <span className={step.status === 'pending' ? 'text-slate-500' : step.status === 'error' ? 'text-red-300' : 'text-slate-200'}>
                                            {step.label}
                                        </span>
                                        {step.detail && <span className="text-xs text-slate-500 ml-auto truncate max-w-48">{step.detail}</span>}
                                    </div>
                                ))}
                            </div>
                            {bundleModal.errors.length > 0 && (
                                <div className="bg-amber-900/20 border border-amber-700/50 rounded p-2 mb-3">
                                    <h4 className="text-xs font-bold text-amber-400 mb-1">Warnings</h4>
                                    <ul className="ml-4 text-xs text-amber-300 list-disc">{bundleModal.errors.map((err, i) => <li key={i}>{err}</li>)}</ul>
                                </div>
                            )}
                            {bundleModal.excluded.length > 0 && (
                                <div className="bg-slate-700/50 border border-slate-600 rounded p-2 mb-3">
                                    <h4 className="text-xs font-bold text-slate-400 mb-1">Excluded Files (size limit)</h4>
                                    <ul className="ml-4 text-xs text-slate-400 list-disc">{bundleModal.excluded.map((ex, i) => <li key={i}>{ex.path} — {ex.reason}</li>)}</ul>
                                </div>
                            )}
                            {bundleModal.result && (
                                <div className="bg-green-900/20 border border-green-700/50 rounded p-3 mb-3">
                                    <p className="text-sm text-green-300 mb-2">
                                        Bundle ready: {(bundleModal.result.blob.size / 1024).toFixed(1)} KB
                                        ({bundleModal.result.manifest.filesIncluded.length} files included)
                                    </p>
                                    <button onClick={handleDownloadBundle}
                                        className="px-4 py-1.5 rounded text-sm bg-green-700 hover:bg-green-600 font-medium">
                                        ⬇️ Download Bundle
                                    </button>
                                </div>
                            )}
                            <div className="flex justify-end">
                                <button onClick={() => setBundleModal(null)}
                                    className="px-3 py-1.5 rounded text-sm bg-slate-700 hover:bg-slate-600">
                                    {bundleModal.active ? 'Cancel' : 'Close'}
                                </button>
                            </div>
                        </div>
                    </div>
                )}

                {/* Phase 3: ODRC Update Modal */}
                {odrcModal && (
                    <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50" onClick={() => setOdrcModal(null)}>
                        <div className="bg-slate-800 border border-slate-600 rounded-lg p-6 max-w-2xl w-full mx-4 max-h-[80vh] overflow-y-auto" onClick={e => e.stopPropagation()}>
                            <h3 className="text-lg font-bold mb-4">📥 Import ODRC Updates</h3>

                            {odrcModal.phase === 'input' && (
                                <div className="space-y-3">
                                    <p className="text-sm text-slate-400">Paste the structured ODRC Updates output from Chat below:</p>
                                    <textarea
                                        value={odrcModal.inputText}
                                        onChange={e => setOdrcModal(prev => ({ ...prev, inputText: e.target.value }))}
                                        placeholder={'## ODRC Updates\n- RESOLVE OPEN: "description" → matched to concept_id xyz\n- NEW OPEN: "description" → tag to Idea Name\n- NEW DECISION: "description"'}
                                        className="w-full bg-slate-900 border border-slate-600 rounded px-3 py-2 text-sm font-mono h-40 resize-y" />
                                    <div className="flex gap-2 justify-end">
                                        <button onClick={() => setOdrcModal(null)}
                                            className="px-3 py-1.5 rounded text-sm bg-slate-700 hover:bg-slate-600">Cancel</button>
                                        <button onClick={parseOdrcInput} disabled={!odrcModal.inputText.trim()}
                                            className="px-3 py-1.5 rounded text-sm bg-indigo-600 hover:bg-indigo-500 font-medium disabled:opacity-50">Parse Updates</button>
                                    </div>
                                </div>
                            )}

                            {odrcModal.phase === 'review' && (
                                <div className="space-y-3">
                                    <p className="text-sm text-slate-400">Found {odrcModal.parsedUpdates.length} updates. Select which to apply:</p>
                                    <div className="space-y-2 max-h-64 overflow-y-auto">
                                        {odrcModal.parsedUpdates.map((update, i) => (
                                            <div key={i} className="flex items-start gap-2 bg-slate-700/50 rounded p-2">
                                                <input type="checkbox" checked={odrcModal.confirmedIndexes.has(i)}
                                                    onChange={e => {
                                                        setOdrcModal(prev => {
                                                            const newSet = new Set(prev.confirmedIndexes);
                                                            e.target.checked ? newSet.add(i) : newSet.delete(i);
                                                            return { ...prev, confirmedIndexes: newSet };
                                                        });
                                                    }}
                                                    className="mt-1" />
                                                <div className="flex-1">
                                                    <div className="flex items-center gap-2 mb-1">
                                                        <span className="text-xs">{update.action === 'resolve' ? '✅' : '➕'}</span>
                                                        <span className={`px-1.5 py-0.5 rounded text-xs ${
                                                            update.type === 'OPEN' ? 'bg-purple-900/50 text-purple-300' :
                                                            update.type === 'DECISION' ? 'bg-blue-900/50 text-blue-300' :
                                                            update.type === 'RULE' ? 'bg-green-900/50 text-green-300' :
                                                            'bg-amber-900/50 text-amber-300'
                                                        }`}>{update.type}</span>
                                                        <span className="text-xs text-slate-400">{update.action === 'resolve' ? 'Resolve' : 'Create'}</span>
                                                    </div>
                                                    <p className="text-sm text-slate-200">{update.description}</p>
                                                    {update.action === 'resolve' && update.conceptId && (
                                                        <p className="text-xs text-slate-400 mt-1">Target: concept {update.conceptId}</p>
                                                    )}
                                                    {update.action === 'create' && (
                                                        <div className="flex items-center gap-2 mt-1">
                                                            <span className="text-xs text-slate-500">Tag to:</span>
                                                            <select className="bg-slate-800 border border-slate-600 rounded px-1 py-0.5 text-xs"
                                                                value={update.overrideIdeaId || update.targetIdea || ''}
                                                                onChange={e => {
                                                                    setOdrcModal(prev => {
                                                                        const newUpdates = [...prev.parsedUpdates];
                                                                        newUpdates[i] = { ...newUpdates[i], overrideIdeaId: e.target.value || null };
                                                                        return { ...prev, parsedUpdates: newUpdates };
                                                                    });
                                                                }}>
                                                                <option value="">Untagged</option>
                                                                {(globalIdeas || []).filter(idea => idea.status === 'active').map(idea => (
                                                                    <option key={idea.id} value={idea.id}>{idea.name}</option>
                                                                ))}
                                                            </select>
                                                        </div>
                                                    )}
                                                </div>
                                            </div>
                                        ))}
                                    </div>
                                    <div className="flex gap-2 justify-end">
                                        <button onClick={() => setOdrcModal(prev => ({ ...prev, phase: 'input' }))}
                                            className="px-3 py-1.5 rounded text-sm bg-slate-700 hover:bg-slate-600">Back</button>
                                        <button onClick={executeOdrcUpdates} disabled={odrcModal.confirmedIndexes.size === 0}
                                            className="px-3 py-1.5 rounded text-sm bg-green-600 hover:bg-green-500 font-medium disabled:opacity-50">
                                            Apply {odrcModal.confirmedIndexes.size} Updates
                                        </button>
                                    </div>
                                </div>
                            )}

                            {odrcModal.phase === 'done' && odrcModal.results && (
                                <div className="space-y-3">
                                    <p className="text-sm text-slate-400">Results:</p>
                                    <div className="space-y-1">
                                        {odrcModal.results.map((r, i) => (
                                            <div key={i} className="flex items-center gap-2 text-sm">
                                                <span>{r.status === 'success' ? '✅' : '❌'}</span>
                                                <span className="text-slate-200">{r.action === 'resolve' ? 'Resolved' : 'Created'} {r.type}: {r.description}</span>
                                                {r.error && <span className="text-red-400 text-xs">({r.error})</span>}
                                            </div>
                                        ))}
                                    </div>
                                    <div className="flex justify-end">
                                        <button onClick={() => setOdrcModal(null)}
                                            className="px-3 py-1.5 rounded text-sm bg-slate-700 hover:bg-slate-600">Close</button>
                                    </div>
                                </div>
                            )}
                        </div>
                    </div>
                )}

                {/* Phase 3: Batch Classification Modal */}
                {batchModal && (
                    <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50" onClick={() => batchModal.phase !== 'assembling' && setBatchModal(null)}>
                        <div className="bg-slate-800 border border-slate-600 rounded-lg p-6 max-w-lg w-full mx-4 max-h-[80vh] overflow-y-auto" onClick={e => e.stopPropagation()}>
                            <h3 className="text-lg font-bold mb-4">📦 Batch Classification</h3>

                            {batchModal.phase === 'select' && (
                                <div className="space-y-3">
                                    <p className="text-sm text-slate-400">Select unclassified jobs to package ({batchModal.selectedIds.size} selected):</p>
                                    <div className="space-y-1 max-h-48 overflow-y-auto">
                                        {batchModal.jobs.map(job => (
                                            <div key={job.id} className="flex items-center gap-2 bg-slate-700/50 rounded p-2">
                                                <input type="checkbox" checked={batchModal.selectedIds.has(job.id)}
                                                    onChange={e => {
                                                        setBatchModal(prev => {
                                                            const newSet = new Set(prev.selectedIds);
                                                            e.target.checked ? newSet.add(job.id) : newSet.delete(job.id);
                                                            return { ...prev, selectedIds: newSet };
                                                        });
                                                    }} />
                                                <div className="flex-1">
                                                    <p className="text-sm text-slate-200">{job.task || job.fileName}</p>
                                                    <p className="text-xs text-slate-400">{job.repoFullName?.split('/').pop()} · {job.files?.length || 0} files</p>
                                                </div>
                                            </div>
                                        ))}
                                    </div>
                                    <div className="flex gap-2 justify-end">
                                        <button onClick={() => setBatchModal(null)}
                                            className="px-3 py-1.5 rounded text-sm bg-slate-700 hover:bg-slate-600">Cancel</button>
                                        <button onClick={executeBatchClassification} disabled={batchModal.selectedIds.size === 0}
                                            className="px-3 py-1.5 rounded text-sm bg-amber-600 hover:bg-amber-500 font-medium disabled:opacity-50">
                                            Package {batchModal.selectedIds.size} Jobs
                                        </button>
                                    </div>
                                </div>
                            )}

                            {batchModal.phase === 'assembling' && (
                                <div className="space-y-2 mb-4">
                                    {batchModal.steps.map(step => (
                                        <div key={step.key} className="flex items-center gap-2 text-sm">
                                            <span className="w-5 text-center">
                                                {step.status === 'pending' && <span className="text-slate-500">○</span>}
                                                {step.status === 'active' && <span className="text-blue-400 animate-spin inline-block">⟳</span>}
                                                {step.status === 'done' && <span className="text-green-400">✓</span>}
                                            </span>
                                            <span className={step.status === 'pending' ? 'text-slate-500' : 'text-slate-200'}>{step.label}</span>
                                        </div>
                                    ))}
                                </div>
                            )}

                            {batchModal.phase === 'done' && (
                                <div className="space-y-3">
                                    {batchModal.errors.length > 0 && (
                                        <div className="bg-amber-900/20 border border-amber-700/50 rounded p-2">
                                            <h4 className="text-xs font-bold text-amber-400 mb-1">Warnings</h4>
                                            <ul className="ml-4 text-xs text-amber-300 list-disc">{batchModal.errors.map((e, i) => <li key={i}>{e}</li>)}</ul>
                                        </div>
                                    )}
                                    {batchModal.result && (
                                        <div className="bg-green-900/20 border border-green-700/50 rounded p-3">
                                            <p className="text-sm text-green-300 mb-2">
                                                Bundle ready: {(batchModal.result.blob.size / 1024).toFixed(1)} KB
                                                ({batchModal.result.manifest.jobCount} jobs)
                                            </p>
                                            <button onClick={handleDownloadBatchBundle}
                                                className="px-4 py-1.5 rounded text-sm bg-green-700 hover:bg-green-600 font-medium">
                                                ⬇️ Download Bundle
                                            </button>
                                        </div>
                                    )}
                                    <div className="flex justify-end">
                                        <button onClick={() => setBatchModal(null)}
                                            className="px-3 py-1.5 rounded text-sm bg-slate-700 hover:bg-slate-600">Close</button>
                                    </div>
                                </div>
                            )}
                        </div>
                    </div>
                )}
            </div>
        );
    }

    // =========================================================================
    // RELEASE COORDINATION VIEW — Phase 4.4 + 4.5
    // Answers: "Is this version ready to ship?"
    // Shows completion %, blocked items, go/no-go summary, test checklists
    // =========================================================================
    // WorkStreamsView — Named, owned, parallel tracks of work (Phase 5.2)
    // =========================================================================
    
    
    // StreamEditModal — Create/edit work streams
    

    // =========================================================================
    // CONFIG VIEW (v7.0.0) - Dynamic Environment & App Configuration
    // =========================================================================
    
    function ConfigView({ config, onConfigChange, showAlert, showConfirm, github, availableRepos, onRefreshRepos }) {
        const [activeTab, setActiveTab] = React.useState('environments');
        const [editingApp, setEditingApp] = React.useState(null);
        const [newAppForm, setNewAppForm] = React.useState(null);
        const [creatingRepo, setCreatingRepo] = React.useState(null); // { appId, env }
        const [repoCreationStatus, setRepoCreationStatus] = React.useState({});
        
        // Internal tools that don't need DEV/BETA repos
        const internalTools = ['testplan', 'command-center'];
        const gameApps = Object.values(config.apps).filter(app => !internalTools.includes(app.id));
        
        // Get GitHub username from available repos
        const githubOwner = availableRepos[0]?.owner || 'stewartdavidp-ship-it';
        
        const updateConfig = (newConfig) => {
            onConfigChange(newConfig);
        };
        
        // Environment Management
        const toggleEnv = (envId) => {
            const newConfig = ConfigManager.toggleEnvironment({ ...config }, envId);
            updateConfig(newConfig);
        };
        
        // App Management
        const saveApp = (appData) => {
            let newConfig = { ...config, apps: { ...config.apps } };
            if (editingApp) {
                newConfig = ConfigManager.updateApp(newConfig, editingApp.id, appData);
            } else {
                newConfig = ConfigManager.addApp(newConfig, appData);
            }
            updateConfig(newConfig);
            setEditingApp(null);
            setNewAppForm(null);
        };
        
        const deleteApp = async (appId) => {
            const confirmed = await showConfirm(`Delete "${config.apps[appId]?.name}"? This cannot be undone.`, 'Delete App');
            if (confirmed) {
                const newConfig = ConfigManager.removeApp({ ...config, apps: { ...config.apps } }, appId);
                updateConfig(newConfig);
            }
        };
        
        // Create a new repository for an app environment
        const createRepoForApp = async (appId, env) => {
            if (!github) {
                await showAlert('Configure GitHub token first', 'GitHub Required');
                return;
            }
            
            const app = config.apps[appId];
            if (!app) return;
            
            // Generate repo name based on patterns
            const repoPatterns = app.repoPatterns[env] || [];
            const suggestedName = repoPatterns[0] || `${appId}${env}`;
            
            // Check if repo already exists
            const exists = await github.repoExists(githubOwner, suggestedName);
            if (exists) {
                const useExisting = await showConfirm(
                    `Repository "${suggestedName}" already exists.\n\nAssign it to ${app.name} ${env.toUpperCase()}?`,
                    'Repository Exists'
                );
                if (useExisting) {
                    // Update config with existing repo
                    const newConfig = { ...config, apps: { ...config.apps } };
                    newConfig.apps[appId] = {
                        ...newConfig.apps[appId],
                        repos: { ...newConfig.apps[appId].repos, [env]: `${githubOwner}/${suggestedName}` }
                    };
                    updateConfig(newConfig);
                    setRepoCreationStatus(prev => ({ ...prev, [`${appId}-${env}`]: 'assigned' }));
                }
                return;
            }
            
            // Confirm creation
            const confirmed = await showConfirm(
                `Create new repository?\n\n` +
                `Name: ${suggestedName}\n` +
                `For: ${app.name} (${env.toUpperCase()})\n` +
                `URL: https://${githubOwner}.github.io/${suggestedName}/\n\n` +
                `This will create a public repo with GitHub Pages enabled.`,
                `Create ${env.toUpperCase()} Repository`
            );
            
            if (!confirmed) return;
            
            setCreatingRepo({ appId, env });
            setRepoCreationStatus(prev => ({ ...prev, [`${appId}-${env}`]: 'creating' }));
            
            try {
                // Create the repository
                const description = `${app.name} - ${env.toUpperCase()} environment`;
                const result = await github.createRepo(suggestedName, description, false);
                
                setRepoCreationStatus(prev => ({ ...prev, [`${appId}-${env}`]: 'enabling-pages' }));
                
                // Wait a moment for GitHub to initialize the repo
                await new Promise(r => setTimeout(r, 2000));
                
                // Enable GitHub Pages
                try {
                    await github.enablePages(result.fullName);
                } catch (e) {
                    console.log('Pages may need manual enabling:', e);
                }
                
                // Update config with new repo
                const newConfig = { ...config, apps: { ...config.apps } };
                newConfig.apps[appId] = {
                    ...newConfig.apps[appId],
                    repos: { ...newConfig.apps[appId].repos, [env]: result.fullName }
                };
                updateConfig(newConfig);
                
                // Refresh repo list
                if (onRefreshRepos) onRefreshRepos();
                
                setRepoCreationStatus(prev => ({ ...prev, [`${appId}-${env}`]: 'complete' }));
                await showAlert(
                    `Repository created successfully!\n\n` +
                    `${result.fullName}\n` +
                    `${result.pagesUrl}`,
                    '✅ Repository Created'
                );
                
            } catch (error) {
                console.error('Failed to create repo:', error);
                setRepoCreationStatus(prev => ({ ...prev, [`${appId}-${env}`]: 'error' }));
                await showAlert(`Failed to create repository: ${error.message}`, 'Error');
            } finally {
                setCreatingRepo(null);
            }
        };
        
        // Get repo status for an app/env
        const getRepoStatus = (appId, env) => {
            const app = config.apps[appId];
            const repo = app?.repos?.[env];
            const statusKey = `${appId}-${env}`;
            
            if (repoCreationStatus[statusKey]) {
                return repoCreationStatus[statusKey];
            }
            if (repo) {
                return 'configured';
            }
            return 'not-created';
        };
        
        const envColors = config.environments.colors;
        const activeEnvs = config.environments.active;
        
        return (
            <div className="space-y-6">
                <div className="flex items-center justify-between">
                    <h2 className="text-xl font-bold flex items-center gap-2">
                        ⚙️ Configuration
                    </h2>
                    <div className="text-xs text-slate-500">Config v{config.version}</div>
                </div>
                
                {/* Tab Navigation */}
                <div className="flex gap-2 border-b border-slate-700 pb-2">
                    {[
                        { id: 'environments', label: '🌍 Environments' },
                        { id: 'repos', label: '🗄️ Repositories' },
                        { id: 'detection', label: '🔍 Detection' }
                    ].map(tab => (
                        <button
                            key={tab.id}
                            onClick={() => setActiveTab(tab.id)}
                            className={`px-4 py-2 rounded-t-lg font-medium transition-colors ${
                                activeTab === tab.id 
                                    ? 'bg-slate-700 text-white' 
                                    : 'text-slate-400 hover:text-white hover:bg-slate-800'
                            }`}
                        >
                            {tab.label}
                        </button>
                    ))}
                </div>
                
                {/* Environments Tab */}
                {activeTab === 'environments' && (
                    <div className="space-y-6">
                        <div className="bg-slate-800 rounded-xl p-6 border border-slate-700">
                            <h3 className="font-semibold mb-4">Deployment Tiers</h3>
                            <p className="text-sm text-slate-400 mb-4">
                                Enable the environments you use. Files deploy through active tiers in order.
                            </p>
                            
                            <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
                                {config.environments.available.map(env => {
                                    const isActive = activeEnvs.includes(env);
                                    const colors = envColors[env];
                                    return (
                                        <button
                                            key={env}
                                            onClick={() => toggleEnv(env)}
                                            className={`p-4 rounded-xl border-2 transition-all ${
                                                isActive 
                                                    ? `${colors.bg} ${colors.border} text-white` 
                                                    : 'bg-slate-900 border-slate-600 text-slate-400 hover:border-slate-500'
                                            }`}
                                        >
                                            <div className="text-2xl mb-2">
                                                {config.environments.icons[env]}
                                            </div>
                                            <div className="font-bold uppercase">{config.environments.labels[env]}</div>
                                            <div className="text-xs mt-1 opacity-75">
                                                {isActive ? '✓ Active' : 'Disabled'}
                                            </div>
                                        </button>
                                    );
                                })}
                            </div>
                            
                            <div className="mt-6 p-4 bg-slate-900 rounded-lg">
                                <div className="text-sm font-medium mb-2">Current Flow:</div>
                                <div className="flex items-center gap-2 flex-wrap">
                                    {activeEnvs.map((env, idx) => (
                                        <React.Fragment key={env}>
                                            <span className={`px-3 py-1 rounded-full text-sm font-medium ${envColors[env].bg}`}>
                                                {config.environments.labels[env]}
                                            </span>
                                            {idx < activeEnvs.length - 1 && (
                                                <span className="text-slate-500">→</span>
                                            )}
                                        </React.Fragment>
                                    ))}
                                </div>
                            </div>
                        </div>
                        
                        <div className="bg-amber-900/30 border border-amber-700 rounded-xl p-4">
                            <div className="flex items-start gap-3">
                                <Icons.AlertTriangle className="text-amber-400 mt-0.5" />
                                <div>
                                    <div className="font-medium text-amber-300">Environment Changes</div>
                                    <div className="text-sm text-slate-300 mt-1">
                                        Adding DEV creates a rapid-build tier before TEST. Adding BETA creates a feature-flag tier after PROD.
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                )}
                
                {/* Repositories Tab */}
                {activeTab === 'repos' && (
                    <div className="space-y-6">
                        <div className="bg-slate-800 rounded-xl p-6 border border-slate-700">
                            <h3 className="font-semibold mb-2">Repository Management</h3>
                            <p className="text-sm text-slate-400 mb-4">
                                Create and manage GitHub repositories for each app environment. 
                                DEV is for rapid iteration, BETA is for feature-flagged production testing.
                            </p>
                            
                            {!github && (
                                <div className="bg-amber-900/30 border border-amber-700 rounded-lg p-4 mb-4">
                                    <div className="text-amber-300 font-medium">⚠️ GitHub Token Required</div>
                                    <div className="text-sm text-slate-300 mt-1">
                                        Configure your GitHub token in Settings to create repositories.
                                    </div>
                                </div>
                            )}
                            
                            <div className="space-y-4">
                                {gameApps.map(app => (
                                    <div key={app.id} className="bg-slate-900 rounded-xl p-4 border border-slate-700">
                                        <div className="flex items-center gap-3 mb-4">
                                            <AppIcon icon={app.icon} size={28} />
                                            <div>
                                                <div className="font-semibold">{app.name}</div>
                                                <div className="text-xs text-slate-400">
                                                    {app.hasServiceWorker ? 'PWA' : 'Web App'}
                                                </div>
                                            </div>
                                        </div>
                                        
                                        <div className="grid grid-cols-2 md:grid-cols-4 gap-3">
                                            {['dev', 'test', 'prod', 'beta'].map(env => {
                                                const isActive = activeEnvs.includes(env);
                                                const repo = app.repos?.[env];
                                                const status = getRepoStatus(app.id, env);
                                                const colors = envColors[env];
                                                const isCreating = creatingRepo?.appId === app.id && creatingRepo?.env === env;
                                                
                                                return (
                                                    <div 
                                                        key={env} 
                                                        className={`p-3 rounded-lg border ${
                                                            isActive ? colors.border : 'border-slate-700 opacity-50'
                                                        } ${isActive ? 'bg-slate-800' : 'bg-slate-900'}`}
                                                    >
                                                        <div className={`text-xs font-medium mb-2 ${isActive ? colors.text : 'text-slate-500'}`}>
                                                            {config.environments.labels[env]}
                                                            {!isActive && ' (disabled)'}
                                                        </div>
                                                        
                                                        {repo ? (
                                                            <div>
                                                                <div className="text-xs font-mono text-green-400 truncate" title={repo}>
                                                                    ✓ {repo.split('/')[1]}
                                                                </div>
                                                                <a 
                                                                    href={`https://github.com/${repo}`}
                                                                    target="_blank"
                                                                    className="text-xs text-slate-400 hover:text-white"
                                                                >
                                                                    View →
                                                                </a>
                                                            </div>
                                                        ) : isActive ? (
                                                            <button
                                                                onClick={() => createRepoForApp(app.id, env)}
                                                                disabled={!github || isCreating}
                                                                className={`w-full px-2 py-1.5 rounded text-xs font-medium transition-colors ${
                                                                    isCreating 
                                                                        ? 'bg-slate-700 text-slate-400 cursor-wait'
                                                                        : github
                                                                            ? `${colors.bg} hover:opacity-90 text-white`
                                                                            : 'bg-slate-700 text-slate-500 cursor-not-allowed'
                                                                }`}
                                                            >
                                                                {isCreating ? (
                                                                    status === 'enabling-pages' ? '⏳ Enabling Pages...' : '⏳ Creating...'
                                                                ) : (
                                                                    <>+ Create Repo</>
                                                                )}
                                                            </button>
                                                        ) : (
                                                            <div className="text-xs text-slate-500 italic">
                                                                Enable {env.toUpperCase()} first
                                                            </div>
                                                        )}
                                                    </div>
                                                );
                                            })}
                                        </div>
                                    </div>
                                ))}
                            </div>
                        </div>
                        
                        <div className="bg-slate-800 rounded-xl p-6 border border-slate-700">
                            <h3 className="font-semibold mb-2">Internal Tools</h3>
                            <p className="text-sm text-slate-400 mb-4">
                                These tools only use TEST and PROD environments.
                            </p>
                            
                            <div className="space-y-3">
                                {Object.values(config.apps)
                                    .filter(app => internalTools.includes(app.id))
                                    .map(app => (
                                        <div key={app.id} className="flex items-center justify-between p-3 bg-slate-900 rounded-lg">
                                            <div className="flex items-center gap-3">
                                                <AppIcon icon={app.icon} size={24} />
                                                <span className="font-medium">{app.name}</span>
                                            </div>
                                            <div className="flex gap-2">
                                                {['test', 'prod'].map(env => {
                                                    const repo = app.repos?.[env];
                                                    return repo ? (
                                                        <span key={env} className="text-xs px-2 py-1 bg-slate-800 rounded text-slate-400">
                                                            {env.toUpperCase()}: {repo.split('/')[1]}
                                                        </span>
                                                    ) : (
                                                        <span key={env} className="text-xs px-2 py-1 bg-slate-800 rounded text-slate-500">
                                                            {env.toUpperCase()}: —
                                                        </span>
                                                    );
                                                })}
                                            </div>
                                        </div>
                                    ))}
                            </div>
                        </div>
                    </div>
                )}
                
                {/* Detection Tab */}
                {activeTab === 'detection' && (
                    <div className="space-y-4">
                        <div className="bg-slate-800 rounded-xl p-6 border border-slate-700">
                            <h3 className="font-semibold mb-2">Content Detection Patterns</h3>
                            <p className="text-sm text-slate-400 mb-4">
                                Regex patterns (case-insensitive) used to auto-detect which app a file belongs to.
                            </p>
                            
                            <div className="space-y-4">
                                {Object.values(config.apps).map(app => (
                                    <div key={app.id} className="p-4 bg-slate-900 rounded-lg">
                                        <div className="flex items-center gap-2 mb-2">
                                            <AppIcon icon={app.icon} size={20} />
                                            <span className="font-medium">{app.name}</span>
                                        </div>
                                        <div className="flex flex-wrap gap-2">
                                            {app.detectionPatterns.map((pattern, idx) => (
                                                <code key={idx} className="px-2 py-1 bg-slate-800 rounded text-xs text-green-400">
                                                    {pattern}
                                                </code>
                                            ))}
                                        </div>
                                    </div>
                                ))}
                            </div>
                        </div>
                        
                        <div className="bg-slate-800 rounded-xl p-6 border border-slate-700">
                            <h3 className="font-semibold mb-2">Repo Name Patterns</h3>
                            <p className="text-sm text-slate-400 mb-4">
                                Patterns for auto-suggesting apps based on GitHub repo names.
                            </p>
                            
                            <div className="overflow-x-auto">
                                <table className="w-full text-sm">
                                    <thead>
                                        <tr className="text-left text-slate-400 border-b border-slate-700">
                                            <th className="pb-2 pr-4">App</th>
                                            {activeEnvs.map(env => (
                                                <th key={env} className={`pb-2 pr-4 ${envColors[env].text}`}>
                                                    {config.environments.labels[env]}
                                                </th>
                                            ))}
                                        </tr>
                                    </thead>
                                    <tbody>
                                        {Object.values(config.apps).map(app => (
                                            <tr key={app.id} className="border-b border-slate-800">
                                                <td className="py-2 pr-4 font-medium">
                                                    <span className="flex items-center gap-2">
                                                        <AppIcon icon={app.icon} size={16} />
                                                        {app.name}
                                                    </span>
                                                </td>
                                                {activeEnvs.map(env => (
                                                    <td key={env} className="py-2 pr-4">
                                                        <div className="flex flex-wrap gap-1">
                                                            {(app.repoPatterns[env] || []).map((p, i) => (
                                                                <code key={i} className="px-1 bg-slate-800 rounded text-xs">
                                                                    {p}
                                                                </code>
                                                            ))}
                                                        </div>
                                                    </td>
                                                ))}
                                            </tr>
                                        ))}
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                )}
            </div>
        );
    }
    
    // App Edit Modal Component
    function AppEditModal({ app, isNew, environments, envLabels, projects, availableRepos, allApps, onSave, onCancel }) {
        const [form, setForm] = React.useState({
            id: app.id || '',
            name: app.name || '',
            icon: app.icon || '📦',
            project: app.project || 'other',
            subPath: app.subPath || '',
            targetPath: app.targetPath || 'index.html',
            swPath: app.swPath || '',
            hasServiceWorker: app.hasServiceWorker || false,
            repos: app.repos || {},
            detectionPatterns: (app.detectionPatterns || []).join('\n'),
            repoPatterns: Object.fromEntries(
                environments.map(env => [env, (app.repoPatterns?.[env] || []).join(', ')])
            ),
            // v8.20.0: Lifecycle fields
            lifecycle: {
                category: app.lifecycle?.category || null,
                currentMaturity: app.lifecycle?.currentMaturity || null,
                maturityTarget: app.lifecycle?.maturityTarget || null,
                problemStatement: app.lifecycle?.problemStatement || '',
                targetAudience: app.lifecycle?.targetAudience || '',
                userGoal: app.lifecycle?.userGoal || '',
                successMetric: app.lifecycle?.successMetric || ''
            }
        });
        
        const [activeTab, setActiveTab] = React.useState('general'); // 'general' or 'lifecycle'
        const [repoMode, setRepoMode] = React.useState('dropdown'); // 'dropdown' or 'manual'
        const [patternsManuallyEdited, setPatternsManuallyEdited] = React.useState(!isNew);
        const [showEmojiPicker, setShowEmojiPicker] = React.useState(false);
        
        // Common emoji options for apps grouped by category
        const emojiOptions = [
            { label: 'Tools', emojis: ['🔧', '🛠️', '⚙️', '🔨', '🪛', '🏗️', '🔩'] },
            { label: 'Games', emojis: ['🎮', '🎲', '🃏', '♟️', '🎯', '🏆', '🎪'] },
            { label: 'Objects', emojis: ['📦', '📋', '📊', '📁', '💾', '🗂️', '📝'] },
            { label: 'Symbols', emojis: ['🚀', '⚡', '🔥', '💡', '🧪', '🎨', '🌟'] },
            { label: 'Combo', emojis: ['🪜🔧', '🪜🛠️', '🏗️🪜', '⚙️🪜'] }
        ];
        
        // Generate detection patterns from app name
        const generatePatterns = (name) => {
            if (!name.trim()) return '';
            const trimmed = name.trim();
            const lower = trimmed.toLowerCase();
            const noSpaces = trimmed.replace(/\s+/g, '');
            const kebab = lower.replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, '');
            const underscored = lower.replace(/[^a-z0-9]+/g, '_').toUpperCase();
            
            const patterns = new Set();
            patterns.add(`<title>${trimmed}`);
            if (kebab !== lower) patterns.add(kebab);
            if (noSpaces !== trimmed) patterns.add(noSpaces);
            patterns.add(underscored);
            return [...patterns].join('\n');
        };
        
        // Handle name changes - auto-generate ID and detection patterns
        const handleNameChange = (newName) => {
            const updates = { name: newName };
            
            // Auto-generate ID for new apps
            if (isNew) {
                updates.id = newName.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, '');
            }
            
            // Auto-generate detection patterns for new apps (unless manually edited)
            if (isNew && !patternsManuallyEdited) {
                updates.detectionPatterns = generatePatterns(newName);
            }
            
            setForm(prev => ({ ...prev, ...updates }));
        };
        
        // Build list of repos already assigned to other apps (for context)
        const assignedRepos = React.useMemo(() => {
            const map = {};
            if (allApps) {
                Object.values(allApps).forEach(a => {
                    if (a.id === app.id) return; // skip current app
                    environments.forEach(env => {
                        const repo = a.repos?.[env];
                        if (repo) {
                            if (!map[repo]) map[repo] = [];
                            map[repo].push(`${a.name} ${envLabels[env]}`);
                        }
                    });
                });
            }
            return map;
        }, [allApps, app.id, environments, envLabels]);
        
        // Group repos: shared repos (used by multiple apps via subPath) vs dedicated
        const repoOptions = React.useMemo(() => {
            if (!availableRepos?.length) return [];
            return availableRepos.map(r => ({
                ...r,
                assignedTo: assignedRepos[r.fullName] || [],
                isShared: (assignedRepos[r.fullName] || []).length > 0
            })).sort((a, b) => {
                // Sort: shared repos first (likely candidates for subPath apps), then alpha
                if (a.isShared && !b.isShared) return -1;
                if (!a.isShared && b.isShared) return 1;
                return a.name.localeCompare(b.name);
            });
        }, [availableRepos, assignedRepos]);
        
        const handleSave = () => {
            const effectiveId = form.id || form.name.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, '');
            
            // Build repo patterns from selected repos
            const repoPatterns = {};
            environments.forEach(env => {
                if (repoMode === 'dropdown') {
                    // In dropdown mode, derive patterns from selected repo
                    const selectedRepo = form.repos[env];
                    if (selectedRepo) {
                        const repoName = selectedRepo.split('/').pop();
                        repoPatterns[env] = [repoName];
                    } else {
                        repoPatterns[env] = [];
                    }
                } else {
                    // Manual mode - parse comma-separated
                    repoPatterns[env] = form.repoPatterns[env]?.split(',').map(s => s.trim()).filter(Boolean) || [];
                }
            });
            
            const data = {
                ...form,
                id: effectiveId,
                detectionPatterns: form.detectionPatterns.split('\n').filter(p => p.trim()),
                repoPatterns,
                // v8.20.0: Include lifecycle data
                lifecycle: form.lifecycle
            };
            onSave(data);
        };
        
        return (
            <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
                <div className="bg-slate-800 rounded-xl border border-slate-600 w-full max-w-2xl max-h-[90vh] overflow-y-auto">
                    <div className="p-6 border-b border-slate-700">
                        <h3 className="text-lg font-bold">{isNew ? 'Add New App' : `Edit ${app.name}`}</h3>
                        {/* v8.20.0: Tab navigation */}
                        <div className="flex gap-1 mt-3">
                            <button 
                                onClick={() => setActiveTab('general')}
                                className={`px-3 py-1.5 rounded text-sm font-medium ${activeTab === 'general' ? 'bg-indigo-600 text-white' : 'bg-slate-700 text-slate-300 hover:bg-slate-600'}`}
                            >
                                ⚙️ General
                            </button>
                            <button 
                                onClick={() => setActiveTab('lifecycle')}
                                className={`px-3 py-1.5 rounded text-sm font-medium ${activeTab === 'lifecycle' ? 'bg-indigo-600 text-white' : 'bg-slate-700 text-slate-300 hover:bg-slate-600'}`}
                            >
                                📊 Lifecycle
                            </button>
                        </div>
                    </div>
                    
                    {activeTab === 'general' && <div className="p-6 space-y-4">
                        <div className="grid grid-cols-2 gap-4">
                            <div>
                                <label className="block text-sm font-medium mb-1">App Name</label>
                                <input 
                                    type="text"
                                    value={form.name}
                                    onChange={e => handleNameChange(e.target.value)}
                                    className="w-full p-2 bg-slate-900 border border-slate-600 rounded"
                                    placeholder="My App"
                                />
                            </div>
                            <div>
                                <label className="block text-sm font-medium mb-1">Icon (emoji)</label>
                                <div className="relative">
                                    <div className="flex gap-2">
                                        <input 
                                            type="text"
                                            value={form.icon}
                                            onChange={e => setForm({ ...form, icon: e.target.value })}
                                            className="w-full p-2 bg-slate-900 border border-slate-600 rounded"
                                        />
                                        <button 
                                            type="button"
                                            onClick={() => setShowEmojiPicker(!showEmojiPicker)}
                                            className={`px-3 py-2 rounded border text-sm whitespace-nowrap ${showEmojiPicker ? 'bg-indigo-600 border-indigo-500 text-white' : 'bg-slate-700 border-slate-600 hover:bg-slate-600 text-slate-300'}`}
                                        >
                                            😀 Pick
                                        </button>
                                    </div>
                                    {showEmojiPicker && (
                                        <div className="absolute right-0 top-full mt-1 bg-slate-800 border border-slate-600 rounded-lg shadow-xl z-50 p-3 w-72">
                                            {emojiOptions.map(group => (
                                                <div key={group.label} className="mb-2">
                                                    <div className="text-xs text-slate-500 mb-1">{group.label}</div>
                                                    <div className="flex flex-wrap gap-1">
                                                        {group.emojis.map(emoji => (
                                                            <button
                                                                key={emoji}
                                                                type="button"
                                                                onClick={() => { setForm({ ...form, icon: emoji }); setShowEmojiPicker(false); }}
                                                                className={`w-9 h-9 rounded hover:bg-slate-700 text-lg flex items-center justify-center ${form.icon === emoji ? 'bg-indigo-600/30 ring-1 ring-indigo-500' : ''}`}
                                                            >
                                                                {emoji}
                                                            </button>
                                                        ))}
                                                    </div>
                                                </div>
                                            ))}
                                        </div>
                                    )}
                                </div>
                            </div>
                        </div>
                        <div>
                            <label className="block text-sm font-medium mb-1">Project</label>
                            <select value={form.project} onChange={e => setForm({ ...form, project: e.target.value })}
                                className="w-full p-2 bg-slate-900 border border-slate-600 rounded">
                                {Object.values(projects || SEED_PROJECTS).sort((a, b) => (a.order || 99) - (b.order || 99)).map(p => (
                                    <option key={p.id} value={p.id}>{p.icon === 'gs-logo' ? '🎮' : p.icon} {p.name}</option>
                                ))}
                            </select>
                        </div>
                        
                        <div>
                            <label className="block text-sm font-medium mb-1">Sub Path</label>
                            <input 
                                type="text"
                                value={form.subPath}
                                onChange={e => setForm({ ...form, subPath: e.target.value })}
                                className="w-full p-2 bg-slate-900 border border-slate-600 rounded font-mono text-sm"
                                placeholder="e.g. rungs, rungs/builder (leave empty for repo root)"
                            />
                            <div className="text-xs text-slate-500 mt-1">Directory within the repo where app files live. Supports nested paths.</div>
                        </div>
                        
                        <div className="grid grid-cols-2 gap-4">
                            <div>
                                <label className="block text-sm font-medium mb-1">Target Path</label>
                                <input 
                                    type="text"
                                    value={form.targetPath}
                                    onChange={e => setForm({ ...form, targetPath: e.target.value })}
                                    className="w-full p-2 bg-slate-900 border border-slate-600 rounded"
                                    placeholder="index.html"
                                />
                            </div>
                            <div>
                                <label className="block text-sm font-medium mb-1">Service Worker Path</label>
                                <input 
                                    type="text"
                                    value={form.swPath}
                                    onChange={e => setForm({ ...form, swPath: e.target.value })}
                                    className="w-full p-2 bg-slate-900 border border-slate-600 rounded"
                                    placeholder="sw.js (leave empty if none)"
                                />
                            </div>
                        </div>
                        
                        <div>
                            <label className="flex items-center gap-2">
                                <input 
                                    type="checkbox"
                                    checked={form.hasServiceWorker}
                                    onChange={e => setForm({ ...form, hasServiceWorker: e.target.checked })}
                                    className="rounded"
                                />
                                <span className="text-sm">Has Service Worker (PWA)</span>
                            </label>
                        </div>
                        
                        <div>
                            <label className="block text-sm font-medium mb-1">
                                Detection Patterns (one per line, regex)
                                {isNew && !patternsManuallyEdited && form.name.trim() && (
                                    <span className="text-xs text-indigo-400 ml-2">✨ auto-generated from name</span>
                                )}
                            </label>
                            <textarea 
                                value={form.detectionPatterns}
                                onChange={e => { setPatternsManuallyEdited(true); setForm({ ...form, detectionPatterns: e.target.value }); }}
                                className="w-full p-2 bg-slate-900 border border-slate-600 rounded font-mono text-sm"
                                rows={4}
                                placeholder="<title>my app&#10;myapp-container"
                            />
                        </div>
                        
                        {/* Repository Assignment */}
                        <div>
                            <div className="flex items-center justify-between mb-2">
                                <label className="block text-sm font-medium">Repository Assignment</label>
                                <button 
                                    onClick={() => setRepoMode(repoMode === 'dropdown' ? 'manual' : 'dropdown')}
                                    className="text-xs text-indigo-400 hover:text-indigo-300"
                                >
                                    {repoMode === 'dropdown' ? '✏️ Manual entry' : '📋 Select from repos'}
                                </button>
                            </div>
                            
                            {repoMode === 'dropdown' ? (
                                <div className="grid grid-cols-2 gap-3">
                                    {environments.map(env => (
                                        <div key={env}>
                                            <label className="block text-xs text-slate-400 mb-1">{envLabels[env]}</label>
                                            <select
                                                value={form.repos[env] || ''}
                                                onChange={e => setForm({
                                                    ...form,
                                                    repos: { ...form.repos, [env]: e.target.value },
                                                    repoPatterns: { 
                                                        ...form.repoPatterns, 
                                                        [env]: e.target.value ? e.target.value.split('/').pop() : '' 
                                                    }
                                                })}
                                                className="w-full p-2 bg-slate-900 border border-slate-600 rounded text-sm"
                                            >
                                                <option value="">— None —</option>
                                                {repoOptions.length > 0 && (() => {
                                                    const shared = repoOptions.filter(r => r.isShared);
                                                    const unassigned = repoOptions.filter(r => !r.isShared);
                                                    return (
                                                        <>
                                                            {shared.length > 0 && (
                                                                <optgroup label="Shared Repos (used by other apps)">
                                                                    {shared.map(r => (
                                                                        <option key={r.fullName} value={r.fullName}>
                                                                            {r.name} — {r.assignedTo.join(', ')}
                                                                        </option>
                                                                    ))}
                                                                </optgroup>
                                                            )}
                                                            {unassigned.length > 0 && (
                                                                <optgroup label="Available Repos">
                                                                    {unassigned.map(r => (
                                                                        <option key={r.fullName} value={r.fullName}>{r.name}</option>
                                                                    ))}
                                                                </optgroup>
                                                            )}
                                                        </>
                                                    );
                                                })()}
                                            </select>
                                            {form.repos[env] && form.subPath && (
                                                <div className="text-xs text-slate-500 mt-1 font-mono">
                                                    → {form.subPath}/{form.targetPath || 'index.html'}
                                                </div>
                                            )}
                                        </div>
                                    ))}
                                </div>
                            ) : (
                                <div>
                                    <div className="text-xs text-slate-500 mb-2">Enter repo name patterns for auto-mapping (comma-separated)</div>
                                    <div className="grid grid-cols-2 gap-3">
                                        {environments.map(env => (
                                            <div key={env}>
                                                <label className="block text-xs text-slate-400 mb-1">{envLabels[env]}</label>
                                                <input 
                                                    type="text"
                                                    value={form.repoPatterns[env] || ''}
                                                    onChange={e => setForm({ 
                                                        ...form, 
                                                        repoPatterns: { ...form.repoPatterns, [env]: e.target.value }
                                                    })}
                                                    className="w-full p-2 bg-slate-900 border border-slate-600 rounded text-sm"
                                                    placeholder={`myapp-${env}, myapp${env}`}
                                                />
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            )}
                        </div>
                    </div>}
                    
                    {/* v8.20.0: Lifecycle Tab */}
                    {activeTab === 'lifecycle' && <div className="p-6 space-y-4">
                        <div className="grid grid-cols-2 gap-4">
                            <div>
                                <label className="block text-sm font-medium mb-1">Category</label>
                                <select
                                    value={form.lifecycle.category || ''}
                                    onChange={e => setForm({ ...form, lifecycle: { ...form.lifecycle, category: e.target.value || null }})}
                                    className="w-full p-2 bg-slate-900 border border-slate-600 rounded"
                                >
                                    <option value="">Not set</option>
                                    <option value="game">🎮 Game</option>
                                    <option value="tool">🔧 Tool</option>
                                    <option value="dashboard">📊 Dashboard</option>
                                    <option value="content">📄 Content</option>
                                    <option value="admin">⚙️ Admin</option>
                                </select>
                            </div>
                            <div>
                                <label className="block text-sm font-medium mb-1">Current Maturity</label>
                                <select
                                    value={form.lifecycle.currentMaturity || ''}
                                    onChange={e => setForm({ ...form, lifecycle: { ...form.lifecycle, currentMaturity: e.target.value || null }})}
                                    className="w-full p-2 bg-slate-900 border border-slate-600 rounded"
                                >
                                    <option value="">Not set</option>
                                    <option value="prototype">🧪 Prototype</option>
                                    <option value="alpha">🔬 Alpha</option>
                                    <option value="beta">🔧 Beta</option>
                                    <option value="production">🚀 Production</option>
                                </select>
                            </div>
                        </div>
                        
                        <div>
                            <label className="block text-sm font-medium mb-1">Maturity Target</label>
                            <select
                                value={form.lifecycle.maturityTarget || ''}
                                onChange={e => setForm({ ...form, lifecycle: { ...form.lifecycle, maturityTarget: e.target.value || null }})}
                                className="w-full p-2 bg-slate-900 border border-slate-600 rounded"
                            >
                                <option value="">Not set</option>
                                <option value="prototype">🧪 Prototype</option>
                                <option value="alpha">🔬 Alpha</option>
                                <option value="beta">🔧 Beta</option>
                                <option value="production">🚀 Production</option>
                            </select>
                        </div>
                        
                        <div>
                            <label className="block text-sm font-medium mb-1">Problem Statement</label>
                            <textarea
                                value={form.lifecycle.problemStatement}
                                onChange={e => setForm({ ...form, lifecycle: { ...form.lifecycle, problemStatement: e.target.value }})}
                                className="w-full p-2 bg-slate-900 border border-slate-600 rounded text-sm"
                                rows="2"
                                placeholder="What problem does this app solve?"
                            />
                        </div>
                        
                        <div className="grid grid-cols-2 gap-4">
                            <div>
                                <label className="block text-sm font-medium mb-1">Target Audience</label>
                                <input
                                    type="text"
                                    value={form.lifecycle.targetAudience}
                                    onChange={e => setForm({ ...form, lifecycle: { ...form.lifecycle, targetAudience: e.target.value }})}
                                    className="w-full p-2 bg-slate-900 border border-slate-600 rounded text-sm"
                                    placeholder="Who is this for?"
                                />
                            </div>
                            <div>
                                <label className="block text-sm font-medium mb-1">User Goal</label>
                                <input
                                    type="text"
                                    value={form.lifecycle.userGoal}
                                    onChange={e => setForm({ ...form, lifecycle: { ...form.lifecycle, userGoal: e.target.value }})}
                                    className="w-full p-2 bg-slate-900 border border-slate-600 rounded text-sm"
                                    placeholder="What should users accomplish?"
                                />
                            </div>
                        </div>
                        
                        <div>
                            <label className="block text-sm font-medium mb-1">Success Metric</label>
                            <input
                                type="text"
                                value={form.lifecycle.successMetric}
                                onChange={e => setForm({ ...form, lifecycle: { ...form.lifecycle, successMetric: e.target.value }})}
                                className="w-full p-2 bg-slate-900 border border-slate-600 rounded text-sm"
                                placeholder="How do we measure success?"
                            />
                        </div>
                        
                        {form.lifecycle.currentMaturity && form.lifecycle.maturityTarget && (
                            <div className="bg-slate-900/50 rounded-lg p-3 border border-slate-700">
                                <div className="text-sm font-medium mb-2">Maturity Progress</div>
                                <div className="flex items-center gap-2 text-sm">
                                    {['prototype', 'alpha', 'beta', 'production'].map((m, i) => {
                                        const milestones = ['prototype', 'alpha', 'beta', 'production'];
                                        const currentIdx = milestones.indexOf(form.lifecycle.currentMaturity);
                                        const targetIdx = milestones.indexOf(form.lifecycle.maturityTarget);
                                        const icons = { prototype: '🧪', alpha: '🔬', beta: '🔧', production: '🚀' };
                                        const isComplete = i <= currentIdx;
                                        const isCurrent = i === currentIdx;
                                        const isTarget = i === targetIdx;
                                        const isInRange = i <= targetIdx;
                                        return React.createElement(React.Fragment, { key: m },
                                            i > 0 && React.createElement('div', { className: `flex-1 h-0.5 ${isComplete ? 'bg-emerald-500' : isInRange ? 'bg-slate-600' : 'bg-slate-800'}` }),
                                            React.createElement('div', { 
                                                className: `flex flex-col items-center ${isComplete ? 'text-emerald-400' : isInRange ? 'text-slate-400' : 'text-slate-600'}`,
                                                title: m.charAt(0).toUpperCase() + m.slice(1)
                                            },
                                                React.createElement('span', { className: 'text-base' }, icons[m]),
                                                React.createElement('span', { className: `text-xs mt-0.5 ${isCurrent ? 'font-bold underline' : ''} ${isTarget ? 'font-bold' : ''}` }, 
                                                    m.charAt(0).toUpperCase() + m.slice(1).substring(0, 4) + (isTarget ? ' ★' : '')
                                                )
                                            )
                                        );
                                    })}
                                </div>
                            </div>
                        )}
                    </div>}
                    
                    <div className="p-6 border-t border-slate-700 flex justify-end gap-3">
                        <button 
                            onClick={onCancel}
                            className="px-4 py-2 bg-slate-700 hover:bg-slate-600 rounded"
                        >
                            Cancel
                        </button>
                        <button 
                            onClick={handleSave}
                            className="px-4 py-2 bg-indigo-600 hover:bg-indigo-500 rounded"
                        >
                            {isNew ? 'Add App' : 'Save Changes'}
                        </button>
                    </div>
                </div>
            </div>
        );
    }

    // =========================================================================
    // PROJECTS TAB (v8.8.0) — Replaces Apps tab in Configure
    // =========================================================================
    function ProjectsTab({ config, updateConfig, activeEnvs, envColors, github, githubOwner, availableRepos, showAlert, showConfirm, showPrompt, onRefreshRepos, deployments, globalWorkItems, firebaseUid, globalStreams }) {
        const [expandedProject, setExpandedProject] = React.useState(null);
        const [editingApp, setEditingApp] = React.useState(null);
        const [editingProject, setEditingProject] = React.useState(null);
        const [newProjectForm, setNewProjectForm] = React.useState(null);
        const [newAppForm, setNewAppForm] = React.useState(null);
        const [prepApp, setPrepApp] = React.useState(null);

        
        const formatDate = (ts) => {
            if (!ts) return '—';
            const d = new Date(ts);
            return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
        };
        
        // Save project (create or update)
        const saveProject = (projectData) => {
            let newConfig = { ...config, projects: { ...(config.projects || {}) } };
            if (editingProject) {
                newConfig = ConfigManager.updateProject(newConfig, editingProject.id, projectData);
            } else {
                newConfig = ConfigManager.addProject(newConfig, projectData);
            }
            updateConfig(newConfig);
            setEditingProject(null);
            setNewProjectForm(null);
        };
        
        // Delete project
        const deleteProject = async (projectId) => {
            const appCount = ConfigManager.getProjectAppCount(config, projectId);
            const msg = appCount > 0 
                ? `Delete "${config.projects[projectId]?.name}"? Its ${appCount} app${appCount !== 1 ? 's' : ''} will be moved to Other.`
                : `Delete "${config.projects[projectId]?.name}"?`;
            const confirmed = await showConfirm(msg, 'Delete Project');
            if (!confirmed) return;
            const newConfig = ConfigManager.removeProject({ ...config, projects: { ...config.projects }, apps: { ...config.apps } }, projectId);
            updateConfig(newConfig);
            setEditingProject(null);
        };
        
        // Build project data with computed attributes
        const projectsData = React.useMemo(() => {
            const projectDefs = config.projects || SEED_PROJECTS;
            const projectMap = {};
            
            // First, create entries for all defined projects (even those with no apps yet)
            Object.values(projectDefs).forEach(projDef => {
                projectMap[projDef.id] = {
                    ...projDef,
                    state: projDef.state || 'active',
                    apps: [],
                    allRepos: new Set(),
                    createdAt: null,
                    updatedAt: null
                };
            });
            
            // Then assign apps to their projects
            Object.values(config.apps).forEach(app => {
                const projId = app.project || 'other';
                if (!projectMap[projId]) {
                    // App references a project not in config — show it under 'other'
                    if (!projectMap['other']) {
                        const otherDef = projectDefs['other'] || { id: 'other', name: 'Other', icon: '📦', color: 'slate', order: 99 };
                        projectMap['other'] = { ...otherDef, state: 'active', apps: [], allRepos: new Set(), createdAt: null, updatedAt: null };
                    }
                    projectMap['other'].apps.push(app);
                } else {
                    projectMap[projId].apps.push(app);
                }
                const p = projectMap[projId] || projectMap['other'];
                // Collect repos
                Object.values(app.repos || {}).forEach(r => { if (r) p.allRepos.add(r); });
                // Track dates from app versions
                if (app.createdAt && (!p.createdAt || app.createdAt < p.createdAt)) p.createdAt = app.createdAt;
                if (app.updatedAt && (!p.updatedAt || app.updatedAt > p.updatedAt)) p.updatedAt = app.updatedAt;
            });
            
            return Object.values(projectMap)
                .sort((a, b) => (a.order || 99) - (b.order || 99))
                .map(p => {
                    // Determine deployment structure
                    const hasTest = p.apps.some(a => a.repos?.test);
                    const repoArr = [...p.allRepos];
                    const structure = repoArr.length <= 1 ? 'single' : hasTest ? 'dual' : 'multi';
                    return { ...p, allRepos: repoArr, structure };
                });
        }, [config.apps, config.projects]);
        
        // Get deployment structure label
        const getStructureLabel = (s) => {
            if (s === 'single') return { label: 'Single Repo', icon: '📦', color: 'text-slate-400' };
            if (s === 'dual') return { label: 'Dual Repo (Test → Prod)', icon: '🔀', color: 'text-blue-400' };
            return { label: 'Multi Repo', icon: '🗂️', color: 'text-purple-400' };
        };
        
        // Get app deployment structure
        const getAppStructure = (app) => {
            if (app.repos?.test && app.repos?.prod) return 'dual';
            return 'single';
        };
        
        // Save app edits
        const saveApp = (appData) => {
            const newConfig = { ...config, apps: { ...config.apps } };
            const id = appData.id || appData.name.toLowerCase().replace(/\s+/g, '-');
            newConfig.apps[id] = {
                ...(config.apps[id] || {}),
                ...appData,
                id,
                detectionPatterns: typeof appData.detectionPatterns === 'string' 
                    ? appData.detectionPatterns.split('\n').filter(p => p.trim()) 
                    : (appData.detectionPatterns || []),
                repoPatterns: typeof appData.repoPatterns === 'object' && !Array.isArray(appData.repoPatterns)
                    ? Object.fromEntries(Object.entries(appData.repoPatterns).map(([k, v]) => [k, typeof v === 'string' ? v.split(',').map(s => s.trim()).filter(Boolean) : v]))
                    : (appData.repoPatterns || {}),
                updatedAt: Date.now(),
                createdAt: config.apps[id]?.createdAt || Date.now()
            };
            updateConfig(newConfig);
            setEditingApp(null);
            setNewAppForm(null);
        };
        
        const deleteApp = async (appId) => {
            const confirmed = await showConfirm(`Delete ${config.apps[appId]?.name || appId}?`, 'Delete App');
            if (!confirmed) return;
            const newConfig = { ...config, apps: { ...config.apps } };
            delete newConfig.apps[appId];
            updateConfig(newConfig);
        };
        
        // Toggle project state
        const toggleProjectState = (projId) => {
            const newConfig = { ...config, projects: { ...config.projects } };
            if (newConfig.projects[projId]) {
                newConfig.projects[projId] = { ...newConfig.projects[projId], state: newConfig.projects[projId].state === 'hidden' ? 'active' : 'hidden' };
                updateConfig(newConfig);
            }
        };
        
        
        // Stats
        const totalApps = Object.keys(config.apps).length;
        const totalProjects = projectsData.length;
        
        return (
            <div className="space-y-4">
                {/* Header */}
                <div className="flex justify-between items-center">
                    <div className="text-sm text-slate-400">
                        {totalProjects} project{totalProjects !== 1 ? 's' : ''} · {totalApps} app{totalApps !== 1 ? 's' : ''}
                    </div>
                    <div className="flex gap-2">
                        <button onClick={() => setNewProjectForm(true)}
                            className="flex items-center gap-2 px-4 py-2 bg-slate-700 hover:bg-slate-600 rounded-lg text-sm">
                            <Icons.Plus /> New Project
                        </button>
                        <button onClick={() => setNewAppForm({ name: '', icon: '📦', targetPath: 'index.html', project: 'other' })}
                            className="flex items-center gap-2 px-4 py-2 bg-indigo-600 hover:bg-indigo-500 rounded-lg text-sm">
                            <Icons.Plus /> Add App
                        </button>
                    </div>
                </div>
                
                {/* Project Cards */}
                {projectsData.map(proj => {
                    const colors = getProjectColor(proj.color);
                    const structInfo = getStructureLabel(proj.structure);
                    const isExpanded = expandedProject === proj.id;
                    const projState = proj.state || 'active';
                    const isHidden = projState === 'hidden';
                    
                    return (
                        <div key={proj.id} className={`rounded-xl border overflow-hidden transition-all ${isHidden ? 'border-slate-700/50 opacity-60' : colors.border}`}>
                            {/* Project Header */}
                            <div className={`p-4 cursor-pointer transition-colors ${isExpanded ? colors.bg : 'hover:bg-white/5'}`}
                                onClick={() => setExpandedProject(isExpanded ? null : proj.id)}>
                                <div className="flex items-center gap-3">
                                    <span className={`transform transition-transform text-sm ${isExpanded ? 'rotate-90' : ''}`}>▶</span>
                                    <AppIcon icon={proj.icon} size={28} />
                                    <div className="flex-1 min-w-0">
                                        <div className="flex items-center gap-2">
                                            <span className={`font-semibold ${colors.text}`}>{proj.name}</span>
                                            <span className={`text-xs px-2 py-0.5 rounded-full ${isHidden ? 'bg-slate-700 text-slate-500' : 'bg-slate-700/50 text-slate-400'}`}>
                                                {projState}
                                            </span>
                                        </div>
                                        {proj.description && <div className="text-xs text-slate-500 mt-0.5">{proj.description}</div>}
                                    </div>
                                    
                                    {/* Compact attributes */}
                                    <div className="flex items-center gap-3 text-xs text-slate-400">
                                        <div className="flex items-center gap-1" title="Deployment Structure">
                                            <span>{structInfo.icon}</span>
                                            <span className={structInfo.color}>{structInfo.label}</span>
                                        </div>
                                        <span className="text-slate-600">|</span>
                                        <span>{proj.apps.length} app{proj.apps.length !== 1 ? 's' : ''}</span>
                                        <span className="text-slate-600">|</span>
                                        <span>{proj.allRepos.length} repo{proj.allRepos.length !== 1 ? 's' : ''}</span>
                                    </div>
                                    
                                    {/* Edit project button */}
                                    <button onClick={(e) => { e.stopPropagation(); setEditingProject(proj); }}
                                        className="p-1.5 rounded hover:bg-white/10 text-slate-500 hover:text-slate-300 transition-colors"
                                        title="Edit project">
                                        ✏️
                                    </button>
                                </div>
                            </div>
                            
                            {/* Expanded Project Detail */}
                            {isExpanded && (
                                <div className="border-t border-slate-700/50">
                                    {/* Project Attributes */}
                                    <div className="p-4 bg-slate-800/50 grid grid-cols-2 md:grid-cols-5 gap-4 text-xs">
                                        <div>
                                            <div className="text-slate-500 uppercase tracking-wide mb-1">State</div>
                                            <button onClick={(e) => { e.stopPropagation(); toggleProjectState(proj.id); }}
                                                className={`px-2 py-1 rounded text-xs font-medium ${isHidden ? 'bg-slate-700 text-slate-400 hover:bg-slate-600' : 'bg-green-900/30 text-green-400 hover:bg-green-900/50'}`}>
                                                {projState === 'hidden' ? '👁️ Show' : '🟢 Active'}
                                            </button>
                                        </div>
                                        <div>
                                            <div className="text-slate-500 uppercase tracking-wide mb-1">Structure</div>
                                            <div className={`font-medium ${structInfo.color}`}>{structInfo.icon} {structInfo.label}</div>
                                        </div>
                                        <div>
                                            <div className="text-slate-500 uppercase tracking-wide mb-1">Repositories</div>
                                            <div className="space-y-0.5">
                                                {proj.allRepos.length > 0 ? proj.allRepos.map(r => (
                                                    <div key={r} className="font-mono text-slate-300 truncate">{r.split('/')[1]}</div>
                                                )) : <span className="text-slate-500 italic">None assigned</span>}
                                            </div>
                                        </div>
                                        <div>
                                            <div className="text-slate-500 uppercase tracking-wide mb-1">Created</div>
                                            <div className="text-slate-300">{formatDate(proj.createdAt)}</div>
                                        </div>
                                        <div>
                                            <div className="text-slate-500 uppercase tracking-wide mb-1">Last Updated</div>
                                            <div className="text-slate-300">{formatDate(proj.updatedAt)}</div>
                                        </div>
                                    </div>
                                    
                                    {/* Apps Table */}
                                    <div className="p-4">
                                        <div className="flex items-center justify-between mb-3">
                                            <div className="text-sm font-semibold text-slate-300">Apps ({proj.apps.length})</div>
                                            <button onClick={() => setNewAppForm({ name: '', icon: '📦', targetPath: 'index.html', project: proj.id })}
                                                className="text-xs px-3 py-1 bg-slate-700 hover:bg-slate-600 rounded flex items-center gap-1">
                                                <Icons.Plus className="w-3 h-3" /> Add App to {proj.name}
                                            </button>
                                        </div>
                                        
                                        {/* Table Header */}
                                        <div className="grid grid-cols-12 gap-2 px-3 py-2 text-xs text-slate-500 uppercase tracking-wide border-b border-slate-700">
                                            <div className="col-span-3">App</div>
                                            <div className="col-span-1">Structure</div>
                                            <div className="col-span-3">Repos</div>
                                            <div className="col-span-2">Version</div>
                                            <div className="col-span-1">Created</div>
                                            <div className="col-span-1">Updated</div>
                                            <div className="col-span-1"></div>
                                        </div>
                                        
                                        {/* App Rows */}
                                        {proj.apps.sort((a, b) => a.name.localeCompare(b.name)).map(app => {
                                            const appStruct = getAppStructure(app);
                                            const appStructInfo = getStructureLabel(appStruct);
                                            const latestVersion = app.versions?.prod || app.versions?.test || '';
                                            const testVersion = app.versions?.test || '';
                                            const prodVersion = app.versions?.prod || '';
                                            
                                            return (
                                                <div key={app.id} className="grid grid-cols-12 gap-2 px-3 py-3 text-sm border-b border-slate-800 hover:bg-slate-800/50 items-center">
                                                    {/* App Name */}
                                                    <div className="col-span-3 flex items-center gap-2 min-w-0">
                                                        <AppIcon icon={app.icon} size={20} />
                                                        <div className="min-w-0">
                                                            <div className="font-medium truncate">{app.name}</div>
                                                            <div className="text-xs text-slate-500 flex items-center gap-1">
                                                                {app.hasServiceWorker && <span className="text-purple-400" title="PWA">📱</span>}
                                                                {app.appType === 'internal' && <span className="text-amber-400" title="Internal">🔒</span>}
                                                                <span className="font-mono">{app.targetPath}</span>
                                                                {app.subPath && <span className="text-slate-600">/{app.subPath}/</span>}
                                                            </div>
                                                        </div>
                                                    </div>
                                                    
                                                    {/* Structure */}
                                                    <div className="col-span-1">
                                                        <span className={`text-xs ${appStructInfo.color}`}>
                                                            {appStructInfo.icon} {appStruct === 'dual' ? 'Dual' : 'Single'}
                                                        </span>
                                                    </div>
                                                    
                                                    {/* Repos */}
                                                    <div className="col-span-3 text-xs font-mono min-w-0 space-y-0.5">
                                                        {app.repos?.test && (
                                                            <div className="flex items-center gap-1 truncate">
                                                                <span className="text-blue-400 w-8 shrink-0">TEST</span>
                                                                <span className="text-slate-400 truncate">{app.repos.test.split('/')[1]}</span>
                                                            </div>
                                                        )}
                                                        {app.repos?.prod && (
                                                            <div className="flex items-center gap-1 truncate">
                                                                <span className="text-green-400 w-8 shrink-0">PROD</span>
                                                                <span className="text-slate-400 truncate">{app.repos.prod.split('/')[1]}</span>
                                                            </div>
                                                        )}
                                                        {!app.repos?.test && !app.repos?.prod && <span className="text-slate-600 italic">No repos</span>}
                                                    </div>
                                                    
                                                    {/* Versions */}
                                                    <div className="col-span-2 text-xs space-y-0.5">
                                                        {testVersion && (
                                                            <div className="flex items-center gap-1">
                                                                <span className="bg-blue-900/40 text-blue-300 px-1.5 py-0.5 rounded">T: v{testVersion}</span>
                                                            </div>
                                                        )}
                                                        {prodVersion && (
                                                            <div className="flex items-center gap-1">
                                                                <span className="bg-green-900/40 text-green-300 px-1.5 py-0.5 rounded">P: v{prodVersion}</span>
                                                            </div>
                                                        )}
                                                        {!testVersion && !prodVersion && <span className="text-slate-600">—</span>}
                                                    </div>
                                                    
                                                    {/* Created */}
                                                    <div className="col-span-1 text-xs text-slate-500">
                                                        {formatDate(app.createdAt)}
                                                    </div>
                                                    
                                                    {/* Updated */}
                                                    <div className="col-span-1 text-xs text-slate-400">
                                                        {formatDate(app.updatedAt)}
                                                    </div>
                                                    
                                                    {/* Actions */}
                                                    <div className="col-span-1 flex gap-1 justify-end">
                                                        <button onClick={() => window.open(getSatelliteUrl(null, 'analytics'), '_blank')}
                                                            className="p-1.5 text-slate-500 hover:text-blue-400 hover:bg-slate-700 rounded" title="Product Brief (Analytics satellite)">
                                                            📄
                                                        </button>
                                                        <button onClick={() => setPrepApp(app)}
                                                            className="p-1.5 text-slate-500 hover:text-purple-400 hover:bg-slate-700 rounded" title="Claude Prep">
                                                            🤖
                                                        </button>
                                                        <button onClick={() => setEditingApp(app)}
                                                            className="p-1.5 text-slate-500 hover:text-white hover:bg-slate-700 rounded" title="Edit">
                                                            <Icons.Edit className="w-3.5 h-3.5" />
                                                        </button>
                                                        <button onClick={() => deleteApp(app.id)}
                                                            className="p-1.5 text-slate-500 hover:text-red-400 hover:bg-slate-700 rounded" title="Delete">
                                                            <Icons.Trash className="w-3.5 h-3.5" />
                                                        </button>
                                                    </div>
                                                </div>
                                            );
                                        })}
                                    </div>
                                </div>
                            )}
                        </div>
                    );
                })}
                
                {/* Add/Edit App Modal */}
                {(newAppForm || editingApp) && (
                    <AppEditModal 
                        app={editingApp || newAppForm}
                        isNew={!editingApp}
                        environments={activeEnvs}
                        envLabels={config.environments.labels}
                        projects={config.projects}
                        availableRepos={availableRepos}
                        allApps={config.apps}
                        onSave={saveApp}
                        onCancel={() => { setEditingApp(null); setNewAppForm(null); }}
                    />
                )}
                
                {/* Add/Edit Project Modal */}
                {(newProjectForm || editingProject) && (
                    <ProjectEditModal
                        project={editingProject || null}
                        isNew={!editingProject}
                        appCount={editingProject ? ConfigManager.getProjectAppCount(config, editingProject.id) : 0}
                        onSave={saveProject}
                        onDelete={deleteProject}
                        onCancel={() => { setEditingProject(null); setNewProjectForm(null); }}
                    />
                )}
                
                {/* Claude Prep Modal */}
                {prepApp && (
                    <ClaudePrepModal
                        app={prepApp}
                        config={config}
                        github={github}
                        githubOwner={githubOwner}
                        deployments={deployments || []}
                        onClose={() => setPrepApp(null)}
                        showAlert={showAlert}
                        showPrompt={showPrompt}
                        globalWorkItems={globalWorkItems}
                        firebaseUid={firebaseUid}
                        globalStreams={globalStreams}
                    />
                )}
                
            </div>
        );
    }

    // (ProductBriefModal extracted to Analytics satellite)

    // =========================================================================
    // PROJECT EDIT MODAL (v8.12.0)
    // =========================================================================
    function ProjectEditModal({ project, isNew, onSave, onDelete, onCancel, appCount }) {
        const [form, setForm] = React.useState({
            id: project?.id || '',
            name: project?.name || '',
            icon: project?.icon || '📦',
            color: project?.color || 'slate',
            description: project?.description || '',
            order: project?.order ?? 50
        });
        
        const [autoId, setAutoId] = React.useState(isNew);
        
        // Auto-generate ID from name for new projects
        React.useEffect(() => {
            if (autoId && isNew) {
                setForm(prev => ({ ...prev, id: prev.name.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, '') }));
            }
        }, [form.name, autoId, isNew]);
        
        const handleSave = () => {
            if (!form.name.trim()) return;
            if (!form.id.trim()) return;
            const { _showPicker, ...saveData } = form;
            onSave({
                ...saveData,
                order: parseInt(form.order) || 50
            });
        };
        
        const colorKeys = Object.keys(PROJECT_COLORS);
        const isOther = project?.id === 'other';
        
        return (
            <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50" onClick={onCancel}>
                <div className="bg-slate-800 rounded-xl border border-slate-600 p-6 w-full max-w-lg" onClick={e => e.stopPropagation()}>
                    <h3 className="text-lg font-semibold mb-4">{isNew ? '✨ New Project' : `Edit ${project.name}`}</h3>
                    
                    <div className="space-y-4">
                        {/* Name */}
                        <div>
                            <label className="block text-sm font-medium mb-1">Project Name</label>
                            <input type="text" value={form.name}
                                onChange={e => setForm({ ...form, name: e.target.value })}
                                className="w-full p-2 bg-slate-900 border border-slate-600 rounded focus:border-indigo-500 focus:outline-none"
                                placeholder="My Project" autoFocus />
                        </div>
                        
                        {/* ID */}
                        <div>
                            <label className="block text-sm font-medium mb-1">
                                Project ID
                                {isNew && <span className="text-xs text-slate-500 ml-2">(auto-generated from name)</span>}
                            </label>
                            <input type="text" value={form.id}
                                onChange={e => { setForm({ ...form, id: e.target.value }); setAutoId(false); }}
                                disabled={!isNew}
                                className={`w-full p-2 bg-slate-900 border border-slate-600 rounded font-mono text-sm ${!isNew ? 'opacity-60' : 'focus:border-indigo-500 focus:outline-none'}`}
                                placeholder="my-project" />
                        </div>
                        
                        {/* Icon + Order */}
                        <div className="grid grid-cols-2 gap-4">
                            <div>
                                <label className="block text-sm font-medium mb-1">Icon</label>
                                <div className="flex gap-2">
                                    <input type="text" value={form.icon}
                                        onChange={e => setForm({ ...form, icon: e.target.value })}
                                        className="flex-1 p-2 bg-slate-900 border border-slate-600 rounded focus:border-indigo-500 focus:outline-none"
                                        placeholder="📦 or gs-logo" />
                                    <button type="button" onClick={() => setForm(prev => ({ ...prev, _showPicker: !prev._showPicker }))}
                                        className="px-3 py-2 bg-slate-700 hover:bg-slate-600 rounded text-sm">
                                        😀 Pick
                                    </button>
                                </div>
                                {form._showPicker && (
                                    <div className="mt-2 p-2 bg-slate-900 border border-slate-600 rounded-lg max-h-36 overflow-y-auto">
                                        <div className="flex flex-wrap gap-1">
                                            {['📦','📋','📊','📁','💾','🗂️','📝','🎮','🎲','🃏','♟️','🎯','🏆','🎪','🔧','🛠️','⚙️','🔨','🪛','🏗️','🔩','🚀','⚡','🔥','💡','🧪','🎨','🌟','🪜','💻','📱','🖥️','⌨️','🖱️','💿','📡','🔌','🔋','📸','🎵','🎬','📚','✏️','🖊️','📌','🗃️','📈','📉','🧮','🔬','🔭','💰','🏦','🛒','🏠','🌍','✈️','🚗','⛵','🎓','🏥','⚖️','🎛️','🤖','👾','🕹️','🧩','🪄','✨'].map(emoji => (
                                                <button key={emoji} type="button"
                                                    onClick={() => setForm(prev => ({ ...prev, icon: emoji, _showPicker: false }))}
                                                    className={`w-8 h-8 flex items-center justify-center rounded hover:bg-slate-700 text-lg ${form.icon === emoji ? 'bg-indigo-600 ring-1 ring-indigo-400' : ''}`}>
                                                    {emoji}
                                                </button>
                                            ))}
                                        </div>
                                    </div>
                                )}
                                <div className="text-xs text-slate-500 mt-1">Emoji or "gs-logo" for Game Shelf icon</div>
                            </div>
                            <div>
                                <label className="block text-sm font-medium mb-1">Sort Order</label>
                                <input type="number" value={form.order}
                                    onChange={e => setForm({ ...form, order: e.target.value })}
                                    className="w-full p-2 bg-slate-900 border border-slate-600 rounded focus:border-indigo-500 focus:outline-none"
                                    min="1" max="99" />
                            </div>
                        </div>
                        
                        {/* Color Picker */}
                        <div>
                            <label className="block text-sm font-medium mb-2">Color Theme</label>
                            <div className="flex gap-2 flex-wrap">
                                {colorKeys.map(c => {
                                    const colors = PROJECT_COLORS[c];
                                    return (
                                        <button key={c}
                                            onClick={() => setForm({ ...form, color: c })}
                                            className={`px-3 py-1.5 rounded-lg text-sm capitalize transition-all ${colors.bg} ${colors.text} border ${form.color === c ? `${colors.border} ring-2 ring-offset-1 ring-offset-slate-800 ring-${c}-500` : 'border-transparent hover:border-slate-600'}`}>
                                            {c}
                                        </button>
                                    );
                                })}
                            </div>
                        </div>
                        
                        {/* Description */}
                        <div>
                            <label className="block text-sm font-medium mb-1">Description</label>
                            <input type="text" value={form.description}
                                onChange={e => setForm({ ...form, description: e.target.value })}
                                className="w-full p-2 bg-slate-900 border border-slate-600 rounded focus:border-indigo-500 focus:outline-none"
                                placeholder="What this project is about" />
                        </div>
                    </div>
                    
                    {/* Actions */}
                    <div className="flex justify-between mt-6">
                        <div>
                            {!isNew && !isOther && onDelete && (
                                <button onClick={() => onDelete(project.id)}
                                    className="px-4 py-2 text-red-400 hover:bg-red-900/30 rounded-lg text-sm">
                                    🗑️ Delete {appCount > 0 ? `(${appCount} app${appCount !== 1 ? 's' : ''} → Other)` : ''}
                                </button>
                            )}
                        </div>
                        <div className="flex gap-2">
                            <button onClick={onCancel} className="px-4 py-2 bg-slate-700 hover:bg-slate-600 rounded-lg text-sm">Cancel</button>
                            <button onClick={handleSave} disabled={!form.name.trim() || !form.id.trim()}
                                className="px-4 py-2 bg-indigo-600 hover:bg-indigo-500 disabled:opacity-50 disabled:cursor-not-allowed rounded-lg text-sm">
                                {isNew ? 'Create Project' : 'Save Changes'}
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        );
    }
    // =========================================================================
    // CLAUDE PREP MODAL (v8.13.0)
    // =========================================================================
    
    // Standard doc filenames for the Claude Prep package convention
    const CLAUDE_PREP_DOCS = ['CLAUDE.md', 'CONTEXT.md', 'PROJECT_PLAN.md', 'CHANGELOG.md', 'RELEASE_NOTES.txt', 'ARCHITECTURE.md', 'CLAUDE-PREP-STANDARD.md', 'CLAUDE_INSTRUCTIONS.md'];

    // Detect if file content is a CLAUDE.md regardless of upload filename.
    // Returns 'CLAUDE.md' if detected, otherwise returns the original filename.
    function detectClaudeMd(fileName, content) {
        if (!content || typeof content !== 'string') return fileName;
        const baseName = fileName.split('/').pop();
        // Already named correctly
        if (baseName === 'CLAUDE.md') return fileName;
        // Only consider .md files
        if (!/\.md$/i.test(baseName)) return fileName;
        // Signal 1: cc-meta tag with targetPath: CLAUDE.md (machine-generated)
        if (/<!--\s*cc-meta[\s\S]*?targetPath:\s*CLAUDE\.md[\s\S]*?-->/.test(content.slice(0, 500))) {
            console.log(`[ClaudeMD] Detected CLAUDE.md by cc-meta tag in "${fileName}"`);
            return fileName.replace(baseName, 'CLAUDE.md');
        }
        // Signal 2: Content heuristics — heading + ODRC section markers
        const hasHeading = /^#\s+CLAUDE\.md/m.test(content.slice(0, 200));
        const odrcSections = ['## RULEs', '## CONSTRAINTs', '## DECISIONs', '## OPENs'];
        const odrcHits = odrcSections.filter(s => content.includes(s)).length;
        if (hasHeading && odrcHits >= 2) {
            console.log(`[ClaudeMD] Detected CLAUDE.md by content heuristics in "${fileName}" (heading + ${odrcHits} ODRC sections)`);
            return fileName.replace(baseName, 'CLAUDE.md');
        }
        return fileName;
    }
    
    // =========================================================================
    // SESSION_RETURN.json — Validation & Session Matching (Phase B)
    // =========================================================================
    
    const SESSION_RETURN_SCHEMA = {
        required: ['version', 'sessionType', 'timestamp', 'summary'],
        optional: ['sessionId', 'versionBump', 'workItems', 'discoveredIssues', 'discoveredIdeas', 'interfaceChanges', 'filesModified', 'filesCreated', 'filesDeleted', 'changelog'],
        workItemStatuses: ['completed', 'partial', 'blocked', 'deferred'],
        severities: ['critical', 'high', 'medium', 'low'],
        changeTypes: ['added', 'modified', 'removed', 'renamed'],
        bumpTypes: ['major', 'minor', 'patch', 'none'],
        suggestedTypes: ['bugfix', 'enhancement', 'chore', 'research', 'feature']
    };
    
    function validateSessionReturn(jsonString) {
        const errors = [];
        const warnings = [];
        let data;
        
        // Step 1: Parse JSON
        try {
            data = JSON.parse(jsonString);
        } catch (e) {
            return { valid: false, data: null, errors: [`Invalid JSON: ${e.message}`], warnings: [] };
        }
        
        // Step 2: Required fields
        for (const field of SESSION_RETURN_SCHEMA.required) {
            if (data[field] === undefined || data[field] === null || data[field] === '') {
                errors.push(`Missing required field: ${field}`);
            }
        }
        
        // Step 3: Version
        if (data.version && data.version !== '1.0') {
            warnings.push(`Unexpected schema version: ${data.version} (expected 1.0)`);
        }
        
        // Step 4: Session type (v8.63.0: simplified — SESSION_TYPES removed)
        if (data.sessionType && typeof data.sessionType !== 'string') {
            warnings.push(`Invalid session type: ${data.sessionType}`);
        }
        
        // Step 5: Timestamp
        if (data.timestamp) {
            const ts = new Date(data.timestamp);
            if (isNaN(ts.getTime())) {
                errors.push(`Invalid timestamp: ${data.timestamp}`);
            }
        }
        
        // Step 6: Version bump
        if (data.versionBump) {
            if (data.versionBump.bumpType && !SESSION_RETURN_SCHEMA.bumpTypes.includes(data.versionBump.bumpType)) {
                warnings.push(`Unknown bump type: ${data.versionBump.bumpType}`);
            }
        }
        
        // Step 7: Work items
        if (data.workItems && Array.isArray(data.workItems)) {
            data.workItems.forEach((wi, i) => {
                if (!wi.id) errors.push(`workItems[${i}]: missing id`);
                if (wi.status && !SESSION_RETURN_SCHEMA.workItemStatuses.includes(wi.status)) {
                    warnings.push(`workItems[${i}]: unknown status "${wi.status}"`);
                }
            });
        }
        
        // Step 8: Discovered issues
        if (data.discoveredIssues && Array.isArray(data.discoveredIssues)) {
            data.discoveredIssues.forEach((issue, i) => {
                if (!issue.title) warnings.push(`discoveredIssues[${i}]: missing title`);
                if (issue.severity && !SESSION_RETURN_SCHEMA.severities.includes(issue.severity)) {
                    warnings.push(`discoveredIssues[${i}]: unknown severity "${issue.severity}"`);
                }
            });
        }
        
        // Step 9: Interface changes
        if (data.interfaceChanges && Array.isArray(data.interfaceChanges)) {
            data.interfaceChanges.forEach((change, i) => {
                if (!change.interface) warnings.push(`interfaceChanges[${i}]: missing interface name`);
                if (change.changeType && !SESSION_RETURN_SCHEMA.changeTypes.includes(change.changeType)) {
                    warnings.push(`interfaceChanges[${i}]: unknown changeType "${change.changeType}"`);
                }
            });
        }
        
        return { valid: errors.length === 0, data, errors, warnings };
    }
    
    function matchSessionReturn(returnData, sessions, apps) {
        if (!sessions || sessions.length === 0) return { session: null, confidence: 'none', reason: 'No sessions available' };
        
        // Filter to active/in-progress sessions, sorted newest first
        const candidates = sessions
            .filter(s => s.status === 'prep' || s.status === 'active' || s.status === 'in-progress' || s.status === 'review')
            .sort((a, b) => new Date(b.createdAt || 0) - new Date(a.createdAt || 0));
        
        if (candidates.length === 0) return { session: null, confidence: 'none', reason: 'No active sessions found' };
        
        // Best match: session ID from the brief
        if (returnData.sessionId) {
            const idMatch = sessions.find(s => s.id === returnData.sessionId);
            if (idMatch) {
                return { session: idMatch, confidence: 'high', reason: `Matched by session ID: ${returnData.sessionId}` };
            }
        }
        
        // Try matching by session type + app context
        const typeMatch = candidates.filter(s => s.type === returnData.sessionType);
        
        // If work items are present, try matching by work item IDs
        if (returnData.workItems && returnData.workItems.length > 0) {
            const returnWiIds = new Set(returnData.workItems.map(wi => wi.id));
            for (const session of candidates) {
                const sessionWiIds = session.workItemId ? session.workItemId.split(',').map(s => s.trim()) : [];
                const overlap = sessionWiIds.filter(id => returnWiIds.has(id));
                if (overlap.length > 0) {
                    return { session, confidence: 'high', reason: `Matched ${overlap.length} work item(s): ${overlap.join(', ')}` };
                }
            }
        }
        
        // Fall back to type + recency
        if (typeMatch.length === 1) {
            return { session: typeMatch[0], confidence: 'medium', reason: `Single active ${returnData.sessionType} session` };
        }
        
        if (typeMatch.length > 1) {
            return { session: typeMatch[0], confidence: 'low', reason: `${typeMatch.length} active ${returnData.sessionType} sessions — matched newest` };
        }
        
        // Last resort: most recent session
        return { session: candidates[0], confidence: 'low', reason: 'No type match — using most recent active session' };
    }
    
    // File action classification: deploy to GitHub Pages or push to source repo
    const DOC_FILE_EXTENSIONS = /\.(md|txt)$/i;
    const DEPLOY_FILE_EXTENSIONS = /\.(html|js|json|css|xml|svg|yml|yaml)$/i;
    
    function classifyFileAction(fileName) {
        const baseName = fileName.split('/').pop();
        // Known doc files always push to repo (check basename for docs/ subfolder support)
        if (CLAUDE_PREP_DOCS.includes(baseName)) return 'push-doc';
        if (baseName === 'SESSION_BRIEF.md') return 'skip'; // Auto-generated, don't push
        if (baseName === 'PRODUCT_BRIEF.md') return 'skip'; // Auto-generated, don't push (Phase 5.5)
        if (baseName === 'SESSION_RETURN.json') return 'skip'; // Session return manifest, processed by CC on drop (Phase A)
        // Files in docs/ folder → push to repo
        if (fileName.startsWith('docs/')) return 'push-doc';
        // .md and .txt files → push to repo
        if (DOC_FILE_EXTENSIONS.test(baseName)) return 'push-doc';
        // Everything else → deploy to GitHub Pages
        return 'deploy';
    }
    
    // Required docs for a full doc set (per CLAUDE-PREP-STANDARD)
    const REQUIRED_DOCS = ['CONTEXT.md', 'PROJECT_PLAN.md', 'CHANGELOG.md', 'RELEASE_NOTES.txt'];
    
    // =========================================================================
    // CONCEPT PARSER (Streams Evolution v8.55.2)
    // Extracts key concepts from <!-- cc-concepts --> markers in documents.
    // Called after doc push to prompt user for stream association.
    // =========================================================================
    
    /**
     * Parse concepts from document content using cc-concepts markers.
     * Returns array of concept objects ready for stream storage.
     * 
     * Format:
     *   <!-- cc-concepts scope="deploy,packaging" -->
     *   - RULE: Path in zip = path in repo.
     *   - DECISION: gs-active is dev archive.
     *   <!-- /cc-concepts -->
     */
    function parseConcepts(docContent, sourceName) {
        const concepts = [];
        if (!docContent || typeof docContent !== 'string') return concepts;
        
        // Match all cc-concepts blocks (there may be multiple)
        const blockRegex = /<!--\s*cc-concepts\s*(.*?)\s*-->([\s\S]*?)<!--\s*\/cc-concepts\s*-->/g;
        let blockMatch;
        
        while ((blockMatch = blockRegex.exec(docContent)) !== null) {
            const attrString = blockMatch[1] || '';
            const blockContent = blockMatch[2] || '';
            
            // Parse scope from attributes: scope="deploy,packaging"
            const scopeMatch = attrString.match(/scope\s*=\s*"([^"]*)"/);
            const scope = scopeMatch ? scopeMatch[1].split(',').map(s => s.trim()).filter(Boolean) : [];
            
            // Parse individual concept lines: - TYPE: text
            const lineRegex = /^[\s]*-\s*(RULE|DECISION|CONSTRAINT|PROCESS|LESSON|OPEN|FIX):\s*(.+)$/gm;
            let lineMatch;
            
            while ((lineMatch = lineRegex.exec(blockContent)) !== null) {
                const type = lineMatch[1].toLowerCase();
                const text = lineMatch[2].trim();
                
                concepts.push({
                    id: `C-${Date.now()}-${concepts.length}`,
                    type,
                    text,
                    scope,
                    source: sourceName || 'unknown',
                    date: new Date().toISOString().split('T')[0],
                    status: 'active'
                });
            }
        }
        
        console.log(`[Concepts] Extracted ${concepts.length} concepts from ${sourceName || 'document'}${concepts.length > 0 ? ': ' + concepts.map(c => c.type.toUpperCase()).join(', ') : ''}`);
        return concepts;
    }
    
    /**
     * Check pushed docs for concepts and prompt user to associate with a stream.
     * Called after successful doc push.
     * 
     * @param {Array} pushedDocs - Array of {name, content} objects that were pushed
     * @param {Array} streams - Current global streams list
     * @param {Function} showConfirm - Dialog function  
     * @param {Function} showPrompt - Prompt dialog function
     * @param {Object} firebaseRefs - {uid, updateStream} for saving
     */
    async function checkPushedDocsForConcepts(pushedDocs, streams, showConfirm, showPrompt, firebaseRefs) {
        if (!pushedDocs || pushedDocs.length === 0 || !streams || streams.length === 0) return;
        
        // Collect all concepts from all pushed docs
        const allConcepts = [];
        for (const doc of pushedDocs) {
            if (!doc.content || typeof doc.content !== 'string') continue;
            const concepts = parseConcepts(doc.content, doc.name);
            if (concepts.length > 0) {
                allConcepts.push(...concepts);
            }
        }
        
        if (allConcepts.length === 0) return;
        
        console.log(`[Concepts] Found ${allConcepts.length} total concepts in ${pushedDocs.length} pushed doc(s)`);
        
        // Build stream selection list
        const activeStreams = streams.filter(s => s.status === 'active' || s.status === 'planning' || s.status === 'testing');
        if (activeStreams.length === 0) {
            console.log('[Concepts] No active streams to attach concepts to');
            return;
        }
        
        // Summarize by type
        const typeCounts = {};
        allConcepts.forEach(c => { typeCounts[c.type] = (typeCounts[c.type] || 0) + 1; });
        const typeSummary = Object.entries(typeCounts).map(([t, n]) => `${n} ${t.toUpperCase()}`).join(', ');
        
        // Build stream options string
        const streamOptions = activeStreams.map((s, i) => `${i + 1}. ${s.name} (${s.status})`).join('\n');
        
        const result = await showPrompt(
            `Found ${allConcepts.length} concepts (${typeSummary}).\n\nAdd to which stream?\n\n${streamOptions}\n\nEnter number (or leave blank to skip):`,
            '',
            `💡 ${allConcepts.length} Concepts Found`
        );
        
        if (!result || !result.trim()) {
            console.log('[Concepts] User skipped concept import');
            return;
        }
        
        const idx = parseInt(result.trim()) - 1;
        if (isNaN(idx) || idx < 0 || idx >= activeStreams.length) {
            console.log('[Concepts] Invalid stream selection:', result);
            return;
        }
        
        const targetStream = activeStreams[idx];
        
        // Merge with existing concepts, avoiding duplicates by text
        const existingTexts = new Set((targetStream.concepts || []).map(c => c.text.toLowerCase()));
        const newConcepts = allConcepts.filter(c => !existingTexts.has(c.text.toLowerCase()));
        const dupeCount = allConcepts.length - newConcepts.length;
        
        if (newConcepts.length === 0) {
            console.log(`[Concepts] All ${allConcepts.length} concepts already exist on stream ${targetStream.id}`);
            return;
        }
        
        const mergedConcepts = [...(targetStream.concepts || []), ...newConcepts];
        
        // Save to Firebase
        if (firebaseRefs?.uid && firebaseRefs?.updateStream) {
            await firebaseRefs.updateStream(firebaseRefs.uid, targetStream.id, { concepts: mergedConcepts });
            console.log(`[Concepts] Added ${newConcepts.length} concepts to stream ${targetStream.id}: "${targetStream.name}"${dupeCount > 0 ? ` (${dupeCount} duplicates skipped)` : ''}`);
        }
    }
    
    /**
     * Check if a doc's content matches what's already in the repo.
     * Returns true if unchanged (skip the push), false if new or different.
     * 
     * @param {Object} existing - GitHub file object from getFile() (has .content base64 + .sha)
     * @param {string} newContent - The local doc content to compare
     * @returns {boolean} true if content is identical
     */
    function isDocUnchanged(existing, newContent) {
        if (!existing || !existing.content) return false; // File doesn't exist or no content → push it
        try {
            // GitHub returns base64-encoded content (may have newlines in the base64 string)
            const decoded = decodeURIComponent(escape(atob(existing.content.replace(/\n/g, ''))));
            // Normalize line endings for comparison
            const normalizedExisting = decoded.replace(/\r\n/g, '\n').trim();
            const normalizedNew = newContent.replace(/\r\n/g, '\n').trim();
            return normalizedExisting === normalizedNew;
        } catch (e) {
            console.warn('[DocPush] Content comparison failed, will push:', e.message);
            return false;
        }
    }

    // =========================================================================
    // UNIFIED PACKAGE VALIDATION (v8.36.0)
    // Selection-driven: runs on selected files to determine intent and issues.
    // Replaces: validateDocPackage, post-extraction showAlerts, deploy-time confirms
    // =========================================================================

    function getValidationIntent(selectedFiles) {
        const deployFiles = selectedFiles.filter(f => f.fileAction === 'deploy');
        const docFiles = selectedFiles.filter(f => f.fileAction === 'push-doc');

        if (selectedFiles.length === 0) return 'none';
        if (deployFiles.length === 0 && docFiles.length > 0) return 'docs-only';
        if (deployFiles.length === 1 && docFiles.length === 0) return 'quick-deploy';

        const hasHtml = deployFiles.some(f => f.name === 'index.html');
        const hasSw = deployFiles.some(f => f.name === 'sw.js');
        const hasManifest = deployFiles.some(f => f.name === 'manifest.json');
        const hasIcons = deployFiles.some(f => f.targetPath?.startsWith('icons/'));
        const pwaFileCount = [hasHtml, hasSw, hasManifest, hasIcons].filter(Boolean).length;

        const isPackage = pwaFileCount >= 3 || (deployFiles.length >= 2 && docFiles.length >= 2);

        if (isPackage && docFiles.length > 0) return 'full-package';
        if (isPackage) return 'deploy-package';
        return 'targeted-update';
    }

    function validatePackage(selectedFiles, stagedFiles, appConfig, deployedVersion) {
        const intent = getValidationIntent(selectedFiles);
        if (intent === 'none' || intent === 'docs-only') return null;

        const deployFiles = selectedFiles.filter(f => f.fileAction === 'deploy');
        const docFiles = selectedFiles.filter(f => f.fileAction === 'push-doc');
        const indexFile = deployFiles.find(f => f.name === 'index.html' || f.targetPath === 'index.html');
        const swFile = deployFiles.find(f => f.name === 'sw.js');
        // For quick-deploy (single file), use that file's version even if not named index.html
        const deployVersion = indexFile?.version || (deployFiles.length === 1 ? deployFiles[0]?.version : null) || null;
        const isPWA = appConfig?.hasServiceWorker === true;

        const issues = [];

        // --- Version not incremented (applies to ALL deploy intents, not just packages) ---
        if (intent !== 'none' && intent !== 'docs-only' && deployVersion && deployedVersion) {
            if (!isNewerVersion(deployVersion, deployedVersion)) {
                const isDowngrade = compareVersions(deployVersion, deployedVersion) < 0;
                const suggestedBump = bumpVersion(deployedVersion, 'patch');
                const hasDocsSelected = docFiles.length > 0;
                issues.push({
                    id: 'version-not-incremented',
                    severity: isDowngrade ? 'error' : 'warning',
                    category: 'versions',
                    title: isDowngrade ? 'Version downgrade detected' : 'Version not incremented',
                    detail: isDowngrade 
                        ? `v${deployVersion} is OLDER than deployed v${deployedVersion} on ${appConfig?.name || 'target'}`
                        : `v${deployVersion} is already on ${appConfig?.name || 'target'}`,
                    fix: `Bump to v${suggestedBump}`,
                    action: hasDocsSelected ? null : {
                        type: 'bump-version',
                        from: deployVersion,
                        suggested: suggestedBump
                    },
                    useClaudePrompt: hasDocsSelected
                });
            }
        }

        // --- Version mismatch: index.html vs sw.js ---
        if (intent !== 'quick-deploy' && indexFile && swFile) {
            if (indexFile.version && swFile.version && indexFile.version !== swFile.version) {
                issues.push({
                    id: 'version-mismatch',
                    severity: 'error',
                    category: 'versions',
                    title: 'Version mismatch: index.html vs sw.js',
                    detail: `index.html: v${indexFile.version}, sw.js: v${swFile.version}`,
                    fix: `Update sw.js CACHE_VERSION to v${indexFile.version}`
                });
            }
        }

        // --- PWA completeness (check against STAGED files, not selected) ---
        if ((intent === 'deploy-package' || intent === 'full-package') && isPWA) {
            const allStagedDeploy = stagedFiles.filter(f => f.fileAction === 'deploy');
            const missing = [];
            if (!allStagedDeploy.some(f => f.name === 'sw.js')) missing.push('sw.js');
            if (!allStagedDeploy.some(f => f.name === 'manifest.json')) missing.push('manifest.json');
            if (!allStagedDeploy.some(f => f.targetPath?.startsWith('icons/'))) missing.push('icons/');

            for (const m of missing) {
                issues.push({
                    id: `pwa-missing-${m.replace(/[/.]/g, '')}`,
                    severity: m === 'icons/' ? 'warning' : 'error',
                    category: 'pwa',
                    title: `Missing: ${m}`,
                    detail: `PWA package needs ${m}`,
                    fix: `Include ${m} in deployment package`
                });
            }
        }

        // --- Missing docs (full-package only, check against STAGED) ---
        if (intent === 'full-package') {
            const stagedDocBaseNames = new Set(
                stagedFiles.filter(f => f.fileAction === 'push-doc').map(f => f.name.split('/').pop())
            );
            for (const required of REQUIRED_DOCS) {
                if (!stagedDocBaseNames.has(required)) {
                    issues.push({
                        id: `docs-missing-${required.toLowerCase().replace(/\./g, '')}`,
                        severity: 'warning',
                        category: 'docs',
                        title: `Missing: ${required}`,
                        detail: `Full package should include ${required} (in docs/ folder or root)`,
                        fix: `Create ${required} following CLAUDE-PREP-STANDARD`
                    });
                }
            }
        }

        // --- Doc version alignment (on selected docs) ---
        // Use the effective target version: if a bump is needed, docs should match the bumped version
        const needsBump = issues.some(i => i.id === 'version-not-incremented');
        const effectiveVersion = needsBump ? bumpVersion(deployedVersion || deployVersion, 'patch') : deployVersion;
        if (effectiveVersion && docFiles.length > 0) {
            const contextFile = docFiles.find(f => f.name === 'CONTEXT.md');
            if (contextFile?.content) {
                const match = contextFile.content.match(/\*\*v([^\s*]+)\*\*/);
                if (match && match[1] !== effectiveVersion) {
                    issues.push({
                        id: 'docs-context-version', severity: 'warning', category: 'docs',
                        title: 'CONTEXT.md version mismatch',
                        detail: `CONTEXT.md: v${match[1]}, deploy: v${effectiveVersion}`,
                        fix: `Update CONTEXT.md header to v${effectiveVersion}`
                    });
                }
            }

            const changelogFile = docFiles.find(f => f.name === 'CHANGELOG.md');
            if (changelogFile?.content) {
                const match = changelogFile.content.match(/## \[([^\]]+)\]/);
                if (match && match[1] !== effectiveVersion) {
                    issues.push({
                        id: 'docs-changelog-version', severity: 'warning', category: 'docs',
                        title: 'CHANGELOG.md version mismatch',
                        detail: `CHANGELOG.md: [${match[1]}], deploy: v${effectiveVersion}`,
                        fix: `Add CHANGELOG.md entry for v${effectiveVersion}`
                    });
                }
            }

            const rnFile = docFiles.find(f => f.name === 'RELEASE_NOTES.txt');
            if (rnFile?.content) {
                const match = rnFile.content.match(/v?(\d+\.\d+[\d.]*)\s*[—–-]/);
                if (match && match[1] !== effectiveVersion) {
                    issues.push({
                        id: 'docs-releasenotes-version', severity: 'warning', category: 'docs',
                        title: 'RELEASE_NOTES.txt version mismatch',
                        detail: `RELEASE_NOTES.txt: v${match[1]}, deploy: v${effectiveVersion}`,
                        fix: `Add RELEASE_NOTES.txt entry for v${effectiveVersion}`
                    });
                }
            }
        }

        // --- Docs not included (info — deploy-package only) ---
        if (intent === 'deploy-package' && deployVersion) {
            issues.push({
                id: 'docs-not-included',
                severity: 'info',
                category: 'docs',
                title: 'Docs not included',
                detail: `Repo docs will be out of sync after deploying v${deployVersion}`,
                fix: null
            });
        }

        // --- Build result ---
        if (issues.length === 0) return null;

        const hasErrors = issues.some(i => i.severity === 'error');
        const hasWarnings = issues.some(i => i.severity === 'warning');
        const severity = hasErrors ? 'error' : hasWarnings ? 'warning' : 'info';

        const errorCount = issues.filter(i => i.severity === 'error').length;
        const warnCount = issues.filter(i => i.severity === 'warning').length;
        const infoCount = issues.filter(i => i.severity === 'info').length;

        const summaryParts = [];
        if (errorCount) summaryParts.push(`${errorCount} error${errorCount !== 1 ? 's' : ''}`);
        if (warnCount) summaryParts.push(`${warnCount} warning${warnCount !== 1 ? 's' : ''}`);
        if (infoCount) summaryParts.push(`${infoCount} info`);

        const needsClaudePrompt = issues.some(i =>
            i.useClaudePrompt ||
            i.category === 'pwa' ||
            (i.category === 'docs' && i.id !== 'docs-not-included') ||
            i.id === 'version-mismatch'
        );

        return {
            issues,
            intent,
            severity,
            summary: summaryParts.join(', '),
            claudePrompt: needsClaudePrompt
                ? generateClaudeFixPrompt(issues, deployVersion, deployedVersion, appConfig)
                : null,
            deployVersion
        };
    }

    function generateClaudeFixPrompt(issues, deployVersion, deployedVersion, appConfig) {
        const lines = [];
        lines.push('Please fix the following issues in my deployment package:\n');

        const notIncremented = issues.find(i => i.id === 'version-not-incremented');
        if (notIncremented) {
            const suggested = bumpVersion(deployedVersion || deployVersion, 'patch');
            const isDowngrade = deployVersion && deployedVersion && compareVersions(deployVersion, deployedVersion) < 0;
            lines.push('Version not incremented:');
            lines.push(`• Code is v${deployVersion} — ${isDowngrade ? `OLDER than deployed v${deployedVersion}` : 'same as deployed'}`);
            lines.push(`• Bump to v${suggested} (or appropriate version)`);
            lines.push(`• Update <meta name="version"> in index.html`);
            if (appConfig?.hasServiceWorker) {
                lines.push('• Update sw.js CACHE_VERSION to match');
            }
            lines.push('');
        }

        const mismatch = issues.find(i => i.id === 'version-mismatch');
        if (mismatch) {
            lines.push('Version mismatch:');
            lines.push(`• ${mismatch.detail}`);
            lines.push(`• ${mismatch.fix}`);
            lines.push('');
        }

        const pwaIssues = issues.filter(i => i.category === 'pwa');
        if (pwaIssues.length > 0) {
            const missingFiles = pwaIssues.map(i => i.title.replace('Missing: ', ''));
            lines.push('PWA package incomplete:');
            lines.push(`• Missing: ${missingFiles.join(', ')}`);
            lines.push('• Include all PWA files in the deployment package');
            lines.push('');
        }

        const missingDocs = issues.filter(i => i.id.startsWith('docs-missing'));
        if (missingDocs.length > 0) {
            const names = missingDocs.map(i => i.title.replace('Missing: ', ''));
            lines.push(`Missing docs: ${names.join(', ')}`);
            lines.push('Please create these following CLAUDE-PREP-STANDARD.');
            lines.push('');
        }

        const docVersions = issues.filter(i =>
            i.category === 'docs' &&
            !i.id.startsWith('docs-missing') &&
            i.id !== 'docs-not-included'
        );
        if (docVersions.length > 0) {
            lines.push('Doc version updates:');
            for (const issue of docVersions) {
                lines.push(`• ${issue.detail}`);
            }
            const targetV = notIncremented
                ? bumpVersion(deployedVersion || deployVersion, 'patch')
                : deployVersion;
            lines.push(`Please update all docs to reference v${targetV}.`);
            lines.push('');
        }

        const promptVersion = notIncremented
            ? bumpVersion(deployedVersion || deployVersion, 'patch')
            : deployVersion;
        if (promptVersion) lines.push(`Current version: v${promptVersion}`);
        if (appConfig?.name) lines.push(`App: ${appConfig.name}`);

        return lines.join('\n');
    }
    
    // Detect config ↔ code drift when deploying CC itself.
    // Parses CC_SEED_MANIFEST from staged HTML and compares against running config.
    function detectConfigDrift(stagedContent, runningConfig) {
        if (!stagedContent || !runningConfig) return null;
        
        // Extract CC_SEED_MANIFEST from staged HTML
        const manifestMatch = stagedContent.match(/\/\* CC_SEED_MANIFEST_START \*\/\s*[\n\r]?\s*const CC_SEED_MANIFEST = (\{[\s\S]*?\});\s*[\n\r]?\s*\/\* CC_SEED_MANIFEST_END \*\//);
        if (!manifestMatch) return null;
        
        let manifest;
        try {
            manifest = JSON.parse(manifestMatch[1]);
        } catch (e) {
            return { parseError: true, drifts: [], claudePrompt: 'Failed to parse CC_SEED_MANIFEST from staged code.' };
        }
        
        const drifts = [];
        
        // 1. Check gs-app-id matches a running app
        const gsAppIdMatch = stagedContent.match(/<meta\s+name=["']gs-app-id["']\s+content=["']([^"']+)["']/i);
        const codeAppId = gsAppIdMatch?.[1];
        if (codeAppId && !runningConfig.apps[codeAppId]) {
            drifts.push({
                type: 'identity', severity: 'error',
                field: 'gs-app-id',
                codeValue: codeAppId, configValue: '(no app with this id)',
                detail: `Code has gs-app-id="${codeAppId}" but no app with that id exists in config`
            });
        }
        
        // 2. Check project drift
        if (manifest.projects) {
            for (const [projId, codeProjData] of Object.entries(manifest.projects)) {
                const configProj = runningConfig.projects?.[projId];
                if (!configProj) {
                    drifts.push({
                        type: 'project', severity: 'warn',
                        field: `projects.${projId}`,
                        codeValue: codeProjData.name, configValue: '(missing)',
                        detail: `Code seeds project "${codeProjData.name}" (${projId}) but it doesn't exist in config`
                    });
                } else if (codeProjData.name !== configProj.name) {
                    drifts.push({
                        type: 'project', severity: 'warn',
                        field: `projects.${projId}.name`,
                        codeValue: codeProjData.name, configValue: configProj.name,
                        detail: `Project ${projId} name: code="${codeProjData.name}", config="${configProj.name}"`
                    });
                }
            }
            // Projects in config but not in code seeds
            for (const projId of Object.keys(runningConfig.projects || {})) {
                if (!manifest.projects[projId]) {
                    drifts.push({
                        type: 'project', severity: 'info',
                        field: `projects.${projId}`,
                        codeValue: '(not in seeds)', configValue: runningConfig.projects[projId].name,
                        detail: `Config has project "${runningConfig.projects[projId].name}" (${projId}) — not in code seeds, fresh install won't have it`
                    });
                }
            }
        }
        
        // 3. Check app drift — key identity fields
        if (manifest.apps) {
            const compareFields = ['name', 'project', 'icon', 'subPath', 'appType', 'hasServiceWorker'];
            
            for (const [appId, codeApp] of Object.entries(manifest.apps)) {
                const configApp = runningConfig.apps?.[appId];
                if (!configApp) {
                    drifts.push({
                        type: 'app', severity: 'warn',
                        field: `apps.${appId}`,
                        codeValue: codeApp.name, configValue: '(missing)',
                        detail: `Code seeds app "${codeApp.name}" (${appId}) but it doesn't exist in config`
                    });
                    continue;
                }
                for (const field of compareFields) {
                    const codeNorm = String(codeApp[field] ?? '');
                    const configNorm = String(configApp[field] ?? '');
                    if (codeNorm !== configNorm) {
                        drifts.push({
                            type: 'app',
                            severity: field === 'project' || field === 'name' ? 'warn' : 'info',
                            field: `apps.${appId}.${field}`,
                            codeValue: codeNorm || '(empty)', configValue: configNorm || '(empty)',
                            detail: `${configApp.name || appId} ${field}: code="${codeNorm || '(empty)'}", config="${configNorm || '(empty)'}"`
                        });
                    }
                }
            }
            // Apps in config but not in code seeds
            for (const appId of Object.keys(runningConfig.apps || {})) {
                if (!manifest.apps[appId]) {
                    drifts.push({
                        type: 'app', severity: 'info',
                        field: `apps.${appId}`,
                        codeValue: '(not in seeds)', configValue: runningConfig.apps[appId].name,
                        detail: `Config has app "${runningConfig.apps[appId].name}" (${appId}) — not in code seeds, fresh install won't have it`
                    });
                }
            }
        }
        
        if (drifts.length === 0) return null;
        
        // Generate Claude fix prompt
        const errors = drifts.filter(d => d.severity === 'error');
        const warns = drifts.filter(d => d.severity === 'warn');
        const infos = drifts.filter(d => d.severity === 'info');
        
        const lines = ['Please fix the following config ↔ code drift in Command Center:\n'];
        if (errors.length > 0) {
            lines.push('🔴 Critical:');
            errors.forEach(d => lines.push(`• ${d.detail}`));
            lines.push('');
        }
        if (warns.length > 0) {
            lines.push('⚠️ Mismatches (fresh installs get wrong defaults):');
            warns.forEach(d => lines.push(`• ${d.detail}`));
            lines.push('');
        }
        if (infos.length > 0) {
            lines.push('ℹ️ Config-only (not in code seeds — optional to add):');
            infos.forEach(d => lines.push(`• ${d.detail}`));
            lines.push('');
        }
        lines.push('Update CC_SEED_MANIFEST, SEED_PROJECTS, and DEFAULT_APP_DEFINITIONS to match.');
        
        return {
            drifts,
            errorCount: errors.length,
            warnCount: warns.length,
            infoCount: infos.length,
            claudePrompt: lines.join('\n')
        };
    }
    
    function getDocsPath(app) {
        // Standalone repos (no subPath): docs at root
        // Consolidated repos (has subPath): docs at {subPath}/docs/
        const subPath = app.subPath || '';
        if (!subPath) return '';
        return `${subPath}/docs`;
    }
    
    // [v8.63.0] generateSessionBrief() removed — replaced by IdeationBriefGenerator

    // Generate skeleton CONTEXT.md for bootstrapping
    function generateSkeletonContext(app, config) {
        const projectDef = config.projects?.[app.project] || {};
        const repos = Object.entries(app.repos || {}).filter(([,v]) => v);
        const repoStr = repos.map(([k,v]) => `- **${k.toUpperCase()}:** ${v}`).join('\n');
        
        return `# ${app.name} — CONTEXT.md

> **Read this first** at the start of every session.

## Current Version

**v${app.versions?.prod || app.versions?.test || '0.0.0'}**

## What ${app.name} Is

*TODO: Describe what this app does and who it's for.*

## Architecture

- **Single-file HTML app**: All CSS/JS inline in ${app.targetPath || 'index.html'}
- **Framework**: *TODO: React via CDN / vanilla JS / etc.*
- **Data**: *TODO: Firebase RTDB / localStorage / none*
- **PWA**: ${app.hasServiceWorker ? 'Yes — sw.js + manifest.json' : 'No'}
- **Deploy target**: *TODO: URL*

## Key Technical Details

### Meta Tags (Required)
\`\`\`html
<meta name="version" content="X.X.X">
<meta name="gs-app-id" content="${app.id}">
\`\`\`

### Data Schema
*TODO: Key data structures, Firebase paths, localStorage keys*

### Key Components / Functions
*TODO: Map of major components or functions*

## Deployment

${repoStr || '- *No repos configured*'}
- **SubPath:** ${app.subPath || '(root)'}
- **Structure:** ${repos.length > 1 ? 'Dual (Test → Prod)' : 'Single repo'}
- **PWA Package:** ${app.hasServiceWorker ? 'Yes — include sw.js, manifest.json, icons/' : 'No — single HTML file'}
- **Detection patterns:** ${(app.detectionPatterns || []).join(', ')}

## Conventions

*TODO: App-specific rules, CSS patterns, state management*

## Recent Changes

*TODO: Updated each session*
`;
    }
    
    // Generate skeleton PROJECT_PLAN.md
    function generateSkeletonPlan(app) {
        return `# ${app.name} — Project Plan

## Mission

*TODO: What this app exists to do.*

## Completed Features

*TODO: List completed features.*

## In Progress

*TODO: What's actively being worked on.*

## Planned Features

### Near Term
*TODO: Next priorities.*

### Medium Term
*TODO: Roadmap items.*

## Architecture Decisions

*TODO: Why key technical choices were made.*

## Open Questions

*TODO: Unresolved decisions.*
`;
    }
    
    // Generate skeleton CHANGELOG.md
    function generateSkeletonChangelog(app) {
        const ver = app.versions?.prod || app.versions?.test || '0.0.0';
        return `# ${app.name} — Changelog

## [${ver}] - ${new Date().toISOString().split('T')[0]}

### Added
- Initial changelog created by Claude Prep

*Use format: Added / Changed / Fixed / Removed per version.*
`;
    }
    // [v8.63.0] SessionLaunchModal removed — replaced by ExploreInChatModal

    
    function ClaudePrepModal({ app, config, github, githubOwner, deployments, onClose, showAlert, showPrompt, globalWorkItems, firebaseUid, globalStreams }) {
        // === Wizard State (v8.37.0: 3-step Session Wizard) ===
        const [wizardStep, setWizardStep] = React.useState(1); // 1: Work Items, 2: Session Type + Context, 3: Generate
        const [phase, setPhase] = React.useState('wizard'); // wizard | building | done | error
        const [sessionType, setSessionType] = React.useState(null);
        const [selectedWorkItems, setSelectedWorkItems] = React.useState([]);
        const [status, setStatus] = React.useState('idle');
        const [log, setLog] = React.useState([]);
        const [progress, setProgress] = React.useState({ current: 0, total: 0 });
        const [result, setResult] = React.useState(null);
        const [uploadMode, setUploadMode] = React.useState(false);
        const [uploadFiles, setUploadFiles] = React.useState([]);
        const [uploading, setUploading] = React.useState(false);
        const [uploadLog, setUploadLog] = React.useState([]);
        const [sessionRecord, setSessionRecord] = React.useState(null);
        
        // Get work items for this app
        const [streamFilter, setStreamFilter] = React.useState('all'); // Phase 5.2: stream filter for work items
        
        const appStreams = React.useMemo(() => {
            return (globalStreams || []).filter(s => s.appId === app.id);
        }, [globalStreams, app.id]);
        
        const appWorkItems = React.useMemo(() => {
            if (!globalWorkItems) return [];
            let items = globalWorkItems.filter(wi => wi.appId === app.id && (wi.status === 'ready' || wi.status === 'in-progress'));
            if (streamFilter !== 'all') {
                items = items.filter(wi => streamFilter === 'unassigned' ? !wi.streamId : wi.streamId === streamFilter);
            }
            return items;
        }, [globalWorkItems, app.id, streamFilter]);
        
        // Auto-suggest session type when a work item is selected
        const handleWorkItemToggle = (wi) => {
            setSelectedWorkItems(prev => {
                const exists = prev.find(w => w.id === wi.id);
                const next = exists ? prev.filter(w => w.id !== wi.id) : [...prev, wi];
                if (next.length > 0 && !sessionType) {
                    setSessionType(SessionBriefGenerator.suggestFromWorkItem(next[0]));
                }
                return next;
            });
        };
        
        const typeInfo = sessionType ? SESSION_TYPES[sessionType] : null;
        const suggestedEngine = typeInfo ? EngineRegistryService.get(typeInfo.suggestedEngine) : null;
        const defaultEngine = EngineRegistryService.getDefault();
        const activeEngine = suggestedEngine || defaultEngine;
        
        const addLog = (msg, type = 'info') => {
            setLog(prev => [...prev, { msg, type, time: new Date().toLocaleTimeString() }]);
        };
        
        // Wizard navigation
        const canProceed = (step) => {
            if (step === 1) return true; // Can always proceed from step 1 (general session is fine)
            if (step === 2) return true; // Session type is optional
            return false;
        };
        
        const goNext = () => setWizardStep(prev => Math.min(prev + 1, 3));
        const goBack = () => setWizardStep(prev => Math.max(prev - 1, 1));
        
        // Quick Skip: jump to building immediately
        const quickBuild = () => {
            setSessionType(null);
            setSelectedWorkItems([]);
            startPrep();
        };
        
        const startPrep = async () => {
            if (!github) {
                await showAlert('GitHub token not configured. Go to Settings to add one.');
                return;
            }
            
            setPhase('building');
            setStatus('fetching');
            setLog([]);
            
            try {
                const zip = new JSZip();
                const appFolder = zip.folder(app.id);
                const files = [];
                const missingDocs = [];
                
                const repo = app.repos?.prod || app.repos?.test;
                if (!repo) {
                    addLog('\u274c No repo configured for this app', 'error');
                    setStatus('error');
                    setPhase('error');
                    return;
                }
                
                addLog(`\ud83d\udcc2 Using repo: ${repo}`);
                const subPath = app.subPath || '';
                const docsPath = getDocsPath(app);
                const strategy = typeInfo?.contextStrategy || null;
                
                // === Fetch source files (session-type-aware) ===
                const includeSource = strategy ? strategy.includeSource : true;
                
                if (includeSource) {
                    addLog('\ud83d\udce5 Fetching source files...');
                    const targetPath = subPath 
                        ? `${subPath}/${app.targetPath || 'index.html'}`
                        : (app.targetPath || 'index.html');
                    
                    setProgress({ current: 1, total: 8 });
                    const mainFile = await github.getFileContent(repo, targetPath);
                    if (mainFile?.textContent) {
                        appFolder.file(app.targetPath || 'index.html', mainFile.textContent);
                        const mainName = app.targetPath || 'index.html';
                        files.push({ name: mainName, size: mainFile.textContent.length, tokens: TokenRegistryService.estimateTokens(mainFile.textContent, mainName) });
                        addLog(`\u2705 ${mainName} (${(mainFile.textContent.length / 1024).toFixed(0)}KB)`);
                    } else {
                        addLog(`\u26a0\ufe0f Could not fetch ${targetPath}`, 'warn');
                    }
                    
                    if (app.hasServiceWorker) {
                        setProgress({ current: 2, total: 8 });
                        const swPath = subPath ? `${subPath}/sw.js` : 'sw.js';
                        const swFile = await github.getFileContent(repo, swPath);
                        if (swFile?.textContent) {
                            appFolder.file('sw.js', swFile.textContent);
                            files.push({ name: 'sw.js', size: swFile.textContent.length, tokens: TokenRegistryService.estimateTokens(swFile.textContent, 'sw.js') });
                            addLog(`\u2705 sw.js (${(swFile.textContent.length / 1024).toFixed(0)}KB)`);
                        } else {
                            addLog('\u26a0\ufe0f sw.js not found (PWA app)', 'warn');
                        }
                        
                        setProgress({ current: 3, total: 8 });
                        const manifestPath = subPath ? `${subPath}/manifest.json` : 'manifest.json';
                        const manifestFile = await github.getFileContent(repo, manifestPath);
                        if (manifestFile?.textContent) {
                            appFolder.file('manifest.json', manifestFile.textContent);
                            files.push({ name: 'manifest.json', size: manifestFile.textContent.length, tokens: TokenRegistryService.estimateTokens(manifestFile.textContent, 'manifest.json') });
                            addLog(`\u2705 manifest.json`);
                        }
                    }
                } else {
                    addLog('\u23ed\ufe0f Skipping source files (not needed for this session type)');
                }
                
                // === Fetch doc files (session-type-aware filtering) ===
                addLog('\ud83d\udcc4 Looking for project docs...');
                setProgress({ current: 4, total: 8 });
                
                const skipSet = new Set(strategy?.skipWhenTight || []);
                const alwaysSet = new Set(strategy?.alwaysInclude || []);
                const preferSet = new Set(strategy?.preferInclude || []);
                
                let docsFound = 0;
                for (const docName of CLAUDE_PREP_DOCS) {
                    if (strategy && !alwaysSet.has(docName) && !preferSet.has(docName) && skipSet.has(docName)) {
                        addLog(`\u23ed\ufe0f Skipping ${docName} (session type: ${typeInfo?.label || 'N/A'})`, 'info');
                        continue;
                    }
                    
                    const paths = docsPath 
                        ? [`${docsPath}/${docName}`, `${subPath}/${docName}`, docName]
                        : [docName];
                    
                    let found = false;
                    for (const tryPath of paths) {
                        const docFile = await github.getFileContent(repo, tryPath);
                        if (docFile?.textContent) {
                            appFolder.file(docName, docFile.textContent);
                            files.push({ name: docName, size: docFile.textContent.length, tokens: TokenRegistryService.estimateTokens(docFile.textContent, docName) });
                            addLog(`\u2705 ${docName} (from ${tryPath})`);
                            docsFound++;
                            found = true;
                            break;
                        }
                    }
                    if (!found && docName !== 'ARCHITECTURE.md' && docName !== 'CLAUDE_INSTRUCTIONS.md' && docName !== 'CLAUDE-PREP-STANDARD.md') {
                        missingDocs.push(docName);
                    }
                }
                
                // === Bootstrap missing docs ===
                if (missingDocs.length > 0) {
                    addLog(`\ud83d\udcdd Generating ${missingDocs.length} missing doc${missingDocs.length > 1 ? 's' : ''}...`, 'warn');
                    setProgress({ current: 6, total: 8 });
                    
                    for (const docName of missingDocs) {
                        let content = '';
                        if (docName === 'CONTEXT.md') content = generateSkeletonContext(app, config);
                        else if (docName === 'PROJECT_PLAN.md') content = generateSkeletonPlan(app);
                        else if (docName === 'CHANGELOG.md') content = generateSkeletonChangelog(app);
                        else if (docName === 'RELEASE_NOTES.txt') content = `${app.name} - Release Notes\n${'='.repeat(app.name.length + 18)}\n\nv${app.versions?.prod || app.versions?.test || '0.0.0'}\n- Initial release notes created by Claude Prep\n`;
                        if (content) {
                            appFolder.file(docName, content);
                            files.push({ name: docName, size: content.length, generated: true, tokens: TokenRegistryService.estimateTokens(content, docName) });
                            addLog(`\ud83d\udcdd Generated skeleton: ${docName}`, 'warn');
                        }
                    }
                }
                
                // === Generate CLAUDE_INSTRUCTIONS.md from scope (if not in repo) ===
                const hasClaudeInstructions = files.some(f => f.name === 'CLAUDE_INSTRUCTIONS.md');
                if (!hasClaudeInstructions && firebaseDb && firebaseAuth?.currentUser) {
                    try {
                        const scopeSnap = await firebaseDb.ref(`command-center/${firebaseAuth.currentUser.uid}/appScopes/${app.id}`).once('value');
                        const scopeData = scopeSnap.val();
                        if (scopeData) {
                            const instructions = generateClaudeInstructions(app, scopeData, config);
                            if (instructions) {
                                appFolder.file('CLAUDE_INSTRUCTIONS.md', instructions);
                                files.push({ name: 'CLAUDE_INSTRUCTIONS.md', size: instructions.length, generated: true, tokens: TokenRegistryService.estimateTokens(instructions, 'CLAUDE_INSTRUCTIONS.md') });
                                addLog('\ud83c\udfaf Generated CLAUDE_INSTRUCTIONS.md from project scope');
                            }
                        }
                    } catch (e) {
                        addLog('\u26a0\ufe0f Could not generate CLAUDE_INSTRUCTIONS.md: ' + e.message, 'warn');
                    }
                }
                
                // === Generate PRODUCT_BRIEF.md (Phase 5.5) ===
                const hasProductBrief = files.some(f => f.name === 'PRODUCT_BRIEF.md');
                if (!hasProductBrief && firebaseDb && firebaseAuth?.currentUser) {
                    try {
                        // Fetch scope data if not already fetched for CLAUDE_INSTRUCTIONS
                        let briefScopeData = null;
                        try {
                            const scopeSnap = await firebaseDb.ref(`command-center/${firebaseAuth.currentUser.uid}/appScopes/${app.id}`).once('value');
                            briefScopeData = scopeSnap.val();
                        } catch (e) { /* scope data optional */ }
                        
                        if (ProductBriefGenerator.hasData(app, briefScopeData, globalWorkItems)) {
                            const brief = ProductBriefGenerator.generate(app, briefScopeData, config, globalWorkItems, deployments, globalStreams);
                            if (brief) {
                                appFolder.file('PRODUCT_BRIEF.md', brief);
                                files.push({ name: 'PRODUCT_BRIEF.md', size: brief.length, generated: true, tokens: TokenRegistryService.estimateTokens(brief, 'PRODUCT_BRIEF.md') });
                                addLog('📄 Generated PRODUCT_BRIEF.md — product context for all streams');
                            }
                        }
                    } catch (e) {
                        addLog('\u26a0\ufe0f Could not generate PRODUCT_BRIEF.md: ' + e.message, 'warn');
                    }
                }
                
                // === Scan for extra docs ===
                addLog('\ud83d\udd0d Scanning for extra reference docs...');
                setProgress({ current: 6, total: 9 });
                
                const alreadyFetched = new Set([...CLAUDE_PREP_DOCS, ...files.map(f => f.name), 'SESSION_BRIEF.md', 'PRODUCT_BRIEF.md']);
                const scanPath = subPath || '';
                
                try {
                    const repoContents = await github.listRepoContents(repo, scanPath);
                    const extraMdFiles = repoContents.filter(f => 
                        f.type === 'file' && 
                        (f.name.endsWith('.md') || f.name.endsWith('.txt')) &&
                        !alreadyFetched.has(f.name) &&
                        f.name !== 'README.md' && f.name !== 'LICENSE' && f.name !== 'LICENSE.md'
                    );
                    
                    for (const extra of extraMdFiles) {
                        const filePath = scanPath ? `${scanPath}/${extra.name}` : extra.name;
                        const extraFile = await github.getFileContent(repo, filePath);
                        if (extraFile?.textContent) {
                            appFolder.file(extra.name, extraFile.textContent);
                            files.push({ name: extra.name, size: extraFile.textContent.length, tokens: TokenRegistryService.estimateTokens(extraFile.textContent, extra.name) });
                            addLog(`\u2705 ${extra.name} (extra reference doc)`);
                        }
                    }
                    if (extraMdFiles.length === 0) addLog('\u2139\ufe0f No extra reference docs found');
                } catch (e) {
                    addLog('\u26a0\ufe0f Could not scan for extra docs: ' + e.message, 'warn');
                }
                
                // === Phase 2.2: Create session record via SessionService (moved before brief for ID embedding) ===
                let newSession = null;
                if (firebaseUid) {
                    try {
                        newSession = await SessionService.create(firebaseUid, {
                            appId: app.id,
                            type: sessionType || 'build',
                            workItemId: selectedWorkItems.length > 0 ? selectedWorkItems.map(wi => wi.id).join(',') : null,
                            engineId: typeInfo?.suggestedEngine || 'claude-sonnet-4.5',
                            packageTokens: totalTokens,
                            packageFiles: files.map(f => f.name)
                        });
                        if (newSession) {
                            setSessionRecord(newSession);
                            addLog(`\ud83d\udcdd Session ${newSession.id} recorded`, 'success');
                            // Phase 3.4: Log session creation
                            const actor = config?.ownerName || 'Owner';
                            ActivityLogService.logSessionCreate(firebaseUid, actor, app.name, sessionType || 'build', newSession.id).catch(() => {});
                        }
                    } catch (e) {
                        addLog(`\u26a0\ufe0f Could not create session record: ${e.message}`, 'warn');
                    }
                }
                
                // === Generate SESSION_BRIEF.md ===
                addLog('\ud83d\udccb Generating session brief...');
                setProgress({ current: 8, total: 9 });
                
                if (sessionType) addLog(`\ud83c\udfaf Session type: ${SESSION_TYPES[sessionType]?.icon || ''} ${SESSION_TYPES[sessionType]?.label || sessionType}`);
                if (selectedWorkItems.length > 0) addLog(`\ud83d\udccb Targeting ${selectedWorkItems.length} work item${selectedWorkItems.length > 1 ? 's' : ''}: ${selectedWorkItems.map(wi => wi.id).join(', ')}`);
                
                const brief = SessionBriefGenerator.generate(app, config, deployments, {
                    sessionType: sessionType || null,
                    targetWorkItems: selectedWorkItems.length > 0 ? selectedWorkItems : null,
                    allWorkItems: globalWorkItems || [],
                    streams: globalStreams || [],  // Phase 5.2: stream context
                    sessionId: newSession?.id || null  // Phase C: embed session ID for return matching
                });
                const manifest = '\n## Files in This Package\n| File | Size | Tokens | Source |\n|------|------|--------|--------|\n' +
                    files.map(f => `| ${f.name} | ${(f.size / 1024).toFixed(1)}KB | ${TokenRegistryService.formatTokens(f.tokens || 0)} | ${f.generated ? '\u26a1 Generated skeleton' : '\ud83d\udcc2 From repo'} |`).join('\n') + '\n';
                const fullBrief = brief + manifest;
                appFolder.file('SESSION_BRIEF.md', fullBrief);
                files.push({ name: 'SESSION_BRIEF.md', size: fullBrief.length, tokens: TokenRegistryService.estimateTokens(fullBrief, 'SESSION_BRIEF.md') });
                
                // === Build zip ===
                addLog('\ud83d\udce6 Building zip...');
                setProgress({ current: 9, total: 9 });
                
                const ver = app.versions?.prod || app.versions?.test || '0.0.0';
                const filename = `${app.id}-project-v${ver}.zip`;
                const blob = await zip.generateAsync({ type: 'blob', compression: 'DEFLATE', compressionOptions: { level: 6 } });
                const blobUrl = URL.createObjectURL(blob);
                const totalSize = files.reduce((sum, f) => sum + f.size, 0);
                
                addLog(`\ud83c\udf89 Package ready: ${filename} (${(blob.size / 1024).toFixed(0)}KB compressed)`, 'success');
                if (missingDocs.length > 0) addLog(`\u26a0\ufe0f ${missingDocs.length} doc${missingDocs.length > 1 ? 's were' : ' was'} generated as skeleton${missingDocs.length > 1 ? 's' : ''} \u2014 flesh out during the session`, 'warn');
                
                const totalTokens = files.reduce((sum, f) => sum + (f.tokens || 0), 0);
                const budget = EngineRegistryService.checkBudget(totalTokens);
                
                addLog(`\ud83d\udcca Token estimate: ${TokenRegistryService.formatTokens(totalTokens)} (${budget.percentUsed}% of ${budget.engine.name} budget)`, budget.fits ? 'success' : 'warn');
                
                // === Phase 2.2: Work item auto-transition to in-progress ===
                if (firebaseUid && selectedWorkItems.length > 0) {
                    for (const wi of selectedWorkItems) {
                        if (wi.status === 'ready') {
                            try {
                                await WorkItemService.updateStatus(firebaseUid, wi.id, 'in-progress');
                                addLog(`\u27a1\ufe0f ${wi.id} \u2192 in-progress`, 'success');
                            } catch (e) {
                                addLog(`\u26a0\ufe0f Could not transition ${wi.id}: ${e.message}`, 'warn');
                            }
                        }
                    }
                }
                
                setResult({ blobUrl, filename, fileCount: files.length, totalSize, missingDocs, files, totalTokens, budget, sessionType });
                setStatus('done');
                setPhase('done');
                
            } catch (e) {
                addLog(`\u274c Error: ${e.message}`, 'error');
                setStatus('error');
                setPhase('error');
            }
        };
        
        // Cleanup blob URL on unmount
        React.useEffect(() => {
            return () => { if (result?.blobUrl) URL.revokeObjectURL(result.blobUrl); };
        }, [result]);
        
        const download = () => {
            if (!result) return;
            const a = document.createElement('a');
            a.href = result.blobUrl;
            a.download = result.filename;
            a.click();
        };
        
        // === Doc Upload Functions (preserved from Phase 2.1) ===
        const ALLOWED_DOC_NAMES = ['CONTEXT.md', 'PROJECT_PLAN.md', 'CHANGELOG.md', 'RELEASE_NOTES.txt', 'ARCHITECTURE.md', 'DATA_MODEL.md', 'UX_LAYERS.md', 'VOICE_OPTIMIZATION.md', 'QUOTE_MIGRATION.md'];
        
        const handleDocDrop = async (e) => {
            e.preventDefault();
            e.stopPropagation();
            const files = Array.from(e.dataTransfer?.files || e.target?.files || []);
            if (files.length === 0) return;
            // Prefer test repo (development-first workflow)
            const repo = app.repos?.test || app.testRepo || app.repos?.prod || app.prodRepo;
            if (!repo) return;
            const subPath = app.subPath || '';
            let docFiles = [];
            for (const file of files) {
                if (file.name.endsWith('.zip')) {
                    try {
                        const zipData = await file.arrayBuffer();
                        const zip = await JSZip.loadAsync(zipData);
                        for (const [path, entry] of Object.entries(zip.files)) {
                            if (entry.dir) continue;
                            const name = path.split('/').pop();
                            if (name.endsWith('.md') || name.endsWith('.txt')) {
                                const content = await entry.async('string');
                                docFiles.push({ name, content });
                            }
                        }
                    } catch (err) { await showAlert('Failed to read zip: ' + err.message); return; }
                } else if (file.name.endsWith('.md') || file.name.endsWith('.txt')) {
                    const content = await file.text();
                    docFiles.push({ name: file.name, content });
                }
            }
            if (docFiles.length === 0) { await showAlert('No .md or .txt doc files found.'); return; }
            const deduped = {};
            for (const f of docFiles) { deduped[f.name] = f; }
            docFiles = Object.values(deduped);
            const parsed = [];
            for (const doc of docFiles) {
                const docsPathLocal = getDocsPath(app);
                const paths = docsPathLocal
                    ? [`${docsPathLocal}/${doc.name}`, `${subPath}/${doc.name}`, doc.name]
                    : subPath ? [`${subPath}/${doc.name}`, doc.name] : [doc.name];
                let existingSha = null;
                let targetPath = paths[0];
                for (const tryPath of paths) {
                    try {
                        const existing = await github.getFile(repo, tryPath);
                        if (existing) { existingSha = existing.sha; targetPath = tryPath; break; }
                    } catch (e) { /* not found */ }
                }
                if (!existingSha && !subPath) targetPath = doc.name;
                else if (!existingSha && subPath) targetPath = docsPathLocal ? `${docsPathLocal}/${doc.name}` : `${subPath}/${doc.name}`;
                parsed.push({ name: doc.name, content: doc.content, size: doc.content.length, existing: !!existingSha, sha: existingSha, targetPath });
            }
            setUploadFiles(parsed);
        };
        
        const pushDocsToRepo = async () => {
            if (!github || uploadFiles.length === 0) return;
            // Prefer test repo (development-first workflow)
            const repo = app.repos?.test || app.testRepo || app.repos?.prod || app.prodRepo;
            if (!repo) return;
            setUploading(true);
            setUploadLog([]);
            const actuallyPushedDocs = [];
            let skippedCount = 0;
            for (const doc of uploadFiles) {
                try {
                    // For existing files, check if content actually changed
                    if (doc.existing) {
                        const existing = await github.getFile(repo, doc.targetPath);
                        if (existing && isDocUnchanged(existing, doc.content)) {
                            setUploadLog(prev => [...prev, { msg: `\u23ed\ufe0f ${doc.name} unchanged, skipping`, type: 'info' }]);
                            skippedCount++;
                            continue;
                        }
                    }
                    
                    const action = doc.existing ? 'Updating' : 'Creating';
                    setUploadLog(prev => [...prev, { msg: `\ud83d\udce4 ${action} ${doc.targetPath}...`, type: 'info' }]);
                    await github.createOrUpdateFile(repo, doc.targetPath, doc.content, `${doc.existing ? 'Update' : 'Add'} ${doc.name} via Command Center`, doc.sha);
                    setUploadLog(prev => [...prev, { msg: `\u2705 ${doc.name} pushed to ${doc.targetPath}`, type: 'success' }]);
                    actuallyPushedDocs.push({ name: doc.name, content: doc.content });
                } catch (e) {
                    setUploadLog(prev => [...prev, { msg: `\u274c Failed to push ${doc.name}: ${e.message}`, type: 'error' }]);
                }
            }
            setUploading(false);
            const doneMsg = skippedCount > 0
                ? `\ud83c\udf89 Done! ${actuallyPushedDocs.length} pushed, ${skippedCount} unchanged.`
                : '\ud83c\udf89 Done! Docs are now in the repo.';
            setUploadLog(prev => [...prev, { msg: doneMsg, type: 'success' }]);
            
            // Check actually-changed docs for concepts (skip unchanged)
            if (actuallyPushedDocs.length > 0 && showPrompt) {
                checkPushedDocsForConcepts(actuallyPushedDocs, globalStreams, null, showPrompt, {
                    uid: firebaseUid,
                    updateStream: WorkStreamService.update.bind(WorkStreamService)
                }).catch(e => console.error('[Concepts] Error during concept check:', e));
            }
        };
        
        const logColors = { info: 'text-slate-400', success: 'text-green-400', warn: 'text-amber-400', error: 'text-red-400' };
        
        // === Wizard Step Labels ===
        const WIZARD_STEPS = [
            { num: 1, label: 'Work Items', icon: '\ud83d\udccb' },
            { num: 2, label: 'Session Type', icon: '\ud83c\udfaf' },
            { num: 3, label: 'Generate', icon: '\ud83d\udce6' }
        ];
        
        // === RENDER ===
        return (
            <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50" onClick={onClose}>
                <div className="bg-slate-800 rounded-xl border border-slate-600 w-full max-w-xl mx-4 max-h-[85vh] flex flex-col" onClick={e => e.stopPropagation()}>
                    {/* Header */}
                    <div className="flex items-center justify-between p-4 border-b border-slate-700">
                        <div className="flex items-center gap-3">
                            <span className="text-2xl">\ud83e\udd16</span>
                            <div>
                                <h2 className="text-lg font-semibold">Claude Session Wizard</h2>
                                <div className="text-sm text-slate-400 flex items-center gap-2">
                                    <AppIcon icon={app.icon} size={16} />
                                    {app.name}
                                    {app.versions?.prod && <span className="text-xs bg-green-900/40 text-green-300 px-1.5 rounded">v{app.versions.prod}</span>}
                                </div>
                            </div>
                        </div>
                        <button onClick={onClose} className="text-slate-400 hover:text-white text-xl px-2">\u2715</button>
                    </div>
                    
                    {/* === Wizard Step Indicator === */}
                    {phase === 'wizard' && (
                        <div className="flex items-center gap-1 px-4 pt-3 pb-1">
                            {WIZARD_STEPS.map((s, i) => (
                                <React.Fragment key={s.num}>
                                    <button 
                                        onClick={() => s.num < wizardStep && setWizardStep(s.num)}
                                        className={`flex items-center gap-1.5 px-2.5 py-1.5 rounded-full text-xs font-medium transition-all ${
                                            wizardStep === s.num 
                                                ? 'bg-purple-600/30 text-purple-200 border border-purple-500' 
                                                : wizardStep > s.num 
                                                    ? 'bg-green-900/20 text-green-400 border border-green-800 cursor-pointer hover:bg-green-900/30'
                                                    : 'bg-slate-700/30 text-slate-500 border border-slate-700'
                                        }`}>
                                        <span>{wizardStep > s.num ? '\u2713' : s.icon}</span>
                                        <span className="hidden sm:inline">{s.label}</span>
                                        <span className="sm:hidden">{s.num}</span>
                                    </button>
                                    {i < WIZARD_STEPS.length - 1 && (
                                        <div className={`flex-1 h-px ${wizardStep > s.num ? 'bg-green-700' : 'bg-slate-700'}`} />
                                    )}
                                </React.Fragment>
                            ))}
                        </div>
                    )}
                    
                    {/* === STEP 1: Work Items === */}
                    {phase === 'wizard' && wizardStep === 1 && (
                        appWorkItems.length === 0 ? (
                            /* Quick Build Bypass: 0 work items → one-screen summary */
                            <div className="flex-1 overflow-y-auto p-5 min-h-0 space-y-4">
                                <div className="text-sm font-medium text-slate-300 mb-1">Quick Build</div>
                                <div className="text-xs text-slate-500 mb-3">No open work items — this will generate a general session package.</div>
                                
                                <div className="bg-slate-900/50 rounded-lg p-4 space-y-3 text-xs">
                                    <div className="flex items-center justify-between">
                                        <span className="text-slate-500">App</span>
                                        <span className="text-slate-300 flex items-center gap-1.5"><AppIcon icon={app.icon} size={14} /> {app.name}</span>
                                    </div>
                                    <div className="flex items-center justify-between">
                                        <span className="text-slate-500">Session Type</span>
                                        <span className="text-slate-300">General (no targeted items)</span>
                                    </div>
                                    <div className="flex items-center justify-between">
                                        <span className="text-slate-500">Engine</span>
                                        <span className="text-slate-300">{activeEngine?.name || 'Default'}</span>
                                    </div>
                                    <div className="flex items-center justify-between">
                                        <span className="text-slate-500">Source Files</span>
                                        <span className="text-slate-300">Included</span>
                                    </div>
                                </div>
                                
                                <div className="bg-green-900/15 border border-green-800/30 rounded-lg p-3 text-xs text-green-300 flex items-center gap-2">
                                    <span className="text-green-400">\u2713</span>
                                    <span>Package fits — Claude will see everything needed.</span>
                                </div>
                                
                                <div className="pt-2">
                                    <button onClick={quickBuild}
                                        className="w-full py-3 bg-purple-600 hover:bg-purple-500 rounded-lg font-medium text-sm flex items-center justify-center gap-2 transition-colors">
                                        \ud83d\udce6 Generate Package
                                    </button>
                                </div>
                            </div>
                        ) : (
                        <div className="flex-1 overflow-y-auto p-5 min-h-0 space-y-4">
                            <div className="text-sm font-medium text-slate-300 mb-1">What are you working on?</div>
                            <div className="text-xs text-slate-500 mb-3">Build a Claude briefing package. Select work items to focus on, or skip for a general session.</div>
                            
                            {/* Stream filter (Phase 5.2) */}
                            {appStreams.length > 0 && (
                                <div className="flex items-center gap-2 mb-2">
                                    <span className="text-xs text-slate-500">Stream:</span>
                                    <select value={streamFilter} onChange={e => setStreamFilter(e.target.value)}
                                        className="bg-slate-700 border border-slate-600 rounded px-2 py-1 text-xs">
                                        <option value="all">All streams</option>
                                        {appStreams.map(s => (
                                            <option key={s.id} value={s.id}>🔀 {s.name}</option>
                                        ))}
                                        <option value="unassigned">📋 Unassigned</option>
                                    </select>
                                </div>
                            )}
                            
                            {appWorkItems.length > 0 ? (
                                <div className="space-y-1.5 max-h-64 overflow-y-auto">
                                    {appWorkItems.map(wi => {
                                        const isSelected = selectedWorkItems.some(w => w.id === wi.id);
                                        const typeColors = { feature: 'text-blue-400', bugfix: 'text-red-400', enhancement: 'text-green-400', chore: 'text-slate-400', research: 'text-amber-400' };
                                        return (
                                            <button key={wi.id}
                                                onClick={() => handleWorkItemToggle(wi)}
                                                className={`w-full text-left px-3 py-2.5 rounded-lg text-xs flex items-center gap-2 transition-all border ${
                                                    isSelected 
                                                        ? 'bg-purple-600/20 border-purple-500/50 text-slate-200' 
                                                        : 'bg-slate-700/30 border-transparent text-slate-400 hover:bg-slate-700/50'
                                                }`}>
                                                <span className={`w-4 h-4 flex items-center justify-center rounded border ${
                                                    isSelected ? 'bg-purple-600 border-purple-500 text-white' : 'border-slate-600'
                                                }`}>
                                                    {isSelected && '\u2713'}
                                                </span>
                                                <span className="font-mono text-slate-500">{wi.id}</span>
                                                <span className={typeColors[wi.type] || 'text-slate-400'}>{wi.type}</span>
                                                <span className="flex-1 truncate text-slate-300">{wi.title}</span>
                                                <span className={`px-1.5 py-0.5 rounded text-[10px] ${
                                                    wi.status === 'in-progress' ? 'bg-blue-900/30 text-blue-300' : 'bg-slate-700 text-slate-400'
                                                }`}>{wi.status}</span>
                                            </button>
                                        );
                                    })}
                                </div>
                            ) : (
                                <div className="bg-slate-900/30 rounded-lg p-4 text-center text-sm text-slate-500">
                                    No open work items for this app.
                                    <div className="text-xs mt-1 text-slate-600">This will be a general session.</div>
                                </div>
                            )}
                            
                            {selectedWorkItems.length > 0 && (
                                <div className="bg-purple-900/20 border border-purple-800/50 rounded-lg p-3 text-xs text-purple-300">
                                    \ud83d\udccb {selectedWorkItems.length} item{selectedWorkItems.length > 1 ? 's' : ''} selected
                                    {selectedWorkItems.filter(wi => wi.status === 'ready').length > 0 && (
                                        <span className="text-purple-400 ml-2">
                                            \u2192 {selectedWorkItems.filter(wi => wi.status === 'ready').length} will transition to in-progress
                                        </span>
                                    )}
                                </div>
                            )}
                        </div>
                        )
                    )}
                    
                    {/* === STEP 2: Session Type + Context Preview === */}
                    {phase === 'wizard' && wizardStep === 2 && (
                        <div className="flex-1 overflow-y-auto p-5 min-h-0 space-y-4">
                            <div className="text-sm font-medium text-slate-300 mb-1">Session Type</div>
                            <div className="text-xs text-slate-500 mb-3">
                                {selectedWorkItems.length > 0 && sessionType 
                                    ? `Auto-suggested from work item type. This determines how Claude approaches the work and what context it receives.` 
                                    : 'Choose what kind of work you\'ll be doing. This shapes Claude\'s approach and the files included.'}
                            </div>
                            
                            <div className="grid grid-cols-4 gap-1.5">
                                {SessionBriefGenerator.getAll().map(t => (
                                    <button key={t.id}
                                        onClick={() => setSessionType(sessionType === t.id ? null : t.id)}
                                        className={`py-2.5 px-1.5 rounded-lg text-center text-xs transition-all border ${
                                            sessionType === t.id 
                                                ? 'bg-purple-600/30 border-purple-500 text-purple-200' 
                                                : 'bg-slate-700/50 border-slate-600/50 text-slate-400 hover:bg-slate-700 hover:text-slate-300'
                                        }`}>
                                        <div className="text-lg mb-0.5">{t.icon}</div>
                                        <div>{t.label}</div>
                                    </button>
                                ))}
                            </div>
                            
                            {typeInfo && (
                                <div className="bg-slate-900/50 rounded-lg p-3 text-xs space-y-2">
                                    <div className="text-slate-300">{typeInfo.description}</div>
                                    {suggestedEngine && (
                                        <div className="text-slate-500">Suggested engine: <span className="text-slate-400">{suggestedEngine.name}</span></div>
                                    )}
                                    <div className="text-slate-400 italic text-[11px]">"{typeInfo.roleFrame}"</div>
                                    <div className="space-y-0.5 mt-1">
                                        {typeInfo.scopeRules.map((rule, i) => (
                                            <div key={i} className="text-slate-500 flex items-start gap-1.5">
                                                <span className="text-slate-600 mt-0.5">\u2022</span> {rule}
                                            </div>
                                        ))}
                                    </div>
                                    <div className="pt-2 border-t border-slate-800">
                                        <div className="text-slate-500 font-medium mb-1">Delivery requirements:</div>
                                        {typeInfo.deliveryRequirements.map((req, i) => (
                                            <div key={i} className="text-slate-500 flex items-start gap-1.5">
                                                <span className="text-green-700 mt-0.5">\u2713</span> {req}
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            )}
                            
                            {/* Context confidence indicator (replaces old Step 3) */}
                            <div className="bg-green-900/15 border border-green-800/30 rounded-lg p-3 text-xs text-green-300 flex items-center gap-2">
                                <span className="text-green-400">\u2713</span>
                                <span>Package fits — Claude will see everything needed for this session.</span>
                            </div>
                            
                            {/* Collapsible: What Claude will see */}
                            <details className="group">
                                <summary className="text-xs text-slate-500 cursor-pointer hover:text-slate-300 transition-colors select-none flex items-center gap-1">
                                    <span className="text-[10px] group-open:rotate-90 transition-transform inline-block">\u25b6</span>
                                    What Claude will see
                                </summary>
                                <div className="mt-2 space-y-2">
                                    {typeInfo ? (
                                        <div className="space-y-1">
                                            {typeInfo.contextStrategy.includeSource && (
                                                <div className="flex items-center gap-2 px-3 py-1.5 bg-green-900/20 rounded text-xs">
                                                    <span className="text-green-400">\u2713</span>
                                                    <span className="text-green-300 font-mono">{app.targetPath || 'index.html'}</span>
                                                    <span className="text-green-600 ml-auto">source</span>
                                                </div>
                                            )}
                                            {!typeInfo.contextStrategy.includeSource && (
                                                <div className="flex items-center gap-2 px-3 py-1.5 bg-slate-800 rounded text-xs">
                                                    <span className="text-slate-600">\u2212</span>
                                                    <span className="text-slate-500 font-mono line-through">{app.targetPath || 'index.html'}</span>
                                                    <span className="text-amber-600 ml-auto">skipped</span>
                                                </div>
                                            )}
                                            {typeInfo.contextStrategy.alwaysInclude.map(f => (
                                                <div key={f} className="flex items-center gap-2 px-3 py-1.5 bg-green-900/20 rounded text-xs">
                                                    <span className="text-green-400">\u2713</span>
                                                    <span className="text-green-300 font-mono">{f}</span>
                                                    <span className="text-green-600 ml-auto">always</span>
                                                </div>
                                            ))}
                                            {typeInfo.contextStrategy.preferInclude.map(f => (
                                                <div key={f} className="flex items-center gap-2 px-3 py-1.5 bg-slate-700/50 rounded text-xs">
                                                    <span className="text-slate-400">+</span>
                                                    <span className="text-slate-300 font-mono">{f}</span>
                                                    <span className="text-slate-500 ml-auto">preferred</span>
                                                </div>
                                            ))}
                                            {typeInfo.contextStrategy.skipWhenTight.map(f => (
                                                <div key={f} className="flex items-center gap-2 px-3 py-1.5 bg-slate-800 rounded text-xs">
                                                    <span className="text-slate-600">\u2212</span>
                                                    <span className="text-slate-500 font-mono">{f}</span>
                                                    <span className="text-slate-600 ml-auto">skipped</span>
                                                </div>
                                            ))}
                                            <div className="text-xs text-slate-500 mt-2">
                                                + SESSION_BRIEF.md (auto-generated) + any extra .md/.txt files found in repo
                                            </div>
                                        </div>
                                    ) : (
                                        <div className="bg-slate-900/30 rounded-lg p-3 text-xs text-slate-500">
                                            All standard docs + source files will be included. Select a session type above to optimize file selection.
                                        </div>
                                    )}
                                </div>
                            </details>
                            
                            {/* Work item context note */}
                            {selectedWorkItems.length > 0 && (
                                <div className="bg-purple-900/15 border border-purple-800/30 rounded-lg p-3 text-xs text-purple-300">
                                    \ud83d\udccb Session brief will include acceptance criteria, files affected, and dependencies for {selectedWorkItems.length} targeted work item{selectedWorkItems.length > 1 ? 's' : ''}.
                                </div>
                            )}
                        </div>
                    )}
                    
                    {/* === STEP 3: Generate (summary before building) === */}
                    {phase === 'wizard' && wizardStep === 3 && (
                        <div className="flex-1 overflow-y-auto p-5 min-h-0 space-y-4">
                            <div className="text-sm font-medium text-slate-300 mb-1">Ready to Generate</div>
                            <div className="text-xs text-slate-500 mb-3">Generate a zip package with source, docs, and a session brief to upload to Claude.</div>
                            
                            {/* Summary */}
                            <div className="bg-slate-900/50 rounded-lg p-4 space-y-3 text-xs">
                                <div className="flex items-center justify-between">
                                    <span className="text-slate-500">Session Type</span>
                                    <span className="text-slate-300">{typeInfo ? `${typeInfo.icon} ${typeInfo.label}` : 'General (no type)'}</span>
                                </div>
                                <div className="flex items-center justify-between">
                                    <span className="text-slate-500">Work Items</span>
                                    <span className="text-slate-300">{selectedWorkItems.length > 0 ? selectedWorkItems.map(wi => wi.id).join(', ') : 'None (general session)'}</span>
                                </div>
                                <div className="flex items-center justify-between">
                                    <span className="text-slate-500">Engine</span>
                                    <span className="text-slate-300">{activeEngine?.name || 'Default'}</span>
                                </div>
                                <div className="flex items-center justify-between">
                                    <span className="text-slate-500">Source Files</span>
                                    <span className="text-slate-300">{typeInfo?.contextStrategy?.includeSource === false ? 'Excluded' : 'Included'}</span>
                                </div>
                                {selectedWorkItems.filter(wi => wi.status === 'ready').length > 0 && (
                                    <div className="pt-2 border-t border-slate-700 text-purple-300">
                                        \u27a1\ufe0f {selectedWorkItems.filter(wi => wi.status === 'ready').length} work item{selectedWorkItems.filter(wi => wi.status === 'ready').length > 1 ? 's' : ''} will transition to <strong>in-progress</strong>
                                    </div>
                                )}
                            </div>
                        </div>
                    )}
                    
                    {/* === Wizard Footer (navigation) === */}
                    {phase === 'wizard' && (
                        <div className="p-4 border-t border-slate-700 space-y-2">
                            <div className="flex gap-2">
                                {wizardStep > 1 && (
                                    <button onClick={goBack}
                                        className="px-4 py-2.5 bg-slate-700 hover:bg-slate-600 rounded-lg text-sm transition-colors">
                                        \u2190 Back
                                    </button>
                                )}
                                {wizardStep < 3 && (
                                    <button onClick={goNext}
                                        className="flex-1 py-2.5 bg-purple-600 hover:bg-purple-500 rounded-lg font-medium text-sm transition-colors">
                                        Next \u2192
                                    </button>
                                )}
                                {wizardStep === 3 && (
                                    <button onClick={startPrep}
                                        className="flex-1 py-2.5 bg-purple-600 hover:bg-purple-500 rounded-lg font-medium text-sm flex items-center justify-center gap-2 transition-colors">
                                        \ud83d\udce6 Generate Package{sessionType ? ` (${SESSION_TYPES[sessionType].icon} ${SESSION_TYPES[sessionType].label})` : ''}
                                    </button>
                                )}
                            </div>
                            {wizardStep === 1 && (
                                <button onClick={quickBuild}
                                    className="w-full py-2 text-sm text-slate-500 hover:text-slate-300 transition-colors">
                                    Skip wizard \u2014 Quick package
                                </button>
                            )}
                        </div>
                    )}
                    
                    {/* === Building/Done/Error Phase (same as before) === */}
                    {(phase === 'building' || phase === 'done' || phase === 'error') && (
                        <React.Fragment>
                    
                    {status === 'fetching' && progress.total > 0 && (
                        <div className="px-5 pt-3">
                            <div className="h-1.5 bg-slate-700 rounded-full overflow-hidden">
                                <div className="h-full bg-purple-500 rounded-full transition-all duration-300"
                                    style={{ width: `${(progress.current / progress.total) * 100}%` }} />
                            </div>
                        </div>
                    )}
                    
                    <div className="flex-1 overflow-y-auto p-5 min-h-0">
                        <div className="space-y-1 font-mono text-xs">
                            {log.map((entry, i) => (
                                <div key={i} className={logColors[entry.type] || 'text-slate-400'}>
                                    <span className="text-slate-600 mr-2">{entry.time}</span>
                                    {entry.msg}
                                </div>
                            ))}
                            {status === 'fetching' && (
                                <div className="text-purple-400 animate-pulse">\u23f3 Working...</div>
                            )}
                        </div>
                    </div>
                    
                    <div className="p-5 border-t border-slate-700">
                        {status === 'done' && result && (
                            <div className="space-y-3">
                                <div className="flex items-center gap-4 text-sm flex-wrap">
                                    <div className="flex items-center gap-1.5 text-slate-300"><span>\ud83d\udce6</span> {result.fileCount} files</div>
                                    <div className="flex items-center gap-1.5 text-slate-300"><span>\ud83d\udcbe</span> {(result.totalSize / 1024).toFixed(0)}KB</div>
                                    <div className="flex items-center gap-1.5 text-slate-300"><span>\ud83e\uddee</span> {TokenRegistryService.formatTokens(result.totalTokens)} tokens</div>
                                    {result.missingDocs.length > 0 && (
                                        <div className="flex items-center gap-1.5 text-amber-400"><span>\u26a1</span> {result.missingDocs.length} skeleton{result.missingDocs.length > 1 ? 's' : ''}</div>
                                    )}
                                    {sessionRecord && (
                                        <div className="flex items-center gap-1.5 text-green-400"><span>\ud83d\udcdd</span> {sessionRecord.id}</div>
                                    )}
                                </div>
                                
                                {result.budget && (() => {
                                    const b = result.budget;
                                    const pct = Math.min(b.percentUsed, 100);
                                    const barColor = b.percentUsed <= 50 ? 'bg-green-500' : b.percentUsed <= 75 ? 'bg-emerald-500' : b.percentUsed <= 90 ? 'bg-amber-500' : b.fits ? 'bg-orange-500' : 'bg-red-500';
                                    const textColor = b.fits ? 'text-slate-400' : 'text-red-400';
                                    return (
                                        <div className="bg-slate-900 rounded-lg p-3">
                                            <div className="flex items-center justify-between text-xs mb-1.5">
                                                <span className="text-slate-400 font-medium">{b.engine.name}</span>
                                                <span className={textColor}>{TokenRegistryService.formatTokens(b.tokenCount)} / {TokenRegistryService.formatTokens(b.usableLimit)} usable ({b.percentUsed}%)</span>
                                            </div>
                                            <div className="h-2.5 bg-slate-700 rounded-full overflow-hidden">
                                                <div className={`h-full rounded-full transition-all duration-500 ${barColor}`} style={{ width: `${pct}%` }} />
                                            </div>
                                            <div className="flex justify-between text-[10px] text-slate-600 mt-1">
                                                <span>0</span>
                                                <span>{TokenRegistryService.formatTokens(b.limit)} total ({TokenRegistryService.formatTokens(b.usableLimit)} usable \u00b7 20% reserved)</span>
                                            </div>
                                            {!b.fits && b.recommendations.length > 0 && (
                                                <div className="mt-2.5 pt-2.5 border-t border-slate-700">
                                                    <div className="text-xs text-red-400 font-medium mb-1.5">\u26a0\ufe0f Over budget by {TokenRegistryService.formatTokens(b.overBy)} tokens</div>
                                                    <div className="space-y-1">{b.recommendations.map((rec, i) => (
                                                        <div key={i} className="flex items-start gap-2 text-xs">
                                                            <span className="text-slate-500 mt-0.5">\u2022</span>
                                                            <div><span className="text-slate-300">{rec.label}</span>{rec.savings && <span className="text-green-500 ml-1">({rec.savings})</span>}{rec.cost && <span className="text-amber-500 ml-1">({rec.cost})</span>}</div>
                                                        </div>
                                                    ))}</div>
                                                </div>
                                            )}
                                        </div>
                                    );
                                })()}
                                
                                {result.files && result.files.length > 0 && (
                                    <details className="group">
                                        <summary className="text-xs text-slate-500 cursor-pointer hover:text-slate-300 select-none">\ud83d\udccb File manifest ({result.files.length} files)</summary>
                                        <div className="mt-2 bg-slate-900 rounded-lg overflow-hidden">
                                            <table className="w-full text-xs">
                                                <thead><tr className="text-slate-500 border-b border-slate-700">
                                                    <th className="text-left py-1.5 px-2 font-medium">File</th>
                                                    <th className="text-right py-1.5 px-2 font-medium">Size</th>
                                                    <th className="text-right py-1.5 px-2 font-medium">Tokens</th>
                                                    <th className="text-right py-1.5 px-2 font-medium">%</th>
                                                </tr></thead>
                                                <tbody>{[...result.files].sort((a, b) => (b.tokens || 0) - (a.tokens || 0)).map((f, i) => {
                                                    const pctOfTotal = result.totalTokens ? Math.round(((f.tokens || 0) / result.totalTokens) * 100) : 0;
                                                    return (<tr key={i} className="border-b border-slate-800 hover:bg-slate-800/50">
                                                        <td className="py-1 px-2 font-mono text-slate-300">{f.generated ? '\u26a1 ' : ''}{f.name}</td>
                                                        <td className="py-1 px-2 text-right text-slate-500">{(f.size / 1024).toFixed(1)}KB</td>
                                                        <td className="py-1 px-2 text-right text-slate-400">{TokenRegistryService.formatTokens(f.tokens || 0)}</td>
                                                        <td className="py-1 px-2 text-right"><span className={pctOfTotal > 50 ? 'text-amber-400' : pctOfTotal > 25 ? 'text-slate-300' : 'text-slate-500'}>{pctOfTotal}%</span></td>
                                                    </tr>);
                                                })}</tbody>
                                                <tfoot><tr className="border-t border-slate-600 font-medium">
                                                    <td className="py-1.5 px-2 text-slate-300">Total</td>
                                                    <td className="py-1.5 px-2 text-right text-slate-400">{(result.totalSize / 1024).toFixed(0)}KB</td>
                                                    <td className="py-1.5 px-2 text-right text-slate-300">{TokenRegistryService.formatTokens(result.totalTokens)}</td>
                                                    <td className="py-1.5 px-2 text-right text-slate-500">100%</td>
                                                </tr></tfoot>
                                            </table>
                                        </div>
                                    </details>
                                )}
                                
                                <button onClick={download} className="w-full py-3 bg-purple-600 hover:bg-purple-500 rounded-lg font-medium flex items-center justify-center gap-2 transition-colors">
                                    \u2b07\ufe0f Download {result.filename}
                                </button>
                                
                                {result.missingDocs.length > 0 && (
                                    <div className="text-xs text-amber-400/80 bg-amber-900/20 rounded-lg p-3">
                                        <strong>Skeleton docs generated:</strong> {result.missingDocs.join(', ')}. 
                                        These are templates \u2014 flesh them out during your first session with this app, 
                                        then commit the docs to the repo so future preps pull the real versions.
                                    </div>
                                )}
                                
                                {!uploadMode && uploadFiles.length === 0 && (
                                    <button onClick={() => setUploadMode(true)}
                                        className="w-full py-2 rounded-lg text-sm flex items-center justify-center gap-2 transition-colors bg-slate-700 hover:bg-slate-600 text-slate-300">
                                        \ud83d\udcc4 Push Docs to Repo
                                    </button>
                                )}
                            </div>
                        )}
                        
                        {(uploadMode || uploadFiles.length > 0) && (
                            <div className="space-y-3 mt-3">
                                {uploadFiles.length === 0 && (
                                    <div>
                                        <div onDrop={handleDocDrop} onDragOver={e => { e.preventDefault(); e.stopPropagation(); }}
                                            onClick={() => { const input = document.createElement('input'); input.type = 'file'; input.multiple = true; input.accept = '.md,.txt,.zip'; input.onchange = handleDocDrop; input.click(); }}
                                            className="border-2 border-dashed border-slate-600 hover:border-indigo-500 rounded-lg p-4 text-center cursor-pointer transition-colors">
                                            <div className="text-slate-400 text-sm">\ud83d\udcc4 Drop doc files or a project zip here</div>
                                            <div className="text-xs text-slate-500 mt-1">Accepts .md, .txt files or .zip packages</div>
                                        </div>
                                        <button onClick={() => setUploadMode(false)} className="w-full mt-2 py-1.5 text-xs text-slate-500 hover:text-slate-300">Cancel</button>
                                    </div>
                                )}
                                {uploadFiles.length > 0 && (
                                    <div className="space-y-2">
                                        <div className="flex items-center justify-between">
                                            <div className="text-xs text-slate-400 font-medium">Files to push:</div>
                                            <button onClick={() => { setUploadFiles([]); setUploadLog([]); }} className="text-xs text-slate-500 hover:text-red-400">\u2715 Clear</button>
                                        </div>
                                        {uploadFiles.map((f, i) => (
                                            <div key={i} className="flex items-center justify-between bg-slate-900 rounded px-3 py-2 text-sm">
                                                <div className="flex items-center gap-2">
                                                    <span>{f.existing ? '\ud83d\udd04' : '\ud83c\udd95'}</span>
                                                    <span className="font-mono text-slate-300">{f.name}</span>
                                                    <span className="text-xs text-slate-500">({(f.size / 1024).toFixed(1)}KB)</span>
                                                </div>
                                                <div className="text-xs text-slate-500 font-mono">{f.targetPath}</div>
                                            </div>
                                        ))}
                                        {!uploading && uploadLog.length === 0 && (
                                            <button onClick={pushDocsToRepo} className="w-full py-2.5 rounded-lg font-medium flex items-center justify-center gap-2 transition-colors bg-green-600 hover:bg-green-500 text-white">
                                                \ud83d\ude80 Push {uploadFiles.length} file{uploadFiles.length > 1 ? 's' : ''} to {(app.repos?.test || app.testRepo || app.repos?.prod || app.prodRepo || 'repo').split('/').pop()}
                                            </button>
                                        )}
                                        {uploading && (
                                            <div className="w-full py-2.5 rounded-lg font-medium flex items-center justify-center gap-2 bg-slate-700 text-amber-400 animate-pulse">\u23f3 Pushing files to repo...</div>
                                        )}
                                    </div>
                                )}
                                {uploadLog.length > 0 && (
                                    <div className="space-y-2">
                                        <div className="bg-slate-900 rounded-lg p-3 space-y-1 font-mono text-xs max-h-40 overflow-y-auto">
                                            {uploadLog.map((entry, i) => (<div key={i} className={logColors[entry.type] || 'text-slate-400'}>{entry.msg}</div>))}
                                        </div>
                                        {!uploading && uploadLog.some(e => e.type === 'success' && e.msg.includes('Done')) && (
                                            <div className="bg-green-900/30 border border-green-700 rounded-lg p-3 text-center">
                                                <div className="text-green-400 font-medium">\u2705 All docs pushed to repo</div>
                                                <div className="text-xs text-green-500 mt-1">Next Claude Prep will pull these docs automatically</div>
                                            </div>
                                        )}
                                        {!uploading && uploadLog.some(e => e.type === 'error') && !uploadLog.some(e => e.msg.includes('Done')) && (
                                            <div className="bg-red-900/30 border border-red-700 rounded-lg p-3 text-center">
                                                <div className="text-red-400 font-medium">\u26a0\ufe0f Some files failed to push</div>
                                                <button onClick={() => setUploadLog([])} className="text-xs text-slate-400 hover:text-white mt-1">Retry</button>
                                            </div>
                                        )}
                                    </div>
                                )}
                            </div>
                        )}
                        
                        {status === 'error' && (
                            <div className="flex gap-2">
                                <button onClick={() => { setPhase('wizard'); setWizardStep(4); setStatus('idle'); }} className="flex-1 py-2 bg-slate-700 hover:bg-slate-600 rounded-lg text-sm">\u2190 Back</button>
                                <button onClick={startPrep} className="flex-1 py-2 bg-slate-700 hover:bg-slate-600 rounded-lg text-sm">\ud83d\udd04 Retry</button>
                                <button onClick={onClose} className="flex-1 py-2 bg-slate-700 hover:bg-slate-600 rounded-lg text-sm">Close</button>
                            </div>
                        )}
                    </div>
                    
                    </React.Fragment>
                    )}
                </div>
            </div>
        );
    }

    // =========================================================================
    // SETUP NEW APP VIEW (v8.7.7)
    // =========================================================================
    function SetupNewAppView({ apps, github, config, updateConfig, showAlert, showConfirm, onRefreshRepos, githubOwner, firebaseUid }) {
        const [step, setStep] = React.useState(1);
        const [appData, setAppData] = React.useState({
            name: '',
            id: '',
            description: '',
            structure: 'prod-only',  // 'prod-only' or 'test-prod'
            isPWA: false,
            appType: 'other',  // 'public', 'internal', 'other'
            project: '',  // v8.8.0: Project grouping
            icon: '📦',
            hasAdmin: false,
            adminSubPath: 'admin',
            customDomain: ''
        });
        const [scopeData, setScopeData] = React.useState(null); // v8.23.0: Project scope
        const [skipScope, setSkipScope] = React.useState(false); // v8.23.0: Quick setup option
        const [showScopeInline, setShowScopeInline] = React.useState(false); // v8.23.0: Inline scope modal
        const [repoStatus, setRepoStatus] = React.useState({ checking: false, prodExists: null, testExists: null });
        const [creating, setCreating] = React.useState(false);
        const [creationLog, setCreationLog] = React.useState([]);
        const [promptGenerated, setPromptGenerated] = React.useState('');
        const [workItemsCreated, setWorkItemsCreated] = React.useState([]); // v8.28.0: Track created work items
        const [reviewData, setReviewData] = React.useState(null); // v8.28.0: Review summary for Step 5
        const [activeDocTab, setActiveDocTab] = React.useState('instructions'); // v8.29.0: Doc viewer tab

        const addLog = (msg, type = 'info') => setCreationLog(prev => [...prev, { msg, type, time: new Date().toLocaleTimeString() }]);

        // Auto-generate ID from name
        const handleNameChange = (name) => {
            const id = name.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/-+$/, '');
            setAppData(prev => ({ ...prev, name, id }));
        };

        // Get repo names
        const prodRepoName = appData.id || 'my-app';
        const testRepoName = `${prodRepoName}-test`;

        // Step 1: Check repos
        const checkRepos = async () => {
            if (!github || !githubOwner) { await showAlert('Configure GitHub token first'); return; }
            setRepoStatus({ checking: true, prodExists: null, testExists: null });
            try {
                const prodExists = await github.repoExists(githubOwner, prodRepoName);
                let testExists = null;
                if (appData.structure === 'test-prod') {
                    testExists = await github.repoExists(githubOwner, testRepoName);
                }
                setRepoStatus({ checking: false, prodExists, testExists });
            } catch (e) {
                setRepoStatus({ checking: false, prodExists: null, testExists: null });
                await showAlert('Error checking repos: ' + e.message);
            }
        };

        // Step 2: Create repos + configure
        const setupApp = async () => {
            if (!github || !githubOwner) return;
            setCreating(true);
            setCreationLog([]);

            try {
                // Create prod repo if needed
                let prodFullName = `${githubOwner}/${prodRepoName}`;
                if (!repoStatus.prodExists) {
                    addLog(`Creating repository: ${prodRepoName}...`);
                    const result = await github.createRepo(prodRepoName, appData.description, false);
                    prodFullName = result.fullName;
                    addLog(`✅ Repository created: ${prodFullName}`, 'success');

                    await new Promise(r => setTimeout(r, 2000));
                    addLog('Enabling GitHub Pages...');
                    try { await github.enablePages(prodFullName); addLog('✅ GitHub Pages enabled', 'success'); }
                    catch (e) { addLog('⚠️ Pages may need manual enabling', 'warn'); }
                } else {
                    addLog(`✅ Prod repo exists: ${prodFullName}`, 'success');
                }

                // Create test repo if needed
                let testFullName = '';
                if (appData.structure === 'test-prod') {
                    testFullName = `${githubOwner}/${testRepoName}`;
                    if (!repoStatus.testExists) {
                        addLog(`Creating test repository: ${testRepoName}...`);
                        const result = await github.createRepo(testRepoName, `${appData.description} (Test)`, false);
                        testFullName = result.fullName;
                        addLog(`✅ Test repository created: ${testFullName}`, 'success');
                        await new Promise(r => setTimeout(r, 2000));
                        try { await github.enablePages(testFullName); addLog('✅ Test Pages enabled', 'success'); }
                        catch (e) { addLog('⚠️ Test Pages may need manual enabling', 'warn'); }
                    } else {
                        addLog(`✅ Test repo exists: ${testFullName}`, 'success');
                    }
                }

                // Seed initial index.html with meta tags for detection
                addLog('Seeding initial files...');
                const initialHTML = generateInitialHTML(appData);
                try {
                    // Check if index.html already exists
                    try {
                        await github.request(`/repos/${prodFullName}/contents/index.html`);
                        addLog('index.html already exists, skipping seed', 'info');
                    } catch {
                        await github.createOrUpdateFile(prodFullName, 'index.html', initialHTML, `Initial setup: ${appData.name}`);
                        addLog('✅ Seeded index.html with app meta tags', 'success');
                    }
                } catch (e) {
                    addLog(`⚠️ Could not seed index.html: ${e.message}`, 'warn');
                }

                // Create admin directory if requested
                if (appData.hasAdmin) {
                    const adminHTML = generateAdminHTML(appData);
                    try {
                        try {
                            await github.request(`/repos/${prodFullName}/contents/${appData.adminSubPath}/index.html`);
                            addLog(`${appData.adminSubPath}/index.html already exists, skipping`, 'info');
                        } catch {
                            await github.createOrUpdateFile(prodFullName, `${appData.adminSubPath}/index.html`, adminHTML, `Initial setup: ${appData.name} Admin`);
                            addLog(`✅ Seeded ${appData.adminSubPath}/index.html`, 'success');
                        }
                    } catch (e) {
                        addLog(`⚠️ Could not seed admin: ${e.message}`, 'warn');
                    }
                }

                // Add app to Command Center config
                addLog('Adding to Command Center configuration...');
                const newAppDef = {
                    id: appData.id,
                    name: appData.name,
                    icon: appData.icon,
                    appType: appData.appType,
                    project: appData.project || appData.id,  // v8.8.0: Use selected project or create new one from app id
                    targetPath: 'index.html',
                    swPath: appData.isPWA ? 'sw.js' : '',
                    hasServiceWorker: appData.isPWA,
                    subPath: '',
                    repos: appData.structure === 'test-prod'
                        ? { test: testFullName, prod: prodFullName }
                        : { prod: prodFullName },
                    versions: appData.structure === 'test-prod'
                        ? { test: '', prod: '' }
                        : { prod: '' },
                    repoPatterns: appData.structure === 'test-prod'
                        ? { test: [testRepoName], prod: [prodRepoName] }
                        : { prod: [prodRepoName] },
                    detectionPatterns: [`gs-app-id.*${appData.id}`, `<title>.*${appData.name}`]
                };

                // Also add admin as a separate app entry if requested
                const newConfig = { ...config, apps: { ...config.apps } };
                newConfig.apps[appData.id] = {
                    ...newAppDef,
                    repos: { ...newAppDef.repos }
                };

                if (appData.hasAdmin) {
                    newConfig.apps[`${appData.id}-admin`] = {
                        id: `${appData.id}-admin`,
                        name: `${appData.name} Admin`,
                        icon: appData.icon + '🔧',
                        appType: appData.appType === 'public' ? 'internal' : appData.appType,
                        project: appData.project || appData.id,
                        targetPath: 'index.html',
                        swPath: '',
                        hasServiceWorker: false,
                        subPath: appData.adminSubPath,
                        repos: { prod: prodFullName },
                        versions: { prod: '' },
                        repoPatterns: { prod: [prodRepoName] },
                        detectionPatterns: [`gs-app-id.*${appData.id}-admin`]
                    };
                }

                updateConfig(newConfig);
                addLog('✅ App added to Command Center', 'success');

                // v8.28.0: Store lifecycle metadata with scope if available
                if (scopeData) {
                    const lifecycleData = {
                        currentMaturity: 'seed',
                        complexity: scopeData.v1Features?.length > 5 ? 'medium' : 'simple',
                        scope: {
                            description: scopeData.description || '',
                            category: scopeData.category || '',
                            categoryAnswers: scopeData.categoryAnswers || {},
                            v1Features: scopeData.v1Features || [],
                            futureFeatures: scopeData.futureFeatures || [],
                            keyDecisions: scopeData.keyDecisions || [],
                            startingStandards: scopeData.startingStandards || [],
                            scopedAt: new Date().toISOString(),
                            source: 'manual'
                        }
                    };
                    // Update the config with lifecycle data on the app
                    const configWithLifecycle = { ...newConfig, apps: { ...newConfig.apps } };
                    configWithLifecycle.apps[appData.id] = {
                        ...configWithLifecycle.apps[appData.id],
                        lifecycle: lifecycleData
                    };
                    updateConfig(configWithLifecycle);
                    addLog('📋 Lifecycle metadata stored with project scope', 'success');
                }

                // v8.28.0: Auto-create work items from scope
                let createdItems = [];
                const ownerName = config?.ownerName || 'Owner';
                if (scopeData && firebaseUid) {
                    const itemsToCreate = [];
                    let nextNum = 1;
                    const padId = (n) => `WI-${String(n).padStart(3, '0')}`;

                    // V1 features → work items (status: ready, source: scoped)
                    (scopeData.v1Features || []).forEach(f => {
                        itemsToCreate.push({
                            id: padId(nextNum++),
                            appId: appData.id,
                            title: f.title,
                            description: f.description || '',
                            type: 'feature',
                            priority: f.priority || 'core',
                            status: 'ready',
                            effort: f.effort || 'session',
                            source: 'scoped',
                            createdBy: ownerName,
                            tags: ['v1', scopeData.category || '']
                        });
                    });

                    // Future features → work items (status: idea, source: scoped)
                    (scopeData.futureFeatures || []).forEach(f => {
                        itemsToCreate.push({
                            id: padId(nextNum++),
                            appId: appData.id,
                            title: f.title,
                            description: f.description || '',
                            type: 'feature',
                            priority: 'nice-to-have',
                            status: 'idea',
                            effort: f.effort || 'session',
                            source: 'scoped',
                            createdBy: ownerName,
                            tags: ['future']
                        });
                    });

                    // Key decisions → work items (type: research, status: ready, source: scoped)
                    (scopeData.keyDecisions || []).filter(d => !d.resolved).forEach(d => {
                        itemsToCreate.push({
                            id: padId(nextNum++),
                            appId: appData.id,
                            title: d.title,
                            description: d.description || '',
                            type: 'research',
                            priority: 'core',
                            status: 'ready',
                            effort: 'quick',
                            source: 'scoped',
                            createdBy: ownerName,
                            tags: ['decision']
                        });
                    });

                    if (itemsToCreate.length > 0) {
                        try {
                            addLog(`Creating ${itemsToCreate.length} work items from scope...`);
                            createdItems = await WorkItemService.createBatch(firebaseUid, itemsToCreate);
                            addLog(`✅ ${createdItems.length} work items created in backlog`, 'success');
                        } catch (e) {
                            addLog(`⚠️ Could not create work items: ${e.message}`, 'warn');
                        }
                    }
                } else if (scopeData && !firebaseUid) {
                    addLog('⚠️ Sign in to Firebase to auto-create work items from scope', 'warn');
                }
                setWorkItemsCreated(createdItems);

                if (onRefreshRepos) {
                    addLog('Refreshing repo list...');
                    await onRefreshRepos();
                    addLog('✅ Repos refreshed', 'success');
                }

                // Generate Claude prompt (use CLAUDE_INSTRUCTIONS.md if scope available)
                let generatedPromptType = 'basic';
                let generatedInstructions = null;
                let generatedContextMd = null;
                let generatedProjectPlanMd = null;
                let generatedChangelogMd = null;
                let generatedReleaseNotes = null;
                
                if (scopeData) {
                    const instructions = generateClaudeInstructions(appData, scopeData, config);
                    if (instructions) {
                        generatedInstructions = instructions;
                        setPromptGenerated(instructions);
                        generatedPromptType = 'instructions';
                        addLog('🎯 Generated CLAUDE_INSTRUCTIONS.md from project scope', 'success');
                    } else {
                        const prompt = generateClaudePrompt(appData, prodFullName, testFullName);
                        setPromptGenerated(prompt);
                        addLog('✅ Claude project prompt generated', 'success');
                    }
                    
                    // v8.29.0: Generate CONTEXT.md and PROJECT_PLAN.md
                    generatedContextMd = generateContextMd(appData, scopeData, config);
                    generatedProjectPlanMd = generateProjectPlanMd(appData, scopeData);
                    addLog('📄 Generated CONTEXT.md and PROJECT_PLAN.md from scope', 'success');
                    
                    // Generate initial CHANGELOG.md and RELEASE_NOTES.txt
                    const today = new Date().toLocaleDateString();
                    generatedChangelogMd = `# ${appData.name} — Changelog\n\nAll notable changes to this project will be documented in this file.\n\n## [0.1.0] - ${today}\n\n### Added\n- Initial seed generated by Command Center\n- App shell with placeholder content\n`;
                    generatedReleaseNotes = `${appData.name} — Release Notes\n${'='.repeat(40)}\n\nv0.1.0 (${today})\n${'─'.repeat(30)}\n- Initial seed generated by Command Center\n- App shell with placeholder content\n`;
                    addLog('📝 Generated CHANGELOG.md and RELEASE_NOTES.txt', 'success');
                    
                } else {
                    const prompt = generateClaudePrompt(appData, prodFullName, testFullName);
                    setPromptGenerated(prompt);
                    addLog('✅ Claude project prompt generated', 'success');
                }
                
                // v8.29.0: Commit generated docs to repo
                let docsCommitted = 0;
                if (scopeData && github) {
                    addLog('📂 Committing generated docs to repository...');
                    const docsToCommit = [];
                    
                    // Determine doc path based on subPath (consolidated vs standalone repo)
                    const docPrefix = appData.subPath ? `${appData.subPath}/docs/` : '';
                    
                    if (generatedPromptType === 'instructions' && generatedInstructions) {
                        docsToCommit.push({ path: `${docPrefix}CLAUDE_INSTRUCTIONS.md`, content: generatedInstructions });
                    }
                    if (generatedContextMd) docsToCommit.push({ path: `${docPrefix}CONTEXT.md`, content: generatedContextMd });
                    if (generatedProjectPlanMd) docsToCommit.push({ path: `${docPrefix}PROJECT_PLAN.md`, content: generatedProjectPlanMd });
                    if (generatedChangelogMd) docsToCommit.push({ path: `${docPrefix}CHANGELOG.md`, content: generatedChangelogMd });
                    if (generatedReleaseNotes) docsToCommit.push({ path: `${docPrefix}RELEASE_NOTES.txt`, content: generatedReleaseNotes });
                    
                    for (const doc of docsToCommit) {
                        try {
                            // Check if file already exists
                            try {
                                await github.request(`/repos/${prodFullName}/contents/${doc.path}`);
                                addLog(`  ⏭️ ${doc.path} already exists, skipping`, 'info');
                            } catch {
                                await github.createOrUpdateFile(prodFullName, doc.path, doc.content, `Add ${doc.path.split('/').pop()} — generated by Command Center setup`);
                                docsCommitted++;
                                addLog(`  ✅ ${doc.path}`, 'success');
                            }
                        } catch (e) {
                            addLog(`  ⚠️ Could not commit ${doc.path}: ${e.message}`, 'warn');
                        }
                    }
                    
                    if (docsCommitted > 0) {
                        addLog(`📂 ${docsCommitted} docs committed to ${prodFullName}`, 'success');
                    }
                }
                
                // v8.29.0: Auto-deploy seed to test environment
                let seedDeployedToTest = false;
                if (appData.structure === 'test-prod' && testFullName && github) {
                    addLog('🚀 Auto-deploying seed to test environment...');
                    try {
                        // Check if test already has index.html
                        try {
                            await github.request(`/repos/${testFullName}/contents/${appData.subPath ? appData.subPath + '/' : ''}index.html`);
                            addLog('  ⏭️ Test already has index.html, skipping seed deploy', 'info');
                        } catch {
                            const testPath = appData.subPath ? `${appData.subPath}/index.html` : 'index.html';
                            const initialHTML = generateInitialHTML(appData);
                            await github.createOrUpdateFile(testFullName, testPath, initialHTML, `Seed deploy: ${appData.name} v0.1.0`);
                            seedDeployedToTest = true;
                            addLog('✅ Seed deployed to test environment', 'success');
                        }
                    } catch (e) {
                        addLog(`⚠️ Could not deploy seed to test: ${e.message}`, 'warn');
                    }
                }

                // v8.29.0: Build review summary (enhanced with doc generation info)
                setReviewData({
                    appName: appData.name,
                    appId: appData.id,
                    repos: {
                        prod: prodFullName,
                        test: appData.structure === 'test-prod' ? testFullName : null
                    },
                    hasScope: !!scopeData,
                    category: scopeData?.category ? (SCOPE_CATEGORIES[scopeData.category]?.icon + ' ' + SCOPE_CATEGORIES[scopeData.category]?.label) : null,
                    v1FeatureCount: scopeData?.v1Features?.length || 0,
                    futureFeatureCount: scopeData?.futureFeatures?.length || 0,
                    standardsCount: scopeData?.startingStandards?.length || 0,
                    workItemsCreated: createdItems.length,
                    promptType: generatedPromptType,
                    hasAdmin: appData.hasAdmin,
                    isPWA: appData.isPWA,
                    lifecycleStored: !!scopeData,
                    docsCommitted,
                    docsGenerated: scopeData ? ['CLAUDE_INSTRUCTIONS.md', 'CONTEXT.md', 'PROJECT_PLAN.md', 'CHANGELOG.md', 'RELEASE_NOTES.txt'] : [],
                    seedDeployedToTest,
                    generatedContextMd,
                    generatedProjectPlanMd,
                    generatedChangelogMd,
                    generatedReleaseNotes
                });

                addLog('🎉 Setup complete!', 'success');

            } catch (e) {
                addLog(`❌ Error: ${e.message}`, 'error');
            } finally {
                setCreating(false);
            }
        };

        // Generate initial HTML with proper meta tags
        const SEED_VERSION = '0.1.0';  // Initial version for new apps — extracted as constant to avoid version scanner false positives
        function generateInitialHTML(app) {
            const pwaHead = app.isPWA ? `\n    <link rel="manifest" href="manifest.json">\n    <meta name="theme-color" content="#0f172a">\n    <link rel="apple-touch-icon" href="icons/icon-192.png">` : '';
            const pwaScript = app.isPWA ? `\n    <scr` + `ipt>\n    if ('serviceWorker' in navigator) {\n        navigator.serviceWorker.register('sw.js').catch(e => console.error('SW:', e));\n    }\n    </scr` + `ipt>` : '';

            return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${app.name}</title>
    <meta name="version" content="${SEED_VERSION}">
    <meta name="gs-app-id" content="${app.id}">
    <meta name="description" content="${app.description}">${pwaHead}
    <style>
        body { margin:0; font-family:system-ui,-apple-system,sans-serif; background:#0f172a; color:#e2e8f0; display:flex; align-items:center; justify-content:center; min-height:100vh; }
        .container { text-align:center; max-width:500px; padding:40px; }
        h1 { font-size:2rem; margin-bottom:8px; }
        p { color:#94a3b8; }
    </style>
</head>
<body>
    <div class="container">
        <h1>${app.icon} ${app.name}</h1>
        <p>${app.description || 'Coming soon'}</p>
        <p style="font-size:0.8rem;color:#475569;margin-top:24px;">v${SEED_VERSION} · Part of the Game Shelf ecosystem</p>
    </div>${pwaScript}
</body>
</html>`;
        }

        function generateAdminHTML(app) {
            return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${app.name} — Admin</title>
    <meta name="version" content="${SEED_VERSION}">
    <meta name="gs-app-id" content="${app.id}-admin">
    <style>
        body { margin:0; font-family:system-ui,-apple-system,sans-serif; background:#0f172a; color:#e2e8f0; display:flex; align-items:center; justify-content:center; min-height:100vh; }
        .container { text-align:center; max-width:500px; padding:40px; }
    </style>
</head>
<body>
    <div class="container">
        <h1>🔧 ${app.name} Admin</h1>
        <p style="color:#94a3b8;">Admin panel placeholder — replace with your admin tool</p>
        <p style="font-size:0.8rem;color:#475569;margin-top:24px;">v${SEED_VERSION}</p>
    </div>
</body>
</html>`;
        }

        // Generate the Claude project prompt
        function generateClaudePrompt(app, prodRepo, testRepo) {
            const isPWA = app.isPWA;
            const hasTest = app.structure === 'test-prod';
            const hasAdmin = app.hasAdmin;

            const deployFilesList = isPWA
                ? `- index.html (main app — single file, all CSS/JS inline)
- sw.js (service worker for offline support)
- manifest.json (PWA manifest with app name, icons, theme)
- icons/ folder (icon-192.png, icon-512.png, icon-maskable-192.png, icon-maskable-512.png, apple-touch-icon.png)
- RELEASE_NOTES.txt (optional changelog)`
                : `- index.html (main app — single file, all CSS/JS inline)
- RELEASE_NOTES.txt (optional changelog)`;

            const adminSection = hasAdmin ? `
## Admin Tool (${app.adminSubPath}/)
- Located at ${app.adminSubPath}/index.html in the same repo
- Has its own gs-app-id: "${app.id}-admin"
- Has its own version meta tag
- Deployed separately via Command Center
` : '';

            const testSection = hasTest ? `
## Test → Prod Workflow
- Test repo: ${testRepo} (deployed at https://${githubOwner}.github.io/${testRepoName}/)
- Prod repo: ${prodRepo} (deployed at https://${githubOwner}.github.io/${prodRepoName}/)
- Always deploy to test first, verify, then promote to prod via Command Center
` : `
## Deployment
- Single prod repo: ${prodRepo}
- Deployed at: https://${githubOwner}.github.io/${prodRepoName}/
${app.customDomain ? `- Custom domain: ${app.customDomain}` : ''}
`;

            return `# ${app.name} — Project Brief

## Overview
${app.description || app.name + ' is a web application.'}

## Technical Requirements

### App Identity (Required for Command Center)
Every HTML file must include these meta tags in <head>:
\`\`\`html
<meta name="version" content="X.Y.Z">
<meta name="gs-app-id" content="${app.id}">
\`\`\`
Version must follow semver (e.g., 1.0.0). Bump on every deploy.

### Architecture
- **Single-file HTML app**: All CSS and JS must be inline in index.html (no external files except CDN libraries)
- **Dark mode by default**: Background #0f172a or similar dark theme
- **Mobile-first responsive design**
${isPWA ? '- **Progressive Web App**: Must include service worker, manifest.json, and app icons' : '- **Standard web app**: No service worker needed'}
- **Firebase integration**: Uses the shared Game Shelf Firebase project (word-boxing-default-rtdb)

### Firebase Config
\`\`\`javascript
const firebaseConfig = {
    apiKey: "AIzaSyBQVwn8vOrFTzLlm2MYIPBwgZV2xR9AuhM",
    authDomain: "word-boxing.firebaseapp.com",
    databaseURL: "https://word-boxing-default-rtdb.firebaseio.com",
    projectId: "word-boxing"
};
\`\`\`
${testSection}
### Deploy Package Structure
The Command Center deploys these files to GitHub Pages:
${deployFilesList}
${adminSection}
### Version Management
- Use \`<meta name="version" content="X.Y.Z">\` in the HTML head
- Command Center reads this to track deployed versions
- Bump the patch version for bug fixes, minor for features, major for breaking changes

## Project Plan

### Phase 1: Foundation
- [ ] Basic UI with app branding and layout
- [ ] Firebase integration (auth if needed, database read/write)
- [ ] Core feature implementation
- [ ] Mobile responsive design

### Phase 2: Polish
- [ ] Error handling and edge cases
- [ ] Loading states and transitions
- [ ] Accessibility basics (semantic HTML, keyboard nav)
${isPWA ? '- [ ] Service worker for offline support\n- [ ] PWA manifest and icons' : ''}

### Phase 3: Launch
- [ ] Test deployment via Command Center
- [ ] Version tracking verified
- [ ] Performance optimization
${hasAdmin ? '- [ ] Admin tool deployment' : ''}

## Current Status
- Version: 0.1.0 (placeholder)
- Status: Initial setup complete
- Repo: ${prodRepo}
${hasTest ? `- Test repo: ${testRepo}` : ''}

## Session Continuity
When starting a new session, provide this document plus any updates to the project plan.
The developer uses Claude for iterative development — each session should:
1. Review this brief and any RELEASE_NOTES.txt
2. Understand what was built previously
3. Continue from where the last session left off
4. Produce deploy-ready files (single HTML with inline CSS/JS)
5. Include updated version meta tags
`;
        }

        // =================== RENDER ===================
        return (
            <div className="max-w-3xl mx-auto">
                <div className="flex items-center gap-3 mb-6">
                    <span className="text-3xl">🆕</span>
                    <div>
                        <h1 className="text-2xl font-bold">Setup New App</h1>
                        <p className="text-slate-400 text-sm">Create repos, configure Command Center, and generate a Claude project brief</p>
                    </div>
                </div>

                {/* Progress */}
                <div className="flex items-center gap-2 mb-8">
                    {[
                        { n: 1, label: 'Define' },
                        { n: 2, label: 'Scope' },
                        { n: 3, label: 'Check Repos' },
                        { n: 4, label: 'Create & Configure' },
                        { n: 5, label: 'Review & Launch' }
                    ].map(s => (
                        <React.Fragment key={s.n}>
                            <div className={`flex items-center gap-2 px-3 py-1.5 rounded-lg text-sm font-medium ${
                                step === s.n ? 'bg-indigo-600 text-white' : step > s.n ? 'bg-green-600/20 text-green-400' : 'bg-slate-800 text-slate-500'
                            }`}>
                                {step > s.n ? '✓' : s.n} {s.label}
                            </div>
                            {s.n < 5 && <div className={`flex-1 h-px ${step > s.n ? 'bg-green-600' : 'bg-slate-700'}`} />}
                        </React.Fragment>
                    ))}
                </div>

                {/* Step 1: Define App */}
                {step === 1 && (
                    <div className="bg-slate-800 rounded-xl p-6 border border-slate-700">
                        <h2 className="text-lg font-semibold mb-4">📝 Define Your App</h2>
                        <div className="space-y-4">
                            <div>
                                <label className="block text-sm text-slate-400 mb-1">App Name <span className="text-red-400">*</span></label>
                                <input value={appData.name} onChange={e => handleNameChange(e.target.value)}
                                    className="w-full px-3 py-2 bg-slate-900 border border-slate-600 rounded-lg text-white focus:border-indigo-500 focus:outline-none"
                                    placeholder="My Awesome App" />
                            </div>
                            <div className="grid grid-cols-2 gap-4">
                                <div>
                                    <label className="block text-sm text-slate-400 mb-1">App ID (auto-generated)</label>
                                    <input value={appData.id} onChange={e => setAppData(prev => ({ ...prev, id: e.target.value }))}
                                        className="w-full px-3 py-2 bg-slate-900 border border-slate-600 rounded-lg text-white font-mono text-sm focus:border-indigo-500 focus:outline-none" />
                                </div>
                                <div>
                                    <label className="block text-sm text-slate-400 mb-1">Icon (emoji)</label>
                                    <input value={appData.icon} onChange={e => setAppData(prev => ({ ...prev, icon: e.target.value }))}
                                        className="w-full px-3 py-2 bg-slate-900 border border-slate-600 rounded-lg text-white text-center text-2xl focus:border-indigo-500 focus:outline-none" />
                                </div>
                            </div>
                            <div>
                                <label className="block text-sm text-slate-400 mb-1">Description</label>
                                <textarea value={appData.description} onChange={e => setAppData(prev => ({ ...prev, description: e.target.value }))}
                                    className="w-full px-3 py-2 bg-slate-900 border border-slate-600 rounded-lg text-white focus:border-indigo-500 focus:outline-none resize-none"
                                    rows={2} placeholder="Brief description of what this app does" />
                            </div>
                            <div className="grid grid-cols-2 gap-4">
                                <div>
                                    <label className="block text-sm text-slate-400 mb-2">Deploy Structure</label>
                                    <div className="space-y-2">
                                        {[['prod-only', '🚀 Prod Only', 'Single repo, deploy directly'],
                                          ['test-prod', '🧪→🚀 Test → Prod', 'Two repos, promote test to prod']
                                        ].map(([val, label, desc]) => (
                                            <label key={val} className={`flex items-start gap-3 p-3 rounded-lg border cursor-pointer ${
                                                appData.structure === val ? 'border-indigo-500 bg-indigo-500/10' : 'border-slate-600 hover:border-slate-500'
                                            }`}>
                                                <input type="radio" name="structure" value={val} checked={appData.structure === val}
                                                    onChange={e => setAppData(prev => ({ ...prev, structure: e.target.value }))} className="mt-1" />
                                                <div><div className="text-sm font-medium">{label}</div><div className="text-xs text-slate-500">{desc}</div></div>
                                            </label>
                                        ))}
                                    </div>
                                </div>
                                <div>
                                    <label className="block text-sm text-slate-400 mb-2">App Category</label>
                                    <select value={appData.appType} onChange={e => setAppData(prev => ({ ...prev, appType: e.target.value }))}
                                        className="w-full px-3 py-2 bg-slate-900 border border-slate-600 rounded-lg text-white focus:border-indigo-500 focus:outline-none mb-3">
                                        <option value="public">Public App</option>
                                        <option value="internal">Internal Tool</option>
                                        <option value="other">Other Project</option>
                                    </select>
                                    <label className="block text-sm text-slate-400 mb-2">Project</label>
                                    <select value={appData.project} onChange={e => setAppData(prev => ({ ...prev, project: e.target.value }))}
                                        className="w-full px-3 py-2 bg-slate-900 border border-slate-600 rounded-lg text-white focus:border-indigo-500 focus:outline-none mb-3">
                                        <option value="">— Select a project —</option>
                                        {Object.values(config.projects || SEED_PROJECTS).filter(p => p.id !== 'other').sort((a, b) => (a.order || 99) - (b.order || 99)).map(p => (
                                            <option key={p.id} value={p.id}>{p.icon === 'gs-logo' ? '🎮' : p.icon} {p.name}</option>
                                        ))}
                                        <option value="other">Other</option>
                                    </select>
                                    <label className="flex items-center gap-3 p-3 rounded-lg border border-slate-600 cursor-pointer hover:border-slate-500">
                                        <input type="checkbox" checked={appData.isPWA} onChange={e => setAppData(prev => ({ ...prev, isPWA: e.target.checked }))} />
                                        <div><div className="text-sm font-medium">📱 Progressive Web App</div><div className="text-xs text-slate-500">SW, manifest, icons</div></div>
                                    </label>
                                </div>
                            </div>
                            <div className="grid grid-cols-2 gap-4">
                                <label className="flex items-center gap-3 p-3 rounded-lg border border-slate-600 cursor-pointer hover:border-slate-500">
                                    <input type="checkbox" checked={appData.hasAdmin} onChange={e => setAppData(prev => ({ ...prev, hasAdmin: e.target.checked }))} />
                                    <div><div className="text-sm font-medium">🔧 Admin Panel</div><div className="text-xs text-slate-500">Separate page in subdirectory</div></div>
                                </label>
                                {appData.hasAdmin && (
                                    <div>
                                        <label className="block text-sm text-slate-400 mb-1">Admin Path</label>
                                        <input value={appData.adminSubPath} onChange={e => setAppData(prev => ({ ...prev, adminSubPath: e.target.value }))}
                                            className="w-full px-3 py-2 bg-slate-900 border border-slate-600 rounded-lg text-white font-mono text-sm focus:border-indigo-500 focus:outline-none"
                                            placeholder="admin" />
                                    </div>
                                )}
                            </div>
                            <div>
                                <label className="block text-sm text-slate-400 mb-1">Custom Domain (optional)</label>
                                <input value={appData.customDomain} onChange={e => setAppData(prev => ({ ...prev, customDomain: e.target.value }))}
                                    className="w-full px-3 py-2 bg-slate-900 border border-slate-600 rounded-lg text-white focus:border-indigo-500 focus:outline-none"
                                    placeholder="myapp.com" />
                            </div>
                        </div>

                        {/* Preview */}
                        {appData.name && (
                            <div className="mt-6 p-4 bg-slate-900 rounded-lg border border-slate-700">
                                <div className="text-xs text-slate-500 uppercase tracking-wide mb-2">Preview</div>
                                <div className="flex items-center gap-2 mb-2">
                                    <span className="text-xl">{appData.icon}</span>
                                    <span className="font-semibold">{appData.name}</span>
                                    <span className="text-xs px-2 py-0.5 bg-slate-700 rounded">{appData.appType}</span>
                                    {appData.isPWA && <span className="text-xs px-2 py-0.5 bg-purple-600/30 text-purple-300 rounded">PWA</span>}
                                </div>
                                <div className="text-sm text-slate-400 space-y-1">
                                    <div>Prod repo: <code className="text-indigo-400">{githubOwner}/{prodRepoName}</code></div>
                                    {appData.structure === 'test-prod' && <div>Test repo: <code className="text-yellow-400">{githubOwner}/{testRepoName}</code></div>}
                                    {appData.hasAdmin && <div>Admin path: <code className="text-green-400">/{appData.adminSubPath}/index.html</code></div>}
                                    {appData.customDomain && <div>Domain: <code className="text-cyan-400">{appData.customDomain}</code></div>}
                                    <div>gs-app-id: <code className="text-slate-300">{appData.id}</code></div>
                                </div>
                            </div>
                        )}

                        <div className="mt-6 flex justify-end">
                            <button onClick={() => { if (!appData.name) return; setStep(2); }}
                                disabled={!appData.name}
                                className="px-6 py-2 bg-indigo-600 hover:bg-indigo-500 disabled:bg-slate-700 disabled:text-slate-500 rounded-lg font-medium transition-colors">
                                Next: Scope →
                            </button>
                        </div>
                    </div>
                )}

                {/* Step 2: Scope (v8.23.0) */}
                {step === 2 && (
                    <div className="bg-slate-800 rounded-xl p-6 border border-slate-700">
                        <h2 className="text-lg font-semibold mb-4">🎯 Project Scope</h2>
                        <p className="text-sm text-slate-400 mb-4">
                            Define what this app does and how it should be built. This generates work items and starting standards for Claude.
                        </p>
                        
                        {!skipScope && !scopeData ? (
                            <div className="space-y-4">
                                <button onClick={() => {
                                        // Create a temporary app object for the scope modal
                                        const tempApp = { id: appData.id, name: appData.name, icon: appData.icon, lifecycle: {} };
                                        // Open inline scope flow
                                        setShowScopeInline(true);
                                    }}
                                    className="w-full p-6 bg-indigo-600/10 border-2 border-dashed border-indigo-500/50 rounded-xl hover:bg-indigo-600/20 transition-colors text-center">
                                    <div className="text-3xl mb-2">🎯</div>
                                    <div className="font-medium">Start Scoping Flow</div>
                                    <div className="text-xs text-slate-400 mt-1">Category-driven questions → features → standards (~2 min)</div>
                                </button>
                                <button onClick={() => { setSkipScope(true); }}
                                    className="w-full p-3 text-slate-400 hover:text-white text-sm transition-colors">
                                    Skip scope — I'll add details later
                                </button>
                            </div>
                        ) : scopeData ? (
                            <div className="space-y-3">
                                <div className="bg-green-900/20 border border-green-700/50 rounded-lg p-4">
                                    <div className="flex items-center gap-2 mb-2">
                                        <span className="text-green-400">✅</span>
                                        <span className="font-medium text-green-300">Scope captured</span>
                                    </div>
                                    <div className="text-sm text-slate-300 grid grid-cols-3 gap-3">
                                        <div><span className="text-slate-500">Category:</span> {SCOPE_CATEGORIES[scopeData.category]?.icon} {SCOPE_CATEGORIES[scopeData.category]?.label}</div>
                                        <div><span className="text-slate-500">Features:</span> {scopeData.v1Features?.length || 0} V1</div>
                                        <div><span className="text-slate-500">Standards:</span> {scopeData.startingStandards?.length || 0}</div>
                                    </div>
                                </div>
                                <button onClick={() => { setScopeData(null); setSkipScope(false); }}
                                    className="text-xs text-slate-400 hover:text-white">Edit scope</button>
                            </div>
                        ) : (
                            <div className="bg-slate-700/30 rounded-lg p-4 text-center text-sm text-slate-400">
                                <p>Scope skipped — you can add one later from the Backlog view.</p>
                                <button onClick={() => setSkipScope(false)} className="mt-2 text-xs text-indigo-400 hover:text-indigo-300">
                                    Actually, let me scope this
                                </button>
                            </div>
                        )}
                        
                        <div className="mt-6 flex justify-between">
                            <button onClick={() => setStep(1)} className="px-4 py-2 text-slate-400 hover:text-white transition-colors">← Back</button>
                            <button onClick={() => { setStep(3); checkRepos(); }}
                                disabled={!skipScope && !scopeData}
                                className="px-6 py-2 bg-indigo-600 hover:bg-indigo-500 disabled:bg-slate-700 disabled:text-slate-500 rounded-lg font-medium transition-colors">
                                Next: Check Repos →
                            </button>
                        </div>
                        
                        {/* Inline Scope Modal */}
                        {showScopeInline && (
                            <ProjectScopeModal
                                app={{ id: appData.id, name: appData.name, icon: appData.icon, lifecycle: {} }}
                                apps={apps}
                                onSave={(scope) => { setScopeData(scope); setShowScopeInline(false); }}
                                onCancel={() => setShowScopeInline(false)}
                                showAlert={showAlert}
                                config={config}
                            />
                        )}
                    </div>
                )}

                {/* Step 3: Repo Check */}
                {step === 3 && (
                    <div className="bg-slate-800 rounded-xl p-6 border border-slate-700">
                        <h2 className="text-lg font-semibold mb-4">🔍 Repository Check</h2>
                        {repoStatus.checking ? (
                            <div className="text-center py-8 text-slate-400"><span className="animate-spin inline-block mr-2">⏳</span> Checking repositories...</div>
                        ) : (
                            <div className="space-y-3">
                                <div className={`p-4 rounded-lg border ${repoStatus.prodExists ? 'border-yellow-600 bg-yellow-600/10' : 'border-green-600 bg-green-600/10'}`}>
                                    <div className="flex items-center gap-2">
                                        <span>{repoStatus.prodExists ? '📂' : '✨'}</span>
                                        <span className="font-medium">{githubOwner}/{prodRepoName}</span>
                                        <span className={`text-xs px-2 py-0.5 rounded ${repoStatus.prodExists ? 'bg-yellow-600/30 text-yellow-300' : 'bg-green-600/30 text-green-300'}`}>
                                            {repoStatus.prodExists ? 'Already exists — will assign' : 'Will create'}
                                        </span>
                                    </div>
                                </div>
                                {appData.structure === 'test-prod' && (
                                    <div className={`p-4 rounded-lg border ${repoStatus.testExists ? 'border-yellow-600 bg-yellow-600/10' : 'border-green-600 bg-green-600/10'}`}>
                                        <div className="flex items-center gap-2">
                                            <span>{repoStatus.testExists ? '📂' : '✨'}</span>
                                            <span className="font-medium">{githubOwner}/{testRepoName}</span>
                                            <span className={`text-xs px-2 py-0.5 rounded ${repoStatus.testExists ? 'bg-yellow-600/30 text-yellow-300' : 'bg-green-600/30 text-green-300'}`}>
                                                {repoStatus.testExists ? 'Already exists — will assign' : 'Will create'}
                                            </span>
                                        </div>
                                    </div>
                                )}
                            </div>
                        )}
                        <div className="mt-6 flex justify-between">
                            <button onClick={() => setStep(2)} className="px-4 py-2 text-slate-400 hover:text-white transition-colors">← Back</button>
                            <button onClick={() => setStep(4)} disabled={repoStatus.checking}
                                className="px-6 py-2 bg-indigo-600 hover:bg-indigo-500 disabled:bg-slate-700 rounded-lg font-medium transition-colors">
                                Next: Create & Configure →
                            </button>
                        </div>
                    </div>
                )}

                {/* Step 4: Create & Configure */}
                {step === 4 && (
                    <div className="bg-slate-800 rounded-xl p-6 border border-slate-700">
                        <h2 className="text-lg font-semibold mb-4">⚡ Create & Configure</h2>
                        {creationLog.length === 0 && !creating ? (
                            <div>
                                <p className="text-slate-400 mb-4">Ready to set up <strong className="text-white">{appData.name}</strong>. This will:</p>
                                <ul className="space-y-2 text-sm text-slate-300 mb-6">
                                    {!repoStatus.prodExists && <li>✨ Create <code className="text-indigo-400">{prodRepoName}</code> repository</li>}
                                    {appData.structure === 'test-prod' && !repoStatus.testExists && <li>✨ Create <code className="text-yellow-400">{testRepoName}</code> repository</li>}
                                    <li>📄 Seed index.html with app meta tags (version + gs-app-id)</li>
                                    {appData.hasAdmin && <li>🔧 Seed {appData.adminSubPath}/index.html</li>}
                                    <li>⚙️ Add app to Command Center configuration</li>
                                    <li>🌐 Enable GitHub Pages</li>
                                    <li>🤖 Generate Claude project prompt</li>
                                </ul>
                                <div className="flex justify-between">
                                    <button onClick={() => setStep(2)} className="px-4 py-2 text-slate-400 hover:text-white transition-colors">← Back</button>
                                    <button onClick={setupApp} className="px-6 py-2 bg-green-600 hover:bg-green-500 rounded-lg font-medium transition-colors">
                                        🚀 Set Up Everything
                                    </button>
                                </div>
                            </div>
                        ) : (
                            <div>
                                <div className="bg-slate-900 rounded-lg p-4 max-h-64 overflow-y-auto space-y-1 font-mono text-sm">
                                    {creationLog.map((log, i) => (
                                        <div key={i} className={`${
                                            log.type === 'success' ? 'text-green-400' : log.type === 'error' ? 'text-red-400' : log.type === 'warn' ? 'text-yellow-400' : 'text-slate-400'
                                        }`}>
                                            <span className="text-slate-600 mr-2">{log.time}</span>{log.msg}
                                        </div>
                                    ))}
                                    {creating && <div className="text-slate-500"><span className="animate-spin inline-block">⏳</span> Working...</div>}
                                </div>
                                {!creating && promptGenerated && (
                                    <div className="mt-4 flex justify-end">
                                        <button onClick={() => setStep(5)} className="px-6 py-2 bg-indigo-600 hover:bg-indigo-500 rounded-lg font-medium transition-colors">
                                            View Claude Prompt →
                                        </button>
                                    </div>
                                )}
                            </div>
                        )}
                    </div>
                )}

                {/* Step 5: Review & Launch (v8.29.0 — Phase 3.2 enhanced) */}
                {step === 5 && (
                    <div className="bg-slate-800 rounded-xl p-6 border border-slate-700 space-y-6">
                        <div>
                            <h2 className="text-lg font-semibold mb-1">🚀 Review & Launch</h2>
                            <p className="text-slate-400 text-sm">Everything has been set up. Review what was created and grab your Claude instructions.</p>
                        </div>

                        {/* Setup Summary */}
                        {reviewData && (
                            <div className="grid grid-cols-2 gap-3">
                                <div className="bg-slate-900/60 rounded-lg p-3 border border-slate-700">
                                    <div className="text-xs text-slate-500 uppercase tracking-wide mb-1">App</div>
                                    <div className="font-medium">{appData.icon} {reviewData.appName}</div>
                                    <div className="text-xs text-slate-400 mt-1 font-mono">{reviewData.appId}</div>
                                </div>
                                <div className="bg-slate-900/60 rounded-lg p-3 border border-slate-700">
                                    <div className="text-xs text-slate-500 uppercase tracking-wide mb-1">Repositories</div>
                                    <div className="text-sm font-mono text-slate-300 truncate">{reviewData.repos?.prod}</div>
                                    {reviewData.repos?.test && <div className="text-xs font-mono text-slate-400 mt-1 truncate">{reviewData.repos.test}</div>}
                                </div>
                                {reviewData.hasScope && (
                                    <div className="bg-slate-900/60 rounded-lg p-3 border border-slate-700">
                                        <div className="text-xs text-slate-500 uppercase tracking-wide mb-1">Scope</div>
                                        <div className="text-sm">{reviewData.category || 'Scoped'}</div>
                                        <div className="text-xs text-slate-400 mt-1">
                                            {reviewData.v1FeatureCount} V1 features · {reviewData.standardsCount} standards
                                        </div>
                                    </div>
                                )}
                                <div className="bg-slate-900/60 rounded-lg p-3 border border-slate-700">
                                    <div className="text-xs text-slate-500 uppercase tracking-wide mb-1">Generated Artifacts</div>
                                    <div className="text-sm space-y-0.5">
                                        {reviewData.workItemsCreated > 0 && (
                                            <div className="text-green-400">✅ {reviewData.workItemsCreated} work items</div>
                                        )}
                                        {reviewData.docsGenerated?.length > 0 && (
                                            <div className="text-green-400">✅ {reviewData.docsGenerated.length} docs generated</div>
                                        )}
                                        {reviewData.docsCommitted > 0 && (
                                            <div className="text-green-400">📂 {reviewData.docsCommitted} committed to repo</div>
                                        )}
                                        {reviewData.seedDeployedToTest && (
                                            <div className="text-green-400">🚀 Seed deployed to test</div>
                                        )}
                                        {reviewData.isPWA && <span className="text-xs text-slate-500">PWA</span>}
                                        {reviewData.hasAdmin && <span className="text-xs text-slate-500 ml-1">Admin</span>}
                                    </div>
                                </div>
                            </div>
                        )}

                        {/* Work Items Summary */}
                        {workItemsCreated.length > 0 && (
                            <div className="bg-slate-900/40 rounded-lg p-4 border border-slate-700">
                                <div className="flex items-center justify-between mb-3">
                                    <h3 className="text-sm font-semibold">📋 Work Items Created</h3>
                                    <span className="text-xs text-slate-500">{workItemsCreated.length} items in backlog</span>
                                </div>
                                <div className="space-y-1 max-h-40 overflow-y-auto">
                                    {workItemsCreated.map((wi, i) => (
                                        <div key={i} className="flex items-center gap-2 text-sm py-1">
                                            <span className={`text-xs px-1.5 py-0.5 rounded font-mono ${
                                                wi.status === 'ready' ? 'bg-blue-600/20 text-blue-400' : 'bg-slate-700 text-slate-400'
                                            }`}>{wi.status}</span>
                                            <span className={`text-xs px-1.5 py-0.5 rounded ${
                                                wi.type === 'feature' ? 'bg-purple-600/20 text-purple-400' : 'bg-amber-600/20 text-amber-400'
                                            }`}>{wi.type}</span>
                                            <span className="text-slate-300 truncate">{wi.title}</span>
                                            <span className={`text-xs ml-auto ${
                                                wi.priority === 'core' ? 'text-red-400' : 'text-slate-500'
                                            }`}>{wi.priority}</span>
                                        </div>
                                    ))}
                                </div>
                            </div>
                        )}

                        {/* Generated Docs Viewer (v8.29.0) */}
                        {reviewData?.docsGenerated?.length > 0 && (() => {
                            const docTabs = [
                                { id: 'instructions', label: 'CLAUDE_INSTRUCTIONS', content: promptGenerated },
                                { id: 'context', label: 'CONTEXT.md', content: reviewData.generatedContextMd },
                                { id: 'plan', label: 'PROJECT_PLAN.md', content: reviewData.generatedProjectPlanMd },
                                { id: 'changelog', label: 'CHANGELOG.md', content: reviewData.generatedChangelogMd },
                                { id: 'release', label: 'RELEASE_NOTES.txt', content: reviewData.generatedReleaseNotes }
                            ].filter(t => t.content);
                            const activeContent = docTabs.find(t => t.id === activeDocTab)?.content || docTabs[0]?.content || '';
                            const activeLabel = docTabs.find(t => t.id === activeDocTab)?.label || docTabs[0]?.label || '';
                            
                            return (
                                <div>
                                    <div className="flex items-center justify-between mb-2">
                                        <h3 className="text-sm font-semibold">📄 Generated Project Docs</h3>
                                        <button onClick={() => { navigator.clipboard.writeText(activeContent); showAlert(`Copied ${activeLabel} to clipboard!`, 'Copied'); }}
                                            className="px-3 py-1.5 bg-indigo-600 hover:bg-indigo-500 rounded text-sm font-medium transition-colors">
                                            📋 Copy {activeLabel}
                                        </button>
                                    </div>
                                    <p className="text-slate-400 text-xs mb-2">
                                        {reviewData.docsCommitted > 0 
                                            ? `These docs have been committed to your repo. They'll be included in Claude Prep packages.`
                                            : `These docs were generated but not committed (no GitHub access). Copy and add to your repo manually.`
                                        }
                                    </p>
                                    <div className="flex gap-1 mb-2 overflow-x-auto">
                                        {docTabs.map(tab => (
                                            <button key={tab.id}
                                                onClick={() => setActiveDocTab(tab.id)}
                                                className={`px-2 py-1 rounded text-xs font-medium whitespace-nowrap transition-colors ${
                                                    activeDocTab === tab.id 
                                                        ? 'bg-indigo-600 text-white' 
                                                        : 'bg-slate-700 text-slate-400 hover:text-white'
                                                }`}>
                                                {tab.label}
                                            </button>
                                        ))}
                                    </div>
                                    <pre className="bg-slate-900 rounded-lg p-4 text-sm text-slate-300 max-h-64 overflow-y-auto whitespace-pre-wrap border border-slate-700">
                                        {activeContent}
                                    </pre>
                                </div>
                            );
                        })()}

                        {/* Fallback: Simple prompt viewer if no docs generated */}
                        {(!reviewData?.docsGenerated?.length && promptGenerated) && (
                            <div>
                                <div className="flex items-center justify-between mb-2">
                                    <h3 className="text-sm font-semibold">
                                        🤖 {reviewData?.promptType === 'instructions' ? 'CLAUDE_INSTRUCTIONS.md' : 'Claude Project Prompt'}
                                    </h3>
                                    <button onClick={() => { navigator.clipboard.writeText(promptGenerated); showAlert('Copied to clipboard!', 'Copied'); }}
                                        className="px-3 py-1.5 bg-indigo-600 hover:bg-indigo-500 rounded text-sm font-medium transition-colors">
                                        📋 Copy
                                    </button>
                                </div>
                                <p className="text-slate-400 text-xs mb-2">Copy this into a Claude Project or use as a session starter.</p>
                                <pre className="bg-slate-900 rounded-lg p-4 text-sm text-slate-300 max-h-64 overflow-y-auto whitespace-pre-wrap border border-slate-700">
                                    {promptGenerated}
                                </pre>
                            </div>
                        )}

                        {/* Actions */}
                        <div className="flex justify-between items-center pt-2 border-t border-slate-700">
                            <button onClick={() => { setStep(1); setAppData({ name:'',id:'',description:'',structure:'prod-only',isPWA:false,appType:'other',project:'',icon:'📦',hasAdmin:false,adminSubPath:'admin',customDomain:'' }); setScopeData(null); setSkipScope(false); setCreationLog([]); setPromptGenerated(''); setRepoStatus({checking:false,prodExists:null,testExists:null}); setWorkItemsCreated([]); setReviewData(null); setActiveDocTab('instructions'); }}
                                className="px-4 py-2 text-slate-400 hover:text-white transition-colors">
                                🆕 Setup Another App
                            </button>
                            <div className="text-green-400 text-sm font-medium">✅ Setup Complete</div>
                        </div>
                    </div>
                )}
            </div>
        );
    }

    // =========================================================================
    // FIREBASE ADMIN SETTINGS (v8.9.0)
    // =========================================================================
    
    // =========================================================================
    // DOMAIN REGISTRAR SETTINGS (v8.35.0)
    // =========================================================================
    
    
    function ProviderConfigPanel({ provider }) {
        const [config, setConfig] = React.useState(provider.service.getConfig());
        const [showKeys, setShowKeys] = React.useState(false);
        const [testing, setTesting] = React.useState(false);
        const [testResult, setTestResult] = React.useState(null);
        const [domains, setDomains] = React.useState(null);
        const [loadingDomains, setLoadingDomains] = React.useState(false);
        
        const updateConfig = (field, value) => {
            const updated = { ...config, [field]: value };
            setConfig(updated);
            provider.service.saveConfig(updated);
        };
        
        const handleTest = async () => {
            setTesting(true);
            setTestResult(null);
            try {
                const result = await provider.service.ping();
                const msg = result.yourIp && result.yourIp !== 'N/A' 
                    ? `Connected! Your IP: ${result.yourIp}`
                    : `Connected! ${result.domainCount !== undefined ? `${result.domainCount}+ domains found` : 'API responding'}`;
                setTestResult({ ok: true, msg });
                await handleFetchDomains();
            } catch (e) {
                setTestResult({ ok: false, msg: e.message });
            }
            setTesting(false);
        };
        
        const handleFetchDomains = async () => {
            setLoadingDomains(true);
            try {
                const domainList = await provider.service.listDomains();
                setDomains(domainList);
            } catch (e) {
                console.error(`Failed to fetch domains from ${provider.name}:`, e);
            }
            setLoadingDomains(false);
        };
        
        React.useEffect(() => {
            if (provider.service.isConfigured() && !domains) {
                handleFetchDomains();
            }
        }, [provider.id]);
        
        const allKeysPresent = provider.keyFields.every(f => config[f.key]);
        
        return (
            <div className="space-y-4">
                <p className="text-sm text-slate-400">
                    {provider.setupNote}{' '}
                    <a href={provider.setupUrl} target="_blank" className="text-indigo-400 hover:underline">
                        Get API keys →
                    </a>
                </p>
                
                {/* Key Fields (dynamic per provider) */}
                {provider.keyFields.map(field => (
                    <div key={field.key}>
                        <label className="text-xs text-slate-400 block mb-1.5">{field.label}</label>
                        <input 
                            type={showKeys ? 'text' : 'password'}
                            value={config[field.key] || ''}
                            onChange={e => updateConfig(field.key, e.target.value.trim())}
                            placeholder={field.placeholder}
                            className="w-full p-2 bg-slate-700 border border-slate-600 rounded text-sm font-mono"
                        />
                    </div>
                ))}
                
                {/* Action Buttons */}
                <div className="flex items-center gap-3 flex-wrap">
                    <button onClick={() => setShowKeys(!showKeys)}
                        className="text-xs px-3 py-1.5 bg-slate-700 rounded hover:bg-slate-600">
                        {showKeys ? '🔒 Hide' : '👁️ Show'} Keys
                    </button>
                    <button onClick={handleTest} disabled={testing || !allKeysPresent}
                        className="text-xs px-3 py-1.5 bg-indigo-600 rounded hover:bg-indigo-500 disabled:opacity-40 disabled:hover:bg-indigo-600">
                        {testing ? '⏳ Testing...' : '🔌 Test Connection'}
                    </button>
                    {provider.service.isConfigured() && (
                        <button onClick={handleFetchDomains} disabled={loadingDomains}
                            className="text-xs px-3 py-1.5 bg-slate-700 rounded hover:bg-slate-600 disabled:opacity-40">
                            {loadingDomains ? '⏳ Loading...' : '🔄 Refresh Domains'}
                        </button>
                    )}
                </div>
                
                {testResult && (
                    <div className={`p-3 rounded-lg border text-sm ${testResult.ok ? 'bg-green-900/30 border-green-700 text-green-300' : 'bg-red-900/30 border-red-700 text-red-300'}`}>
                        {testResult.ok ? '✅' : '❌'} {testResult.msg}
                    </div>
                )}
                
                {/* Domain List */}
                {domains && domains.length > 0 && (
                    <div className="mt-4">
                        <div className="text-xs text-slate-400 mb-2">{provider.icon} {provider.name} Domains ({domains.length})</div>
                        <div className="space-y-1.5">
                            {domains.map(d => {
                                const isExpiringSoon = d.expireDate && new Date(d.expireDate) - Date.now() < 60 * 24 * 60 * 60 * 1000;
                                return (
                                    <div key={d.domain} className="flex items-center gap-3 p-2.5 bg-slate-900/50 rounded-lg text-sm">
                                        <span className="text-lg">🌐</span>
                                        <span className="font-mono text-slate-200 flex-1">{d.domain}</span>
                                        <span className={`text-xs px-2 py-0.5 rounded ${
                                            d.status === 'ACTIVE' ? 'bg-green-900/30 text-green-400' : 'bg-amber-900/30 text-amber-400'
                                        }`}>
                                            {d.status || 'unknown'}
                                        </span>
                                        {d.expireDate && (
                                            <span className={`text-xs ${isExpiringSoon ? 'text-amber-400' : 'text-slate-500'}`}>
                                                {isExpiringSoon ? '⚠️ ' : ''}expires {new Date(d.expireDate).toLocaleDateString()}
                                            </span>
                                        )}
                                        <span className={`text-xs ${d.autoRenew ? 'text-green-500' : 'text-slate-600'}`}>
                                            {d.autoRenew ? '🔄 auto' : '⏸️ manual'}
                                        </span>
                                    </div>
                                );
                            })}
                        </div>
                    </div>
                )}
                
                {domains && domains.length === 0 && (
                    <div className="text-sm text-slate-500 p-4 text-center bg-slate-900/50 rounded-lg">
                        No domains found on this {provider.name} account.
                    </div>
                )}
            </div>
        );
    }

    // =========================================================================

    function FirebaseAdminSettings() {
        const [showKeyInput, setShowKeyInput] = React.useState(false);
        const [keyInput, setKeyInput] = React.useState('');
        const [info, setInfo] = React.useState(() => firebaseAdmin.getInfo());
        const [testing, setTesting] = React.useState(false);
        const [testResult, setTestResult] = React.useState(null);
        const [saveResult, setSaveResult] = React.useState(null);
        
        const refreshInfo = () => setInfo(firebaseAdmin.getInfo());
        
        const handleSave = () => {
            setSaveResult(null);
            setTestResult(null);
            const result = firebaseAdmin.saveServiceAccount(keyInput);
            setSaveResult(result);
            if (result.success) {
                setKeyInput('');
                setShowKeyInput(false);
                refreshInfo();
            }
        };
        
        const handleClear = () => {
            firebaseAdmin.clearServiceAccount();
            setSaveResult(null);
            setTestResult(null);
            refreshInfo();
        };
        
        const handleTest = async () => {
            setTesting(true);
            setTestResult(null);
            try {
                const result = await firebaseAdmin.testConnection();
                setTestResult(result);
                refreshInfo();
            } catch (e) {
                setTestResult({ token: false, rules: false, functions: false, errors: [e.message] });
            }
            setTesting(false);
        };
        
        const handleRefreshToken = async () => {
            setTesting(true);
            setTestResult(null);
            try {
                firebaseAdmin.clearToken();
                await firebaseAdmin.getAccessToken();
                refreshInfo();
                setTestResult({ token: true, errors: [], message: 'Token refreshed' });
            } catch (e) {
                setTestResult({ token: false, errors: [e.message] });
            }
            setTesting(false);
        };
        
        const configured = info !== null;
        
        return (
            <div className="space-y-4">
                {/* Status display */}
                {configured ? (
                    <div className="space-y-3">
                        <div className="p-4 bg-slate-900 rounded-lg border border-slate-600">
                            <div className="grid grid-cols-2 gap-3 text-sm">
                                <div>
                                    <div className="text-xs text-slate-500 uppercase tracking-wide mb-1">Service Account</div>
                                    <div className="font-mono text-slate-300 text-xs truncate" title={info.email}>{info.email}</div>
                                </div>
                                <div>
                                    <div className="text-xs text-slate-500 uppercase tracking-wide mb-1">Firebase Project</div>
                                    <div className="font-mono text-slate-300 text-xs">{info.projectId}</div>
                                </div>
                                <div>
                                    <div className="text-xs text-slate-500 uppercase tracking-wide mb-1">Key ID</div>
                                    <div className="font-mono text-slate-300 text-xs">{info.keyId}</div>
                                </div>
                                <div>
                                    <div className="text-xs text-slate-500 uppercase tracking-wide mb-1">OAuth Token</div>
                                    <div className="flex items-center gap-2">
                                        {info.tokenValid ? (
                                            <span className="text-green-400 text-xs flex items-center gap-1">
                                                <span className="inline-block w-2 h-2 rounded-full bg-green-400"></span>
                                                Active — expires {info.tokenExpiry}
                                            </span>
                                        ) : info.tokenCached ? (
                                            <span className="text-amber-400 text-xs flex items-center gap-1">
                                                <span className="inline-block w-2 h-2 rounded-full bg-amber-400"></span>
                                                Expired
                                            </span>
                                        ) : (
                                            <span className="text-slate-500 text-xs flex items-center gap-1">
                                                <span className="inline-block w-2 h-2 rounded-full bg-slate-500"></span>
                                                Not yet requested
                                            </span>
                                        )}
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        {/* Actions */}
                        <div className="flex gap-2 flex-wrap">
                            <button onClick={handleTest} disabled={testing}
                                className="px-4 py-2 bg-indigo-600 hover:bg-indigo-500 rounded text-sm disabled:opacity-50">
                                {testing ? '⏳ Testing...' : '🧪 Test Connection'}
                            </button>
                            <button onClick={handleRefreshToken} disabled={testing}
                                className="px-4 py-2 bg-slate-700 hover:bg-slate-600 rounded text-sm disabled:opacity-50">
                                🔄 Refresh Token
                            </button>
                            <button onClick={() => setShowKeyInput(true)}
                                className="px-4 py-2 bg-slate-700 hover:bg-slate-600 rounded text-sm">
                                🔑 Update Key
                            </button>
                            <button onClick={handleClear}
                                className="px-4 py-2 bg-red-900/50 hover:bg-red-900/70 text-red-400 border border-red-800 rounded text-sm">
                                🗑️ Remove
                            </button>
                        </div>
                    </div>
                ) : (
                    <div className="p-4 bg-slate-900/50 rounded-lg border border-dashed border-slate-600 text-center">
                        <div className="text-slate-400 text-sm mb-3">No service account configured</div>
                        <button onClick={() => setShowKeyInput(true)}
                            className="px-4 py-2 bg-indigo-600 hover:bg-indigo-500 rounded text-sm">
                            🔑 Add Service Account Key
                        </button>
                    </div>
                )}
                
                {/* Key input area */}
                {showKeyInput && (
                    <div className="p-4 bg-slate-900 rounded-lg border border-indigo-500/30">
                        <div className="text-sm text-slate-300 mb-2 font-medium">
                            Paste Service Account JSON Key
                        </div>
                        <p className="text-xs text-slate-500 mb-3">
                            Firebase Console → Project Settings → Service Accounts → Generate New Private Key. 
                            Paste the entire JSON file contents below.
                        </p>
                        <textarea
                            value={keyInput}
                            onChange={e => setKeyInput(e.target.value)}
                            placeholder='{"type": "service_account", "project_id": "...", ...}'
                            className="w-full h-32 bg-slate-800 border border-slate-600 rounded p-3 font-mono text-xs text-slate-300 resize-y"
                            spellCheck="false"
                        />
                        <div className="flex gap-2 mt-3">
                            <button onClick={handleSave} disabled={!keyInput.trim()}
                                className="px-4 py-2 bg-green-600 hover:bg-green-500 rounded text-sm disabled:opacity-50">
                                💾 Save Key
                            </button>
                            <button onClick={() => { setShowKeyInput(false); setKeyInput(''); setSaveResult(null); }}
                                className="px-4 py-2 bg-slate-700 hover:bg-slate-600 rounded text-sm">
                                Cancel
                            </button>
                        </div>
                        
                        {/* Save result */}
                        {saveResult && (
                            <div className={`mt-3 p-3 rounded text-sm ${saveResult.success ? 'bg-green-900/30 border border-green-700 text-green-300' : 'bg-red-900/30 border border-red-700 text-red-300'}`}>
                                {saveResult.success 
                                    ? `✅ Saved — ${saveResult.email} (project: ${saveResult.project})`
                                    : `❌ ${saveResult.error}`
                                }
                            </div>
                        )}
                    </div>
                )}
                
                {/* Test results */}
                {testResult && (
                    <div className="p-4 bg-slate-900 rounded-lg border border-slate-600">
                        <div className="text-sm font-medium text-slate-300 mb-3">Connection Test Results</div>
                        <div className="space-y-2">
                            <div className="flex items-center gap-2 text-sm">
                                <span className={testResult.token ? 'text-green-400' : 'text-red-400'}>
                                    {testResult.token ? '✅' : '❌'}
                                </span>
                                <span>OAuth2 Token</span>
                                <span className="text-slate-500 text-xs">— JWT signing & token exchange</span>
                            </div>
                        </div>
                        {testResult.errors?.length > 0 && (
                            <div className="mt-3 space-y-1">
                                {testResult.errors.map((err, i) => (
                                    <div key={i} className="text-xs text-red-400 bg-red-900/20 px-3 py-1.5 rounded font-mono">{err}</div>
                                ))}
                            </div>
                        )}
                        {testResult.token && (
                            <div className="mt-2 text-xs text-slate-500">Full connection tests (Rules, Functions, Auth) available in the <a href={getSatelliteUrl(null, 'infrastructure')} target="_blank" className="text-indigo-400 hover:text-indigo-300">Infrastructure satellite</a>.</div>
                        )}
                    </div>
                )}
                
                {/* Info about what admin access enables */}
                <div className="text-xs text-slate-500 space-y-1">
                    <div>Admin access enables:</div>
                    <div className="ml-3">• Read & deploy RTDB security rules</div>
                    <div className="ml-3">• List Cloud Functions and their status</div>
                    <div className="ml-3">• View Cloud Logging entries and errors</div>
                    <div className="ml-3">• Manage Firebase Auth authorized domains</div>
                    <div className="ml-3">• Admin-level RTDB data access</div>
                </div>
            </div>
        );
    }
    // =========================================================================
    // SETTINGS VIEW
    // =========================================================================
    
    function SettingsView({ token, setToken, settings, setSettings, repoCount, syncStatus, onForceSync, config, onConfigChange, firebaseUid, firebaseUser, teamMembers, teamMembership, showAlert, showConfirm, completionFileSettings }) {
        const [show, setShow] = React.useState(false);
        const [testing, setTesting] = React.useState(false);
        const [result, setResult] = React.useState(null);
        const [storageDiag, setStorageDiag] = React.useState(null);
        const [cleanupResult, setCleanupResult] = React.useState(null);
        
        // Firebase Sync state
        const [syncAction, setSyncAction] = React.useState(null); // 'pushing' | 'pulling' | 'clearing'
        const [syncResult, setSyncResult] = React.useState(null);
        const [dataSize, setDataSize] = React.useState(null);
        const [loadingSize, setLoadingSize] = React.useState(false);
        const [lastSyncTime, setLastSyncTime] = React.useState(null);
        
        // Fetch data size on mount and when sync status changes
        React.useEffect(() => {
            if (FirebaseConfigSync.initialized && syncStatus === 'synced') {
                fetchDataSize();
            }
        }, [syncStatus]);
        
        const fetchDataSize = async () => {
            setLoadingSize(true);
            const size = await FirebaseConfigSync.getDataSize();
            setDataSize(size);
            setLoadingSize(false);
        };
        
        const formatBytes = (bytes) => {
            if (bytes < 1024) return `${bytes} B`;
            if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
            return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
        };
        
        const handlePushAll = async () => {
            setSyncAction('pushing');
            setSyncResult(null);
            try {
                const localConfig = ConfigManager.load();
                const localDeployments = DeployService.load();
                const localRulesHistory = (() => { try { return JSON.parse(localStorage.getItem('cc_rulesHistory') || '[]'); } catch { return []; } })();
                const localSessionLog = SessionLogService.load();
                const localDeletionHistory = (() => { try { return JSON.parse(localStorage.getItem('cc_deletion_history') || '[]'); } catch { return []; } })();
                const localRollbackSnapshots = RollbackService.load();
                
                const ok = await FirebaseConfigSync.pushAll({
                    config: localConfig,
                    deployHistory: localDeployments,
                    rulesHistory: localRulesHistory,
                    sessionLog: localSessionLog,
                    deletionHistory: localDeletionHistory,
                    rollbackSnapshots: localRollbackSnapshots
                });
                
                setSyncResult(ok ? { ok: true, msg: 'All local data pushed to Firebase' } : { ok: false, msg: 'Push failed' });
                setLastSyncTime(Date.now());
                await fetchDataSize();
            } catch (e) {
                setSyncResult({ ok: false, msg: e.message });
            }
            setSyncAction(null);
        };
        
        const handlePullAll = async () => {
            setSyncAction('pulling');
            setSyncResult(null);
            try {
                if (onForceSync) {
                    await onForceSync('pull');
                    setSyncResult({ ok: true, msg: 'Firebase data pulled and overlaid onto local state' });
                    setLastSyncTime(Date.now());
                } else {
                    setSyncResult({ ok: false, msg: 'Force sync not available' });
                }
            } catch (e) {
                setSyncResult({ ok: false, msg: e.message });
            }
            setSyncAction(null);
        };
        
        const handleClearFirebase = async () => {
            if (!window.confirm('Are you sure you want to clear ALL Command Center data from Firebase?\n\nThis cannot be undone. Your local data will remain intact.')) {
                return;
            }
            setSyncAction('clearing');
            setSyncResult(null);
            try {
                const ok = await FirebaseConfigSync.clearAll();
                setSyncResult(ok ? { ok: true, msg: 'All Command Center data cleared from Firebase' } : { ok: false, msg: 'Clear failed' });
                setDataSize({ totalBytes: 0, keys: {} });
            } catch (e) {
                setSyncResult({ ok: false, msg: e.message });
            }
            setSyncAction(null);
        };
        
        // Token expiration tracking (v8.3.3)
        const [tokenExpires, setTokenExpires] = React.useState(() => {
            try { return localStorage.getItem('cc_token_expires') || ''; } catch { return ''; }
        });
        
        const saveTokenWithExpiry = (newToken, days = 90) => {
            setToken(newToken);
            if (newToken) {
                const expires = new Date();
                expires.setDate(expires.getDate() + days);
                const expiresStr = expires.toISOString();
                setTokenExpires(expiresStr);
                try { localStorage.setItem('cc_token_expires', expiresStr); localStorage.setItem('gs_token_expires', expiresStr); } catch {}
            }
        };
        
        const daysUntilExpiry = tokenExpires ? Math.ceil((new Date(tokenExpires) - new Date()) / (1000 * 60 * 60 * 24)) : null;
        const expiryWarning = daysUntilExpiry !== null && daysUntilExpiry <= 14;
        const expiryDanger = daysUntilExpiry !== null && daysUntilExpiry <= 3;
        
        return (
            <div className="space-y-6">
                {/* Your Name (v8.37.0) */}
                <div className="bg-slate-800 rounded-xl border border-slate-700 p-6">
                    <h2 className="text-lg font-semibold mb-2 flex items-center gap-2">
                        👤 Your Name
                    </h2>
                    <p className="text-sm text-slate-400 mb-3">
                        Used to attribute work items, deploys, and session activity. Leave blank to use "Owner".
                    </p>
                    <input 
                        type="text" 
                        value={config?.ownerName || ''} 
                        onChange={e => {
                            if (onConfigChange) {
                                onConfigChange({ ...config, ownerName: e.target.value });
                            }
                        }}
                        placeholder="e.g. Dave"
                        className="w-full max-w-xs p-2 bg-slate-700 border border-slate-600 rounded text-sm focus:border-indigo-500 focus:outline-none" />
                    {config?.ownerName && (
                        <div className="mt-2 text-xs text-green-400">✓ Records will be attributed to "{config.ownerName}"</div>
                    )}
                </div>
                
                {/* Anthropic API Key (v8.60.1 — Bug Fix) */}
                {(() => {
                    const [apiKeyVal, setApiKeyVal] = React.useState(() => {
                        try { return localStorage.getItem('cc_anthropic_api_key') || ''; } catch { return ''; }
                    });
                    const [showKey, setShowKey] = React.useState(false);
                    const [saved, setSaved] = React.useState(false);
                    return (
                        <div className="bg-slate-800 rounded-xl border border-slate-700 p-6">
                            <h2 className="text-lg font-semibold mb-2 flex items-center gap-2">🔑 Anthropic API Key</h2>
                            <p className="text-sm text-slate-400 mb-1">Required for AI-generated review prompts in the validation bundle pipeline.</p>
                            <p className="text-xs text-slate-500 mb-4">Get your key from <a href="https://console.anthropic.com/" target="_blank" rel="noopener" className="text-indigo-400 hover:underline">console.anthropic.com</a>. Stored in localStorage only — never sent to Firebase.</p>
                            <div className="flex items-center gap-2 mb-2">
                                <input type={showKey ? 'text' : 'password'} value={apiKeyVal}
                                    onChange={e => { setApiKeyVal(e.target.value); setSaved(false); }}
                                    placeholder="sk-ant-api03-..."
                                    className="bg-slate-700 border border-slate-600 rounded px-3 py-1.5 text-sm flex-1 font-mono" />
                                <button onClick={() => setShowKey(!showKey)}
                                    className="px-2 py-1.5 rounded text-xs bg-slate-700 hover:bg-slate-600">
                                    {showKey ? '🙈 Hide' : '👁 Show'}
                                </button>
                                <button onClick={() => { localStorage.setItem('cc_anthropic_api_key', apiKeyVal); setSaved(true); }}
                                    disabled={saved}
                                    className="px-3 py-1.5 rounded text-xs bg-indigo-600 hover:bg-indigo-500 font-medium disabled:opacity-50">
                                    {saved ? '✓ Saved' : 'Save'}
                                </button>
                                {apiKeyVal && (
                                    <button onClick={() => { localStorage.removeItem('cc_anthropic_api_key'); setApiKeyVal(''); setSaved(false); }}
                                        className="px-2 py-1.5 rounded text-xs bg-red-900/50 hover:bg-red-800 text-red-300">
                                        Clear
                                    </button>
                                )}
                            </div>
                            <div className="text-xs">
                                {apiKeyVal ? (
                                    <span className="text-green-400">✅ Configured — review prompts will use Claude API</span>
                                ) : (
                                    <span className="text-amber-400">⚠️ Not set — review prompt generation will use static fallback</span>
                                )}
                            </div>
                        </div>
                    );
                })()}

                {/* Completion Files Settings (v8.58.0 — Ingestion Pipeline) */}
                <div className="bg-slate-800 rounded-xl border border-slate-700 p-6">
                    <h2 className="text-lg font-semibold mb-2 flex items-center gap-2">📦 Completion Files</h2>
                    <p className="text-sm text-slate-400 mb-4">Configure completion file detection and ingestion thresholds.</p>
                    <div className="space-y-3">
                        <div>
                            <label className="text-sm text-slate-300 block mb-1">Unclassified Nudge Threshold</label>
                            <p className="text-xs text-slate-500 mb-1">Show a nudge banner when this many jobs lack classification.</p>
                            <input type="number" min="1" max="100" data-testid="nudge-threshold"
                                value={completionFileSettings?.unclassifiedNudgeThreshold || 5}
                                onChange={e => { if (firebaseUid) CompletionFileSettings.save(firebaseUid, { ...completionFileSettings, unclassifiedNudgeThreshold: parseInt(e.target.value) || 5 }); }}
                                className="bg-slate-700 border border-slate-600 rounded px-3 py-1.5 text-sm w-24" />
                        </div>
                        <div>
                            <label className="text-sm text-slate-300 block mb-1">Orphan Detection Window (days)</label>
                            <p className="text-xs text-slate-500 mb-1">Lookback window for orphan commit detection. (Phase 3)</p>
                            <input type="number" min="1" max="90"
                                value={completionFileSettings?.orphanDetectionDays || 14}
                                onChange={e => { if (firebaseUid) CompletionFileSettings.save(firebaseUid, { ...completionFileSettings, orphanDetectionDays: parseInt(e.target.value) || 14 }); }}
                                className="bg-slate-700 border border-slate-600 rounded px-3 py-1.5 text-sm w-24" />
                        </div>
                    </div>
                </div>

                {/* Team Management (v8.46.0 — Phase 5.7) */}
                <div className="bg-slate-800 rounded-xl border border-slate-700 p-6">
                    <h2 className="text-lg font-semibold mb-2 flex items-center gap-2">
                        👥 Team
                    </h2>
                    <p className="text-sm text-slate-400 mb-4">
                        Invite collaborators to share your Command Center workspace. Team members see your apps, work items, streams, and activity.
                    </p>
                    
                    {!firebaseUid ? (
                        <div className="text-sm text-amber-400 bg-amber-900/20 border border-amber-700/30 rounded-lg p-3">
                            ⚠️ Sign in with Google to manage team members
                        </div>
                    ) : teamMembership ? (
                        <div className="text-sm text-slate-300 bg-slate-700/50 rounded-lg p-3">
                            You're a <span className="font-semibold text-indigo-400">{teamMembership.role}</span> in{' '}
                            <span className="font-semibold">{teamMembership.workspaceName || 'a shared workspace'}</span>.
                            Team management is handled by the workspace owner.
                        </div>
                    ) : (() => {
                        const [inviteEmail, setInviteEmail] = React.useState('');
                        const [inviteRole, setInviteRole] = React.useState('editor');
                        const [inviting, setInviting] = React.useState(false);
                        const [showRules, setShowRules] = React.useState(false);
                        
                        const handleInvite = async () => {
                            if (!inviteEmail.trim() || !inviteEmail.includes('@')) return;
                            setInviting(true);
                            try {
                                await TeamService.invite(firebaseUid, inviteEmail.trim(), inviteRole, config?.ownerName || 'Owner');
                                setInviteEmail('');
                            } catch (e) {
                                console.error('[Team] Invite failed:', e);
                            }
                            setInviting(false);
                        };
                        
                        return (
                            <div className="space-y-4">
                                {/* Current owner */}
                                <div className="flex items-center gap-3 p-3 bg-slate-700/30 rounded-lg">
                                    {firebaseUser?.photoURL ? (
                                        <img src={firebaseUser.photoURL} className="w-8 h-8 rounded-full" alt="" />
                                    ) : (
                                        <div className="w-8 h-8 rounded-full bg-indigo-600 flex items-center justify-center text-sm font-bold">
                                            {(config?.ownerName || 'O')[0]}
                                        </div>
                                    )}
                                    <div className="flex-1">
                                        <div className="text-sm font-medium">{config?.ownerName || firebaseUser?.displayName || 'Owner'}</div>
                                        <div className="text-xs text-slate-400">{firebaseUser?.email}</div>
                                    </div>
                                    <span className="px-2 py-0.5 bg-indigo-600/30 text-indigo-300 text-xs rounded-full font-medium">Owner</span>
                                </div>
                                
                                {/* Team members list */}
                                {(teamMembers || []).length > 0 && (
                                    <div className="space-y-2">
                                        {(teamMembers || []).map(member => (
                                            <div key={member.uid} className="flex items-center gap-3 p-3 bg-slate-700/30 rounded-lg">
                                                {member.photoURL ? (
                                                    <img src={member.photoURL} className="w-8 h-8 rounded-full" alt="" />
                                                ) : (
                                                    <div className="w-8 h-8 rounded-full bg-slate-600 flex items-center justify-center text-sm font-bold">
                                                        {(member.name || member.email || '?')[0]}
                                                    </div>
                                                )}
                                                <div className="flex-1">
                                                    <div className="text-sm font-medium">{member.name || member.email}</div>
                                                    <div className="text-xs text-slate-400">{member.email}</div>
                                                </div>
                                                <div className="flex items-center gap-2">
                                                    {member.status === 'invited' && (
                                                        <span className="px-2 py-0.5 bg-amber-600/20 text-amber-400 text-xs rounded-full">Pending</span>
                                                    )}
                                                    <select value={member.role} onChange={async (e) => {
                                                        try { await TeamService.updateRole(firebaseUid, member.uid, e.target.value); }
                                                        catch (err) { console.error('[Team] Role update failed:', err); }
                                                    }} className="px-2 py-0.5 bg-slate-700 border border-slate-600 rounded text-xs">
                                                        <option value="editor">Editor</option>
                                                        <option value="viewer">Viewer</option>
                                                    </select>
                                                    <button onClick={async () => {
                                                        if (window.confirm(`Remove ${member.name || member.email} from team?`)) {
                                                            try { await TeamService.remove(firebaseUid, member.uid); }
                                                            catch (err) { console.error('[Team] Remove failed:', err); }
                                                        }
                                                    }} className="text-red-400 hover:text-red-300 text-xs px-1" title="Remove">✕</button>
                                                </div>
                                            </div>
                                        ))}
                                    </div>
                                )}
                                
                                {/* Invite form */}
                                <div className="flex gap-2">
                                    <input type="email" value={inviteEmail} onChange={e => setInviteEmail(e.target.value)}
                                        placeholder="email@example.com"
                                        onKeyDown={e => e.key === 'Enter' && handleInvite()}
                                        className="flex-1 p-2 bg-slate-700 border border-slate-600 rounded text-sm focus:border-indigo-500 focus:outline-none" />
                                    <select value={inviteRole} onChange={e => setInviteRole(e.target.value)}
                                        className="px-2 bg-slate-700 border border-slate-600 rounded text-xs">
                                        <option value="editor">Editor</option>
                                        <option value="viewer">Viewer</option>
                                    </select>
                                    <button onClick={handleInvite} disabled={inviting || !inviteEmail.includes('@')}
                                        className="px-4 py-2 bg-indigo-600 hover:bg-indigo-500 disabled:opacity-50 rounded text-sm font-medium">
                                        {inviting ? '...' : 'Invite'}
                                    </button>
                                </div>
                                
                                {/* Security rules template */}
                                <details className="text-xs">
                                    <summary className="text-slate-500 cursor-pointer hover:text-slate-400">
                                        🔒 Firebase Security Rules Template
                                    </summary>
                                    <div className="mt-2 bg-slate-900 rounded p-3 font-mono text-slate-400 overflow-x-auto whitespace-pre text-[11px]">
                                        {TeamService.generateRulesTemplate(firebaseUid)}
                                    </div>
                                    <button onClick={() => navigator.clipboard.writeText(TeamService.generateRulesTemplate(firebaseUid))}
                                        className="mt-1 text-indigo-400 hover:text-indigo-300 text-xs">📋 Copy Rules</button>
                                </details>
                            </div>
                        );
                    })()}
                </div>
                
                <div className="bg-slate-800 rounded-xl border border-slate-700 p-6">
                    <h2 className="text-lg font-semibold mb-4 flex items-center gap-2">
                        <Icons.GitBranch /> GitHub Token
                    </h2>
                    <div className="flex gap-2 mb-2">
                        <input type={show ? 'text' : 'password'} value={token} onChange={e => setToken(e.target.value)}
                            placeholder="ghp_xxxx" className="flex-1 p-2 bg-slate-700 border border-slate-600 rounded font-mono text-sm" />
                        <button onClick={() => setShow(!show)} className="px-3 bg-slate-700 border border-slate-600 rounded">{show ? '🙈' : '👁️'}</button>
                        <button onClick={async () => {
                            setTesting(true);
                            try { const gh = new GitHubAPI(token); const r = await gh.listRepos(); setResult({ ok: true, count: r.length }); }
                            catch (e) { setResult({ ok: false, error: e.message }); }
                            setTesting(false);
                        }} disabled={testing} className="px-4 bg-indigo-600 rounded">{testing ? '...' : 'Test'}</button>
                    </div>
                    <div className="flex items-center gap-4 mt-3">
                        <a href="https://github.com/settings/tokens/new?scopes=repo" target="_blank" className="text-xs text-indigo-400">Create token →</a>
                        {token && (
                            <button onClick={() => saveTokenWithExpiry(token, 90)} 
                                className="text-xs px-2 py-1 bg-slate-700 border border-slate-600 rounded hover:bg-slate-600">
                                🔄 Reset 90-day timer
                            </button>
                        )}
                    </div>
                    {result && <div className={`mt-2 text-sm ${result.ok ? 'text-green-400' : 'text-red-400'}`}>
                        {result.ok ? `✓ Found ${result.count} repos` : `✗ ${result.error}`}
                    </div>}
                    
                    {/* Token expiration warning */}
                    {token && tokenExpires && (
                        <div className={`mt-3 p-3 rounded-lg border ${
                            expiryDanger ? 'bg-red-900/30 border-red-700 text-red-300' :
                            expiryWarning ? 'bg-amber-900/30 border-amber-700 text-amber-300' :
                            'bg-slate-700/50 border-slate-600 text-slate-300'
                        }`}>
                            <div className="flex items-center gap-2">
                                <span>{expiryDanger ? '🚨' : expiryWarning ? '⚠️' : '🔑'}</span>
                                <span className="text-sm">
                                    {daysUntilExpiry <= 0 
                                        ? <strong>Token may have expired!</strong>
                                        : <>Token expires in <strong>{daysUntilExpiry} days</strong> ({new Date(tokenExpires).toLocaleDateString()})</>
                                    }
                                </span>
                            </div>
                            {(expiryWarning || expiryDanger) && (
                                <div className="mt-2 text-xs">
                                    <a href="https://github.com/settings/tokens" target="_blank" className="text-indigo-400 underline">
                                        Generate a new token →
                                    </a>
                                    {' '}then paste it above and click "Reset 90-day timer"
                                </div>
                            )}
                        </div>
                    )}
                    {token && !tokenExpires && (
                        <div className="mt-3 p-3 rounded-lg border bg-amber-900/30 border-amber-700 text-amber-300">
                            <div className="text-sm">⚠️ Token expiration not set</div>
                            <button onClick={() => saveTokenWithExpiry(token, 90)} 
                                className="mt-2 text-xs px-3 py-1 bg-amber-700 rounded hover:bg-amber-600">
                                Set 90-day expiration from today
                            </button>
                        </div>
                    )}
                </div>
                
                {/* Firebase Admin (v8.9.0) */}
                <div className="bg-slate-800 rounded-xl border border-slate-700 p-6">
                    <h2 className="text-lg font-semibold mb-4 flex items-center gap-2">
                        🔥 Firebase Admin
                    </h2>
                    <p className="text-sm text-slate-400 mb-4">
                        Service account credentials enable admin access to Firebase RTDB rules, Cloud Functions status, and logging. 
                        Generate a key at <a href="https://console.firebase.google.com/project/word-boxing/settings/serviceaccounts/adminsdk" target="_blank" className="text-indigo-400 hover:underline">Firebase Console → Project Settings → Service Accounts</a>.
                    </p>
                    
                    <FirebaseAdminSettings />
                </div>
                
                {/* Domain Management — Moved to Infrastructure Satellite (v8.50.0) */}
                <div className="bg-slate-800 rounded-xl border border-slate-700 p-6">
                    <h2 className="text-lg font-semibold mb-4 flex items-center gap-2">
                        🌐 Domain & Infrastructure Management
                    </h2>
                    <p className="text-sm text-slate-400 mb-4">
                        Firebase Auth Domains, GitHub Pages Domains, and Domain Registrar management have moved to the Infrastructure satellite app.
                    </p>
                    <a href={getSatelliteUrl(null, 'infrastructure')} target="_blank" className="inline-flex items-center gap-2 px-4 py-2 bg-indigo-600 hover:bg-indigo-500 rounded-lg text-sm font-medium text-white no-underline transition-colors">
                        🔧 Open Infrastructure
                    </a>
                </div>
                {/* Firebase Config Sync (v8.18.0) */}
                <div className="bg-slate-800 rounded-xl border border-slate-700 p-6">
                    <h2 className="text-lg font-semibold mb-4 flex items-center gap-2">
                        ☁️ Firebase Config Sync
                    </h2>
                    <p className="text-sm text-slate-400 mb-4">
                        Non-sensitive CC data (config, deploy history, session log, rules history) is synced to Firebase RTDB at <code className="text-xs bg-slate-700 px-1.5 py-0.5 rounded">command-center/</code>. 
                        Secrets (GitHub PAT, Firebase SA key) stay in localStorage only.
                    </p>
                    
                    {/* Status row */}
                    <div className="grid grid-cols-1 sm:grid-cols-3 gap-3 mb-4">
                        <div className="bg-slate-700/50 rounded-lg p-3">
                            <div className="text-xs text-slate-400 mb-1">Status</div>
                            <div className="text-sm font-medium flex items-center gap-2">
                                {syncStatus === 'synced' && <><span className="text-green-400">☁️</span> Synced</>}
                                {syncStatus === 'syncing' && <><span className="text-yellow-400 animate-pulse">🔄</span> Syncing...</>}
                                {syncStatus === 'offline' && <><span className="text-slate-500">⚡</span> Offline</>}
                                {syncStatus === 'error' && <><span className="text-red-400">⚠️</span> Error</>}
                            </div>
                        </div>
                        <div className="bg-slate-700/50 rounded-lg p-3">
                            <div className="text-xs text-slate-400 mb-1">Firebase Data Size</div>
                            <div className="text-sm font-medium">
                                {loadingSize ? '...' : dataSize ? formatBytes(dataSize.totalBytes) : '—'}
                                {!loadingSize && dataSize && dataSize.totalBytes > 0 && (
                                    <button onClick={fetchDataSize} className="ml-2 text-xs text-slate-400 hover:text-slate-300">🔄</button>
                                )}
                            </div>
                        </div>
                        <div className="bg-slate-700/50 rounded-lg p-3">
                            <div className="text-xs text-slate-400 mb-1">Last Manual Sync</div>
                            <div className="text-sm font-medium">
                                {lastSyncTime ? new Date(lastSyncTime).toLocaleTimeString() : '—'}
                            </div>
                        </div>
                    </div>
                    
                    {/* Data breakdown */}
                    {dataSize && dataSize.keys && Object.keys(dataSize.keys).length > 0 && (
                        <div className="mb-4 bg-slate-700/30 rounded-lg p-3">
                            <div className="text-xs text-slate-400 mb-2">Data Breakdown</div>
                            <div className="grid grid-cols-2 sm:grid-cols-3 gap-2">
                                {Object.entries(dataSize.keys).sort((a, b) => b[1] - a[1]).map(([key, bytes]) => (
                                    <div key={key} className="flex justify-between items-center text-xs">
                                        <span className="text-slate-300">{key}</span>
                                        <span className="text-slate-500 ml-2">{formatBytes(bytes)}</span>
                                    </div>
                                ))}
                            </div>
                        </div>
                    )}
                    
                    {/* Action buttons */}
                    <div className="flex flex-wrap gap-2 mb-3">
                        <button 
                            onClick={handlePushAll}
                            disabled={!!syncAction || !FirebaseConfigSync.initialized}
                            className="px-4 py-2 bg-indigo-600 hover:bg-indigo-500 disabled:opacity-50 disabled:cursor-not-allowed rounded text-sm font-medium transition-colors">
                            {syncAction === 'pushing' ? '⏳ Pushing...' : '⬆️ Push All to Firebase'}
                        </button>
                        <button 
                            onClick={handlePullAll}
                            disabled={!!syncAction || !FirebaseConfigSync.initialized}
                            className="px-4 py-2 bg-emerald-700 hover:bg-emerald-600 disabled:opacity-50 disabled:cursor-not-allowed rounded text-sm font-medium transition-colors">
                            {syncAction === 'pulling' ? '⏳ Pulling...' : '⬇️ Pull All from Firebase'}
                        </button>
                        <button 
                            onClick={handleClearFirebase}
                            disabled={!!syncAction || !FirebaseConfigSync.initialized}
                            className="px-4 py-2 bg-red-900/50 text-red-400 border border-red-700 hover:bg-red-900 disabled:opacity-50 disabled:cursor-not-allowed rounded text-sm font-medium transition-colors">
                            {syncAction === 'clearing' ? '⏳ Clearing...' : '🗑️ Clear Firebase Data'}
                        </button>
                    </div>
                    
                    {!FirebaseConfigSync.initialized && (
                        <div className="text-sm text-amber-400 mb-3">⚠️ Firebase not initialized — sync features unavailable</div>
                    )}
                    
                    {/* Result feedback */}
                    {syncResult && (
                        <div className={`p-3 rounded-lg text-sm ${syncResult.ok ? 'bg-green-900/30 border border-green-700 text-green-400' : 'bg-red-900/30 border border-red-700 text-red-400'}`}>
                            {syncResult.ok ? '✓' : '✗'} {syncResult.msg}
                        </div>
                    )}
                </div>
                
                {/* AI Engines (v8.21.0) */}
                <div className="bg-slate-800 rounded-xl border border-slate-700 p-6">
                    <h2 className="text-lg font-semibold mb-4 flex items-center gap-2">
                        🤖 AI Engines
                    </h2>
                    <p className="text-sm text-slate-400 mb-4">
                        Engine profiles used for context budget calculations in Claude Prep. Set your default engine to match your primary Claude plan.
                    </p>
                    
                    {/* Default Engine Selector */}
                    <div className="mb-4">
                        <label className="text-xs text-slate-400 block mb-1.5">Default Engine</label>
                        <select 
                            value={EngineRegistryService.getDefault()}
                            onChange={e => { EngineRegistryService.setDefault(e.target.value); setSettings(prev => ({...prev, _engineRefresh: Date.now()})); }}
                            className="w-full sm:w-auto p-2 bg-slate-700 border border-slate-600 rounded text-sm"
                        >
                            {EngineRegistryService.getAll().map(e => (
                                <option key={e.id} value={e.id}>{e.name} — {TokenRegistryService.formatTokens(e.contextWindow)} context</option>
                            ))}
                        </select>
                    </div>
                    
                    {/* Engine Comparison Table */}
                    <div className="overflow-x-auto -mx-2 px-2">
                        <table className="w-full text-xs">
                            <thead>
                                <tr className="text-slate-500 border-b border-slate-700">
                                    <th className="text-left py-2 px-2 font-medium">Engine</th>
                                    <th className="text-center py-2 px-1 font-medium">Tier</th>
                                    <th className="text-right py-2 px-2 font-medium">Context</th>
                                    <th className="text-right py-2 px-2 font-medium">Extended</th>
                                    <th className="text-right py-2 px-2 font-medium">~$/Session</th>
                                    <th className="text-center py-2 px-1 font-medium">Projects</th>
                                    <th className="text-center py-2 px-1 font-medium">Skills</th>
                                </tr>
                            </thead>
                            <tbody>
                                {EngineRegistryService.getAll().map(engine => {
                                    const isDefault = engine.id === EngineRegistryService.getDefault();
                                    const tierColors = { fast: 'text-cyan-400 bg-cyan-900/30', balanced: 'text-blue-400 bg-blue-900/30', flagship: 'text-purple-400 bg-purple-900/30' };
                                    return (
                                        <tr key={engine.id} className={`border-b border-slate-800 ${isDefault ? 'bg-indigo-900/20' : 'hover:bg-slate-700/30'}`}>
                                            <td className="py-2 px-2">
                                                <div className="flex items-center gap-1.5">
                                                    {isDefault && <span className="text-indigo-400 text-[10px]">★</span>}
                                                    <span className={`font-medium ${isDefault ? 'text-indigo-300' : 'text-slate-300'}`}>{engine.name}</span>
                                                </div>
                                                <div className="text-[10px] text-slate-500 mt-0.5">{engine.strengths.slice(0, 2).join(', ')}</div>
                                            </td>
                                            <td className="py-2 px-1 text-center">
                                                <span className={`px-1.5 py-0.5 rounded text-[10px] font-medium ${tierColors[engine.tier] || 'text-slate-400'}`}>
                                                    {engine.tier}
                                                </span>
                                            </td>
                                            <td className="py-2 px-2 text-right text-slate-300 font-mono">{TokenRegistryService.formatTokens(engine.contextWindow)}</td>
                                            <td className="py-2 px-2 text-right font-mono">
                                                {engine.contextWindowExtended 
                                                    ? <span className="text-green-400">{TokenRegistryService.formatTokens(engine.contextWindowExtended)}</span>
                                                    : <span className="text-slate-600">—</span>
                                                }
                                            </td>
                                            <td className="py-2 px-2 text-right text-slate-400 font-mono" title={`$${engine.cost.input.toFixed(2)}/$${engine.cost.output.toFixed(2)} per MTok`}>
                                                ~${(EngineRegistryService.estimateSessionCost(50000, 10000, engine.id)?.totalCost || 0).toFixed(2)}
                                            </td>
                                            <td className="py-2 px-1 text-center">{engine.features.projects ? <span className="text-green-400">✓</span> : <span className="text-slate-600">—</span>}</td>
                                            <td className="py-2 px-1 text-center">{engine.features.skills ? <span className="text-green-400">✓</span> : <span className="text-slate-600">—</span>}</td>
                                        </tr>
                                    );
                                })}
                            </tbody>
                        </table>
                    </div>
                    
                    {/* Engine Details (expandable) */}
                    <details className="mt-3">
                        <summary className="text-xs text-slate-500 cursor-pointer hover:text-slate-300 select-none">Session type → engine recommendations</summary>
                        <div className="mt-2 grid grid-cols-2 sm:grid-cols-4 gap-2">
                            {SessionBriefGenerator.getAll().map(t => {
                                const engine = EngineRegistryService.get(t.suggestedEngine);
                                return (
                                    <div key={t.id} className="bg-slate-900 rounded px-2.5 py-1.5" title={t.description}>
                                        <div className="text-[10px] text-slate-500 uppercase flex items-center gap-1">{t.icon} {t.label}</div>
                                        <div className="text-xs text-slate-300">{engine?.name?.split(' ').pop()}</div>
                                    </div>
                                );
                            })}
                        </div>
                    </details>
                </div>
                
                <div className="bg-slate-800 rounded-xl border border-slate-700 p-6">
                    <h2 className="text-lg font-semibold mb-4">Options</h2>
                    <label className="flex items-center gap-3 p-3 bg-slate-700/50 rounded cursor-pointer">
                        <input type="checkbox" checked={settings.createTag} onChange={e => setSettings({ ...settings, createTag: e.target.checked })} />
                        <span>Create Git Tags</span>
                    </label>
                </div>
                
                <div className="bg-slate-800 rounded-xl border border-slate-700 p-6">
                    <h2 className="text-lg font-semibold mb-4">Reset</h2>
                    <div className="space-y-3">
                        <button onClick={() => { 
                            localStorage.removeItem('cc_apps_v6'); 
                            location.reload(); 
                        }}
                            className="px-4 py-2 bg-amber-900/50 text-amber-400 border border-amber-700 rounded mr-3">
                            Reset App Mappings
                        </button>
                        <button onClick={() => { localStorage.clear(); location.reload(); }}
                            className="px-4 py-2 bg-red-900/50 text-red-400 border border-red-700 rounded">
                            Clear All Data
                        </button>
                        <p className="text-xs text-slate-500 mt-2">
                            "Reset App Mappings" keeps your token but resets all app→repo mappings to defaults and re-runs auto-detection.
                        </p>
                    </div>
                </div>
                
                {/* Storage Management */}
                <div className="bg-slate-800 rounded-xl border border-slate-700 p-6">
                    <h2 className="text-lg font-semibold mb-4 flex items-center gap-2">
                        💾 Local Storage
                    </h2>
                    
                    {!storageDiag ? (
                        <button onClick={() => setStorageDiag(StorageManager.getDiagnostics())}
                            className="px-4 py-2 bg-slate-700 rounded hover:bg-slate-600 text-sm">
                            📊 Analyze Storage
                        </button>
                    ) : (
                        <div className="space-y-3">
                            {/* Usage bar */}
                            <div>
                                <div className="flex justify-between text-sm mb-1">
                                    <span>{storageDiag.totalFormatted} / {storageDiag.quotaFormatted}</span>
                                    <span className={storageDiag.percent > 80 ? 'text-red-400' : storageDiag.percent > 60 ? 'text-amber-400' : 'text-green-400'}>
                                        {storageDiag.percent}%
                                    </span>
                                </div>
                                <div className="w-full bg-slate-700 rounded-full h-3">
                                    <div className={`h-3 rounded-full transition-all ${
                                        storageDiag.percent > 80 ? 'bg-red-500' : storageDiag.percent > 60 ? 'bg-amber-500' : 'bg-green-500'
                                    }`} style={{ width: `${Math.min(storageDiag.percent, 100)}%` }} />
                                </div>
                            </div>
                            
                            {/* Breakdown */}
                            <div className="space-y-1 max-h-48 overflow-y-auto">
                                {storageDiag.entries.map(e => (
                                    <div key={e.key} className="flex items-center gap-2 text-xs">
                                        <span className={`w-2 h-2 rounded-full ${e.protected ? 'bg-blue-400' : 'bg-slate-500'}`} />
                                        <span className="flex-1 font-mono truncate text-slate-400">{e.key}</span>
                                        <span className="text-slate-500">{e.sizeFormatted}</span>
                                        <span className="text-slate-600 w-10 text-right">{e.percent}%</span>
                                    </div>
                                ))}
                            </div>
                            <div className="text-xs text-slate-500">
                                <span className="inline-flex items-center gap-1"><span className="w-2 h-2 rounded-full bg-blue-400 inline-block" /> Protected</span>
                                {' · '}
                                <span className="inline-flex items-center gap-1"><span className="w-2 h-2 rounded-full bg-slate-500 inline-block" /> Prunable</span>
                            </div>
                            
                            {/* Actions */}
                            <div className="flex gap-2 pt-2">
                                <button onClick={() => {
                                    const r = StorageManager.cleanup(false);
                                    setCleanupResult(r);
                                    setStorageDiag(StorageManager.getDiagnostics());
                                }} className="px-3 py-1.5 bg-amber-700 rounded hover:bg-amber-600 text-sm">
                                    🧹 Smart Cleanup
                                </button>
                                <button onClick={() => {
                                    const r = StorageManager.cleanup(true);
                                    setCleanupResult(r);
                                    setStorageDiag(StorageManager.getDiagnostics());
                                }} className="px-3 py-1.5 bg-red-700 rounded hover:bg-red-600 text-sm">
                                    🗑️ Aggressive Cleanup
                                </button>
                                <button onClick={() => { setStorageDiag(StorageManager.getDiagnostics()); setCleanupResult(null); }}
                                    className="px-3 py-1.5 bg-slate-700 rounded hover:bg-slate-600 text-sm">
                                    🔄 Refresh
                                </button>
                            </div>
                            
                            {cleanupResult && (
                                <div className="p-3 bg-slate-900 rounded text-xs space-y-1">
                                    <div className="text-green-400">Freed {StorageManager._formatBytes(cleanupResult.freed)}</div>
                                    {cleanupResult.actions.map((a, i) => (
                                        <div key={i} className="text-slate-400">
                                            {a.key}: {a.action} ({StorageManager._formatBytes(a.freed)})
                                        </div>
                                    ))}
                                    {cleanupResult.actions.length === 0 && (
                                        <div className="text-slate-500">Nothing to clean up</div>
                                    )}
                                </div>
                            )}
                        </div>
                    )}
                </div>
            </div>
        );
    }

    // =========================================================================
    // RENDER
    // =========================================================================
    
    try {
        ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    } catch (error) {
        document.getElementById('root').innerHTML = `<div style="padding:20px;background:#7f1d1d;margin:20px;border-radius:10px;">
            <h2>Error</h2><pre>${error.message}</pre>
            <button onclick="localStorage.clear();location.reload();" style="margin-top:10px;padding:10px;cursor:pointer;">Clear & Reload</button>
        </div>`;
    }
    </script>
</body>
</html>
