<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Command Center</title>
    <meta name="version" content="8.44.0">
    <meta name="gs-app-id" content="command-center">
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-functions-compat.js"></script>
    <style>
        * { box-sizing: border-box; }
        body { margin: 0; font-family: system-ui, -apple-system, sans-serif; background: #0f172a; color: #e2e8f0; }
        .animate-spin { animation: spin 1s linear infinite; }
        @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
        .fade-in { animation: fadeIn 0.2s ease-out; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(-10px); } to { opacity: 1; transform: translateY(0); } }
    </style>
</head>
<body>
    <div id="root"><div style="display:flex;align-items:center;justify-content:center;min-height:100vh;"><div style="text-align:center;"><div style="margin-bottom:20px;"><svg viewBox="0 0 100 100" width="64" height="64" xmlns="http://www.w3.org/2000/svg"><defs><linearGradient id="gsLoadGrad" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" style="stop-color:#667eea"/><stop offset="100%" style="stop-color:#764ba2"/></linearGradient></defs><rect x="5" y="5" width="90" height="90" rx="20" fill="url(#gsLoadGrad)"/><g transform="rotate(-12, 35, 50)"><rect x="15" y="28" width="28" height="36" rx="4" fill="white"/><circle cx="43" cy="46" r="6" fill="white"/><text x="29" y="54" font-family="Arial" font-size="20" font-weight="bold" fill="#667eea" text-anchor="middle">G</text></g><g transform="rotate(12, 65, 50)"><rect x="57" y="28" width="28" height="36" rx="4" fill="rgba(255,255,255,0.9)"/><circle cx="57" cy="46" r="6" fill="url(#gsLoadGrad)"/><text x="71" y="54" font-family="Arial" font-size="20" font-weight="bold" fill="#764ba2" text-anchor="middle">S</text></g></svg></div>Loading...</div></div></div>

    <script type="text/babel">
    console.log(`Command Center v${document.querySelector('meta[name="version"]')?.content || '?'} starting...`);
    
    // =========================================================================
    // FIREBASE CONFIG
    // =========================================================================
    
    const FIREBASE_CONFIG = {
        apiKey: "AIzaSyBQVwn8vOrFTzLlm2MYIPBwgZV2xR9AuhM",
        authDomain: "word-boxing.firebaseapp.com",
        databaseURL: "https://word-boxing-default-rtdb.firebaseio.com",
        projectId: "word-boxing"
    };
    
    // Custom domain mapping for repos
    // Maps repo full names to their custom domains
    const CUSTOM_DOMAINS = {
        'stewartdavidp-ship-it/gameshelf': 'gameshelf.co',
        'stewartdavidp-ship-it/quote-info': 'quotle.info'
    };
    
    // Initialize Firebase
    let firebaseApp = null;
    let firebaseAuth = null;
    let firebaseDb = null;
    
    try {
        if (!firebase.apps.length) {
            firebaseApp = firebase.initializeApp(FIREBASE_CONFIG);
        } else {
            firebaseApp = firebase.apps[0];
        }
        firebaseAuth = firebase.auth();
        firebaseDb = firebase.database();
        console.log('Firebase initialized successfully');
    } catch (e) {
        console.error('Firebase init error:', e);
    }
    
    // =========================================================================
    // FIREBASE ADMIN (v8.9.0 — Service Account Token Management)
    // =========================================================================
    
    class FirebaseAdmin {
        constructor() {
            this.serviceAccount = null;
            this.cachedToken = null;
            this.tokenExpiry = null;
            this.loadServiceAccount();
        }
        
        // Load service account JSON from localStorage
        loadServiceAccount() {
            try {
                const stored = localStorage.getItem('cc_firebase_sa');
                if (stored) {
                    this.serviceAccount = JSON.parse(stored);
                    console.log('Firebase SA loaded:', this.serviceAccount.client_email);
                }
            } catch (e) {
                console.error('Failed to load service account:', e);
                this.serviceAccount = null;
            }
        }
        
        // Save service account JSON to localStorage
        saveServiceAccount(saJson) {
            try {
                const sa = typeof saJson === 'string' ? JSON.parse(saJson) : saJson;
                // Validate required fields
                const required = ['type', 'project_id', 'private_key', 'client_email'];
                const missing = required.filter(f => !sa[f]);
                if (missing.length > 0) {
                    throw new Error(`Missing required fields: ${missing.join(', ')}`);
                }
                if (sa.type !== 'service_account') {
                    throw new Error(`Invalid type "${sa.type}" — expected "service_account"`);
                }
                // Validate private key format
                if (!sa.private_key.includes('BEGIN') || !sa.private_key.includes('PRIVATE KEY')) {
                    throw new Error('Invalid private key format');
                }
                this.serviceAccount = sa;
                localStorage.setItem('cc_firebase_sa', JSON.stringify(sa));
                this.cachedToken = null;
                this.tokenExpiry = null;
                console.log('Firebase SA saved:', sa.client_email);
                return { success: true, email: sa.client_email, project: sa.project_id };
            } catch (e) {
                console.error('Failed to save service account:', e);
                return { success: false, error: e.message };
            }
        }
        
        // Remove service account from localStorage
        clearServiceAccount() {
            this.serviceAccount = null;
            this.cachedToken = null;
            this.tokenExpiry = null;
            localStorage.removeItem('cc_firebase_sa');
            console.log('Firebase SA cleared');
        }
        
        // Check if configured
        isConfigured() {
            return this.serviceAccount !== null && !!this.serviceAccount.private_key;
        }
        
        // Get summary info (safe to display)
        getInfo() {
            if (!this.serviceAccount) return null;
            return {
                email: this.serviceAccount.client_email,
                projectId: this.serviceAccount.project_id,
                keyId: this.serviceAccount.private_key_id?.slice(0, 8) + '...',
                tokenCached: !!this.cachedToken,
                tokenExpiry: this.tokenExpiry ? new Date(this.tokenExpiry).toLocaleTimeString() : null,
                tokenValid: this.cachedToken && this.tokenExpiry && Date.now() < this.tokenExpiry
            };
        }
        
        // Parse PEM private key to CryptoKey for RS256 signing
        async importPrivateKey(pemKey) {
            // Strip PEM header/footer and whitespace
            const pemContents = pemKey
                .replace(/-----BEGIN (RSA )?PRIVATE KEY-----/, '')
                .replace(/-----END (RSA )?PRIVATE KEY-----/, '')
                .replace(/\s/g, '');
            
            // Decode base64 to ArrayBuffer
            const binaryStr = atob(pemContents);
            const bytes = new Uint8Array(binaryStr.length);
            for (let i = 0; i < binaryStr.length; i++) {
                bytes[i] = binaryStr.charCodeAt(i);
            }
            
            // Import as PKCS8 key
            return await crypto.subtle.importKey(
                'pkcs8',
                bytes.buffer,
                { name: 'RSASSA-PKCS1-v1_5', hash: 'SHA-256' },
                false,
                ['sign']
            );
        }
        
        // Base64url encode (no padding, URL-safe)
        base64url(data) {
            if (typeof data === 'string') {
                data = new TextEncoder().encode(data);
            }
            const bytes = new Uint8Array(data);
            let binary = '';
            for (let i = 0; i < bytes.length; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            const base64 = btoa(binary);
            return base64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
        }
        
        // Create and sign a JWT for Google OAuth2
        async createSignedJWT(scopes) {
            const sa = this.serviceAccount;
            if (!sa) throw new Error('No service account configured');
            
            const now = Math.floor(Date.now() / 1000);
            
            const header = { alg: 'RS256', typ: 'JWT' };
            if (sa.private_key_id) header.kid = sa.private_key_id;
            
            const payload = {
                iss: sa.client_email,
                scope: Array.isArray(scopes) ? scopes.join(' ') : scopes,
                aud: 'https://oauth2.googleapis.com/token',
                iat: now,
                exp: now + 3600 // 1 hour
            };
            
            const headerB64 = this.base64url(JSON.stringify(header));
            const payloadB64 = this.base64url(JSON.stringify(payload));
            const signingInput = `${headerB64}.${payloadB64}`;
            
            // Import key and sign
            const cryptoKey = await this.importPrivateKey(sa.private_key);
            const signature = await crypto.subtle.sign(
                'RSASSA-PKCS1-v1_5',
                cryptoKey,
                new TextEncoder().encode(signingInput)
            );
            
            const signatureB64 = this.base64url(signature);
            return `${signingInput}.${signatureB64}`;
        }
        
        // Exchange signed JWT for a Google OAuth2 access token
        async getAccessToken(scopes = [
            'https://www.googleapis.com/auth/userinfo.email',
            'https://www.googleapis.com/auth/firebase.database',
            'https://www.googleapis.com/auth/cloud-platform'
        ]) {
            // Return cached token if still valid (with 5 min buffer)
            if (this.cachedToken && this.tokenExpiry && Date.now() < (this.tokenExpiry - 300000)) {
                return this.cachedToken;
            }
            
            const jwt = await this.createSignedJWT(scopes);
            
            const response = await fetch('https://oauth2.googleapis.com/token', {
                method: 'POST',
                headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                body: new URLSearchParams({
                    grant_type: 'urn:ietf:params:oauth:grant-type:jwt-bearer',
                    assertion: jwt
                })
            });
            
            if (!response.ok) {
                const err = await response.json().catch(() => ({}));
                throw new Error(`Token exchange failed: ${err.error_description || err.error || response.status}`);
            }
            
            const data = await response.json();
            this.cachedToken = data.access_token;
            this.tokenExpiry = Date.now() + ((data.expires_in || 3600) * 1000);
            console.log('Firebase admin token obtained, expires:', new Date(this.tokenExpiry).toLocaleTimeString());
            return this.cachedToken;
        }
        
        // Invalidate cached token
        clearToken() {
            this.cachedToken = null;
            this.tokenExpiry = null;
        }
        
        // ---- RTDB Rules API ----
        
        // Get current RTDB security rules
        async getRules() {
            const token = await this.getAccessToken();
            const dbUrl = FIREBASE_CONFIG.databaseURL;
            const response = await fetch(`${dbUrl}/.settings/rules.json?access_token=${encodeURIComponent(token)}`);
            if (!response.ok) {
                const err = await response.text();
                throw new Error(`Failed to fetch rules: ${response.status} — ${err}`);
            }
            return await response.json();
        }
        
        // Deploy new RTDB security rules
        async putRules(rules) {
            const token = await this.getAccessToken();
            const dbUrl = FIREBASE_CONFIG.databaseURL;
            const body = typeof rules === 'string' ? rules : JSON.stringify(rules);
            const response = await fetch(`${dbUrl}/.settings/rules.json?access_token=${encodeURIComponent(token)}`, {
                method: 'PUT',
                body: body
            });
            if (!response.ok) {
                const err = await response.text();
                throw new Error(`Failed to deploy rules: ${response.status} — ${err}`);
            }
            return await response.json();
        }
        
        // ---- Cloud Functions API ----
        
        // List all Cloud Functions in the project
        async listFunctions(location = 'us-central1') {
            const token = await this.getAccessToken();
            const projectId = this.serviceAccount.project_id;
            const url = `https://cloudfunctions.googleapis.com/v1/projects/${projectId}/locations/${location}/functions`;
            const response = await fetch(url, {
                headers: { 'Authorization': `Bearer ${token}` }
            });
            if (!response.ok) {
                const err = await response.json().catch(() => ({}));
                throw new Error(`Failed to list functions: ${err.error?.message || response.status}`);
            }
            const data = await response.json();
            return data.functions || [];
        }
        
        // ---- Cloud Logging API ----
        
        // Fetch recent logs (filtered by severity, function name, etc.)
        async getLogs(options = {}) {
            const token = await this.getAccessToken();
            const projectId = this.serviceAccount.project_id;
            const {
                filter = 'resource.type="cloud_function"',
                orderBy = 'timestamp desc',
                pageSize = 50
            } = options;
            
            const url = 'https://logging.googleapis.com/v2/entries:list';
            const response = await fetch(url, {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${token}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    resourceNames: [`projects/${projectId}`],
                    filter,
                    orderBy,
                    pageSize
                })
            });
            if (!response.ok) {
                const err = await response.json().catch(() => ({}));
                throw new Error(`Failed to fetch logs: ${err.error?.message || response.status}`);
            }
            const data = await response.json();
            return data.entries || [];
        }
        
        // Quick test — tries to read RTDB rules to verify admin access
        async testConnection() {
            const results = { token: false, rules: false, functions: false, errors: [] };
            
            try {
                await this.getAccessToken();
                results.token = true;
            } catch (e) {
                results.errors.push(`Token: ${e.message}`);
                return results;
            }
            
            try {
                const rules = await this.getRules();
                results.rules = rules && typeof rules === 'object';
            } catch (e) {
                results.errors.push(`Rules: ${e.message}`);
            }
            
            try {
                const fns = await this.listFunctions();
                results.functions = Array.isArray(fns);
                results.functionCount = fns.length;
            } catch (e) {
                results.errors.push(`Functions: ${e.message}`);
            }
            
            return results;
        }
    }
    
    // Global instance
    const firebaseAdmin = new FirebaseAdmin();
    
    // =========================================================================
    // FIREBASE CONFIG SYNC (v8.17.0 — Server-Side Config Storage)
    // =========================================================================
    // Syncs CC configuration data to Firebase RTDB as source of truth.
    // localStorage remains the instant-load cache; Firebase is the primary store.
    // Sensitive data (tokens, SA keys, API keys) stays in localStorage only.
    //
    // Firebase path: command-center/{dataKey}
    // Data sets synced: config, deploy-history, rules-history, session-log,
    //                   deletion-history, rollback-snapshots
    // =========================================================================
    
    const FirebaseConfigSync = {
        BASE_PATH: 'command-center',
        db: null,
        initialized: false,
        syncStatus: 'offline', // 'offline' | 'syncing' | 'synced' | 'error'
        statusListeners: new Set(),
        
        // Data key → localStorage key mapping
        DATA_KEYS: {
            'config': 'commandCenterConfig',
            'deploy-history': 'cc_history_v2',
            'rules-history': 'cc_rulesHistory',
            'session-log': 'cc_session_log',
            'deletion-history': 'cc_deletion_history',
            'rollback-snapshots': 'cc_rollback_snapshots'
        },
        
        // Initialize with Firebase database reference
        init(database) {
            if (!database) {
                console.warn('[ConfigSync] No database provided, running in offline mode');
                return;
            }
            this.db = database;
            this.initialized = true;
            console.log('[ConfigSync] Initialized with Firebase RTDB');
        },
        
        // --- Status management ---
        
        _setStatus(status) {
            this.syncStatus = status;
            this.statusListeners.forEach(fn => fn(status));
        },
        
        onStatusChange(callback) {
            this.statusListeners.add(callback);
            return () => this.statusListeners.delete(callback);
        },
        
        // --- Write methods (fire-and-forget after localStorage save) ---
        
        // Debounce timers per data key (prevents rapid-fire writes during batch operations)
        _debounceTimers: {},
        DEBOUNCE_KEYS: new Set(['deploy-history', 'session-log', 'deletion-history']), // Keys that get debounced
        DEBOUNCE_MS: 2000, // 2-second debounce window
        
        async push(dataKey, data) {
            if (!this.initialized || !this.db) return;
            try {
                const payload = JSON.parse(JSON.stringify(data)); // Deep clone to strip undefined
                payload._updatedAt = Date.now();
                payload._updatedBy = 'local';
                await this.db.ref(`${this.BASE_PATH}/${dataKey}`).set(payload);
                this._setStatus('synced');
                console.log(`[ConfigSync] Pushed ${dataKey} to Firebase`);
            } catch (err) {
                console.warn(`[ConfigSync] Failed to push ${dataKey}:`, err.message);
                this._setStatus('error');
            }
        },
        
        // Debounced push — delays the write, resets timer on each call
        pushDebounced(dataKey, data) {
            if (!this.initialized || !this.db) return Promise.resolve();
            
            // Clear any existing timer for this key
            if (this._debounceTimers[dataKey]) {
                clearTimeout(this._debounceTimers[dataKey]);
            }
            
            this._setStatus('syncing');
            
            return new Promise((resolve) => {
                this._debounceTimers[dataKey] = setTimeout(() => {
                    delete this._debounceTimers[dataKey];
                    this.push(dataKey, data).then(resolve).catch(resolve);
                }, this.DEBOUNCE_MS);
            });
        },
        
        // Smart push — uses debounce for rapid-fire keys, immediate for others
        pushSmart(dataKey, data) {
            if (this.DEBOUNCE_KEYS.has(dataKey)) {
                return this.pushDebounced(dataKey, data);
            }
            return this.push(dataKey, data);
        },
        
        async pushConfig(config) {
            return this.push('config', config);
        },
        
        async pushDeployHistory(history) {
            return this.pushSmart('deploy-history', history);
        },
        
        async pushRulesHistory(history) {
            return this.push('rules-history', history);
        },
        
        async pushSessionLog(log) {
            return this.pushSmart('session-log', log);
        },
        
        async pushDeletionHistory(history) {
            return this.pushSmart('deletion-history', history);
        },
        
        async pushRollbackSnapshots(snapshots) {
            return this.push('rollback-snapshots', snapshots);
        },
        
        // --- Read methods (one-time fetch for startup overlay) ---
        
        async pull(dataKey) {
            if (!this.initialized || !this.db) return null;
            try {
                const snap = await this.db.ref(`${this.BASE_PATH}/${dataKey}`).once('value');
                return snap.val();
            } catch (err) {
                console.warn(`[ConfigSync] Failed to pull ${dataKey}:`, err.message);
                return null;
            }
        },
        
        async pullConfig() {
            return this.pull('config');
        },
        
        async pullDeployHistory() {
            const data = await this.pull('deploy-history');
            return data || [];
        },
        
        async pullRulesHistory() {
            const data = await this.pull('rules-history');
            return data || [];
        },
        
        async pullSessionLog() {
            const data = await this.pull('session-log');
            return data || { currentSession: null, sessions: [], issues: [], notes: '' };
        },
        
        async pullDeletionHistory() {
            const data = await this.pull('deletion-history');
            return data || [];
        },
        
        async pullRollbackSnapshots() {
            const data = await this.pull('rollback-snapshots');
            return data || {};
        },
        
        // --- Startup sync: pull all data from Firebase ---
        // Returns an object with all synced data sets, or null for sets not found.
        // The caller decides whether to overlay onto local state.
        
        async pullAll() {
            if (!this.initialized || !this.db) {
                this._setStatus('offline');
                return null;
            }
            
            this._setStatus('syncing');
            
            try {
                const [config, deployHistory, rulesHistory, sessionLog, deletionHistory, rollbackSnapshots] = await Promise.all([
                    this.pullConfig(),
                    this.pullDeployHistory(),
                    this.pullRulesHistory(),
                    this.pullSessionLog(),
                    this.pullDeletionHistory(),
                    this.pullRollbackSnapshots()
                ]);
                
                this._setStatus('synced');
                
                return {
                    config,
                    deployHistory,
                    rulesHistory,
                    sessionLog,
                    deletionHistory,
                    rollbackSnapshots,
                    _pulledAt: Date.now()
                };
            } catch (err) {
                console.warn('[ConfigSync] pullAll failed:', err.message);
                this._setStatus('error');
                return null;
            }
        },
        
        // --- Push all non-sensitive data to Firebase (initial seed or manual sync) ---
        
        async pushAll({ config, deployHistory, rulesHistory, sessionLog, deletionHistory, rollbackSnapshots }) {
            if (!this.initialized || !this.db) return false;
            
            this._setStatus('syncing');
            
            try {
                const promises = [];
                if (config) promises.push(this.pushConfig(config));
                if (deployHistory) promises.push(this.pushDeployHistory(deployHistory));
                if (rulesHistory) promises.push(this.pushRulesHistory(rulesHistory));
                if (sessionLog) promises.push(this.pushSessionLog(sessionLog));
                if (deletionHistory) promises.push(this.pushDeletionHistory(deletionHistory));
                if (rollbackSnapshots) promises.push(this.pushRollbackSnapshots(rollbackSnapshots));
                
                await Promise.all(promises);
                this._setStatus('synced');
                console.log('[ConfigSync] Pushed all data to Firebase');
                return true;
            } catch (err) {
                console.warn('[ConfigSync] pushAll failed:', err.message);
                this._setStatus('error');
                return false;
            }
        },
        
        // --- Determine if Firebase data is newer than local ---
        
        isNewer(firebaseData, localTimestamp) {
            if (!firebaseData || !firebaseData._updatedAt) return false;
            return firebaseData._updatedAt > (localTimestamp || 0);
        },
        
        // --- Clear all Command Center data from Firebase ---
        
        async clearAll() {
            if (!this.initialized || !this.db) return false;
            this._setStatus('syncing');
            try {
                await this.db.ref(this.BASE_PATH).remove();
                this._setStatus('synced');
                console.log('[ConfigSync] Cleared all Firebase data');
                return true;
            } catch (err) {
                console.warn('[ConfigSync] Failed to clear Firebase data:', err.message);
                this._setStatus('error');
                return false;
            }
        },
        
        // --- Get approximate data size in Firebase ---
        
        async getDataSize() {
            if (!this.initialized || !this.db) return null;
            try {
                const snap = await this.db.ref(this.BASE_PATH).once('value');
                const data = snap.val();
                if (!data) return { totalBytes: 0, keys: {} };
                const totalStr = JSON.stringify(data);
                const keys = {};
                for (const key of Object.keys(data)) {
                    keys[key] = JSON.stringify(data[key]).length;
                }
                return { totalBytes: totalStr.length, keys };
            } catch (err) {
                console.warn('[ConfigSync] Failed to get data size:', err.message);
                return null;
            }
        }
    };
    
    // Initialize ConfigSync with the database reference
    FirebaseConfigSync.init(firebaseDb);
    
    // =========================================================================
    // DATA SERVICE LAYER (v8.19.0)
    // Namespaced service objects that encapsulate CRUD for each entity type.
    // Pattern: localStorage (immediate) + Firebase (async, fire-and-forget).
    // These services wrap existing data access patterns into clean APIs.
    // Views continue to use React state for rendering; services handle persistence.
    // =========================================================================
    
    /**
     * DeployService — Deploy history CRUD
     * Wraps: localStorage 'cc_history_v2' + FirebaseConfigSync deploy-history
     * Used by: App() deployments state, HistoryView, DashboardView
     */
    const DeployService = {
        STORAGE_KEY: 'cc_history_v2',
        MAX_HISTORY: 100,
        
        // Load deploy history from localStorage
        load() {
            try {
                const s = localStorage.getItem(this.STORAGE_KEY);
                return s ? JSON.parse(s) : [];
            } catch {
                return [];
            }
        },
        
        // Save full deploy history (localStorage + Firebase)
        save(deployments) {
            try {
                const history = deployments.slice(0, this.MAX_HISTORY);
                StorageManager.safeSet(this.STORAGE_KEY, JSON.stringify(history));
                if (FirebaseConfigSync.initialized) {
                    FirebaseConfigSync.pushDeployHistory(history).catch(() => {});
                }
                return true;
            } catch (e) {
                console.error('[DeployService] Save failed:', e);
                return false;
            }
        },
        
        // Add a deployment record to the front of the list
        add(deployment, currentList) {
            const updated = [deployment, ...currentList].slice(0, this.MAX_HISTORY);
            this.save(updated);
            return updated;
        },
        
        // Update a specific deployment record by id
        update(deploymentId, updates, currentList) {
            const updated = currentList.map(d =>
                d.id === deploymentId ? { ...d, ...updates } : d
            );
            this.save(updated);
            return updated;
        },
        
        // Get deployments for a specific app
        getForApp(appId, currentList) {
            return currentList.filter(d => d.appId === appId);
        },
        
        // Get recent deployments (last N)
        getRecent(n, currentList) {
            return currentList.slice(0, n);
        },
        
        // Overlay from Firebase (used during startup sync)
        overlay(remoteData) {
            if (!remoteData) return null;
            const { _updatedAt, _updatedBy, ...clean } = remoteData;
            try {
                localStorage.setItem(this.STORAGE_KEY, JSON.stringify(clean));
            } catch {}
            return Array.isArray(clean) ? clean : Object.values(clean);
        }
    };
    
    /**
     * SessionLogService — Session log CRUD
     * Wraps: localStorage 'cc_session_log' + FirebaseConfigSync session-log
     * Used by: App() sessionLog state, SessionLogView, generateSessionBrief
     */
    const SessionLogService = {
        STORAGE_KEY: 'cc_session_log',
        
        DEFAULT_STATE: {
            currentSession: null,
            sessions: [],
            issues: [],
            notes: '',
            recentEntries: []
        },
        
        // Load session log from localStorage
        load() {
            try {
                const s = localStorage.getItem(this.STORAGE_KEY);
                return s ? JSON.parse(s) : { ...this.DEFAULT_STATE };
            } catch {
                return { ...this.DEFAULT_STATE };
            }
        },
        
        // Save full session log (localStorage + Firebase)
        save(sessionLog) {
            try {
                StorageManager.safeSet(this.STORAGE_KEY, JSON.stringify(sessionLog));
                if (FirebaseConfigSync.initialized) {
                    FirebaseConfigSync.pushSessionLog(sessionLog).catch(() => {});
                }
                return true;
            } catch (e) {
                console.error('[SessionLogService] Save failed:', e);
                return false;
            }
        },
        
        // Add a recent entry to the session log
        addRecentEntry(entry, currentLog) {
            const updated = {
                ...currentLog,
                recentEntries: [...(currentLog.recentEntries || []), entry].slice(-20)
            };
            this.save(updated);
            return updated;
        },
        
        // Update session notes
        updateNotes(notes, currentLog) {
            const updated = { ...currentLog, notes };
            this.save(updated);
            return updated;
        },
        
        // Set current session
        setCurrentSession(session, currentLog) {
            const updated = { ...currentLog, currentSession: session };
            this.save(updated);
            return updated;
        },
        
        // Overlay from Firebase (used during startup sync)
        overlay(remoteData) {
            if (!remoteData || !remoteData._updatedAt) return null;
            const { _updatedAt, _updatedBy, ...clean } = remoteData;
            try {
                localStorage.setItem(this.STORAGE_KEY, JSON.stringify(clean));
            } catch {}
            return clean;
        }
    };
    
    /**
     * IssueService — Issues CRUD via Firebase (per-user path)
     * Wraps: Firebase RTDB `command-center/{uid}/issues` path
     * Used by: IssuesView, App() globalIssues state, deploy issue-linking
     * Note: Issues are stored in Firebase under the user's UID, not in localStorage.
     */
    const IssueService = {
        BASE_PATH: 'command-center',
        
        // Get the Firebase ref for issues (requires uid)
        _ref(uid) {
            if (!firebaseDb || !uid) return null;
            return firebaseDb.ref(`${this.BASE_PATH}/${uid}/issues`);
        },
        
        // Listen for all issues (returns unsubscribe function)
        listen(uid, callback) {
            const ref = this._ref(uid);
            if (!ref) return () => {};
            
            ref.on('value', (snapshot) => {
                const data = snapshot.val();
                if (data) {
                    const list = Object.entries(data).map(([id, issue]) => ({ id, ...issue }));
                    callback(list.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt)));
                } else {
                    callback([]);
                }
            });
            
            return () => ref.off();
        },
        
        // Create a new issue
        async create(uid, issueData) {
            const ref = this._ref(uid);
            if (!ref) return null;
            
            const issue = {
                ...issueData,
                status: 'open',
                createdAt: new Date().toISOString(),
                createdBy: issueData.createdBy || 'manual',
                notes: issueData.notes || []
            };
            
            await ref.child(issueData.id).set(issue);
            return issue;
        },
        
        // Update an issue (partial update)
        async update(uid, issueId, updates) {
            const ref = this._ref(uid);
            if (!ref) return;
            await ref.child(issueId).update(updates);
        },
        
        // Update issue status with timestamp
        async updateStatus(uid, issueId, newStatus, extraData = {}) {
            const updates = {
                status: newStatus,
                [`${newStatus}At`]: new Date().toISOString(),
                ...extraData
            };
            await this.update(uid, issueId, updates);
        },
        
        // Link issues to a deployed version
        async linkToVersion(uid, issueIds, version, appId) {
            if (!issueIds || !issueIds.length) return;
            
            for (const issueId of issueIds) {
                await this.update(uid, issueId, {
                    status: 'fixed',
                    fixedAt: new Date().toISOString(),
                    fixedInVersion: version,
                    fixedInApp: appId
                });
            }
        },
        
        // Mark issues as released to prod
        async markReleasedToProd(uid, issueIds, version) {
            for (const issueId of issueIds) {
                await this.update(uid, issueId, {
                    status: 'closed',
                    closedAt: new Date().toISOString(),
                    releasedToProd: true,
                    releasedInVersion: version
                });
            }
        },
        
        // Get next issue ID from existing list
        getNextId(currentIssues) {
            const existing = currentIssues.map(i => parseInt(i.id?.replace('ISS-', '') || 0));
            const max = Math.max(0, ...existing);
            return `ISS-${String(max + 1).padStart(3, '0')}`;
        }
    };
    
    /**
     * ReleaseService — Release records via Firebase (per-user path)
     * Wraps: Firebase RTDB `command-center/{uid}/releases` path
     * Used by: IssuesView for release tracking
     */
    const ReleaseService = {
        BASE_PATH: 'command-center',
        
        _ref(uid) {
            if (!firebaseDb || !uid) return null;
            return firebaseDb.ref(`${this.BASE_PATH}/${uid}/releases`);
        },
        
        // Listen for all releases
        listen(uid, callback) {
            const ref = this._ref(uid);
            if (!ref) return () => {};
            
            ref.on('value', (snapshot) => {
                const data = snapshot.val();
                if (data) {
                    const list = Object.entries(data).map(([id, rel]) => ({ id, ...rel }));
                    callback(list.sort((a, b) => new Date(b.deployedAt) - new Date(a.deployedAt)));
                } else {
                    callback([]);
                }
            });
            
            return () => ref.off();
        },
        
        // Create a release record
        async create(uid, releaseData) {
            const ref = this._ref(uid);
            if (!ref) return;
            
            const releaseId = `${releaseData.app}-${releaseData.version}-${Date.now()}`;
            await ref.child(releaseId).set({
                ...releaseData,
                deployedAt: releaseData.deployedAt || new Date().toISOString()
            });
            return releaseId;
        }
    };
    
    /**
     * UserReportService — User-submitted bug reports via Firebase (public path)
     * Wraps: Firebase RTDB `reported-issues` path
     * Used by: IssuesView for user report inbox
     */
    const UserReportService = {
        _ref() {
            if (!firebaseDb) return null;
            return firebaseDb.ref('reported-issues');
        },
        
        // Listen for all user reports
        listen(callback) {
            const ref = this._ref();
            if (!ref) return () => {};
            
            ref.on('value', (snapshot) => {
                const data = snapshot.val();
                if (data) {
                    const list = Object.entries(data).map(([id, report]) => ({
                        firebaseKey: id,
                        ...report
                    }));
                    callback(list.sort((a, b) =>
                        new Date(b.timestamp || b.createdAt || 0) - new Date(a.timestamp || a.createdAt || 0)
                    ));
                } else {
                    callback([]);
                }
            });
            
            return () => ref.off();
        }
    };
    
    /**
     * RollbackService — Rollback snapshot CRUD
     * Wraps: localStorage 'cc_rollback_snapshots' + FirebaseConfigSync rollback-snapshots
     * Used by: App() rollbackSnapshots state, DashboardView quick rollback
     */
    const RollbackService = {
        STORAGE_KEY: 'cc_rollback_snapshots',
        
        // Load from localStorage
        load() {
            try {
                const s = localStorage.getItem(this.STORAGE_KEY);
                return s ? JSON.parse(s) : {};
            } catch {
                return {};
            }
        },
        
        // Save (localStorage + Firebase)
        save(snapshots) {
            try {
                StorageManager.safeSet(this.STORAGE_KEY, JSON.stringify(snapshots));
                if (FirebaseConfigSync.initialized) {
                    FirebaseConfigSync.pushRollbackSnapshots(snapshots).catch(() => {});
                }
                return true;
            } catch (e) {
                console.error('[RollbackService] Save failed:', e);
                return false;
            }
        },
        
        // Get snapshot for an app/target
        get(appId, target, currentSnapshots) {
            return currentSnapshots[`${appId}:${target}`] || null;
        },
        
        // Save a snapshot
        set(appId, target, snapshot, currentSnapshots) {
            const key = `${appId}:${target}`;
            const updated = { ...currentSnapshots, [key]: snapshot };
            this.save(updated);
            return updated;
        },
        
        // Clear a snapshot
        clear(appId, target, currentSnapshots) {
            const key = `${appId}:${target}`;
            const updated = { ...currentSnapshots };
            delete updated[key];
            this.save(updated);
            return updated;
        }
    };
    
    // =========================================================================
    // STORAGE MANAGER — Intelligent localStorage cleanup
    // Monitors usage, auto-prunes when approaching quota, provides diagnostics
    // =========================================================================
    
    const StorageManager = {
        // Approximate localStorage limit (5MB for most browsers)
        QUOTA_LIMIT: 5 * 1024 * 1024,
        // Trigger cleanup when usage exceeds this percentage
        CLEANUP_THRESHOLD: 0.80,
        // After cleanup, try to get down to this percentage
        TARGET_AFTER_CLEANUP: 0.60,
        
        // Keys ordered by cleanup priority (first = safe to prune aggressively)
        PRUNABLE_KEYS: [
            { key: 'cc_rollback_snapshots', type: 'object', strategy: 'keep-latest', maxAge: 7 * 24 * 60 * 60 * 1000, label: 'Rollback Snapshots' },
            { key: 'cc_history_v2', type: 'array', strategy: 'trim', keepCount: 30, label: 'Deploy History' },
            { key: 'cc_session_log', type: 'object', strategy: 'trim-entries', keepCount: 10, label: 'Session Log' },
            { key: 'cc_deletion_history', type: 'array', strategy: 'trim', keepCount: 20, label: 'Deletion History' },
            { key: 'cc_rulesHistory', type: 'array', strategy: 'trim', keepCount: 10, label: 'Rules History' },
            { key: 'cc_tld_prices', type: 'object', strategy: 'clear', label: 'TLD Price Cache' },
            { key: 'cc_domain_health', type: 'object', strategy: 'clear', label: 'Domain Health Cache' },
        ],
        
        // Keys that should never be pruned
        PROTECTED_KEYS: ['cc_token', 'cc_token_expires', 'cc_apps_v6', 'commandCenterConfig', 'cc_firebase_sa', 'cc_firebase_uid', 'cc_collapsedProjects', 'cc_default_engine', 'cc_projectStates', 'cc_domain_config', 'cc_godaddy_config', 'cc_token_registry', 'cc_api_key', 'cc_repo_health_last', 'githubRepoAssignments'],
        
        // Get current storage usage in bytes
        getUsage() {
            let total = 0;
            const breakdown = {};
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                const value = localStorage.getItem(key);
                const size = (key.length + value.length) * 2; // UTF-16
                total += size;
                breakdown[key] = size;
            }
            return { total, breakdown, percent: (total / this.QUOTA_LIMIT * 100).toFixed(1) };
        },
        
        // Get human-readable diagnostics
        getDiagnostics() {
            const { total, breakdown, percent } = this.getUsage();
            const sorted = Object.entries(breakdown).sort((a, b) => b[1] - a[1]);
            return {
                totalBytes: total,
                totalFormatted: this._formatBytes(total),
                percent: parseFloat(percent),
                quotaFormatted: this._formatBytes(this.QUOTA_LIMIT),
                entries: sorted.map(([key, size]) => ({
                    key,
                    size,
                    sizeFormatted: this._formatBytes(size),
                    percent: (size / total * 100).toFixed(1),
                    protected: this.PROTECTED_KEYS.includes(key)
                }))
            };
        },
        
        // Intelligent cleanup — called automatically on QuotaExceededError or manually
        cleanup(aggressive = false) {
            const before = this.getUsage();
            const target = this.QUOTA_LIMIT * (aggressive ? 0.40 : this.TARGET_AFTER_CLEANUP);
            let freed = 0;
            const actions = [];
            
            console.log(`[StorageManager] Cleanup started. Usage: ${this._formatBytes(before.total)} (${before.percent}%)`);
            
            for (const rule of this.PRUNABLE_KEYS) {
                if (before.total - freed <= target) break;
                
                try {
                    const raw = localStorage.getItem(rule.key);
                    if (!raw) continue;
                    const sizeBefore = (rule.key.length + raw.length) * 2;
                    
                    if (rule.strategy === 'clear') {
                        localStorage.removeItem(rule.key);
                        freed += sizeBefore;
                        actions.push({ key: rule.key, action: 'cleared', freed: sizeBefore });
                        continue;
                    }
                    
                    const data = JSON.parse(raw);
                    
                    if (rule.strategy === 'keep-latest' && typeof data === 'object' && !Array.isArray(data)) {
                        // Rollback snapshots: remove entries older than maxAge, keep only most recent per app
                        const now = Date.now();
                        const maxAge = aggressive ? 24 * 60 * 60 * 1000 : rule.maxAge;
                        const pruned = {};
                        for (const [k, v] of Object.entries(data)) {
                            const savedAt = v.savedAt ? new Date(v.savedAt).getTime() : 0;
                            if (now - savedAt < maxAge) {
                                pruned[k] = v;
                            }
                        }
                        // If still too big, strip content from oldest snapshots (keep metadata)
                        if (aggressive) {
                            const entries = Object.entries(pruned).sort((a, b) => 
                                new Date(b[1].savedAt || 0) - new Date(a[1].savedAt || 0));
                            // Keep only the 3 most recent with content
                            entries.slice(3).forEach(([k, v]) => {
                                pruned[k] = { ...v, content: '[pruned]', prunedAt: new Date().toISOString() };
                            });
                        }
                        const newRaw = JSON.stringify(pruned);
                        localStorage.setItem(rule.key, newRaw);
                        const sizeAfter = (rule.key.length + newRaw.length) * 2;
                        freed += sizeBefore - sizeAfter;
                        actions.push({ key: rule.key, action: `pruned ${Object.keys(data).length - Object.keys(pruned).length} snapshots`, freed: sizeBefore - sizeAfter });
                    }
                    
                    if (rule.strategy === 'trim' && Array.isArray(data)) {
                        const keepCount = aggressive ? Math.floor(rule.keepCount / 2) : rule.keepCount;
                        if (data.length > keepCount) {
                            const trimmed = data.slice(0, keepCount);
                            const newRaw = JSON.stringify(trimmed);
                            localStorage.setItem(rule.key, newRaw);
                            const sizeAfter = (rule.key.length + newRaw.length) * 2;
                            freed += sizeBefore - sizeAfter;
                            actions.push({ key: rule.key, action: `trimmed ${data.length} → ${keepCount}`, freed: sizeBefore - sizeAfter });
                        }
                    }
                    
                    if (rule.strategy === 'trim-entries' && typeof data === 'object') {
                        // Session log: trim sessions and recentEntries arrays
                        const keepCount = aggressive ? 5 : rule.keepCount;
                        const pruned = { ...data };
                        if (Array.isArray(pruned.sessions)) pruned.sessions = pruned.sessions.slice(-keepCount);
                        if (Array.isArray(pruned.recentEntries)) pruned.recentEntries = pruned.recentEntries.slice(-keepCount);
                        const newRaw = JSON.stringify(pruned);
                        localStorage.setItem(rule.key, newRaw);
                        const sizeAfter = (rule.key.length + newRaw.length) * 2;
                        freed += sizeBefore - sizeAfter;
                        actions.push({ key: rule.key, action: 'trimmed entries', freed: sizeBefore - sizeAfter });
                    }
                } catch (e) {
                    console.warn(`[StorageManager] Error pruning ${rule.key}:`, e);
                }
            }
            
            // Remove any orphan cc_ keys not in protected or prunable lists
            if (aggressive) {
                const knownKeys = new Set([
                    ...this.PROTECTED_KEYS,
                    ...this.PRUNABLE_KEYS.map(r => r.key)
                ]);
                for (let i = localStorage.length - 1; i >= 0; i--) {
                    const key = localStorage.key(i);
                    if (key?.startsWith('cc_') && !knownKeys.has(key)) {
                        const size = (key.length + localStorage.getItem(key).length) * 2;
                        localStorage.removeItem(key);
                        freed += size;
                        actions.push({ key, action: 'removed orphan', freed: size });
                    }
                }
            }
            
            const after = this.getUsage();
            console.log(`[StorageManager] Cleanup complete. Freed: ${this._formatBytes(freed)}. Usage: ${this._formatBytes(after.total)} (${after.percent}%)`);
            
            return { before: before.total, after: after.total, freed, actions };
        },
        
        // Wrap a localStorage.setItem call with auto-cleanup on quota error
        safeSet(key, value) {
            try {
                localStorage.setItem(key, value);
                return true;
            } catch (e) {
                if (e.name === 'QuotaExceededError') {
                    console.warn(`[StorageManager] Quota exceeded on ${key}, running cleanup...`);
                    this.cleanup(false);
                    try {
                        localStorage.setItem(key, value);
                        return true;
                    } catch {
                        console.warn(`[StorageManager] Still full after cleanup, running aggressive cleanup...`);
                        this.cleanup(true);
                        try {
                            localStorage.setItem(key, value);
                            return true;
                        } catch {
                            console.error(`[StorageManager] Cannot save ${key} even after aggressive cleanup`);
                            return false;
                        }
                    }
                }
                throw e;
            }
        },
        
        _formatBytes(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
            return (bytes / (1024 * 1024)).toFixed(2) + ' MB';
        }
    };
    
    // =========================================================================
    // PHASE 0.2 DATA SERVICES — Orchestrator entity services
    // =========================================================================
    
    /**
     * WorkItemService — Work item (backlog) CRUD via Firebase
     * Wraps: Firebase RTDB `command-center/{uid}/backlog` path
     * Used by: Future BacklogView, Claude Prep targeting, deploy close-the-loop
     * 
     * Work items are the building blocks of project planning:
     *   id: 'WI-NNN' (auto-generated)
     *   appId: which app this belongs to
     *   title, description: what to build
     *   type: feature | bugfix | enhancement | chore | research
     *   priority: core | nice-to-have | out-of-scope
     *   milestone: prototype | alpha | beta | production
     *   status: idea → ready → in-progress → review → done → deferred
     *   effort: quick | session | multi-session | epic
     *   criteria: acceptance criteria array
     *   context: { filesAffected, sections, dependencies, notes, relatedItems }
     *   tags: string array for filtering
     *   Timestamps: createdAt, startedAt, completedAt, completedInVersion, sessionId
     */
    const WorkItemService = {
        BASE_PATH: 'command-center',
        
        _ref(uid) {
            if (!firebaseDb || !uid) return null;
            return firebaseDb.ref(`${this.BASE_PATH}/${uid}/backlog`);
        },
        
        // Listen for all work items (returns unsubscribe function)
        listen(uid, callback) {
            const ref = this._ref(uid);
            if (!ref) return () => {};
            
            ref.on('value', (snapshot) => {
                const data = snapshot.val();
                if (data) {
                    const list = Object.entries(data).map(([id, item]) => ({ id, ...item }));
                    callback(list.sort((a, b) => new Date(b.createdAt || 0) - new Date(a.createdAt || 0)));
                } else {
                    callback([]);
                }
            });
            
            return () => ref.off();
        },
        
        // Get a single work item
        async get(uid, itemId) {
            const ref = this._ref(uid);
            if (!ref) return null;
            const snapshot = await ref.child(itemId).once('value');
            const data = snapshot.val();
            return data ? { id: itemId, ...data } : null;
        },
        
        // Create a new work item
        async create(uid, itemData) {
            const ref = this._ref(uid);
            if (!ref) return null;
            
            const item = {
                appId: itemData.appId,
                streamId: itemData.streamId || null,  // Phase 5.3: optional stream assignment
                title: itemData.title,
                description: itemData.description || '',
                type: itemData.type || 'feature',
                priority: itemData.priority || 'core',
                milestone: itemData.milestone || 'beta',
                status: itemData.status || 'idea',
                effort: itemData.effort || 'session',
                criteria: itemData.criteria || [],
                context: {
                    filesAffected: itemData.context?.filesAffected || [],
                    sections: itemData.context?.sections || [],
                    dependencies: itemData.context?.dependencies || [],
                    notes: itemData.context?.notes || '',
                    relatedItems: itemData.context?.relatedItems || []
                },
                tags: itemData.tags || [],
                createdAt: new Date().toISOString(),
                createdBy: itemData.createdBy || 'manual',
                source: itemData.source || 'manual',
                startedAt: null,
                completedAt: null,
                completedInVersion: null,
                sessionId: null
            };
            
            await ref.child(itemData.id).set(item);
            console.log(`[WorkItemService] Created ${itemData.id}: ${item.title}`);
            return { id: itemData.id, ...item };
        },
        
        // Update a work item (partial)
        async update(uid, itemId, updates) {
            const ref = this._ref(uid);
            if (!ref) return;
            await ref.child(itemId).update(updates);
        },
        
        // Transition status with timestamps
        async updateStatus(uid, itemId, newStatus, extraData = {}) {
            const now = new Date().toISOString();
            const updates = { status: newStatus, ...extraData };
            
            // Auto-set timestamps on status transitions
            switch (newStatus) {
                case 'in-progress':
                    updates.startedAt = now;
                    break;
                case 'review':
                    updates.reviewStartedAt = now;
                    break;
                case 'done':
                    updates.completedAt = now;
                    break;
                case 'deferred':
                    updates.deferredAt = now;
                    break;
            }
            
            await this.update(uid, itemId, updates);
            console.log(`[WorkItemService] ${itemId} → ${newStatus}`);
        },
        
        // Complete a work item (from deploy close-the-loop)
        async complete(uid, itemId, version) {
            await this.updateStatus(uid, itemId, 'done', {
                completedInVersion: version
            });
        },
        
        // Check if item has criteria (used for auto-transition suggestions)
        hasCriteria(item) {
            return item?.criteria && item.criteria.length > 0 && item.criteria.some(c => c.trim());
        },
        
        // Check if item is stale (in-progress or review for 7+ days)
        isStale(item) {
            if (item.status !== 'in-progress' && item.status !== 'review') return false;
            const startDate = item.status === 'review' ? item.reviewStartedAt : item.startedAt;
            if (!startDate) return false;
            return (Date.now() - new Date(startDate).getTime()) > 7 * 24 * 60 * 60 * 1000;
        },
        
        // Get stale days count
        getStaleDays(item) {
            const startDate = item.status === 'review' ? item.reviewStartedAt : item.startedAt;
            if (!startDate) return 0;
            return Math.floor((Date.now() - new Date(startDate).getTime()) / (24 * 60 * 60 * 1000));
        },
        
        // Get work items filtered by app
        filterByApp(items, appId) {
            return items.filter(i => i.appId === appId);
        },
        
        // Get work items filtered by stream (Phase 5.3)
        filterByStream(items, streamId) {
            return items.filter(i => i.streamId === streamId);
        },
        
        // Get unassigned work items (no stream) for an app
        getUnassigned(items, appId) {
            return items.filter(i => (!i.streamId) && (!appId || i.appId === appId));
        },
        
        // Get work items filtered by milestone
        filterByMilestone(items, milestone) {
            return items.filter(i => i.milestone === milestone);
        },
        
        // Get work items filtered by status
        filterByStatus(items, status) {
            return items.filter(i => i.status === status);
        },
        
        // Get in-progress items (for deploy close-the-loop)
        getInProgress(items, appId) {
            return items.filter(i => i.status === 'in-progress' && (!appId || i.appId === appId));
        },
        
        // Get items in review (for post-deploy completion)
        getInReview(items, appId) {
            return items.filter(i => i.status === 'review' && (!appId || i.appId === appId));
        },
        
        // Batch create work items (for scoping flow)
        async createBatch(uid, itemsData) {
            const ref = this._ref(uid);
            if (!ref) return [];
            
            const results = [];
            const updates = {};
            for (const itemData of itemsData) {
                const item = {
                    appId: itemData.appId,
                    streamId: itemData.streamId || null,  // Phase 5.3
                    title: itemData.title,
                    description: itemData.description || '',
                    type: itemData.type || 'feature',
                    priority: itemData.priority || 'core',
                    milestone: itemData.milestone || 'beta',
                    status: itemData.status || 'idea',
                    effort: itemData.effort || 'session',
                    criteria: itemData.criteria || [],
                    context: {
                        filesAffected: itemData.context?.filesAffected || [],
                        sections: itemData.context?.sections || [],
                        dependencies: itemData.context?.dependencies || [],
                        notes: itemData.context?.notes || '',
                        relatedItems: itemData.context?.relatedItems || []
                    },
                    tags: itemData.tags || [],
                    createdAt: new Date().toISOString(),
                    createdBy: itemData.createdBy || 'manual',
                    source: itemData.source || 'manual',
                    startedAt: null,
                    completedAt: null,
                    completedInVersion: null,
                    sessionId: null
                };
                updates[itemData.id] = item;
                results.push({ id: itemData.id, ...item });
            }
            await ref.update(updates);
            console.log(`[WorkItemService] Batch created ${results.length} items`);
            return results;
        },
        
        // Delete a work item
        async delete(uid, itemId) {
            const ref = this._ref(uid);
            if (!ref) return;
            await ref.child(itemId).remove();
            console.log(`[WorkItemService] Deleted ${itemId}`);
        },
        
        // Generate next work item ID from existing list
        getNextId(currentItems) {
            const existing = currentItems.map(i => parseInt(i.id?.replace('WI-', '') || '0'));
            const max = Math.max(0, ...existing);
            return `WI-${String(max + 1).padStart(3, '0')}`;
        }
    };
    
    /**
     * SessionService — Claude session tracking via Firebase
     * Wraps: Firebase RTDB `command-center/{uid}/sessions` path
     * Used by: Claude Prep (create on package generation), deploy (link session to deploy)
     * 
     * A session represents one AI interaction cycle: prep → build → handoff → deploy
     *   id: auto-generated timestamp-based
     *   appId: which app the session is for
     *   type: build | design | fix | test | research | review | polish | document
     *   workItemId: optional linked work item
     *   engineId: which AI engine was targeted
     *   status: prep | active | completed | abandoned
     *   packageTokens: estimated token count of the generated package
     *   deployId: linked deploy record (set after deploy)
     *   Timestamps: createdAt, completedAt
     */
    const SessionService = {
        BASE_PATH: 'command-center',
        
        _ref(uid) {
            if (!firebaseDb || !uid) return null;
            return firebaseDb.ref(`${this.BASE_PATH}/${uid}/sessions`);
        },
        
        // Listen for all sessions
        listen(uid, callback) {
            const ref = this._ref(uid);
            if (!ref) return () => {};
            
            ref.on('value', (snapshot) => {
                const data = snapshot.val();
                if (data) {
                    const list = Object.entries(data).map(([id, s]) => ({ id, ...s }));
                    callback(list.sort((a, b) => new Date(b.createdAt || 0) - new Date(a.createdAt || 0)));
                } else {
                    callback([]);
                }
            });
            
            return () => ref.off();
        },
        
        // Create a session record (called when Claude Prep generates a package)
        async create(uid, sessionData) {
            const ref = this._ref(uid);
            if (!ref) return null;
            
            const sessionId = `sess-${Date.now()}`;
            const session = {
                appId: sessionData.appId,
                type: sessionData.type || 'build',
                workItemId: sessionData.workItemId || null,
                engineId: sessionData.engineId || 'claude-sonnet-4.5',
                status: 'prep',
                packageTokens: sessionData.packageTokens || 0,
                packageFiles: sessionData.packageFiles || [],
                deployId: null,
                notes: sessionData.notes || '',
                // Phase 3: Review tracking
                review: null,       // { criteriaResults: [{id, text, met: bool}], reviewedBy, reviewedAt, notes }
                deliverables: null,  // { files: [string], importedAt, summary }
                createdAt: new Date().toISOString(),
                completedAt: null
            };
            
            await ref.child(sessionId).set(session);
            console.log(`[SessionService] Created ${sessionId} for ${session.appId} (${session.type})`);
            return { id: sessionId, ...session };
        },
        
        // Update a session
        async update(uid, sessionId, updates) {
            const ref = this._ref(uid);
            if (!ref) return;
            await ref.child(sessionId).update(updates);
        },
        
        // Link a deploy to a session
        async linkDeploy(uid, sessionId, deployId) {
            await this.update(uid, sessionId, {
                deployId,
                status: 'completed',
                completedAt: new Date().toISOString()
            });
            console.log(`[SessionService] Linked deploy ${deployId} to session ${sessionId}`);
        },
        
        // Phase 3: Start review — session moves from prep to review
        async startReview(uid, sessionId, deliverables) {
            await this.update(uid, sessionId, {
                status: 'review',
                deliverables: {
                    files: deliverables.files || [],
                    importedAt: new Date().toISOString(),
                    summary: deliverables.summary || ''
                }
            });
            console.log(`[SessionService] ${sessionId} → review (${deliverables.files?.length || 0} files)`);
        },
        
        // Phase 3: Complete review with criteria results
        async completeReview(uid, sessionId, reviewData) {
            await this.update(uid, sessionId, {
                review: {
                    criteriaResults: reviewData.criteriaResults || [],
                    reviewedBy: reviewData.reviewedBy || 'Owner',
                    reviewedAt: new Date().toISOString(),
                    notes: reviewData.notes || '',
                    allMet: (reviewData.criteriaResults || []).every(c => c.met)
                }
            });
            console.log(`[SessionService] ${sessionId} review complete`);
        },
        
        // Get recent sessions for an app
        getForApp(sessions, appId, limit = 5) {
            return sessions
                .filter(s => s.appId === appId)
                .slice(0, limit);
        },
        
        // Get active (non-completed) sessions
        getActive(sessions, appId) {
            return sessions.filter(s => 
                s.status !== 'completed' && s.status !== 'abandoned' &&
                (!appId || s.appId === appId)
            );
        }
    };
    
    /**
     * ActivityLogService — Audit trail for all meaningful actions (Phase 3.4)
     * Wraps: Firebase RTDB `command-center/{uid}/activity` path
     * 
     * Every meaningful action (deploy, session create/complete, work item transitions,
     * scoping, reviews) writes an event. For solo use: audit trail.
     * For Phase 5 multi-person: the activity feed everyone sees.
     */
    const ActivityLogService = {
        BASE_PATH: 'command-center',
        MAX_EVENTS: 500,
        
        _ref(uid) {
            if (!firebaseDb || !uid) return null;
            return firebaseDb.ref(`${this.BASE_PATH}/${uid}/activity`);
        },
        
        // Listen for activity events (returns unsubscribe function)
        listen(uid, callback, limit = 100) {
            const ref = this._ref(uid);
            if (!ref) return () => {};
            
            ref.orderByChild('timestamp').limitToLast(limit).on('value', (snapshot) => {
                const data = snapshot.val();
                if (data) {
                    const list = Object.entries(data).map(([id, evt]) => ({ id, ...evt }));
                    callback(list.sort((a, b) => new Date(b.timestamp || 0) - new Date(a.timestamp || 0)));
                } else {
                    callback([]);
                }
            });
            
            return () => ref.off();
        },
        
        // Log an activity event
        async log(uid, event) {
            const ref = this._ref(uid);
            if (!ref) return null;
            
            const eventId = `evt-${Date.now()}-${Math.random().toString(36).slice(2, 6)}`;
            const entry = {
                appId: event.appId || null,
                streamId: event.streamId || null,
                actor: event.actor || 'Owner',
                action: event.action,          // deploy, session_create, session_complete, item_transition, scope, review
                summary: event.summary,        // Human-readable: "Dave deployed Core Gameplay v0.9"
                metadata: event.metadata || {},
                timestamp: new Date().toISOString()
            };
            
            await ref.child(eventId).set(entry);
            return { id: eventId, ...entry };
        },
        
        // Convenience loggers for common actions
        async logDeploy(uid, actor, appName, version, env, sessionId) {
            return this.log(uid, {
                appId: appName,
                actor,
                action: 'deploy',
                summary: `${actor} deployed ${appName} v${version} to ${env}`,
                metadata: { version, environment: env, sessionId }
            });
        },
        
        async logSessionCreate(uid, actor, appName, sessionType, sessionId) {
            return this.log(uid, {
                appId: appName,
                actor,
                action: 'session_create',
                summary: `${actor} started ${sessionType} session for ${appName}`,
                metadata: { sessionType, sessionId }
            });
        },
        
        async logSessionComplete(uid, actor, appName, sessionId, itemsCompleted) {
            return this.log(uid, {
                appId: appName,
                actor,
                action: 'session_complete',
                summary: `${actor} completed session for ${appName} — ${itemsCompleted} item${itemsCompleted !== 1 ? 's' : ''} done`,
                metadata: { sessionId, itemsCompleted }
            });
        },
        
        async logItemTransition(uid, actor, appName, itemId, itemTitle, fromStatus, toStatus) {
            return this.log(uid, {
                appId: appName,
                actor,
                action: 'item_transition',
                summary: `${actor} moved "${itemTitle}" from ${fromStatus} to ${toStatus}`,
                metadata: { itemId, fromStatus, toStatus }
            });
        },
        
        async logReview(uid, actor, appName, sessionId, criteriaMetCount, criteriaTotalCount) {
            return this.log(uid, {
                appId: appName,
                actor,
                action: 'review',
                summary: `${actor} reviewed ${appName} — ${criteriaMetCount}/${criteriaTotalCount} criteria met`,
                metadata: { sessionId, criteriaMetCount, criteriaTotalCount }
            });
        }
    };
    
    /**
     * WorkStreamService — Named, owned, parallel tracks of work (Phase 5.2)
     * Wraps: Firebase RTDB `command-center/{uid}/streams` path
     * 
     * A work stream groups related work items into a coherent track:
     *   id: 'WS-NNN' (auto-generated)
     *   appId: which app this belongs to
     *   name: "Core Gameplay", "Help & Onboarding"
     *   owner: who owns this stream
     *   goal: what done looks like
     *   status: active | paused | blocked | complete
     *   targetRelease: target version or milestone
     *   blockedBy: [stream_id] — streams this depends on
     *   blockedUntil: milestone description
     *   createdAt, completedAt timestamps
     */
    const WorkStreamService = {
        BASE_PATH: 'command-center',
        
        _ref(uid) {
            if (!firebaseDb || !uid) return null;
            return firebaseDb.ref(`${this.BASE_PATH}/${uid}/streams`);
        },
        
        // Listen for all streams (returns unsubscribe function)
        listen(uid, callback) {
            const ref = this._ref(uid);
            if (!ref) return () => {};
            
            ref.on('value', (snapshot) => {
                const data = snapshot.val();
                if (data) {
                    const list = Object.entries(data).map(([id, stream]) => ({ id, ...stream }));
                    callback(list.sort((a, b) => (a.name || '').localeCompare(b.name || '')));
                } else {
                    callback([]);
                }
            });
            
            return () => ref.off();
        },
        
        // Create a new work stream
        async create(uid, streamData) {
            const ref = this._ref(uid);
            if (!ref) return null;
            
            const stream = {
                appId: streamData.appId,
                name: streamData.name,
                owner: streamData.owner || 'Owner',
                goal: streamData.goal || '',
                status: streamData.status || 'active',
                targetRelease: streamData.targetRelease || '',
                blockedBy: streamData.blockedBy || [],
                blockedUntil: streamData.blockedUntil || '',
                createdAt: new Date().toISOString(),
                createdBy: streamData.createdBy || 'Owner',
                completedAt: null
            };
            
            await ref.child(streamData.id).set(stream);
            console.log(`[WorkStreamService] Created ${streamData.id}: ${stream.name}`);
            return { id: streamData.id, ...stream };
        },
        
        // Update a stream (partial)
        async update(uid, streamId, updates) {
            const ref = this._ref(uid);
            if (!ref) return;
            await ref.child(streamId).update(updates);
            console.log(`[WorkStreamService] Updated ${streamId}`);
        },
        
        // Delete a stream
        async delete(uid, streamId) {
            const ref = this._ref(uid);
            if (!ref) return;
            await ref.child(streamId).remove();
            console.log(`[WorkStreamService] Deleted ${streamId}`);
        },
        
        // Update status with timestamp management
        async updateStatus(uid, streamId, newStatus) {
            const updates = { status: newStatus };
            if (newStatus === 'complete') {
                updates.completedAt = new Date().toISOString();
            } else {
                updates.completedAt = null;
            }
            await this.update(uid, streamId, updates);
            console.log(`[WorkStreamService] ${streamId} → ${newStatus}`);
        },
        
        // Get streams filtered by app
        filterByApp(streams, appId) {
            return streams.filter(s => s.appId === appId);
        },
        
        // Get active streams for an app
        getActive(streams, appId) {
            return streams.filter(s => s.status === 'active' && (!appId || s.appId === appId));
        },
        
        // Get stream completion percentage from its work items
        getCompletion(stream, workItems) {
            const streamItems = workItems.filter(wi => wi.streamId === stream.id);
            if (streamItems.length === 0) return { total: 0, done: 0, pct: 0 };
            const done = streamItems.filter(wi => wi.status === 'done').length;
            return { total: streamItems.length, done, pct: Math.round((done / streamItems.length) * 100) };
        },
        
        // Check if a stream is blocked by other streams
        isBlocked(stream, allStreams) {
            if (!stream.blockedBy || stream.blockedBy.length === 0) return false;
            return stream.blockedBy.some(blockerId => {
                const blocker = allStreams.find(s => s.id === blockerId);
                return blocker && blocker.status !== 'complete';
            });
        },
        
        // Generate next stream ID from existing list
        getNextId(currentStreams) {
            const existing = currentStreams.map(s => parseInt(s.id?.replace('WS-', '') || '0'));
            const max = Math.max(0, ...existing);
            return `WS-${String(max + 1).padStart(3, '0')}`;
        },
        
        // Get a "Default" stream for an app, creating it if needed
        getDefaultStreamId(streams, appId) {
            const appStreams = this.filterByApp(streams, appId);
            if (appStreams.length > 0) return appStreams[0].id;
            return null; // No stream exists yet — items remain unassigned
        }
    };
    
    /**
     * StreamInterfaceService — Declared contracts between streams (Phase 5.4 foundation)
     * Wraps: Firebase RTDB `command-center/{uid}/interfaces` path
     * 
     * Stream interfaces describe what a stream PROVIDES — human-readable descriptions
     * of behavior or output, not code contracts.
     * 
     *   id: 'SI-NNN'
     *   streamId: which stream provides this
     *   description: "Scoring format: ★ 450"
     *   category: behavior | output | data | naming | timing
     *   lastUpdated, lastUpdatedBy timestamps
     */
    const StreamInterfaceService = {
        BASE_PATH: 'command-center',
        
        _ref(uid) {
            if (!firebaseDb || !uid) return null;
            return firebaseDb.ref(`${this.BASE_PATH}/${uid}/interfaces`);
        },
        
        listen(uid, callback) {
            const ref = this._ref(uid);
            if (!ref) return () => {};
            
            ref.on('value', (snapshot) => {
                const data = snapshot.val();
                if (data) {
                    const list = Object.entries(data).map(([id, iface]) => ({ id, ...iface }));
                    callback(list);
                } else {
                    callback([]);
                }
            });
            
            return () => ref.off();
        },
        
        async create(uid, data) {
            const ref = this._ref(uid);
            if (!ref) return null;
            
            const iface = {
                streamId: data.streamId,
                description: data.description,
                category: data.category || 'behavior',
                lastUpdated: new Date().toISOString(),
                lastUpdatedBy: data.updatedBy || 'Owner'
            };
            
            await ref.child(data.id).set(iface);
            console.log(`[StreamInterfaceService] Created ${data.id}: ${iface.description}`);
            return { id: data.id, ...iface };
        },
        
        async update(uid, ifaceId, updates) {
            const ref = this._ref(uid);
            if (!ref) return;
            updates.lastUpdated = new Date().toISOString();
            await ref.child(ifaceId).update(updates);
        },
        
        async delete(uid, ifaceId) {
            const ref = this._ref(uid);
            if (!ref) return;
            await ref.child(ifaceId).remove();
        },
        
        // Get interfaces provided by a stream
        getByStream(interfaces, streamId) {
            return interfaces.filter(i => i.streamId === streamId);
        },
        
        getNextId(current) {
            const existing = current.map(i => parseInt(i.id?.replace('SI-', '') || '0'));
            const max = Math.max(0, ...existing);
            return `SI-${String(max + 1).padStart(3, '0')}`;
        }
    };
    
    /**
     * DependencyService — Declared dependencies between streams (Phase 5.4 foundation)
     * Wraps: Firebase RTDB `command-center/{uid}/dependencies` path
     * 
     * Dependencies declare what one stream CONSUMES from another:
     *   id: 'DEP-NNN'
     *   dependentStreamId: stream that CONSUMES this
     *   interfaceId: which interface is depended upon
     *   context: "Tutorial screenshots show this format"
     *   status: active | changed | verified
     *   lastVerified, lastVerifiedBy timestamps
     */
    const DependencyService = {
        BASE_PATH: 'command-center',
        
        _ref(uid) {
            if (!firebaseDb || !uid) return null;
            return firebaseDb.ref(`${this.BASE_PATH}/${uid}/dependencies`);
        },
        
        listen(uid, callback) {
            const ref = this._ref(uid);
            if (!ref) return () => {};
            
            ref.on('value', (snapshot) => {
                const data = snapshot.val();
                if (data) {
                    const list = Object.entries(data).map(([id, dep]) => ({ id, ...dep }));
                    callback(list);
                } else {
                    callback([]);
                }
            });
            
            return () => ref.off();
        },
        
        async create(uid, data) {
            const ref = this._ref(uid);
            if (!ref) return null;
            
            const dep = {
                dependentStreamId: data.dependentStreamId,
                interfaceId: data.interfaceId,
                context: data.context || '',
                status: 'active',
                lastVerified: new Date().toISOString(),
                lastVerifiedBy: data.verifiedBy || 'Owner'
            };
            
            await ref.child(data.id).set(dep);
            console.log(`[DependencyService] Created ${data.id}`);
            return { id: data.id, ...dep };
        },
        
        async update(uid, depId, updates) {
            const ref = this._ref(uid);
            if (!ref) return;
            await ref.child(depId).update(updates);
        },
        
        async delete(uid, depId) {
            const ref = this._ref(uid);
            if (!ref) return;
            await ref.child(depId).remove();
        },
        
        // Get dependencies that consume from a stream (via its interfaces)
        getDependentsOf(dependencies, interfaces, streamId) {
            const streamInterfaceIds = interfaces.filter(i => i.streamId === streamId).map(i => i.id);
            return dependencies.filter(d => streamInterfaceIds.includes(d.interfaceId));
        },
        
        // Get dependencies that a stream consumes
        getConsumedBy(dependencies, streamId) {
            return dependencies.filter(d => d.dependentStreamId === streamId);
        },
        
        getNextId(current) {
            const existing = current.map(d => parseInt(d.id?.replace('DEP-', '') || '0'));
            const max = Math.max(0, ...existing);
            return `DEP-${String(max + 1).padStart(3, '0')}`;
        }
    };
    
    /**
     * DependencyAlertService — Auto-remediation alerts (Phase 5.4)
     * Wraps: Firebase RTDB `command-center/{uid}/dependencyAlerts` path
     * 
     * When a session changes a provided interface, alerts are generated
     * for every dependent stream. Each alert auto-creates a work item
     * in the dependent stream with change context for prompt chaining.
     * 
     *   id: 'DA-NNN'
     *   dependencyId: which dependency was affected
     *   interfaceId: which interface changed
     *   triggeredBySession: session ID that caused the change
     *   triggeredByItem: work item ID that caused the change
     *   changeDescription: what changed (user-provided)
     *   changeNotes: detailed notes for the dependent stream's Claude session
     *   triggeredAt: timestamp
     *   triggeredBy: actor name
     *   generatedItemId: auto-created work item in dependent stream
     *   resolution: pending | updated | no_impact
     *   resolvedBy, resolvedAt
     */
    const DependencyAlertService = {
        BASE_PATH: 'command-center',
        
        _ref(uid) {
            if (!firebaseDb || !uid) return null;
            return firebaseDb.ref(`${this.BASE_PATH}/${uid}/dependencyAlerts`);
        },
        
        listen(uid, callback) {
            const ref = this._ref(uid);
            if (!ref) return () => {};
            
            ref.on('value', (snapshot) => {
                const data = snapshot.val();
                if (data) {
                    const list = Object.entries(data).map(([id, alert]) => ({ id, ...alert }));
                    callback(list.sort((a, b) => new Date(b.triggeredAt || 0) - new Date(a.triggeredAt || 0)));
                } else {
                    callback([]);
                }
            });
            
            return () => ref.off();
        },
        
        async create(uid, data) {
            const ref = this._ref(uid);
            if (!ref) return null;
            
            const alert = {
                dependencyId: data.dependencyId,
                interfaceId: data.interfaceId,
                triggeredBySession: data.triggeredBySession || null,
                triggeredByItem: data.triggeredByItem || null,
                changeDescription: data.changeDescription,
                changeNotes: data.changeNotes || '',
                triggeredAt: new Date().toISOString(),
                triggeredBy: data.triggeredBy || 'Owner',
                generatedItemId: data.generatedItemId || null,
                resolution: 'pending',
                resolvedBy: null,
                resolvedAt: null
            };
            
            await ref.child(data.id).set(alert);
            console.log(`[DependencyAlertService] Created ${data.id}: ${alert.changeDescription}`);
            return { id: data.id, ...alert };
        },
        
        async resolve(uid, alertId, resolution, resolvedBy) {
            const ref = this._ref(uid);
            if (!ref) return;
            await ref.child(alertId).update({
                resolution: resolution,  // 'updated' or 'no_impact'
                resolvedBy: resolvedBy || 'Owner',
                resolvedAt: new Date().toISOString()
            });
            console.log(`[DependencyAlertService] Resolved ${alertId}: ${resolution}`);
        },
        
        async updateGeneratedItem(uid, alertId, itemId) {
            const ref = this._ref(uid);
            if (!ref) return;
            await ref.child(alertId).update({ generatedItemId: itemId });
        },
        
        async delete(uid, alertId) {
            const ref = this._ref(uid);
            if (!ref) return;
            await ref.child(alertId).remove();
        },
        
        // Get pending alerts for a stream (items that need attention)
        getPendingForStream(alerts, dependencies, streamId) {
            const streamDepIds = dependencies.filter(d => d.dependentStreamId === streamId).map(d => d.id);
            return alerts.filter(a => a.resolution === 'pending' && streamDepIds.includes(a.dependencyId));
        },
        
        // Get all pending alerts
        getPending(alerts) {
            return alerts.filter(a => a.resolution === 'pending');
        },
        
        // Get alerts triggered by a specific session
        getBySession(alerts, sessionId) {
            return alerts.filter(a => a.triggeredBySession === sessionId);
        },
        
        getNextId(current) {
            const existing = current.map(a => parseInt(a.id?.replace('DA-', '') || '0'));
            const max = Math.max(0, ...existing);
            return `DA-${String(max + 1).padStart(3, '0')}`;
        },
        
        /**
         * triggerAlerts — Core auto-remediation flow (Phase 5.4)
         * 
         * Called when a user confirms an interface changed during post-session review.
         * For each dependency on the changed interface:
         *   1. Creates a dependency alert
         *   2. Auto-creates a work item in the dependent stream with change context
         *   3. Marks the dependency status as 'changed'
         *   4. Logs to activity feed
         * 
         * The generated work item includes changeContext so when the dependent stream
         * owner preps a Claude session, the session brief includes what changed and why.
         * This is the prompt chain: session output → change context → next session input.
         */
        async triggerAlerts(uid, { interfaceId, changeDescription, changeNotes, sessionId, workItemId, actor, interfaces, dependencies, streams, workItems, alerts }) {
            const iface = interfaces.find(i => i.id === interfaceId);
            if (!iface) return [];
            
            // Find all dependencies that consume this interface
            const affectedDeps = dependencies.filter(d => d.interfaceId === interfaceId);
            if (affectedDeps.length === 0) return [];
            
            const providerStream = streams.find(s => s.id === iface.streamId);
            const results = [];
            
            for (const dep of affectedDeps) {
                const dependentStream = streams.find(s => s.id === dep.dependentStreamId);
                if (!dependentStream) continue;
                
                // 1. Create the alert
                const alertId = this.getNextId(alerts.concat(results.map(r => r.alert)));
                
                // 2. Auto-create a work item in the dependent stream
                const itemId = WorkItemService.getNextId(workItems);
                const workItem = await WorkItemService.create(uid, {
                    id: itemId,
                    appId: dependentStream.appId || iface.appId || '',
                    streamId: dep.dependentStreamId,
                    title: `Update: ${iface.description} changed`,
                    description: `Interface "${iface.description}" provided by ${providerStream?.name || 'unknown stream'} has changed.\n\n**What changed:** ${changeDescription}\n\n**Why this stream is affected:** ${dep.context || 'This stream depends on this interface.'}\n\n**Change notes from source session:**\n${changeNotes || 'No additional notes.'}`,
                    type: 'dependency_update',
                    priority: 'core',
                    status: 'ready',
                    effort: 'session',
                    criteria: [
                        `Verify ${dependentStream.name} works correctly with the updated interface`,
                        `Update any references to: ${iface.description}`
                    ],
                    context: {
                        notes: `Auto-generated from dependency alert ${alertId}. Source session: ${sessionId || 'N/A'}.`,
                        dependencies: [iface.description],
                        relatedItems: workItemId ? [workItemId] : []
                    },
                    tags: ['dependency-update', 'auto-generated'],
                    createdBy: actor,
                    source: 'dependency_alert'
                });
                
                // 3. Create the alert record
                const alert = await this.create(uid, {
                    id: alertId,
                    dependencyId: dep.id,
                    interfaceId: interfaceId,
                    triggeredBySession: sessionId,
                    triggeredByItem: workItemId,
                    changeDescription: changeDescription,
                    changeNotes: changeNotes,
                    triggeredBy: actor,
                    generatedItemId: itemId
                });
                
                // 4. Mark the dependency as 'changed'
                await DependencyService.update(uid, dep.id, { 
                    status: 'changed',
                    lastChangedAt: new Date().toISOString(),
                    lastChangedBy: actor
                });
                
                // 5. Log to activity feed
                ActivityLogService.log(uid, {
                    appId: dependentStream.appId,
                    streamId: dep.dependentStreamId,
                    actor: actor,
                    action: 'dependency_alert',
                    summary: `Dependency alert: "${iface.description}" changed — ${dependentStream.name} has update queued`,
                    metadata: { alertId, interfaceId, dependencyId: dep.id, generatedItemId: itemId }
                }).catch(e => console.warn('[Activity] Dependency alert log failed:', e));
                
                results.push({ alert, workItem, dependency: dep, dependentStream });
            }
            
            return results;
        }
    };
    
    /**
     * TokenRegistryService — Token estimation and caching
     * Provides heuristic token counting for context budget management.
     * Cache stored in localStorage for instant access during Claude Prep.
     * 
     * Three estimation tiers:
     *   Tier 1: Heuristic (instant, browser-only) — used by default
     *   Tier 2: js-tiktoken (accurate for GPT) — future
     *   Tier 3: Anthropic API countTokens (exact for Claude) — future
     */
    const TokenRegistryService = {
        STORAGE_KEY: 'cc_token_registry',
        
        // Content type ratios (tokens per character) based on empirical data
        RATIOS: {
            code:     0.37,   // ~18 tokens per line, ~49 chars/line (JS/HTML/CSS)
            markdown: 0.35,   // ~1.35 tokens per word, ~3.8 chars/word
            prose:    0.33,   // ~1.3 tokens per word, ~4 chars/word
            json:     0.40,   // Higher due to structural characters
        },
        
        // Detect content type from filename or content
        detectContentType(filename) {
            if (!filename) return 'prose';
            const ext = filename.split('.').pop()?.toLowerCase();
            switch (ext) {
                case 'html': case 'htm': case 'js': case 'jsx': case 'ts':
                case 'tsx': case 'css': case 'scss': case 'py': case 'rb':
                case 'java': case 'c': case 'cpp': case 'go': case 'rs':
                case 'php': case 'sh': case 'bash': case 'yaml': case 'yml':
                case 'xml': case 'svg':
                    return 'code';
                case 'md': case 'mdx': case 'txt':
                    return 'markdown';
                case 'json': case 'jsonl':
                    return 'json';
                default:
                    return 'prose';
            }
        },
        
        // Tier 1: Heuristic token estimation (instant, no dependencies)
        estimateTokens(text, filenameOrType) {
            if (!text) return 0;
            const contentType = this.RATIOS[filenameOrType] 
                ? filenameOrType 
                : this.detectContentType(filenameOrType);
            const ratio = this.RATIOS[contentType] || 0.35;
            return Math.ceil(text.length * ratio);
        },
        
        // Estimate tokens from byte count (when text isn't available)
        estimateFromBytes(bytes, filenameOrType) {
            if (!bytes) return 0;
            const contentType = this.RATIOS[filenameOrType]
                ? filenameOrType
                : this.detectContentType(filenameOrType);
            const ratio = this.RATIOS[contentType] || 0.35;
            return Math.ceil(bytes * ratio);
        },
        
        // Load cached registry from localStorage
        load() {
            try {
                return JSON.parse(localStorage.getItem(this.STORAGE_KEY) || '{}');
            } catch { return {}; }
        },
        
        // Save registry to localStorage
        save(registry) {
            try {
                localStorage.setItem(this.STORAGE_KEY, JSON.stringify(registry));
            } catch (e) {
                console.error('[TokenRegistryService] Save failed:', e);
            }
        },
        
        // Cache a token count for a specific app artifact
        cacheArtifact(appId, path, tokenData) {
            const registry = this.load();
            if (!registry[appId]) registry[appId] = { artifacts: {}, lastScanned: null };
            registry[appId].artifacts[path] = {
                path,
                tokens: tokenData.tokens,
                bytes: tokenData.bytes,
                type: tokenData.type || 'source',
                version: tokenData.version || null,
                lastUpdated: new Date().toISOString()
            };
            registry[appId].lastScanned = new Date().toISOString();
            this.save(registry);
        },
        
        // Get cached data for an app
        getForApp(appId) {
            const registry = this.load();
            return registry[appId] || null;
        },
        
        // Calculate totals from a list of token counts
        calculateTotals(artifacts) {
            const totals = { source: 0, documentation: 0, instructions: 0, total: 0 };
            for (const art of Object.values(artifacts)) {
                const tokens = art.tokens?.estimated || art.tokens || 0;
                const type = art.type || 'source';
                if (totals[type] !== undefined) {
                    totals[type] += tokens;
                }
                totals.total += tokens;
            }
            return totals;
        },
        
        // Format token count for display
        formatTokens(count) {
            if (count >= 1000000) return `${(count / 1000000).toFixed(1)}M`;
            if (count >= 1000) return `${(count / 1000).toFixed(1)}K`;
            return String(count);
        }
    };
    
    /**
     * EngineRegistryService — AI engine profiles and recommendations
     * Static reference data for AI model capabilities, costs, and constraints.
     * User preferences (default engine) stored in localStorage.
     * 
     * Engine profiles inform:
     *   - Context budget calculation in Claude Prep
     *   - Engine recommendation per session type
     *   - Cost estimation per session
     *   - Platform feature awareness (Projects, Skills, Artifacts, etc.)
     */
    const EngineRegistryService = {
        PREF_KEY: 'cc_default_engine',
        
        // Static engine definitions
        ENGINES: {
            'claude-sonnet-4.5': {
                id: 'claude-sonnet-4.5',
                provider: 'anthropic',
                name: 'Claude Sonnet 4.5',
                tier: 'balanced',
                contextWindow: 200000,
                contextWindowExtended: 1000000,
                maxOutput: 64000,
                cost: {
                    input: 3.00,
                    output: 15.00,
                    cacheWrite: 3.75,
                    cacheRead: 0.30,
                    longContextInput: 6.00,
                    longContextOutput: 22.50
                },
                strengths: ['Coding and refactoring', 'Agentic workflows', 'Multi-step reasoning', 'Extended thinking'],
                bestFor: ['coding', 'architecture', 'testing', 'complex-features'],
                notes: 'Default recommendation for most sessions. Best coding model per benchmarks.',
                features: { projects: true, skills: true, artifacts: true, extendedThinking: true, computerUse: true, webSearch: true, memory: true }
            },
            'claude-haiku-4.5': {
                id: 'claude-haiku-4.5',
                provider: 'anthropic',
                name: 'Claude Haiku 4.5',
                tier: 'fast',
                contextWindow: 200000,
                maxOutput: 64000,
                cost: { input: 1.00, output: 5.00, cacheWrite: 1.25, cacheRead: 0.10 },
                strengths: ['Speed', 'Cost efficiency', 'Classification'],
                bestFor: ['quick-fixes', 'text-changes', 'chores', 'research'],
                notes: 'Use for simple bug fixes, text updates, research tasks. 3x cheaper than Sonnet.',
                features: { projects: true, skills: true, artifacts: true, extendedThinking: true, computerUse: true, webSearch: true, memory: true }
            },
            'claude-opus-4.5': {
                id: 'claude-opus-4.5',
                provider: 'anthropic',
                name: 'Claude Opus 4.5',
                tier: 'flagship',
                contextWindow: 200000,
                contextWindowExtended: 1000000,
                maxOutput: 64000,
                cost: { input: 5.00, output: 25.00, cacheWrite: 6.25, cacheRead: 0.50 },
                strengths: ['Most intelligent', 'Complex architecture', 'Novel problem solving'],
                bestFor: ['design', 'architecture', 'complex-debugging', 'research'],
                notes: 'Reserve for high-complexity work: architecture design, novel patterns, difficult debugging.',
                features: { projects: true, skills: true, artifacts: true, extendedThinking: true, computerUse: true, webSearch: true, memory: true }
            },
            'gpt-4.1': {
                id: 'gpt-4.1',
                provider: 'openai',
                name: 'GPT-4.1',
                tier: 'balanced',
                contextWindow: 1000000,
                maxOutput: 32768,
                cost: { input: 2.00, output: 8.00 },
                strengths: ['Large context native', 'Good at instruction following'],
                bestFor: ['large-codebase-review', 'migration'],
                notes: 'Useful when full source must be in context. Cheaper per token but lower coding quality than Sonnet.',
                features: { projects: false, skills: false, artifacts: false }
            },
            'gemini-2.5-pro': {
                id: 'gemini-2.5-pro',
                provider: 'google',
                name: 'Gemini 2.5 Pro',
                tier: 'balanced',
                contextWindow: 2000000,
                maxOutput: 65536,
                cost: { input: 1.25, output: 10.00 },
                strengths: ['Largest context window', 'Multimodal', 'Competitive coding'],
                bestFor: ['full-codebase-analysis', 'design-review', 'documentation'],
                notes: '2M tokens means entire CC codebase fits in one session. Good for architectural review.',
                features: { projects: false, skills: false, artifacts: false }
            }
        },
        
        // Session type → recommended engine mapping
        SESSION_TYPE_ENGINES: {
            'build':    'claude-sonnet-4.5',
            'design':   'claude-opus-4.5',
            'fix':      'claude-sonnet-4.5',
            'test':     'claude-sonnet-4.5',
            'research': 'claude-haiku-4.5',
            'review':   'claude-sonnet-4.5',
            'polish':   'claude-haiku-4.5',
            'document': 'claude-haiku-4.5'
        },
        
        // Work item type → suggested session type
        WORK_ITEM_SESSION_MAP: {
            'feature':     'build',
            'bugfix':      'fix',
            'enhancement': 'build',
            'chore':       'build',
            'research':    'research'
        },
        
        // Get all engines
        getAll() {
            return Object.values(this.ENGINES);
        },
        
        // Get a specific engine
        get(engineId) {
            return this.ENGINES[engineId] || null;
        },
        
        // Get user's default engine
        getDefault() {
            const pref = localStorage.getItem(this.PREF_KEY);
            return pref && this.ENGINES[pref] ? pref : 'claude-sonnet-4.5';
        },
        
        // Set user's default engine
        setDefault(engineId) {
            if (this.ENGINES[engineId]) {
                localStorage.setItem(this.PREF_KEY, engineId);
            }
        },
        
        // Recommend engine for a session type
        recommendForSessionType(sessionType) {
            const engineId = this.SESSION_TYPE_ENGINES[sessionType] || 'claude-sonnet-4.5';
            return this.ENGINES[engineId];
        },
        
        // Recommend engine based on work item
        recommendForWorkItem(workItem) {
            const sessionType = this.WORK_ITEM_SESSION_MAP[workItem.type] || 'build';
            return {
                sessionType,
                engine: this.recommendForSessionType(sessionType)
            };
        },
        
        // Check if a package fits within an engine's context window
        checkBudget(tokenCount, engineId, useExtended = false) {
            const engine = this.get(engineId || this.getDefault());
            if (!engine) return { fits: false, engine: null };
            
            const limit = useExtended && engine.contextWindowExtended 
                ? engine.contextWindowExtended 
                : engine.contextWindow;
            
            // Reserve ~20% for conversation/reasoning room
            const usableLimit = Math.floor(limit * 0.80);
            
            return {
                fits: tokenCount <= usableLimit,
                engine,
                limit,
                usableLimit,
                tokenCount,
                remaining: usableLimit - tokenCount,
                percentUsed: Math.round((tokenCount / usableLimit) * 100),
                overBy: tokenCount > usableLimit ? tokenCount - usableLimit : 0,
                recommendations: this._getBudgetRecommendations(tokenCount, engine, useExtended)
            };
        },
        
        // Generate context budget recommendations
        _getBudgetRecommendations(tokenCount, engine, useExtended) {
            const recs = [];
            const limit = useExtended && engine.contextWindowExtended
                ? engine.contextWindowExtended
                : engine.contextWindow;
            const usableLimit = Math.floor(limit * 0.80);
            
            if (tokenCount <= usableLimit) return recs;
            
            // Over budget — generate recommendations
            if (!useExtended && engine.contextWindowExtended) {
                recs.push({
                    action: 'extended-context',
                    label: `Switch to ${TokenRegistryService.formatTokens(engine.contextWindowExtended)} extended context`,
                    savings: null,
                    cost: engine.cost.longContextInput ? `$${engine.cost.longContextInput}/$${engine.cost.longContextOutput} per MTok` : null
                });
            }
            
            recs.push({
                action: 'architecture-summary',
                label: 'Use architecture summary instead of full source',
                savings: `~${TokenRegistryService.formatTokens(Math.floor(tokenCount * 0.85))} saved`,
                cost: null
            });
            
            recs.push({
                action: 'section-extraction',
                label: 'Include only relevant code sections for this work item',
                savings: `~${TokenRegistryService.formatTokens(Math.floor(tokenCount * 0.90))} saved`,
                cost: null
            });
            
            recs.push({
                action: 'skip-changelog',
                label: 'Skip CHANGELOG.md (low value for build sessions)',
                savings: null,
                cost: null
            });
            
            // Suggest a different engine if this one can't handle it
            const biggerEngines = Object.values(this.ENGINES).filter(e => 
                e.id !== engine.id && 
                (e.contextWindow > limit || (e.contextWindowExtended && e.contextWindowExtended > limit))
            );
            if (biggerEngines.length > 0) {
                const best = biggerEngines.sort((a, b) => 
                    (b.contextWindowExtended || b.contextWindow) - (a.contextWindowExtended || a.contextWindow)
                )[0];
                recs.push({
                    action: 'switch-engine',
                    label: `Switch to ${best.name} (${TokenRegistryService.formatTokens(best.contextWindowExtended || best.contextWindow)} context)`,
                    savings: null,
                    cost: `$${best.cost.input}/$${best.cost.output} per MTok`
                });
            }
            
            return recs;
        },
        
        // Estimate session cost
        estimateSessionCost(packageTokens, outputTokens, engineId) {
            const engine = this.get(engineId || this.getDefault());
            if (!engine) return null;
            
            const inputCost = (packageTokens / 1000000) * engine.cost.input;
            const outputCost = (outputTokens / 1000000) * engine.cost.output;
            
            return {
                inputCost: Math.round(inputCost * 100) / 100,
                outputCost: Math.round(outputCost * 100) / 100,
                totalCost: Math.round((inputCost + outputCost) * 100) / 100,
                engine: engine.name
            };
        }
    };
    
    // =========================================================================
    // SESSION TYPES + SESSION BRIEF GENERATOR (v8.25.0 — Phase 2.1)
    // =========================================================================
    
    // =========================================================================
    // PORKBUN SERVICE — Domain registrar API integration (v8.35.0)
    // Handles: domain search, registration, DNS CRUD, GitHub Pages wiring
    // API docs: https://porkbun.com/api/json/v3/documentation
    // All calls are POST with JSON body. Auth via apiKey + secretApiKey in body.
    // Credentials stored in localStorage (NOT synced to Firebase — sensitive).
    // =========================================================================
    
    const PorkbunService = {
        CONFIG_KEY: 'cc_domain_config',
        PRICE_CACHE_KEY: 'cc_tld_prices',
        HEALTH_CACHE_KEY: 'cc_domain_health',
        BASE_URL: 'https://api.porkbun.com/api/json/v3',
        PROXY_URL: 'https://us-central1-word-boxing.cloudfunctions.net/domainProxy',
        
        // GitHub Pages IP addresses (current as of 2025)
        GITHUB_PAGES_IPS: [
            '185.199.108.153',
            '185.199.109.153',
            '185.199.110.153',
            '185.199.111.153'
        ],
        
        // Preferred TLDs for domain search (ordered by relevance for dev tools)
        PREFERRED_TLDS: ['com', 'dev', 'app', 'io', 'co', 'ai', 'sh', 'tools', 'site', 'net'],
        
        // ─── Configuration ───
        
        getConfig() {
            try { return JSON.parse(localStorage.getItem(this.CONFIG_KEY) || '{}'); }
            catch { return {}; }
        },
        
        saveConfig(config) {
            localStorage.setItem(this.CONFIG_KEY, JSON.stringify(config));
        },
        
        isConfigured() {
            const cfg = this.getConfig();
            return !!(cfg.apiKey && cfg.secretApiKey);
        },
        
        // ─── Core API Call (via Firebase proxy to avoid CORS) ───
        
        async _call(endpoint, extraBody = {}) {
            const cfg = this.getConfig();
            if (!cfg.apiKey || !cfg.secretApiKey) {
                throw new Error('Porkbun API keys not configured. Go to Settings → Domain Registrar.');
            }
            
            const response = await fetch(this.PROXY_URL, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    provider: 'porkbun',
                    endpoint: endpoint,
                    method: 'POST',
                    body: {
                        apikey: cfg.apiKey,
                        secretapikey: cfg.secretApiKey,
                        ...extraBody
                    }
                })
            });
            
            if (!response.ok) {
                const text = await response.text();
                throw new Error(`Porkbun API error (${response.status}): ${text}`);
            }
            
            const data = await response.json();
            if (data.status === 'ERROR') {
                throw new Error(data.message || 'Porkbun API returned an error');
            }
            return data;
        },
        
        // ─── Connection Test ───
        
        async ping() {
            return await this._call('/ping');
            // Returns: { status: "SUCCESS", yourIp: "x.x.x.x" }
        },
        
        // ─── Domain Operations ───
        
        async listDomains() {
            const data = await this._call('/domain/listAll');
            return data.domains || [];
            // Returns: [{ domain, status, tld, createDate, expireDate, autoRenew, ... }]
        },
        
        async checkAvailability(domain) {
            const data = await this._call(`/domain/checkDomain/${domain}`);
            return {
                domain,
                available: data.response?.avail === 'yes',
                price: parseFloat(data.response?.price || 0),
                regularPrice: parseFloat(data.response?.regularPrice || 0),
                renewalPrice: parseFloat(data.response?.additional?.renewal?.price || 0),
                premium: data.response?.premium === 'yes',
                firstYearPromo: data.response?.firstYearPromo === 'yes',
                limits: data.limits
            };
        },
        
        async checkMultipleTLDs(keyword) {
            // Check availability across preferred TLDs
            // Rate limited: 1 check per 10 seconds at Porkbun
            const results = [];
            for (const tld of this.PREFERRED_TLDS) {
                const domain = keyword.includes('.') ? keyword : `${keyword}.${tld}`;
                try {
                    const result = await this.checkAvailability(domain);
                    results.push(result);
                } catch (e) {
                    results.push({ domain, available: false, error: e.message });
                }
                // Respect rate limits
                if (results.length < this.PREFERRED_TLDS.length) {
                    await this._rateLimit(10500); // 10.5s between checks
                }
            }
            return results;
        },
        
        async registerDomain(domain, costInPennies) {
            return await this._call(`/domain/create/${domain}`, {
                cost: costInPennies,
                agreeToTerms: 'yes'
            });
            // Returns: { status, domain, cost, orderId, balance }
        },
        
        async updateAutoRenew(domain, on = true) {
            return await this._call(`/domain/updateAutoRenew/${domain}`, {
                status: on ? 'on' : 'off'
            });
        },
        
        // ─── DNS Record Management ───
        
        async listDNSRecords(domain) {
            const data = await this._call(`/dns/retrieve/${domain}`);
            return data.records || [];
            // Returns: [{ id, name, type, content, ttl, prio, notes }]
        },
        
        async createDNSRecord(domain, type, name, content, ttl = 600, prio = null) {
            const body = { type, content, ttl: String(ttl) };
            if (name) body.name = name;
            if (prio !== null) body.prio = String(prio);
            const data = await this._call(`/dns/create/${domain}`, body);
            return { id: data.id, type, name: name || '@', content };
        },
        
        async editDNSRecord(domain, recordId, type, name, content, ttl = 600) {
            return await this._call(`/dns/edit/${domain}/${recordId}`, {
                type, content, ttl: String(ttl),
                ...(name ? { name } : {})
            });
        },
        
        async deleteDNSRecord(domain, recordId, allRecords) {
            // allRecords param unused — Porkbun supports individual record delete by ID
            return await this._call(`/dns/delete/${domain}/${recordId}`);
        },
        
        async deleteDNSByType(domain, type, subdomain) {
            const endpoint = subdomain 
                ? `/dns/deleteByNameType/${domain}/${type}/${subdomain}`
                : `/dns/deleteByNameType/${domain}/${type}`;
            return await this._call(endpoint);
        },
        
        // ─── TLD Pricing (cached) ───
        
        async getTLDPrices(forceRefresh = false) {
            // Check cache first
            if (!forceRefresh) {
                try {
                    const cached = JSON.parse(localStorage.getItem(this.PRICE_CACHE_KEY) || '{}');
                    if (cached.timestamp && Date.now() - cached.timestamp < 24 * 60 * 60 * 1000) {
                        return cached.prices;
                    }
                } catch {}
            }
            
            // Pricing endpoint via proxy (no auth needed but still has CORS issues)
            const response = await fetch(this.PROXY_URL, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    provider: 'porkbun',
                    endpoint: '/pricing/get',
                    method: 'POST',
                    body: {}
                })
            });
            const data = await response.json();
            
            if (data.status === 'SUCCESS' && data.pricing) {
                localStorage.setItem(this.PRICE_CACHE_KEY, JSON.stringify({
                    timestamp: Date.now(),
                    prices: data.pricing
                }));
                return data.pricing;
            }
            throw new Error('Failed to fetch TLD pricing');
        },
        
        // ─── GitHub Pages DNS Configuration ───
        
        async configureForGitHubPages(domain, githubUsername) {
            const results = [];
            const log = [];
            
            // Step 1: Get existing records and remove conflicting ones
            log.push('Fetching existing DNS records...');
            const existing = await this.listDNSRecords(domain);
            
            // Delete existing A, AAAA, and root CNAME records that would conflict
            for (const record of existing) {
                const isRoot = record.name === domain || record.name === '';
                const isWww = record.name === `www.${domain}` || record.name === 'www';
                if ((isRoot && (record.type === 'A' || record.type === 'AAAA' || record.type === 'CNAME' || record.type === 'ALIAS')) ||
                    (isWww && record.type === 'CNAME')) {
                    log.push(`Deleting conflicting ${record.type} record: ${record.content}`);
                    await this.deleteDNSRecord(domain, record.id);
                    await this._rateLimit(1100);
                }
            }
            
            // Step 2: Create 4 A records for apex domain
            for (const ip of this.GITHUB_PAGES_IPS) {
                log.push(`Creating A record → ${ip}`);
                const result = await this.createDNSRecord(domain, 'A', '', ip, 600);
                results.push(result);
                await this._rateLimit(1100);
            }
            
            // Step 3: Create CNAME for www → username.github.io
            log.push(`Creating CNAME www → ${githubUsername}.github.io`);
            const cnameResult = await this.createDNSRecord(
                domain, 'CNAME', 'www', `${githubUsername}.github.io`, 600
            );
            results.push(cnameResult);
            
            return { 
                success: true, 
                recordsCreated: results.length, 
                records: results,
                log
            };
        },
        
        // ─── Domain Health Caching ───
        
        getHealthCache() {
            try { return JSON.parse(localStorage.getItem(this.HEALTH_CACHE_KEY) || '{}'); }
            catch { return {}; }
        },
        
        setHealthCache(domain, result) {
            const cache = this.getHealthCache();
            cache[domain] = { lastCheck: new Date().toISOString(), result };
            localStorage.setItem(this.HEALTH_CACHE_KEY, JSON.stringify(cache));
        },
        
        // ─── Utility ───
        
        _rateLimit(ms = 1100) {
            return new Promise(resolve => setTimeout(resolve, ms));
        },
        
        // Format price from string to display
        formatPrice(price) {
            const num = typeof price === 'string' ? parseFloat(price) : price;
            return isNaN(num) ? '—' : `$${num.toFixed(2)}`;
        }
    };

    // =========================================================================
    // GODADDY SERVICE — Domain registrar DNS API integration (v8.35.0)
    // Handles: domain listing, DNS CRUD for existing GoDaddy domains
    // API docs: https://developer.godaddy.com/doc/endpoint/domains
    // Auth: sso-key API_KEY:API_SECRET in Authorization header
    // Note: GoDaddy API requires 10+ domains or Domain Pro Plan
    // Note: GoDaddy uses GET/PUT/PATCH (not POST like Porkbun)
    // Note: Records identified by type+name, NOT unique IDs
    // =========================================================================
    
    const GoDaddyService = {
        CONFIG_KEY: 'cc_godaddy_config',
        BASE_URL: 'https://api.godaddy.com/v1',
        PROXY_URL: 'https://us-central1-word-boxing.cloudfunctions.net/domainProxy',
        
        GITHUB_PAGES_IPS: [
            '185.199.108.153',
            '185.199.109.153',
            '185.199.110.153',
            '185.199.111.153'
        ],
        
        // ─── Configuration ───
        
        getConfig() {
            try { return JSON.parse(localStorage.getItem(this.CONFIG_KEY) || '{}'); }
            catch { return {}; }
        },
        
        saveConfig(config) {
            localStorage.setItem(this.CONFIG_KEY, JSON.stringify(config));
        },
        
        isConfigured() {
            const cfg = this.getConfig();
            return !!(cfg.apiKey && cfg.apiSecret);
        },
        
        // ─── Core API Call (via Firebase proxy to avoid CORS) ───
        
        async _call(endpoint, method = 'GET', body = null) {
            const cfg = this.getConfig();
            if (!cfg.apiKey || !cfg.apiSecret) {
                throw new Error('GoDaddy API keys not configured. Go to Settings → Domain Registrar.');
            }
            
            const proxyBody = {
                provider: 'godaddy',
                endpoint: endpoint,
                method: method,
                headers: {
                    'Authorization': `sso-key ${cfg.apiKey}:${cfg.apiSecret}`
                }
            };
            if (body && ['POST', 'PUT', 'PATCH'].includes(method)) {
                proxyBody.body = body;
            }
            
            const response = await fetch(this.PROXY_URL, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(proxyBody)
            });
            
            if (!response.ok) {
                const data = await response.json().catch(() => ({}));
                throw new Error(data.message || `GoDaddy API error (${response.status})`);
            }
            
            const text = await response.text();
            return text ? JSON.parse(text) : { status: 'SUCCESS' };
        },
        
        // ─── Connection Test ───
        
        async ping() {
            // GoDaddy has no explicit ping — we list domains as a test
            const domains = await this._call('/domains?limit=1');
            return { status: 'SUCCESS', yourIp: 'N/A', domainCount: domains.length };
        },
        
        // ─── Domain Operations ───
        
        async listDomains() {
            const data = await this._call('/domains');
            // Normalize to match PorkbunService format
            return data.map(d => ({
                domain: d.domain,
                status: d.status,
                tld: d.domain.split('.').pop(),
                createDate: d.createdAt,
                expireDate: d.expires,
                autoRenew: d.renewAuto,
                provider: 'godaddy'
            }));
        },
        
        // ─── DNS Record Management ───
        // GoDaddy uses type+name to identify records, NOT unique IDs
        // Records have: type, name, data (not content), ttl, priority
        
        async listDNSRecords(domain) {
            const data = await this._call(`/domains/${domain}/records`);
            // Normalize to match Porkbun format
            return data.map((r, i) => ({
                id: `${r.type}-${r.name}-${i}`,  // Synthetic ID (GoDaddy has none)
                name: r.name === '@' ? domain : `${r.name}.${domain}`,
                type: r.type,
                content: r.data,
                ttl: String(r.ttl),
                prio: r.priority ? String(r.priority) : '0',
                notes: '',
                _gdName: r.name,  // Keep original GoDaddy name for API calls
                _gdData: r.data
            }));
        },
        
        async createDNSRecord(domain, type, name, content, ttl = 600, prio = null) {
            // GoDaddy uses PATCH to add records (append)
            const record = {
                type,
                name: name || '@',
                data: content,
                ttl: parseInt(ttl) || 600
            };
            if (prio !== null) record.priority = parseInt(prio);
            
            await this._call(`/domains/${domain}/records`, 'PATCH', [record]);
            return { id: `${type}-${name || '@'}-new`, type, name: name || '@', content };
        },
        
        async deleteDNSRecord(domain, recordId, allRecords) {
            // GoDaddy has no individual delete — we must replace all records of that type/name
            // OR replace ALL records minus the one we want to remove
            // We need the full record list to do this
            if (!allRecords) {
                allRecords = await this.listDNSRecords(domain);
            }
            
            const toKeep = allRecords.filter(r => r.id !== recordId);
            
            // Rebuild in GoDaddy's format
            const gdRecords = toKeep
                .filter(r => !['NS', 'SOA'].includes(r.type)) // Can't replace NS/SOA
                .map(r => ({
                    type: r.type,
                    name: r._gdName || (r.name === domain ? '@' : r.name.replace(`.${domain}`, '')),
                    data: r._gdData || r.content,
                    ttl: parseInt(r.ttl) || 600,
                    ...(r.prio && r.prio !== '0' ? { priority: parseInt(r.prio) } : {})
                }));
            
            if (gdRecords.length === 0) {
                throw new Error('Cannot delete all records. At least one record must remain.');
            }
            
            await this._call(`/domains/${domain}/records`, 'PUT', gdRecords);
            return { status: 'SUCCESS' };
        },
        
        // ─── GitHub Pages DNS Configuration ───
        
        async configureForGitHubPages(domain, githubUsername) {
            const log = [];
            
            // Step 1: Get existing records
            log.push('Fetching existing DNS records...');
            const existing = await this.listDNSRecords(domain);
            
            // Step 2: Build new record set — keep non-conflicting, replace A/CNAME
            const keepRecords = existing
                .filter(r => !['NS', 'SOA'].includes(r.type))
                .filter(r => {
                    const isRoot = r._gdName === '@' || r.name === domain;
                    const isWww = r._gdName === 'www';
                    if (isRoot && (r.type === 'A' || r.type === 'AAAA' || r.type === 'CNAME' || r.type === 'ALIAS')) {
                        log.push(`Removing conflicting ${r.type} record: ${r.content}`);
                        return false;
                    }
                    if (isWww && r.type === 'CNAME') {
                        log.push(`Removing conflicting CNAME www record: ${r.content}`);
                        return false;
                    }
                    return true;
                })
                .map(r => ({
                    type: r.type,
                    name: r._gdName || '@',
                    data: r._gdData || r.content,
                    ttl: parseInt(r.ttl) || 600,
                    ...(r.prio && r.prio !== '0' ? { priority: parseInt(r.prio) } : {})
                }));
            
            // Step 3: Add GitHub Pages records
            const ghRecords = this.GITHUB_PAGES_IPS.map(ip => {
                log.push(`Adding A record → ${ip}`);
                return { type: 'A', name: '@', data: ip, ttl: 600 };
            });
            
            log.push(`Adding CNAME www → ${githubUsername}.github.io`);
            ghRecords.push({ type: 'CNAME', name: 'www', data: `${githubUsername}.github.io`, ttl: 600 });
            
            // Step 4: Replace all records at once (GoDaddy's approach)
            const allRecords = [...keepRecords, ...ghRecords];
            await this._call(`/domains/${domain}/records`, 'PUT', allRecords);
            
            return {
                success: true,
                recordsCreated: ghRecords.length,
                records: ghRecords.map(r => ({ type: r.type, name: r.name, content: r.data })),
                log
            };
        },
        
        // ─── Utility ───
        formatPrice(price) {
            const num = typeof price === 'string' ? parseFloat(price) : price;
            return isNaN(num) ? '—' : `$${num.toFixed(2)}`;
        }
    };

    // =========================================================================
    // DOMAIN PROVIDER REGISTRY — Abstracts multiple registrar APIs (v8.35.0)
    // All providers implement the same interface: ping, listDomains,
    // listDNSRecords, createDNSRecord, deleteDNSRecord, configureForGitHubPages
    // =========================================================================
    
    const DomainProviderRegistry = {
        PROVIDERS: {
            porkbun: {
                id: 'porkbun',
                name: 'Porkbun',
                icon: '🐷',
                service: PorkbunService,
                configKey: PorkbunService.CONFIG_KEY,
                keyFields: [
                    { key: 'apiKey', label: 'API Key', placeholder: 'pk1_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx' },
                    { key: 'secretApiKey', label: 'Secret API Key', placeholder: 'sk1_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx' }
                ],
                setupUrl: 'https://porkbun.com/account/api',
                setupNote: 'Generate API keys, then enable API access per domain in Domain Management → Details.',
                hasRegistration: true
            },
            godaddy: {
                id: 'godaddy',
                name: 'GoDaddy',
                icon: '🟢',
                service: GoDaddyService,
                configKey: GoDaddyService.CONFIG_KEY,
                keyFields: [
                    { key: 'apiKey', label: 'API Key', placeholder: 'Your GoDaddy API Key' },
                    { key: 'apiSecret', label: 'API Secret', placeholder: 'Your GoDaddy API Secret' }
                ],
                setupUrl: 'https://developer.godaddy.com/keys',
                setupNote: 'Requires 10+ domains or Domain Pro Plan. Create a Production API key (not OTE/Test).',
                hasRegistration: false
            }
        },
        
        getAll() {
            return Object.values(this.PROVIDERS);
        },
        
        get(providerId) {
            return this.PROVIDERS[providerId] || null;
        },
        
        getService(providerId) {
            const provider = this.get(providerId);
            return provider ? provider.service : null;
        },
        
        // Get all configured providers
        getConfigured() {
            return this.getAll().filter(p => p.service.isConfigured());
        },
        
        // Get all domains across all configured providers
        async getAllDomains() {
            const results = [];
            for (const provider of this.getConfigured()) {
                try {
                    const domains = await provider.service.listDomains();
                    domains.forEach(d => {
                        d.provider = provider.id;
                        d.providerName = provider.name;
                        d.providerIcon = provider.icon;
                    });
                    results.push(...domains);
                } catch (e) {
                    console.warn(`Failed to fetch domains from ${provider.name}:`, e);
                }
            }
            return results;
        },
        
        // Get the service for a specific domain (by checking which provider owns it)
        getServiceForDomain(domain, allDomains) {
            const match = allDomains.find(d => d.domain === domain);
            if (match) return this.getService(match.provider);
            // Default to first configured
            const configured = this.getConfigured();
            return configured.length > 0 ? configured[0].service : null;
        }
    };

    const SESSION_TYPES = {
        build: {
            id: 'build',
            label: 'Build',
            icon: '🔨',
            description: 'Implement new features or significant functionality',
            suggestedEngine: 'claude-sonnet-4.5',
            roleFrame: 'You are building new functionality for this app. Focus on clean implementation that follows established patterns. Deliver working, tested code.',
            scopeRules: [
                'Implement the specified feature(s) completely',
                'Follow existing code patterns and conventions',
                'Include error handling and edge cases',
                'Update version number (minor bump for new features)'
            ],
            deliveryRequirements: [
                'Working implementation of specified features',
                'Updated version number in all locations',
                'RELEASE_NOTES.txt entry describing what was built',
                'Deploy package (if PWA: include sw.js, manifest, icons)'
            ],
            contextStrategy: {
                alwaysInclude: ['CONTEXT.md', 'CLAUDE_INSTRUCTIONS.md', 'CLAUDE-PREP-STANDARD.md'],
                preferInclude: ['PROJECT_PLAN.md', 'ARCHITECTURE.md'],
                skipWhenTight: ['CHANGELOG.md', 'RELEASE_NOTES.txt'],
                includeSource: true
            },
            workItemFocus: 'Targets work items with status "ready" or "in-progress". Prefer items matching: feature, enhancement.',
            autoSuggestFrom: ['feature', 'enhancement', 'chore']
        },
        design: {
            id: 'design',
            label: 'Design',
            icon: '🎨',
            description: 'Plan architecture, design UI/UX, or create technical specifications',
            suggestedEngine: 'claude-opus-4.5',
            roleFrame: 'You are designing a feature or system for this app. Focus on clear specifications, architecture decisions, and tradeoff analysis. Do NOT implement — design only.',
            scopeRules: [
                'Produce design documents, not code',
                'Consider multiple approaches and recommend one',
                'Document tradeoffs and constraints',
                'Define clear acceptance criteria for implementation'
            ],
            deliveryRequirements: [
                'Design document or specification',
                'Architecture diagrams (described in text/markdown)',
                'List of work items for implementation',
                'Key decisions with rationale'
            ],
            contextStrategy: {
                alwaysInclude: ['CONTEXT.md', 'ARCHITECTURE.md', 'PROJECT_PLAN.md'],
                preferInclude: ['CLAUDE_INSTRUCTIONS.md'],
                skipWhenTight: ['CHANGELOG.md', 'RELEASE_NOTES.txt', 'CLAUDE-PREP-STANDARD.md'],
                includeSource: true
            },
            workItemFocus: 'Targets research items or complex features that need design before implementation.',
            autoSuggestFrom: ['research']
        },
        fix: {
            id: 'fix',
            label: 'Fix',
            icon: '🔧',
            description: 'Fix bugs, resolve issues, or correct broken behavior',
            suggestedEngine: 'claude-sonnet-4.5',
            roleFrame: 'You are fixing a specific bug or issue. Focus ONLY on the reported problem. Do NOT refactor unrelated code, do NOT add features, do NOT reorganize unless directly required by the fix.',
            scopeRules: [
                'Fix ONLY the reported issue — nothing else',
                'Do not refactor unrelated code',
                'Do not add features or enhancements',
                'Minimize changes to reduce regression risk',
                'Verify the fix addresses the root cause, not just symptoms'
            ],
            deliveryRequirements: [
                'Targeted fix with minimal code changes',
                'Updated version number (patch bump)',
                'RELEASE_NOTES.txt entry describing what was fixed',
                'Deploy package'
            ],
            contextStrategy: {
                alwaysInclude: ['CONTEXT.md', 'CLAUDE-PREP-STANDARD.md'],
                preferInclude: ['CLAUDE_INSTRUCTIONS.md'],
                skipWhenTight: ['CHANGELOG.md', 'RELEASE_NOTES.txt', 'PROJECT_PLAN.md', 'ARCHITECTURE.md'],
                includeSource: true
            },
            workItemFocus: 'Targets bugfix items. Include issue details and reproduction steps.',
            autoSuggestFrom: ['bugfix']
        },
        test: {
            id: 'test',
            label: 'Test',
            icon: '🧪',
            description: 'Write tests, create test plans, or validate functionality',
            suggestedEngine: 'claude-sonnet-4.5',
            roleFrame: 'You are creating tests or a test plan for this app. Focus on coverage of critical paths, edge cases, and regression prevention.',
            scopeRules: [
                'Focus on test coverage for specified areas',
                'Include both happy path and edge cases',
                'Document manual testing steps if automated testing is not possible',
                'Prioritize tests for recently changed or bug-prone areas'
            ],
            deliveryRequirements: [
                'Test cases or test plan document',
                'Automated tests if test framework is available',
                'Manual testing checklist for areas that cannot be automated',
                'Coverage assessment'
            ],
            contextStrategy: {
                alwaysInclude: ['CONTEXT.md', 'CLAUDE_INSTRUCTIONS.md'],
                preferInclude: ['ARCHITECTURE.md', 'PROJECT_PLAN.md'],
                skipWhenTight: ['CHANGELOG.md', 'RELEASE_NOTES.txt', 'CLAUDE-PREP-STANDARD.md'],
                includeSource: true
            },
            workItemFocus: 'Targets areas needing test coverage. Can complement any work item type.',
            autoSuggestFrom: []
        },
        research: {
            id: 'research',
            label: 'Research',
            icon: '🔍',
            description: 'Investigate options, evaluate approaches, or answer technical questions',
            suggestedEngine: 'claude-haiku-4.5',
            roleFrame: 'You are researching a specific question or evaluating options for this project. Focus on clear comparisons, concrete recommendations, and actionable findings.',
            scopeRules: [
                'Answer the specific research question(s)',
                'Compare alternatives with pros/cons',
                'Provide a concrete recommendation',
                'Do NOT implement — research only'
            ],
            deliveryRequirements: [
                'Research findings document',
                'Comparison of alternatives (if applicable)',
                'Concrete recommendation with rationale',
                'Next steps or implementation plan'
            ],
            contextStrategy: {
                alwaysInclude: ['CONTEXT.md'],
                preferInclude: ['ARCHITECTURE.md', 'PROJECT_PLAN.md'],
                skipWhenTight: ['CHANGELOG.md', 'RELEASE_NOTES.txt', 'CLAUDE-PREP-STANDARD.md', 'CLAUDE_INSTRUCTIONS.md'],
                includeSource: false
            },
            workItemFocus: 'Targets research items and unresolved key decisions.',
            autoSuggestFrom: []
        },
        review: {
            id: 'review',
            label: 'Review',
            icon: '👁️',
            description: 'Code review, architecture review, or quality assessment',
            suggestedEngine: 'claude-sonnet-4.5',
            roleFrame: 'You are reviewing this app for quality, correctness, and adherence to standards. Provide specific, actionable feedback organized by severity.',
            scopeRules: [
                'Review code for bugs, security issues, and performance problems',
                'Check adherence to stated conventions and standards',
                'Prioritize findings by severity (critical → minor)',
                'Suggest fixes but do NOT implement them'
            ],
            deliveryRequirements: [
                'Review findings organized by severity',
                'Specific line/function references for each finding',
                'Suggested fixes (described, not implemented)',
                'Overall quality assessment'
            ],
            contextStrategy: {
                alwaysInclude: ['CONTEXT.md', 'CLAUDE_INSTRUCTIONS.md', 'CLAUDE-PREP-STANDARD.md'],
                preferInclude: ['ARCHITECTURE.md'],
                skipWhenTight: ['CHANGELOG.md', 'RELEASE_NOTES.txt', 'PROJECT_PLAN.md'],
                includeSource: true
            },
            workItemFocus: 'Not typically tied to specific work items. Reviews the overall codebase or recent changes.',
            autoSuggestFrom: []
        },
        polish: {
            id: 'polish',
            label: 'Polish',
            icon: '✨',
            description: 'UI refinement, UX improvements, accessibility, performance tuning',
            suggestedEngine: 'claude-haiku-4.5',
            roleFrame: 'You are polishing this app — improving UI details, UX flow, accessibility, and visual consistency. Focus on refinement, not new features.',
            scopeRules: [
                'Improve visual consistency and polish',
                'Fix alignment, spacing, color consistency issues',
                'Improve accessibility (ARIA, contrast, keyboard nav)',
                'Do NOT add new features',
                'Keep changes scoped to UI/UX layer'
            ],
            deliveryRequirements: [
                'Polished code with UI/UX improvements',
                'Updated version number (patch bump)',
                'RELEASE_NOTES.txt entry describing improvements',
                'Deploy package'
            ],
            contextStrategy: {
                alwaysInclude: ['CONTEXT.md', 'CLAUDE_INSTRUCTIONS.md'],
                preferInclude: ['CLAUDE-PREP-STANDARD.md'],
                skipWhenTight: ['CHANGELOG.md', 'RELEASE_NOTES.txt', 'PROJECT_PLAN.md', 'ARCHITECTURE.md'],
                includeSource: true
            },
            workItemFocus: 'Targets enhancement items focused on UX/UI. Can also address chore items.',
            autoSuggestFrom: []
        },
        document: {
            id: 'document',
            label: 'Document',
            icon: '📝',
            description: 'Write or update documentation, changelogs, or project plans',
            suggestedEngine: 'claude-haiku-4.5',
            roleFrame: 'You are writing or updating documentation for this project. Focus on accuracy, clarity, and completeness. Reference the actual codebase to ensure docs match reality.',
            scopeRules: [
                'Update documentation to match current codebase',
                'Fill in TODO placeholders with accurate information',
                'Keep documentation concise and scannable',
                'Do NOT modify code — documentation only'
            ],
            deliveryRequirements: [
                'Updated documentation files',
                'No TODO placeholders remaining (where possible)',
                'Accurate version references',
                'CHANGELOG.md updated if documenting a release'
            ],
            contextStrategy: {
                alwaysInclude: ['CONTEXT.md'],
                preferInclude: ['PROJECT_PLAN.md', 'CHANGELOG.md', 'RELEASE_NOTES.txt', 'ARCHITECTURE.md'],
                skipWhenTight: ['CLAUDE-PREP-STANDARD.md', 'CLAUDE_INSTRUCTIONS.md'],
                includeSource: true
            },
            workItemFocus: 'Targets chore items related to documentation. Also useful after feature sprints.',
            autoSuggestFrom: []
        }
    };
    
    // Session Brief Generator — session-type-aware brief production (Phase 2.1)
    const SessionBriefGenerator = {
        
        // Main entry point: generate a session brief with optional session type and work item context
        generate(app, config, deployments, options = {}) {
            const { sessionType, targetWorkItems, allWorkItems } = options;
            const now = new Date();
            const projectDef = config.projects?.[app.project] || {};
            const typeInfo = sessionType ? SESSION_TYPES[sessionType] : null;
            
            let brief = '';
            
            // === Header ===
            brief += `# Session Brief — ${app.name}\n`;
            brief += `Generated by Command Center on ${now.toLocaleString()}\n\n`;
            
            // === Session Type Banner (if specified) ===
            if (typeInfo) {
                brief += `## Session Type: ${typeInfo.icon} ${typeInfo.label}\n\n`;
                brief += `**Role:** ${typeInfo.roleFrame}\n\n`;
                brief += `### Scope Rules\n`;
                typeInfo.scopeRules.forEach(rule => {
                    brief += `- ${rule}\n`;
                });
                brief += `\n### Delivery Requirements\n`;
                typeInfo.deliveryRequirements.forEach(req => {
                    brief += `- ${req}\n`;
                });
                brief += '\n';
            }
            
            // === Target Work Items (if specified) ===
            if (targetWorkItems && targetWorkItems.length > 0) {
                brief += `## Target Work Items\n\n`;
                targetWorkItems.forEach(wi => {
                    brief += `### ${wi.id}: ${wi.title}\n`;
                    brief += `- **Type:** ${wi.type} | **Priority:** ${wi.priority} | **Effort:** ${wi.effort || '—'}\n`;
                    if (wi.streamId && options.streams) {
                        const stream = options.streams.find(s => s.id === wi.streamId);
                        if (stream) brief += `- **Stream:** ${stream.name} (${stream.status}) — Owner: ${stream.owner}\n`;
                    }
                    if (wi.description) brief += `- **Description:** ${wi.description}\n`;
                    if (wi.criteria && wi.criteria.length > 0) {
                        brief += `- **Acceptance Criteria:**\n`;
                        wi.criteria.forEach(c => {
                            brief += `  - [ ] ${typeof c === 'string' ? c : c.text || c}\n`;
                        });
                    }
                    if (wi.context?.filesAffected?.length > 0) {
                        brief += `- **Files Affected:** ${wi.context.filesAffected.join(', ')}\n`;
                    }
                    if (wi.context?.dependencies?.length > 0) {
                        brief += `- **Dependencies:** ${wi.context.dependencies.join(', ')}\n`;
                    }
                    if (wi.context?.notes) {
                        brief += `- **Notes:** ${wi.context.notes}\n`;
                    }
                    brief += '\n';
                });
                
                // Stream context: if all targeted items belong to the same stream, show stream details
                if (options.streams && options.streams.length > 0) {
                    const targetStreamIds = [...new Set(targetWorkItems.filter(wi => wi.streamId).map(wi => wi.streamId))];
                    if (targetStreamIds.length === 1) {
                        const stream = options.streams.find(s => s.id === targetStreamIds[0]);
                        if (stream) {
                            brief += `## Stream Context: ${stream.name}\n`;
                            brief += `- **Owner:** ${stream.owner}\n`;
                            brief += `- **Goal:** ${stream.goal || 'Not specified'}\n`;
                            brief += `- **Status:** ${stream.status}\n`;
                            if (stream.targetRelease) brief += `- **Target Release:** ${stream.targetRelease}\n`;
                            brief += '\n';
                        }
                    }
                }
                
                // Phase 5.4: Dependency change context (prompt chaining)
                // If any targeted work items are dependency_update type, include the change context
                // from the source session. This is the core prompt chain: previous session's output
                // becomes this session's input, routed through dependency contracts.
                const depUpdateItems = targetWorkItems.filter(wi => wi.type === 'dependency_update' || wi.source === 'dependency_alert');
                if (depUpdateItems.length > 0) {
                    brief += `## ⚠️ Dependency Changes — Context from Source Session\n\n`;
                    brief += `This session addresses ${depUpdateItems.length} dependency update${depUpdateItems.length !== 1 ? 's' : ''}. `;
                    brief += `Another stream changed an interface this stream depends on. Review the change context below before making updates.\n\n`;
                    
                    depUpdateItems.forEach(wi => {
                        brief += `### ${wi.title}\n`;
                        if (wi.description) brief += `${wi.description}\n\n`;
                        if (wi.context?.notes) brief += `**Notes:** ${wi.context.notes}\n`;
                        if (wi.context?.dependencies?.length) brief += `**Affected interfaces:** ${wi.context.dependencies.join(', ')}\n`;
                        if (wi.context?.relatedItems?.length) brief += `**Source work item:** ${wi.context.relatedItems.join(', ')}\n`;
                        brief += '\n';
                    });
                }
            }
            
            // === Current Status ===
            brief += this._generateStatusSection(app, deployments);
            
            // === Open Work Items Summary (if available and not already targeted) ===
            if (allWorkItems && allWorkItems.length > 0) {
                const appItems = allWorkItems.filter(wi => wi.appId === app.id);
                const openItems = appItems.filter(wi => wi.status === 'ready' || wi.status === 'in-progress' || wi.status === 'review');
                const targetIds = new Set((targetWorkItems || []).map(wi => wi.id));
                const otherOpen = openItems.filter(wi => !targetIds.has(wi.id));
                
                if (otherOpen.length > 0) {
                    brief += `## Other Open Work Items (${otherOpen.length})\n`;
                    brief += `| ID | Title | Type | Priority | Status |\n|-----|-------|------|----------|--------|\n`;
                    otherOpen.slice(0, 10).forEach(wi => {
                        brief += `| ${wi.id} | ${wi.title} | ${wi.type} | ${wi.priority} | ${wi.status} |\n`;
                    });
                    if (otherOpen.length > 10) {
                        brief += `\n*...and ${otherOpen.length - 10} more open items*\n`;
                    }
                    brief += '\n';
                }
            }
            
            // === App Config ===
            brief += this._generateAppConfigSection(app, projectDef);
            
            // === Maturity Context ===
            if (app.lifecycle?.currentMaturity) {
                brief += `## Maturity Context\n`;
                brief += `- **Current:** ${app.lifecycle.currentMaturity}\n`;
                if (app.lifecycle.maturityTarget) {
                    brief += `- **Target:** ${app.lifecycle.maturityTarget}\n`;
                }
                brief += `- **Build quality to:** ${app.lifecycle.maturityTarget || app.lifecycle.currentMaturity} standards\n\n`;
            }
            
            return brief;
        },
        
        _generateStatusSection(app, deployments) {
            const appDeploys = (deployments || [])
                .filter(d => d.appId === app.id && d.status === 'success')
                .slice(0, 5);
            
            const deployRows = appDeploys.length > 0
                ? appDeploys.map(d => {
                    const date = new Date(d.completedAt || d.startedAt);
                    return `| ${date.toLocaleDateString()} | ${d.version || '—'} | ${(d.target || '').toUpperCase()} | ${d.isPromotion ? 'Promoted' : d.isRollback ? 'Rollback' : ''} |`;
                }).join('\n')
                : '| — | — | — | No recent deploys |';
            
            const testVer = app.versions?.test || '—';
            const prodVer = app.versions?.prod || '—';
            const lastTestDeploy = appDeploys.find(d => d.target === 'test');
            const lastProdDeploy = appDeploys.find(d => d.target === 'prod');
            const fmtDate = (d) => d ? new Date(d.completedAt || d.startedAt).toLocaleDateString() : '—';
            
            let section = `## Current Status\n`;
            section += `| Environment | Version | Last Deploy |\n`;
            section += `|-------------|---------|-------------|\n`;
            section += `| Test        | ${testVer} | ${fmtDate(lastTestDeploy)} |\n`;
            section += `| Prod        | ${prodVer} | ${fmtDate(lastProdDeploy)} |\n\n`;
            
            section += `## Recent Deploys (Last 5)\n`;
            section += `| Date | Version | Target | Notes |\n`;
            section += `|------|---------|--------|-------|\n`;
            section += deployRows + '\n\n';
            
            return section;
        },
        
        _generateAppConfigSection(app, projectDef) {
            let section = `## App Config\n`;
            section += `- **Project:** ${projectDef.name || app.project || '—'}\n`;
            section += `- **Type:** ${app.appType || 'other'}\n`;
            section += `- **PWA:** ${app.hasServiceWorker ? 'Yes (sw.js + manifest.json)' : 'No'}\n`;
            section += `- **Repos:** ${Object.entries(app.repos || {}).filter(([,v]) => v).map(([k,v]) => `${k}: ${v}`).join(', ') || '—'}\n`;
            section += `- **SubPath:** ${app.subPath || '(root)'}\n`;
            section += `- **Target:** ${app.targetPath || 'index.html'}\n`;
            section += `- **Detection patterns:** ${(app.detectionPatterns || []).join(', ') || '—'}\n\n`;
            return section;
        },
        
        // Get recommended file inclusion list based on session type
        getFileStrategy(sessionType) {
            const typeInfo = SESSION_TYPES[sessionType];
            if (!typeInfo) return { alwaysInclude: [], preferInclude: [], skipWhenTight: [], includeSource: true };
            return typeInfo.contextStrategy;
        },
        
        // Suggest session type from a work item
        suggestFromWorkItem(workItem) {
            if (!workItem) return 'build';
            // Check each session type's autoSuggestFrom list
            for (const [typeId, typeDef] of Object.entries(SESSION_TYPES)) {
                if (typeDef.autoSuggestFrom.includes(workItem.type)) {
                    return typeId;
                }
            }
            // Fallback to the EngineRegistryService mapping
            return EngineRegistryService.WORK_ITEM_SESSION_MAP[workItem.type] || 'build';
        },
        
        // Get all session types for UI display
        getAll() {
            return Object.values(SESSION_TYPES);
        },
        
        // Get a specific session type
        get(typeId) {
            return SESSION_TYPES[typeId] || null;
        }
    };
    
    // =========================================================================
    // END DATA SERVICE LAYER
    // =========================================================================
    
    function extractVersionFromHTML(content) {
        // Collect all version candidates with their source
        const candidates = [];
        
        // Priority 1: const APP_VERSION - the authoritative runtime version
        const appVersionMatch = content.match(/const\s+APP_VERSION\s*=\s*['"]([^'"]+)['"]/);
        if (appVersionMatch) {
            candidates.push({ version: appVersionMatch[1], source: 'APP_VERSION', priority: 1 });
        }
        
        // Priority 2: meta version tag
        const metaMatch = content.match(/<meta\s+name=["']version["']\s+content=["']([^"']+)["']/i);
        if (metaMatch) {
            candidates.push({ version: metaMatch[1], source: 'meta', priority: 2 });
        }
        
        // Priority 2b: meta tag with reversed attributes
        const metaMatch2 = content.match(/<meta\s+content=["']([^"']+)["']\s+name=["']version["']/i);
        if (metaMatch2 && !metaMatch) {
            candidates.push({ version: metaMatch2[1], source: 'meta', priority: 2 });
        }
        
        // Priority 3: const VERSION (without APP_ prefix)
        const versionConstMatch = content.match(/const\s+VERSION\s*=\s*['"]([^'"]+)['"]/);
        if (versionConstMatch) {
            candidates.push({ version: versionConstMatch[1], source: 'VERSION', priority: 3 });
        }
        
        // Priority 4: HTML comment with VERSION label
        const commentMatch = content.match(/<!--\s*VERSION:\s*([^\s]+)\s*-->/i);
        if (commentMatch) {
            candidates.push({ version: commentMatch[1], source: 'comment', priority: 4 });
        }
        
        // Priority 5: data-version attribute
        const dataMatch = content.match(/data-version=["']([^"']+)["']/i);
        if (dataMatch) {
            candidates.push({ version: dataMatch[1], source: 'data-attr', priority: 5 });
        }
        
        // If we have candidates, return the highest priority one
        if (candidates.length > 0) {
            candidates.sort((a, b) => a.priority - b.priority);
            return candidates[0].version;
        }
        
        // Fallback: JSON-style version field (but skip if looks like example/docs)
        const jsonMatch = content.match(/["']version["']\s*:\s*["'](\d+\.\d+\.\d+)["']/i);
        if (jsonMatch && jsonMatch[1] !== '1.0.0') return jsonMatch[1];
        
        // Fallback: JSDoc @version tag
        const jsdocMatch = content.match(/@version\s+(\d+\.\d+\.\d+)/i);
        if (jsdocMatch && jsdocMatch[1] !== '1.0.0') return jsdocMatch[1];
        
        return null;
    }
    
    // Find ALL version-like strings in HTML for debugging
    function findAllVersionStrings(content) {
        const versions = [];
        
        // Helper to check if a match is inside a comment or code example
        function shouldSkip(matchIndex, matchText) {
            // Get surrounding context (200 chars before, line content)
            const before = content.substring(Math.max(0, matchIndex - 200), matchIndex);
            const lineStart = content.lastIndexOf('\n', matchIndex) + 1;
            const lineEnd = content.indexOf('\n', matchIndex);
            const lineContent = content.substring(lineStart, lineEnd === -1 ? matchIndex + 100 : lineEnd);
            
            // Skip if inside a comment block or pattern documentation
            if (/^\s*(\/\/|\*|#)/.test(lineContent)) return true;
            if (/Pattern|Example|e\.g\.|like|→|-->/i.test(lineContent)) return true;
            
            // Skip if the match looks like documentation (Pattern 1:, Pattern 2:, etc.)
            if (/Pattern\s*\d+|\/\/\s*Pattern/i.test(before.slice(-80))) return true;
            
            // Skip if this appears to be inside function code that manipulates versions
            // (i.e., the fixVersionsInContent function, version bump examples, etc.)
            if (/fixVersions|incrementVersion|bumpVersion|parseVersion/i.test(before.slice(-150))) return true;
            
            // Skip template literal patterns - these are code, not actual versions
            if (matchText && matchText.includes('${')) return true;
            if (matchText && matchText.includes('targetVersion')) return true;
            
            // Skip if inside a generate* function (skeleton docs, HTML templates, Claude prompts)
            // These contain meta version tags as template output, not the app's own version
            const fnContext = before.slice(-1000);
            if (/function\s+generate\w*\s*\(/.test(fnContext) && !/function\s+(extractVersion|findAllVersion|validateVersion)/.test(fnContext)) return true;
            
            // Skip placeholder version patterns (X.X.X, X.Y.Z, etc.)
            if (matchText && /^[A-Z]\.[A-Z]\.[A-Z]$/.test(matchText)) return true;
            
            // Skip if it's a version format example like "1.0.0 → 1.0.1"
            if (/\d+\.\d+\.\d+\s*→/.test(lineContent)) return true;
            
            return false;
        }
        
        // Meta tag versions
        const metaMatches = content.matchAll(/<meta\s+[^>]*name=["']version["'][^>]*content=["']([^"']+)["'][^>]*>/gi);
        for (const m of metaMatches) {
            if (shouldSkip(m.index, m[1])) continue;
            versions.push({ source: 'meta tag', value: m[1], line: content.substring(0, m.index).split('\n').length });
        }
        // Also check reverse order: content before name
        const metaMatches2 = content.matchAll(/<meta\s+[^>]*content=["']([^"']+)["'][^>]*name=["']version["'][^>]*>/gi);
        for (const m of metaMatches2) {
            if (shouldSkip(m.index, m[1])) continue;
            versions.push({ source: 'meta tag', value: m[1], line: content.substring(0, m.index).split('\n').length });
        }
        
        // JS variable versions - but NOT inside comments, template literals, or the integration module definition
        const jsMatches = content.matchAll(/^\s*const\s+(VERSION|APP_VERSION|GAME_VERSION)\s*=\s*['"]([^'"]+)['"]/gm);
        for (const m of jsMatches) {
            // Skip if it's inside the GameShelf integration module (those are module versions, not app versions)
            const before = content.substring(Math.max(0, m.index - 200), m.index);
            if (before.includes('GAMESHELF_VERSION') || before.includes('Integration Module')) continue;
            if (shouldSkip(m.index, m[2])) continue;
            versions.push({ source: `JS: ${m[1]}`, value: m[2], line: content.substring(0, m.index).split('\n').length });
        }
        
        // Footer versions - look for patterns like "v1.0.0 •" or ">v1.0.0<" or "v1.0.0 &bull;"
        const footerMatches = content.matchAll(/[>\s]v(\d+\.\d+\.\d+)\s*[•<·&]/g);
        for (const m of footerMatches) {
            if (shouldSkip(m.index, m[1])) continue;
            versions.push({ source: 'footer/visible', value: m[1], line: content.substring(0, m.index).split('\n').length });
        }
        
        // Version in about/info sections
        const aboutMatches = content.matchAll(/Version:?\s*<\/?\w*>?\s*v?(\d+\.\d+\.\d+)/gi);
        for (const m of aboutMatches) {
            if (shouldSkip(m.index, m[1])) continue;
            versions.push({ source: 'about/info text', value: m[1], line: content.substring(0, m.index).split('\n').length });
        }
        
        return versions;
    }
    
    // Validate version consistency in HTML content
    function validateVersions(content, filename) {
        const versions = findAllVersionStrings(content);
        const primary = extractVersionFromHTML(content);
        
        // Get unique version values
        const uniqueVersions = [...new Set(versions.map(v => v.value))];
        
        const result = {
            isValid: true,
            primary: primary,
            allVersions: versions,
            uniqueVersions: uniqueVersions,
            mismatches: [],
            missing: []
        };
        
        // Check for mismatches
        if (uniqueVersions.length > 1) {
            result.isValid = false;
            result.mismatches = versions.filter(v => v.value !== primary);
        }
        
        // Check for missing meta tag
        const hasMeta = versions.some(v => v.source === 'meta tag');
        if (!hasMeta) {
            result.isValid = false;
            result.missing.push('meta tag');
        }
        
        // Check for missing JS VERSION constant (for apps that should have one)
        const hasJsVersion = versions.some(v => v.source.startsWith('JS:'));
        if (!hasJsVersion && content.includes('const VERSION')) {
            // There's a VERSION constant but we didn't capture it - might be okay
        }
        
        return result;
    }
    
    // Auto-fix version strings in HTML content
    function fixVersionsInContent(content, targetVersion) {
        let fixed = content;
        
        // Fix or add meta tag
        const metaRegex = /<meta\s+name=["']version["']\s+content=["'][^"']*["']\s*\/?>/i;
        const metaRegex2 = /<meta\s+content=["'][^"']*["']\s+name=["']version["']\s*\/?>/i;
        
        if (metaRegex.test(fixed)) {
            fixed = fixed.replace(metaRegex, `<meta name="version" content="${targetVersion}">`);
        } else if (metaRegex2.test(fixed)) {
            fixed = fixed.replace(metaRegex2, `<meta name="version" content="${targetVersion}">`);
        } else {
            // Add meta tag after charset or viewport
            fixed = fixed.replace(
                /(<meta\s+[^>]*viewport[^>]*>)/i,
                `$1\n    <meta name="version" content="${targetVersion}">`
            );
        }
        
        // Fix const VERSION = '8.36.0' (but not GAMESHELF_VERSION)
        fixed = fixed.replace(
            /(const\s+VERSION\s*=\s*['"])[^'"]*(['"])/g,
            `$1${targetVersion}$2`
        );
        
        // Fix CACHE_VERSION = 'v8.7.6' in service workers (with or without 'v' prefix)
        fixed = fixed.replace(
            /(CACHE_VERSION\s*=\s*['"])v?[^'"]*(['"])/g,
            `$1v${targetVersion}$2`
        );
        
        // Fix console.log version strings like "App v1.0.0 starting" or "Command Center v8.7.5"
        fixed = fixed.replace(
            /(console\.log\(['"][^'"]*\s+v)\d+\.\d+\.\d+(\s+[^'"]*['"])/g,
            `$1${targetVersion}$2`
        );
        
        // Fix footer versions like "v1.0.0 •" or "v1.0.0 ·" or "v1.0.0 &bull;"
        fixed = fixed.replace(
            /(>\s*)v\d+\.\d+\.\d+(\s*[•·])/g,
            `$1v${targetVersion}$2`
        );
        fixed = fixed.replace(
            /(>\s*)v\d+\.\d+\.\d+(\s*&bull;)/g,
            `$1v${targetVersion}$2`
        );
        
        // Fix about/version display
        fixed = fixed.replace(
            /(Version:?\s*<\/?\w*>?\s*)v?\d+\.\d+\.\d+/gi,
            `$1v${targetVersion}`
        );
        
        return fixed;
    }
    
    function parseVersion(version) {
        if (!version) return null;
        const parts = version.replace(/^v/i, '').split('.').map(p => parseInt(p, 10) || 0);
        while (parts.length < 4) parts.push(0);
        return parts;
    }
    
    function compareVersions(a, b) {
        const pa = parseVersion(a);
        const pb = parseVersion(b);
        if (!pa || !pb) return 0;
        for (let i = 0; i < 4; i++) {
            if (pa[i] > pb[i]) return 1;
            if (pa[i] < pb[i]) return -1;
        }
        return 0;
    }
    
    function isNewerVersion(newVersion, currentVersion) {
        if (!currentVersion) return true;
        return compareVersions(newVersion, currentVersion) > 0;
    }
    
    function bumpVersion(version, type) {
        if (!version) return '1.0.0';
        const parts = version.replace(/^v/i, '').split('.').map(Number);
        while (parts.length < 3) parts.push(0);
        if (type === 'major') { parts[0]++; parts[1] = 0; parts[2] = 0; }
        else if (type === 'minor') { parts[1]++; parts[2] = 0; }
        else { parts[2]++; }
        return parts.join('.');
    }
    
    function formatVersion(v) {
        return v ? `v${v}` : '—';
    }

    // =========================================================================
    // DYNAMIC CONFIGURATION SYSTEM (v7.0.0)
    // =========================================================================
    
    // Environment definitions - extensible for dev, test, prod, beta
    const DEFAULT_ENVIRONMENTS = {
        available: ['dev', 'test', 'prod', 'beta'],
        active: ['test', 'prod'],  // Currently enabled
        colors: {
            dev: { bg: 'bg-purple-600', text: 'text-purple-300', border: 'border-purple-500', hex: '#9333ea' },
            test: { bg: 'bg-blue-600', text: 'text-blue-300', border: 'border-blue-500', hex: '#2563eb' },
            prod: { bg: 'bg-green-600', text: 'text-green-300', border: 'border-green-500', hex: '#16a34a' },
            beta: { bg: 'bg-orange-600', text: 'text-orange-300', border: 'border-orange-500', hex: '#ea580c' }
        },
        labels: { dev: 'DEV', test: 'TEST', prod: 'PROD', beta: 'BETA' },
        icons: { dev: '🛠️', test: '🧪', prod: '🚀', beta: '🔬' }
    };
    
    // App type categories (v8.3.3)
    const APP_TYPES = {
        public: { label: 'Public Apps', description: 'User-facing apps with Test → Prod workflow', collapsed: false },
        internal: { label: 'Internal Tools', description: 'Prod only - no test environment', collapsed: false },
        other: { label: 'Other Projects', description: 'Side projects and prototypes', collapsed: true }
    };
    
    // Project definitions (v8.8.0) - Umbrella grouping for apps
    // Seed data — used only for initial migration into config.projects
    // Seed project definitions — ONLY used for first-time initialization.
    // After first load, config.projects is the source of truth.
    // UI components may reference SEED_PROJECTS as a fallback safety net
    // but it should never be reached in normal operation.
    const SEED_PROJECTS = {
        'gameshelf': { id: 'gameshelf', name: 'Game Shelf', icon: 'gs-logo', color: 'indigo', description: 'Daily puzzle game platform', order: 1, state: 'active' },
        'command-center': { id: 'command-center', name: 'Command Center', icon: '🏗️', color: 'cyan', description: 'Deploy & manage apps', order: 2, state: 'active' },
        'quotle-info': { id: 'quotle-info', name: 'Quotle-info', icon: '📖', color: 'rose', description: 'Quote context engine', order: 3, state: 'active' },
        'labelkeeper': { id: 'labelkeeper', name: 'LabelKeeper', icon: '🏷️', color: 'emerald', description: 'Label printing tool', order: 4, state: 'active' },
        'superbowl': { id: 'superbowl', name: 'Super Bowl', icon: '🏈', color: 'amber', description: 'Super Bowl squares & pools', order: 5, state: 'active' },
        'other': { id: 'other', name: 'Other', icon: '📦', color: 'slate', description: 'Uncategorized apps', order: 99, state: 'active' }
    };
    
    // Seed app definitions — ONLY used for first-time initialization (empty config).
    // After first load, config.apps is the source of truth. Do NOT reference
    // these as fallbacks in runtime code — use config.apps[appId] instead.
    const DEFAULT_APP_DEFINITIONS = {
        // ===== PUBLIC APPS (Test → Prod workflow) =====
        gameshelf: {
            id: 'gameshelf', name: 'Game Shelf', icon: 'gs-logo', project: 'gameshelf',
            appType: 'public',
            targetPath: 'index.html', swPath: 'sw.js', hasServiceWorker: true,
            subPath: 'app',
            repos: { test: '', prod: '' },
            versions: { test: '', prod: '' },
            repoPatterns: {
                test: ['gameshelftest', 'gameshelf-test'],
                prod: ['gameshelf']
            },
            detectionPatterns: ['gameshelfdata', 'game.shelf.pwa', '#setup-welcome', 'APP_VERSION']
        },
        beta: {
            id: 'beta', name: 'Beta Hub', icon: '🚀', project: 'gameshelf',
            appType: 'public',
            targetPath: 'index.html', swPath: null, hasServiceWorker: false,
            subPath: 'beta',
            repos: { test: '', prod: '' },
            versions: { test: '', prod: '' },
            repoPatterns: {
                test: [],  // No test for Beta Hub - uses same repo as Game Shelf
                prod: ['gameshelf']
            },
            detectionPatterns: ['<title>Game Shelf Beta Hub', 'Beta Hub v\\d', 'beta-hub', 'Early Access signup']
        },
        slate: {
            id: 'slate', name: 'Slate', icon: '🪨', project: 'gameshelf',
            appType: 'public',
            targetPath: 'index.html', swPath: 'sw.js', hasServiceWorker: true,
            subPath: 'slate',
            repos: { test: '', prod: '' },
            versions: { test: '', prod: '' },
            repoPatterns: {
                test: ['slatetest', 'slate-test'],
                prod: ['gameshelf']
            },
            detectionPatterns: ['<title>slate', 'slate.*daily.*word', 'chalkboard-bg', 'slate-board']
        },
        rungs: {
            id: 'rungs', name: 'Rungs', icon: '🪜', project: 'gameshelf',
            appType: 'public',
            targetPath: 'index.html', swPath: 'sw.js', hasServiceWorker: true,
            subPath: 'rungs',
            repos: { test: '', prod: '' },
            versions: { test: '', prod: '' },
            repoPatterns: {
                test: ['rungstest', 'rungs-test'],
                prod: ['gameshelf']
            },
            detectionPatterns: ['<title>rungs', 'rungs.*daily', 'word-ladder', 'rung-container']
        },
        quotle: {
            id: 'quotle', name: 'Quotle', icon: '💬', project: 'gameshelf',
            appType: 'public',
            targetPath: 'index.html', swPath: 'sw.js', hasServiceWorker: true,
            subPath: 'quotle',
            repos: { test: '', prod: '' },
            versions: { test: '', prod: '' },
            repoPatterns: {
                test: ['quotletest', 'quotle-test'],
                prod: ['gameshelf']
            },
            detectionPatterns: ['<title>quotle', 'quotle.*daily.*quote', 'quotes-database']
        },
        wordboxing: {
            id: 'wordboxing', name: 'Word Boxing', icon: '🥊', project: 'gameshelf',
            appType: 'public',
            targetPath: 'index.html', swPath: 'sw.js', hasServiceWorker: true,
            subPath: 'wordboxing',
            repos: { test: '', prod: '' },
            versions: { test: '', prod: '' },
            repoPatterns: {
                test: ['wordboxingtest', 'wordboxing-test'],
                prod: ['gameshelf']
            },
            detectionPatterns: ['<title>word\\s*boxing', 'word-boxing', 'boxing-ring']
        },
        landing: {
            id: 'landing', name: 'Landing Page', icon: '📣', project: 'gameshelf',
            appType: 'public',
            targetPath: 'index.html', swPath: '', hasServiceWorker: false,
            subPath: '',  // Root of gameshelf repo
            repos: { test: '', prod: '' },
            versions: { test: '', prod: '' },
            repoPatterns: {
                test: ['gameshelftest'],
                prod: ['gameshelf']
            },
            detectionPatterns: ['Track Every Daily Puzzle', 'track.*every.*daily.*puzzle', 'Join the Beta', 'cta-button']
        },
        terms: {
            id: 'terms', name: 'Terms of Service', icon: '📋', project: 'gameshelf',
            appType: 'public',
            targetPath: 'index.html', swPath: '', hasServiceWorker: false,
            subPath: 'terms',
            repos: { test: '', prod: '' },
            versions: { test: '', prod: '' },
            repoPatterns: {
                test: ['gameshelftest'],
                prod: ['gameshelf']
            },
            detectionPatterns: ['gameshelf-terms', '<title>Terms of Service', 'Terms of Service.*Game Shelf']
        },
        privacy: {
            id: 'privacy', name: 'Privacy Policy', icon: '🔒', project: 'gameshelf',
            appType: 'public',
            targetPath: 'index.html', swPath: '', hasServiceWorker: false,
            subPath: 'privacy',
            repos: { test: '', prod: '' },
            versions: { test: '', prod: '' },
            repoPatterns: {
                test: ['gameshelftest'],
                prod: ['gameshelf']
            },
            detectionPatterns: ['gameshelf-privacy', '<title>Privacy Policy', 'Privacy Policy.*Game Shelf']
        },
        
        // ===== INTERNAL TOOLS (Prod only) =====
        testplan: {
            id: 'testplan', name: 'Test Plan', icon: '🧪', project: 'gameshelf',
            appType: 'internal',
            targetPath: 'index.html', swPath: '', hasServiceWorker: false,
            subPath: '',
            repos: { prod: '' },
            versions: { prod: '' },
            repoPatterns: {
                prod: ['gameshelf-testplan']
            },
            detectionPatterns: ['<title>.*test\\s*plan', 'playwright.*runner', 'test-plan-app']
        },
        'command-center': {
            id: 'command-center', name: 'Command Center', icon: '🏗️', project: 'command-center',
            appType: 'public',
            targetPath: 'index.html', swPath: '', hasServiceWorker: false,
            subPath: '',
            repos: { test: '', prod: '' },
            versions: { test: '', prod: '' },
            repoPatterns: {
                test: ['command-center-test'],
                prod: ['command-center']
            },
            detectionPatterns: ['<title>.*command\\s*center', '<title>.*ship\\s*it', 'command-center', 'claude.*deploy.*queue']
        },
        'firebase-functions': {
            id: 'firebase-functions', name: 'Firebase Functions', icon: '⚡', project: 'gameshelf',
            appType: 'internal',
            targetPath: 'functions/index.js', swPath: '', hasServiceWorker: false,
            subPath: '',
            deployType: 'github-actions',
            repos: { prod: '' },
            versions: { prod: '' },
            repoPatterns: {
                prod: ['gameshelf-functions']
            },
            detectionPatterns: ['firebase-functions', 'onRequest', 'onCall', 'getHint', 'ANTHROPIC_API_KEY']
        },
        
        // ===== OTHER PROJECTS (Collapsed by default) =====
        'quotle-info': {
            id: 'quotle-info', name: 'Quotle-info', icon: '📖', project: 'quotle-info',
            appType: 'other',
            targetPath: 'index.html', swPath: '', hasServiceWorker: false,
            subPath: '',
            repos: { prod: '' },
            versions: { prod: '' },
            repoPatterns: {
                prod: ['quote-info']
            },
            detectionPatterns: ['quotle.info', 'Quote Context Engine', 'quotle-info/quotes']
        },
        'quotle-info-admin': {
            id: 'quotle-info-admin', name: 'Quotle-info Admin', icon: '📖🔧', project: 'quotle-info',
            appType: 'other',
            targetPath: 'index.html', swPath: '', hasServiceWorker: false,
            subPath: 'admin',
            repos: { prod: '' },
            versions: { prod: '' },
            repoPatterns: {
                prod: ['quote-info']
            },
            detectionPatterns: ['Database Manager', 'quotle-info.*manager', 'Enrichment Queue']
        },
        'sb-squares': {
            id: 'sb-squares', name: 'SB Squares', icon: '🏈', project: 'superbowl',
            appType: 'other',
            targetPath: 'index.html', swPath: '', hasServiceWorker: false,
            subPath: '',
            repos: { prod: '' },
            versions: { prod: '' },
            repoPatterns: {
                prod: ['sb-squares-lx', 'superbowl']
            },
            detectionPatterns: ['sb-squares', 'super.*bowl.*squares', 'football.*pool']
        },
        'labelkeeper': {
            id: 'labelkeeper', name: 'LabelKeeper', icon: '🏷️', project: 'labelkeeper',
            appType: 'public',
            targetPath: 'index.html', swPath: '', hasServiceWorker: false,
            subPath: '',
            repos: { test: '', prod: '' },
            versions: { test: '', prod: '' },
            repoPatterns: {
                test: ['labelkeepertest'],
                prod: ['labelkeeper']
            },
            detectionPatterns: ['labelkeeper', 'label.keeper']
        },
        'teacher-assist': {
            id: 'teacher-assist', name: 'Teacher Assist', icon: '👩‍🏫', project: 'other',
            appType: 'other',
            targetPath: 'index.html', swPath: '', hasServiceWorker: false,
            subPath: '',
            repos: { test: '', prod: '' },
            versions: { test: '', prod: '' },
            repoPatterns: {
                test: ['teacher-assist-test'],
                prod: ['teacher-assist']
            },
            detectionPatterns: ['teacher.assist', 'teacher-assist']
        },
        'daily-shelf': {
            id: 'daily-shelf', name: 'Daily Shelf', icon: '📅', project: 'other',
            appType: 'other',
            targetPath: 'index.html', swPath: '', hasServiceWorker: false,
            subPath: '',
            repos: { test: '', prod: '' },
            versions: { test: '', prod: '' },
            repoPatterns: {
                test: ['daily-shelf-test'],
                prod: ['daily-shelf']
            },
            detectionPatterns: ['daily.shelf', 'daily-shelf']
        },
        'ui-prototypes': {
            id: 'ui-prototypes', name: 'UI Prototypes', icon: '🎨', project: 'other',
            appType: 'other',
            targetPath: 'index.html', swPath: '', hasServiceWorker: false,
            subPath: '',
            repos: { test: '', prod: '' },
            versions: { test: '', prod: '' },
            repoPatterns: {
                test: ['gameshelf-ui-test'],
                prod: ['gameshelf-ui']
            },
            detectionPatterns: ['ui.prototype', 'gameshelf-ui']
        }
    };
    
    // Machine-readable seed manifest for config ↔ code drift detection.
    // When CC deploys itself, this is parsed from the staged HTML and compared
    // against the running config to detect mismatches.
    // Format: /* CC_SEED_MANIFEST_START */ JSON /* CC_SEED_MANIFEST_END */
    /* CC_SEED_MANIFEST_START */
    const CC_SEED_MANIFEST = {
        "appId": "command-center",
        "title": "Command Center",
        "projects": {
            "gameshelf": { "name": "Game Shelf", "icon": "gs-logo", "color": "indigo" },
            "command-center": { "name": "Command Center", "icon": "🏗️", "color": "cyan" },
            "quotle-info": { "name": "Quotle-info", "icon": "📖", "color": "rose" },
            "labelkeeper": { "name": "LabelKeeper", "icon": "🏷️", "color": "emerald" },
            "superbowl": { "name": "Super Bowl", "icon": "🏈", "color": "amber" },
            "other": { "name": "Other", "icon": "📦", "color": "slate" }
        },
        "apps": {
            "gameshelf": { "name": "Game Shelf", "project": "gameshelf", "icon": "gs-logo", "subPath": "app", "appType": "public", "hasServiceWorker": true },
            "beta": { "name": "Beta Hub", "project": "gameshelf", "icon": "🚀", "subPath": "beta", "appType": "public", "hasServiceWorker": false },
            "slate": { "name": "Slate", "project": "gameshelf", "icon": "🪨", "subPath": "slate", "appType": "public", "hasServiceWorker": true },
            "rungs": { "name": "Rungs", "project": "gameshelf", "icon": "🪜", "subPath": "rungs", "appType": "public", "hasServiceWorker": true },
            "quotle": { "name": "Quotle", "project": "gameshelf", "icon": "💬", "subPath": "quotle", "appType": "public", "hasServiceWorker": true },
            "wordboxing": { "name": "Word Boxing", "project": "gameshelf", "icon": "🥊", "subPath": "wordboxing", "appType": "public", "hasServiceWorker": true },
            "command-center": { "name": "Command Center", "project": "command-center", "icon": "🏗️", "subPath": "", "appType": "public", "hasServiceWorker": false },
            "testplan": { "name": "Test Plan", "project": "gameshelf", "icon": "🧪", "subPath": "", "appType": "internal", "hasServiceWorker": false },
            "firebase-functions": { "name": "Firebase Functions", "project": "gameshelf", "icon": "⚡", "subPath": "", "appType": "internal", "hasServiceWorker": false },
            "labelkeeper": { "name": "LabelKeeper", "project": "labelkeeper", "icon": "🏷️", "subPath": "", "appType": "public", "hasServiceWorker": false }
        }
    };
    /* CC_SEED_MANIFEST_END */
    
    // Configuration manager
    const ConfigManager = {
        STORAGE_KEY: 'commandCenterConfig',
        REPO_STORAGE_KEY: 'githubRepoAssignments',
        
        // Load config from localStorage or use defaults
        load() {
            try {
                const stored = localStorage.getItem(this.STORAGE_KEY);
                if (stored) {
                    const config = JSON.parse(stored);
                    return this.mergeWithDefaults(config);
                }
            } catch (e) {
                console.warn('Failed to load config, using defaults:', e);
            }
            return this.getDefaultConfig();
        },
        
        // Save config to localStorage + Firebase
        save(config) {
            try {
                // Add sync timestamp
                config._updatedAt = Date.now();
                config._updatedBy = 'local';
                
                // 1. localStorage (immediate, synchronous)
                localStorage.setItem(this.STORAGE_KEY, JSON.stringify(config));
                
                // 2. Firebase (async, fire-and-forget)
                if (FirebaseConfigSync.initialized) {
                    FirebaseConfigSync.pushConfig(config).catch(err =>
                        console.warn('[ConfigManager] Firebase sync failed:', err.message)
                    );
                }
                
                return true;
            } catch (e) {
                console.error('Failed to save config:', e);
                return false;
            }
        },
        
        // Get default configuration
        getDefaultConfig() {
            return {
                version: '7.0.0',
                ownerName: '',
                environments: { ...DEFAULT_ENVIRONMENTS },
                apps: JSON.parse(JSON.stringify(DEFAULT_APP_DEFINITIONS)),
                projects: JSON.parse(JSON.stringify(SEED_PROJECTS))
            };
        },
        
        // Merge stored config with defaults (handles upgrades)
        mergeWithDefaults(stored) {
            const defaults = this.getDefaultConfig();
            
            // v8.15.0: Migrate app id 'management' → 'command-center'
            if (stored.apps && stored.apps['management'] && !stored.apps['command-center']) {
                stored.apps['command-center'] = { ...stored.apps['management'], id: 'command-center' };
                delete stored.apps['management'];
                console.log('🔄 Migrated app: management → command-center');
            }
            
            // Ensure environments structure
            if (!stored.environments) {
                stored.environments = defaults.environments;
            } else {
                stored.environments = { ...defaults.environments, ...stored.environments };
            }
            
            // v8.37.0: Ensure ownerName field exists
            if (stored.ownerName === undefined) {
                stored.ownerName = '';
            }
            
            // v8.12.0: Ensure projects structure exists — one-time migration
            if (!stored.projects) {
                stored.projects = JSON.parse(JSON.stringify(SEED_PROJECTS));
                // Migrate _standalone → other for any existing apps
                for (const app of Object.values(stored.apps || {})) {
                    if (app.project === '_standalone') app.project = 'other';
                }
                // Migrate cc_projectStates into project objects
                try {
                    const oldStates = JSON.parse(localStorage.getItem('cc_projectStates') || '{}');
                    for (const [id, state] of Object.entries(oldStates)) {
                        const projId = id === '_standalone' ? 'other' : id;
                        if (stored.projects[projId]) {
                            stored.projects[projId].state = state;
                        }
                    }
                } catch (e) { /* ignore */ }
            }
            // Note: We do NOT force-merge SEED_PROJECTS into existing stored.projects.
            // Once projects exist in config, the user's stored data is the source of truth.
            // New projects are created through the UI, not by adding seeds here.
            
            // v8.13.1.7: Stored apps are the source of truth.
            // Only seed default apps if the apps object is completely empty (first-time setup).
            // After that, apps are created/edited/deleted through the UI.
            if (!stored.apps || Object.keys(stored.apps).length === 0) {
                stored.apps = JSON.parse(JSON.stringify(defaults.apps));
            } else {
                // Ensure structural fields exist on each stored app (schema migration only)
                // This adds NEW fields from the schema without overwriting user values
                for (const [id, app] of Object.entries(stored.apps)) {
                    if (!app.repos) app.repos = { test: '', prod: '' };
                    if (!app.versions) app.versions = { test: '', prod: '' };
                    if (!app.createdAt) app.createdAt = Date.now();
                    if (!app.detectionPatterns) app.detectionPatterns = [];
                    if (app.appType === undefined) app.appType = 'public';
                    if (app.hasServiceWorker === undefined) app.hasServiceWorker = false;
                    // v8.18.0: Ensure project field exists — fall back to seed definition or 'other'
                    if (!app.project) app.project = DEFAULT_APP_DEFINITIONS[id]?.project || 'other';
                    // v8.20.0: Ensure lifecycle object exists (Phase 0.2 orchestrator)
                    if (!app.lifecycle) app.lifecycle = {};
                    if (!app.lifecycle.category) app.lifecycle.category = app.appType === 'internal' ? 'admin' : null;
                    if (!app.lifecycle.currentMaturity) app.lifecycle.currentMaturity = null;
                    if (!app.lifecycle.maturityTarget) app.lifecycle.maturityTarget = null;
                    if (!app.lifecycle.problemStatement) app.lifecycle.problemStatement = '';
                    if (!app.lifecycle.targetAudience) app.lifecycle.targetAudience = '';
                    if (!app.lifecycle.userGoal) app.lifecycle.userGoal = '';
                    if (!app.lifecycle.successMetric) app.lifecycle.successMetric = '';
                    if (!app.lifecycle.stack) app.lifecycle.stack = {};
                    if (!app.lifecycle.maturityCriteria) app.lifecycle.maturityCriteria = {};
                }
            }
            
            return stored;
        },
        
        // Migrate from old format (testRepo/prodRepo to repos object)
        migrateFromOldFormat(oldApps, config) {
            const repoAssignments = JSON.parse(localStorage.getItem(this.REPO_STORAGE_KEY) || '{}');
            let synced = 0;
            
            for (const [id, oldApp] of Object.entries(oldApps)) {
                if (config.apps[id]) {
                    // Check repo assignments first, then fall back to old format
                    const assignment = repoAssignments[id] || {};
                    const newTest = assignment.testRepo || oldApp.testRepo || '';
                    const newProd = assignment.prodRepo || oldApp.prodRepo || '';
                    if (newTest || newProd) {
                        config.apps[id].repos.test = newTest;
                        config.apps[id].repos.prod = newProd;
                        synced++;
                    }
                    config.apps[id].versions.test = oldApp.currentTestVersion || '';
                    config.apps[id].versions.prod = oldApp.currentProdVersion || '';
                }
            }
            console.log(`[ConfigManager] migrateFromOldFormat: synced repos for ${synced}/${Object.keys(oldApps).length} apps`);
            
            return config;
        },
        
        // Add a new app
        addApp(config, appData) {
            const id = appData.id || appData.name.toLowerCase().replace(/\s+/g, '');
            config.apps[id] = {
                id,
                name: appData.name,
                icon: appData.icon || '📦',
                targetPath: appData.targetPath || 'index.html',
                swPath: appData.swPath || '',
                hasServiceWorker: appData.hasServiceWorker || false,
                repos: { dev: '', test: '', prod: '', beta: '' },
                versions: { dev: '', test: '', prod: '', beta: '' },
                repoPatterns: {
                    dev: [`${id}dev`, `${id}-dev`],
                    test: [`${id}test`, `${id}-test`],
                    prod: [id],
                    beta: [`${id}beta`, `${id}-beta`]
                },
                detectionPatterns: appData.detectionPatterns || [`<title>${appData.name.toLowerCase()}`],
                // v8.20.0: Include lifecycle metadata
                lifecycle: appData.lifecycle || {
                    category: null,
                    currentMaturity: null,
                    maturityTarget: null,
                    problemStatement: '',
                    targetAudience: '',
                    userGoal: '',
                    successMetric: '',
                    stack: {},
                    maturityCriteria: {}
                }
            };
            return config;
        },
        
        // Remove an app
        removeApp(config, appId) {
            delete config.apps[appId];
            return config;
        },
        
        // Update app
        updateApp(config, appId, updates) {
            if (config.apps[appId]) {
                config.apps[appId] = { ...config.apps[appId], ...updates };
            }
            return config;
        },
        
        // Add a new project
        addProject(config, projectData) {
            const id = projectData.id || projectData.name.toLowerCase().replace(/\s+/g, '-');
            config.projects[id] = {
                id,
                name: projectData.name,
                icon: projectData.icon || '📦',
                color: projectData.color || 'slate',
                description: projectData.description || '',
                order: projectData.order ?? (Math.max(...Object.values(config.projects).map(p => p.order || 0)) + 1),
                state: projectData.state || 'active'
            };
            return config;
        },
        
        // Update a project
        updateProject(config, projectId, updates) {
            if (config.projects[projectId]) {
                config.projects[projectId] = { ...config.projects[projectId], ...updates };
            }
            return config;
        },
        
        // Remove a project (reassigns orphaned apps to 'other')
        removeProject(config, projectId) {
            if (projectId === 'other') return config; // Can't delete catch-all
            // Reassign any apps in this project to 'other'
            for (const app of Object.values(config.apps)) {
                if (app.project === projectId) {
                    app.project = 'other';
                }
            }
            delete config.projects[projectId];
            return config;
        },
        
        // Get number of apps in a project
        getProjectAppCount(config, projectId) {
            return Object.values(config.apps).filter(a => (a.project || 'other') === projectId).length;
        },
        
        // Enable/disable an environment
        toggleEnvironment(config, envId) {
            const idx = config.environments.active.indexOf(envId);
            if (idx >= 0) {
                // Don't allow disabling all environments
                if (config.environments.active.length > 1) {
                    config.environments.active.splice(idx, 1);
                }
            } else {
                config.environments.active.push(envId);
                // Sort by the defined order
                config.environments.active.sort((a, b) => 
                    config.environments.available.indexOf(a) - config.environments.available.indexOf(b)
                );
            }
            return config;
        },
        
        // Convert config to legacy apps format for backward compatibility
        toLegacyAppsFormat(config) {
            const apps = {};
            const activeEnvs = config.environments.active;
            
            for (const [id, app] of Object.entries(config.apps)) {
                apps[id] = {
                    id: app.id,
                    name: app.name,
                    icon: app.icon,
                    appType: app.appType || 'public',  // v8.3.3: App category
                    project: app.project || 'other',  // v8.8.0: Project grouping
                    targetPath: app.targetPath,
                    subPath: app.subPath || '',
                    swPath: app.swPath,
                    hasServiceWorker: app.hasServiceWorker,
                    repoPatterns: app.repoPatterns,
                    detectionPatterns: app.detectionPatterns,
                    deployType: app.deployType || null,  // v8.3.3: For GitHub Actions deploys
                    createdAt: app.createdAt || null,  // v8.8.0: Timestamp tracking
                    updatedAt: app.updatedAt || null,  // v8.8.0: Timestamp tracking
                    // Legacy format fields
                    testRepo: app.repos?.test || '',
                    prodRepo: app.repos?.prod || '',
                    currentTestVersion: app.versions?.test || '',
                    currentProdVersion: app.versions?.prod || '',
                    // New format - include all env repos
                    repos: app.repos || {},
                    versions: app.versions || {}
                };
            }
            
            return apps;
        },
        
        // Build detection signatures from config
        buildDetectionSignatures(config) {
            return Object.values(config.apps).map(app => ({
                id: app.id,
                patterns: app.detectionPatterns.map(p => {
                    try {
                        return new RegExp(p, 'i');
                    } catch (e) {
                        console.warn(`Invalid pattern for ${app.id}: ${p}`);
                        return null;
                    }
                }).filter(Boolean),
                confidence: 'high'
            }));
        },
        
        // Get active environments
        getActiveEnvironments(config) {
            return config.environments.active;
        },
        
        // Get environment display info
        getEnvDisplay(config, envId) {
            return {
                label: config.environments.labels[envId] || envId.toUpperCase(),
                icon: config.environments.icons[envId] || '📦',
                colors: config.environments.colors[envId] || config.environments.colors.test
            };
        }
    };

    // =========================================================================
    // ICONS
    // =========================================================================
    
    const Icons = {
        // Game Shelf badge logo (puzzle pieces G and S)
        GameShelfLogo: ({ size = 20 }) => (
            <svg viewBox="0 0 100 100" width={size} height={size} xmlns="http://www.w3.org/2000/svg">
                <defs>
                    <linearGradient id="gsBadgeGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                        <stop offset="0%" style={{stopColor:'#667eea'}}/>
                        <stop offset="100%" style={{stopColor:'#764ba2'}}/>
                    </linearGradient>
                </defs>
                <rect x="5" y="5" width="90" height="90" rx="20" fill="url(#gsBadgeGrad)"/>
                <g transform="rotate(-12, 35, 50)">
                    <rect x="15" y="28" width="28" height="36" rx="4" fill="white"/>
                    <circle cx="43" cy="46" r="6" fill="white"/>
                    <text x="29" y="54" fontFamily="Arial" fontSize="20" fontWeight="bold" fill="#667eea" textAnchor="middle">G</text>
                </g>
                <g transform="rotate(12, 65, 50)">
                    <rect x="57" y="28" width="28" height="36" rx="4" fill="rgba(255,255,255,0.9)"/>
                    <circle cx="57" cy="46" r="6" fill="url(#gsBadgeGrad)"/>
                    <text x="71" y="54" fontFamily="Arial" fontSize="20" fontWeight="bold" fill="#764ba2" textAnchor="middle">S</text>
                </g>
            </svg>
        ),
        Upload: () => <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12" /></svg>,
        Rocket: () => <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15.59 14.37a6 6 0 01-5.84 7.38v-4.8m5.84-2.58a14.98 14.98 0 006.16-12.12A14.98 14.98 0 009.631 8.41m5.96 5.96a14.926 14.926 0 01-5.841 2.58m-.119-8.54a6 6 0 00-7.381 5.84h4.8m2.581-5.84a14.927 14.927 0 00-2.58 5.84m2.699 2.7c-.103.021-.207.041-.311.06a15.09 15.09 0 01-2.448-2.448 14.9 14.9 0 01.06-.312m-2.24 2.39a4.493 4.493 0 00-1.757 4.306 4.493 4.493 0 004.306-1.758M16.5 9a1.5 1.5 0 11-3 0 1.5 1.5 0 013 0z" /></svg>,
        X: () => <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" /></svg>,
        Settings: () => <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" /><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" /></svg>,
        History: () => <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>,
        ExternalLink: () => <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14" /></svg>,
        ArrowRight: () => <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M14 5l7 7m0 0l-7 7m7-7H3" /></svg>,
        Zap: () => <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 10V3L4 14h7v7l9-11h-7z" /></svg>,
        AlertTriangle: () => <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" /></svg>,
        Rewind: () => <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12.066 11.2a1 1 0 000 1.6l5.334 4A1 1 0 0019 16V8a1 1 0 00-1.6-.8l-5.333 4zM4.066 11.2a1 1 0 000 1.6l5.334 4A1 1 0 0011 16V8a1 1 0 00-1.6-.8l-5.334 4z" /></svg>,
        GitBranch: () => <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 9l3 3-3 3m5 0h3M5 20h14a2 2 0 002-2V6a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z" /></svg>,
        Check: () => <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" /></svg>,
        Shield: () => <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 9c0 5.591 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.042-.133-2.052-.382-3.016z" /></svg>,
        Refresh: () => <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" /></svg>,
        Play: () => <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z" /><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>,
        Folder: () => <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-6l-2-2H5a2 2 0 00-2 2z" /></svg>,
        File: () => <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" /></svg>,
        Trash: () => <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" /></svg>,
        Archive: () => <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 8h14M5 8a2 2 0 110-4h14a2 2 0 110 4M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8m-9 4h4" /></svg>,
        Eye: () => <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" /><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z" /></svg>,
        Download: () => <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" /></svg>,
        Plus: () => <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v16m8-8H4" /></svg>,
        Database: () => <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 7v10c0 2.21 3.582 4 8 4s8-1.79 8-4V7M4 7c0 2.21 3.582 4 8 4s8-1.79 8-4M4 7c0-2.21 3.582-4 8-4s8 1.79 8 4m0 5c0 2.21-3.582 4-8 4s-8-1.79-8-4" /></svg>,
        User: () => <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" /></svg>,
        AlertCircle: () => <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>,
        Edit: () => <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" /></svg>,
        Copy: () => <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" /></svg>,
        Search: () => <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" /></svg>,
    };
    
    // Helper to render app icons (handles both emojis and special logo identifiers)
    const AppIcon = ({ icon, size = 20 }) => {
        if (icon === 'gs-logo') {
            return <Icons.GameShelfLogo size={size} />;
        }
        // Return emoji as-is
        return <span style={{ fontSize: size * 0.9 }}>{icon}</span>;
    };
    
    // Helper for native <option> elements that can't render components
    const getAppEmoji = (icon) => {
        if (icon === 'gs-logo') return '🎮'; // Fallback emoji for Game Shelf
        return icon || '📦';
    };

    // =========================================================================
    // UTILITIES
    // =========================================================================
    
    function parseFilename(filename) {
        const patterns = [
            /^(gameshelf|game[-_]?shelf)[-_]v?(\d+)[_.](\d+)[_.](\d+)[_.](\d+)\.html$/i,
            /^(\w+)[-_]v?(\d+)[_.](\d+)[_.](\d+)\.html$/i,
        ];
        for (const pattern of patterns) {
            const match = filename.match(pattern);
            if (match) {
                let app = match[1].toLowerCase().replace(/[-_]/g, '');
                const version = match.length === 6 
                    ? `${match[2]}.${match[3]}.${match[4]}.${match[5]}`
                    : `${match[2]}.${match[3]}.${match[4]}`;
                return { app, version };
            }
        }
        const appMatch = filename.match(/^(\w+)/);
        return { app: appMatch ? appMatch[1].toLowerCase() : null, version: null };
    }
    
    // Detect app from HTML content
    // Primary: Explicit gs-app-id meta tag (definitive, permanent)
    // Fallback: Pattern matching for legacy files
    function detectAppFromContent(content) {
        if (!content || typeof content !== 'string') return null;
        
        // =====================================================================
        // PRIMARY: Check for explicit app identifier (100% reliable)
        // Format: <meta name="gs-app-id" content="appname">
        // =====================================================================
        const appIdMatch = content.match(/<meta\s+name=["']gs-app-id["']\s+content=["']([^"']+)["']/i);
        if (appIdMatch) {
            const appId = appIdMatch[1].toLowerCase();
            return {
                id: appId,
                confidence: 'definite',
                method: 'gs-app-id',
                matchCount: 1,
                matchedPatterns: ['gs-app-id meta tag']
            };
        }
        
        // =====================================================================
        // SECONDARY: Dynamic patterns from app config (user-configurable)
        // Scores all apps and picks the best (most matches) to avoid
        // broad patterns shadowing specific ones (e.g. "rungs" vs "rungs builder")
        // =====================================================================
        const allApps = window.__CC_APPS || {};
        const dynamicCandidates = [];
        
        for (const [appId, app] of Object.entries(allApps)) {
            const patterns = app.detectionPatterns || [];
            if (!patterns.length) continue;
            
            let matchCount = 0;
            let matchedPatterns = [];
            let totalPatternLength = 0;
            
            for (const pat of patterns) {
                try {
                    const regex = new RegExp(pat, 'i');
                    if (regex.test(content)) {
                        matchCount++;
                        matchedPatterns.push(pat);
                        totalPatternLength += pat.length;
                    }
                } catch (e) { /* skip invalid regex */ }
            }
            
            if (matchCount > 0) {
                dynamicCandidates.push({
                    id: appId,
                    confidence: matchCount >= 2 ? 'high' : 'medium',
                    method: 'dynamic-pattern',
                    matchCount,
                    matchedPatterns,
                    // Specificity score: prefer more matches, then longer patterns
                    specificity: matchCount * 1000 + totalPatternLength
                });
            }
        }
        
        if (dynamicCandidates.length > 0) {
            // Pick the most specific match
            dynamicCandidates.sort((a, b) => b.specificity - a.specificity);
            const best = dynamicCandidates[0];
            return {
                id: best.id,
                confidence: best.confidence,
                method: best.method,
                matchCount: best.matchCount,
                matchedPatterns: best.matchedPatterns
            };
        }
        
        // =====================================================================
        // FALLBACK: Hardcoded pattern matching for legacy files without gs-app-id
        // This can be removed once all apps have the meta tag
        // =====================================================================
        const sample = content.substring(0, 5000).toLowerCase();
        
        // Legacy signatures - ordered by specificity
        const signatures = [
            {
                id: 'command-center',
                patterns: [
                    /<title>.*command\s*center/i,
                    /<title>.*ship\s*it/i,
                    /command-center/i,
                    /claude.*deploy.*queue/i
                ]
            },
            {
                id: 'beta',
                patterns: [
                    /<title>game\s*shelf\s*beta\s*hub/i,
                    /beta\s*hub\s*v\d/i,
                    /gs-app-id.*beta/i,
                    /earlyAccess.*surveyResponses/i
                ]
            },
            {
                id: 'landing',
                patterns: [
                    /track\s*every\s*daily\s*puzzle/i,
                    /join\s*the\s*beta/i,
                    /cta-button/i,
                    /<h1[^>]*>GAME\s*SHELF<\/h1>/i
                ]
            },
            {
                id: 'gameshelf',
                patterns: [
                    /gameshelfdata/i,
                    /game\.shelf\.pwa/i,
                    /#setup-welcome/i,
                    /APP_VERSION\s*=/i
                ]
            },
            {
                id: 'testplan',
                patterns: [
                    /<title>.*test\s*plan/i,
                    /playwright.*runner/i,
                    /lean-tests\.spec/i
                ]
            },
            {
                id: 'quotle',
                patterns: [
                    /<title>quotle/i,
                    /quotle.*daily.*quote/i,
                    /quotes-database/i
                ]
            },
            {
                id: 'slate',
                patterns: [
                    /<title>slate/i,
                    /slate.*daily.*word/i,
                    /chalkboard-bg/i
                ]
            },
            {
                id: 'rungs',
                patterns: [
                    /<title>rungs/i,
                    /rungs.*daily/i,
                    /word-ladder/i
                ]
            },
            {
                id: 'wordboxing',
                patterns: [
                    /<title>word\s*boxing/i,
                    /word-boxing/i,
                    /boxing-ring/i
                ]
            },
            {
                id: 'edutrack',
                patterns: [
                    /<title>edutrack/i,
                    /edutrack-data/i,
                    /ET-[A-Z]{2}-\d{3}/,
                    /student-codes/i
                ]
            },
            {
                id: 'firebase-functions',
                patterns: [
                    /firebase-functions/i,
                    /exports\.getHint/i,
                    /onRequest|onCall/i,
                    /ANTHROPIC_API_KEY/i
                ]
            }
        ];
        
        // Check each app's signatures
        for (const app of signatures) {
            let matchCount = 0;
            let matchedPatterns = [];
            
            for (const pattern of app.patterns) {
                if (pattern.test(content)) {
                    matchCount++;
                    matchedPatterns.push(pattern.toString());
                }
            }
            
            if (matchCount > 0) {
                return {
                    id: app.id,
                    confidence: matchCount >= 2 ? 'high' : 'medium',
                    method: 'pattern-match',
                    matchCount,
                    matchedPatterns
                };
            }
        }
        
        return null;
    }
    
    function formatBytes(bytes) {
        if (bytes < 1024) return bytes + ' B';
        if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
        return (bytes / (1024 * 1024)).toFixed(2) + ' MB';
    }
    
    function formatDate(date) {
        return new Date(date).toLocaleString();
    }
    
    // Get the URL for a GitHub Pages site
    // Supports custom domains and subPaths for consolidated repos
    function getGitHubPagesUrl(repo, subPath = '') {
        if (!repo) return null;
        const [owner, repoName] = repo.split('/');
        
        // Check for custom domain
        if (CUSTOM_DOMAINS[repo]) {
            const domain = CUSTOM_DOMAINS[repo];
            // Custom domain - subPath goes after domain
            if (subPath) {
                return `https://${domain}/${subPath}/`;
            }
            return `https://${domain}/`;
        }
        
        // Standard GitHub Pages URL
        if (subPath) {
            return `https://${owner}.github.io/${repoName}/${subPath}/`;
        }
        return `https://${owner}.github.io/${repoName}/`;
    }
    
    // Helper to get effective subPath (falls back to defaults if stored value is empty)
    function getEffectiveSubPath(app, appId) {
        return app.subPath || '';
    }
    
    // Helper to get full file path in repo (prepends subPath if needed)
    function getRepoFilePath(app, filename) {
        if (app.subPath) {
            return `${app.subPath}/${filename}`;
        }
        return filename;
    }
    
    function autoMapRepos(apps, repos) {
        const updatedApps = { ...apps };
        console.log('Auto-mapping repos. Available:', repos.map(r => r.name));
        
        for (const [appId, app] of Object.entries(updatedApps)) {
            const patterns = app.repoPatterns;
            if (!patterns) continue;
            
            if (!app.testRepo && patterns.test) {
                for (const pattern of patterns.test) {
                    const found = repos.find(r => r.name.toLowerCase() === pattern.toLowerCase());
                    if (found) { 
                        console.log(`[${appId}] Mapped TEST: ${found.fullName}`);
                        updatedApps[appId] = { ...updatedApps[appId], testRepo: found.fullName }; 
                        break; 
                    }
                }
            }
            if (!app.prodRepo && patterns.prod) {
                for (const pattern of patterns.prod) {
                    const found = repos.find(r => r.name.toLowerCase() === pattern.toLowerCase() && !r.name.toLowerCase().includes('test'));
                    if (found) { 
                        console.log(`[${appId}] Mapped PROD: ${found.fullName}`);
                        updatedApps[appId] = { ...updatedApps[appId], prodRepo: found.fullName }; 
                        break; 
                    }
                }
            }
        }
        return updatedApps;
    }
    
    // v8.8.0: Group apps by project
    function getProjectsWithApps(apps, projects, filterFn = null) {
        const projectMap = {};
        const projectDefs = projects || SEED_PROJECTS;
        const appList = Object.values(apps).filter(a => (a.testRepo || a.prodRepo) && (!filterFn || filterFn(a)));
        
        for (const app of appList) {
            const projId = app.project || 'other';
            if (!projectMap[projId]) {
                const projDef = projectDefs[projId] || projectDefs['other'] || { id: projId, name: projId, icon: '📦', color: 'slate', order: 98 };
                projectMap[projId] = { ...projDef, id: projId, apps: [] };
            }
            projectMap[projId].apps.push(app);
        }
        
        // Sort projects by order, then apps within each project by name
        return Object.values(projectMap)
            .sort((a, b) => (a.order || 99) - (b.order || 99))
            .map(p => ({ ...p, apps: p.apps.sort((a, b) => a.name.localeCompare(b.name)) }));
    }
    
    // Project color classes
    const PROJECT_COLORS = {
        indigo: { bg: 'bg-indigo-600/15', border: 'border-indigo-500/30', text: 'text-indigo-400', accent: 'bg-indigo-600' },
        rose: { bg: 'bg-rose-600/15', border: 'border-rose-500/30', text: 'text-rose-400', accent: 'bg-rose-600' },
        emerald: { bg: 'bg-emerald-600/15', border: 'border-emerald-500/30', text: 'text-emerald-400', accent: 'bg-emerald-600' },
        amber: { bg: 'bg-amber-600/15', border: 'border-amber-500/30', text: 'text-amber-400', accent: 'bg-amber-600' },
        slate: { bg: 'bg-slate-600/15', border: 'border-slate-500/30', text: 'text-slate-400', accent: 'bg-slate-600' },
        cyan: { bg: 'bg-cyan-600/15', border: 'border-cyan-500/30', text: 'text-cyan-400', accent: 'bg-cyan-600' },
        purple: { bg: 'bg-purple-600/15', border: 'border-purple-500/30', text: 'text-purple-400', accent: 'bg-purple-600' }
    };
    
    function getProjectColor(color) {
        return PROJECT_COLORS[color] || PROJECT_COLORS.slate;
    }

    function getFileIcon(filename) {
        const ext = filename.split('.').pop()?.toLowerCase();
        const icons = {
            html: '📄', js: '📜', css: '🎨', json: '📋', md: '📝',
            png: '🖼️', jpg: '🖼️', jpeg: '🖼️', gif: '🖼️', svg: '🎨',
            ico: '🔷', txt: '📃', xml: '📰', yml: '⚙️', yaml: '⚙️'
        };
        return icons[ext] || '📄';
    }

    // =========================================================================
    // GITHUB API
    // =========================================================================
    
    class GitHubAPI {
        constructor(token) {
            this.token = token;
            this.baseUrl = 'https://api.github.com';
        }
        
        // Helper: Clean base64 content from GitHub (remove newlines)
        cleanBase64(content) {
            return content ? content.replace(/[\r\n\s]/g, '') : '';
        }
        
        // Helper: Decode base64 content from GitHub to UTF-8 string
        decodeContent(content) {
            const clean = this.cleanBase64(content);
            return decodeURIComponent(escape(atob(clean)));
        }
        
        async request(endpoint, options = {}) {
            const url = `${this.baseUrl}${endpoint}`;
            try {
                const response = await fetch(url, {
                    ...options,
                    headers: {
                        'Authorization': `token ${this.token}`,
                        'Accept': 'application/vnd.github.v3+json',
                        'Content-Type': 'application/json',
                        ...options.headers
                    }
                });
                
                // Track rate limit from response headers
                const remaining = response.headers.get('X-RateLimit-Remaining');
                const limit = response.headers.get('X-RateLimit-Limit');
                const resetTime = response.headers.get('X-RateLimit-Reset');
                
                if (remaining !== null) {
                    this.rateLimit = { remaining: parseInt(remaining), limit: parseInt(limit), resetTime: parseInt(resetTime) * 1000 };
                    if (parseInt(remaining) < 100) {
                        console.warn(`⚠️ GitHub API rate limit low: ${remaining}/${limit} remaining. Resets at ${new Date(this.rateLimit.resetTime).toLocaleTimeString()}`);
                    }
                }
                
                // Handle rate limit exceeded
                if (response.status === 403 && remaining === '0') {
                    const resetDate = new Date(parseInt(resetTime) * 1000);
                    throw new Error(`GitHub API rate limit exceeded. Resets at ${resetDate.toLocaleTimeString()}. Please wait and try again.`);
                }
                
                if (!response.ok) {
                    const error = await response.json().catch(() => ({}));
                    console.error('GitHub API Error:', {
                        url,
                        status: response.status,
                        error,
                        body: options.body ? JSON.parse(options.body) : null
                    });
                    throw new Error(error.message || `GitHub API error: ${response.status}`);
                }
                return response.json();
            } catch (e) {
                console.error('Request failed:', url, e);
                throw e;
            }
        }
        
        // Get current rate limit status
        getRateLimit() {
            return this.rateLimit || { remaining: null, limit: null, resetTime: null };
        }
        
        async listRepos() {
            const repos = await this.request('/user/repos?per_page=100&sort=updated');
            return repos.map(r => ({ fullName: r.full_name, name: r.name, owner: r.owner.login }));
        }
        
        async getFile(repo, path) {
            try {
                const [owner, repoName] = repo.split('/');
                // Add timestamp to bust GitHub API cache
                return await this.request(`/repos/${owner}/${repoName}/contents/${path}?_=${Date.now()}`);
            } catch { return null; }
        }
        
        // Get file content - handles large files (>1MB) that GitHub API doesn't return content for
        async getFileContent(repo, path) {
            try {
                const file = await this.getFile(repo, path);
                if (!file) return null;
                
                // For large files (>1MB), GitHub API doesn't return content - use download_url
                if (!file.content && file.download_url) {
                    console.log(`Large file detected (${path}), using download_url`);
                    // Add cache-busting to download_url
                    const cacheBustUrl = file.download_url + (file.download_url.includes('?') ? '&' : '?') + '_=' + Date.now();
                    const response = await fetch(cacheBustUrl);
                    const content = await response.text();
                    return { ...file, content: null, textContent: content };
                }
                
                // Normal file - decode base64 content
                const textContent = this.decodeContent(file.content);
                return { ...file, textContent };
            } catch (e) {
                console.warn(`Failed to get file content for ${path}:`, e);
                return null;
            }
        }
        
        // Get file content at specific commit - handles large files
        async getFileContentAtCommit(repo, path, commitSha) {
            try {
                const file = await this.getFileAtCommit(repo, path, commitSha);
                if (!file) return null;
                
                // For large files, use raw URL with commit ref
                if (!file.content && file.download_url) {
                    console.log(`Large file detected at commit (${path}), using download_url`);
                    const response = await fetch(file.download_url);
                    const content = await response.text();
                    return { ...file, content: null, textContent: content };
                }
                
                // Normal file - decode base64 content
                const textContent = this.decodeContent(file.content);
                return { ...file, textContent };
            } catch (e) {
                console.warn(`Failed to get file content at commit for ${path}:`, e);
                return null;
            }
        }
        
        async getFileAtCommit(repo, path, commitSha) {
            try {
                const [owner, repoName] = repo.split('/');
                return await this.request(`/repos/${owner}/${repoName}/contents/${path}?ref=${commitSha}`);
            } catch { return null; }
        }
        
        // Get blob content directly via Git Blob API - bypasses CDN caching
        async getBlobContent(repo, sha) {
            try {
                const [owner, repoName] = repo.split('/');
                const blob = await this.request(`/repos/${owner}/${repoName}/git/blobs/${sha}?_=${Date.now()}`);
                if (blob && blob.content) {
                    return {
                        content: blob.content,
                        encoding: blob.encoding,
                        size: blob.size
                    };
                }
                return null;
            } catch (e) {
                console.warn(`Failed to get blob ${sha}:`, e);
                return null;
            }
        }
        
        async listRepoContents(repo, path = '') {
            try {
                const [owner, repoName] = repo.split('/');
                const endpoint = path 
                    ? `/repos/${owner}/${repoName}/contents/${path}`
                    : `/repos/${owner}/${repoName}/contents`;
                // Add timestamp to bust any caching
                const cacheBuster = `?_=${Date.now()}`;
                const contents = await this.request(endpoint + cacheBuster);
                return Array.isArray(contents) ? contents : [contents];
            } catch { return []; }
        }
        
        // Get all files in a repo recursively
        async getRepoFiles(repo, path = '') {
            const allFiles = [];
            try {
                const contents = await this.listRepoContents(repo, path);
                for (const item of contents) {
                    if (item.type === 'file') {
                        allFiles.push({
                            type: 'file',
                            path: item.path,
                            sha: item.sha,
                            size: item.size
                        });
                    } else if (item.type === 'dir') {
                        // Recursively get files from subdirectories
                        const subFiles = await this.getRepoFiles(repo, item.path);
                        allFiles.push(...subFiles);
                    }
                }
            } catch (e) {
                console.log(`Error getting files at ${path}:`, e);
            }
            return allFiles;
        }
        
        async createOrUpdateFile(repo, path, content, message, sha = null, branch = 'main') {
            const [owner, repoName] = repo.split('/');
            const body = {
                message,
                content: btoa(unescape(encodeURIComponent(content))),
                committer: { name: 'Command Center', email: 'deploy@gameshelf.app' },
                branch
            };
            if (sha) body.sha = sha;
            
            const url = `/repos/${owner}/${repoName}/contents/${path}`;
            console.log('createOrUpdateFile request:', { 
                url,
                repo, 
                path, 
                sha, 
                branch,
                messageLength: message.length, 
                contentLength: content.length,
                base64Length: body.content.length
            });
            
            try {
                return await this.request(url, { method: 'PUT', body: JSON.stringify(body) });
            } catch (error) {
                console.error('createOrUpdateFile failed:', {
                    url,
                    error: error.message,
                    sha,
                    bodyPreview: JSON.stringify(body).substring(0, 200)
                });
                throw error;
            }
        }
        
        async deleteFile(repo, path, message, sha) {
            const [owner, repoName] = repo.split('/');
            return this.request(`/repos/${owner}/${repoName}/contents/${path}`, {
                method: 'DELETE',
                body: JSON.stringify({
                    message,
                    sha,
                    committer: { name: 'Command Center', email: 'deploy@gameshelf.app' }
                })
            });
        }
        
        async createTag(repo, tagName, sha, message) {
            const [owner, repoName] = repo.split('/');
            
            // Check if tag already exists
            try {
                await this.request(`/repos/${owner}/${repoName}/git/ref/tags/${tagName}`);
                console.log(`Tag ${tagName} already exists, skipping`);
                return { existing: true, tag: tagName };
            } catch {
                // Tag doesn't exist, create it
            }
            
            const tagObj = await this.request(`/repos/${owner}/${repoName}/git/tags`, {
                method: 'POST',
                body: JSON.stringify({
                    tag: tagName, message, object: sha, type: 'commit',
                    tagger: { name: 'Command Center', email: 'deploy@gameshelf.app', date: new Date().toISOString() }
                })
            });
            await this.request(`/repos/${owner}/${repoName}/git/refs`, {
                method: 'POST',
                body: JSON.stringify({ ref: `refs/tags/${tagName}`, sha: tagObj.sha })
            });
            return tagObj;
        }
        
        async enablePages(repo) {
            const [owner, repoName] = repo.split('/');
            try {
                await this.request(`/repos/${owner}/${repoName}/pages`);
                return { alreadyEnabled: true };
            } catch {}
            const response = await fetch(`${this.baseUrl}/repos/${owner}/${repoName}/pages`, {
                method: 'POST',
                headers: { 'Authorization': `token ${this.token}`, 'Accept': 'application/vnd.github.v3+json', 'Content-Type': 'application/json' },
                body: JSON.stringify({ source: { branch: 'main', path: '/' } })
            });
            if (!response.ok) throw new Error(`Failed to enable Pages`);
            return { enabled: true };
        }
        
        // v8.35.0: Custom domain configuration for GitHub Pages
        async updatePagesConfig(repo, cname, enforceHttps = false) {
            const [owner, repoName] = repo.split('/');
            const response = await fetch(`${this.baseUrl}/repos/${owner}/${repoName}/pages`, {
                method: 'PUT',
                headers: { 'Authorization': `token ${this.token}`, 'Accept': 'application/vnd.github.v3+json', 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    cname: cname,
                    https_enforced: enforceHttps,
                    source: { branch: 'main', path: '/' }
                })
            });
            if (!response.ok) {
                const err = await response.json().catch(() => ({}));
                throw new Error(err.message || `Failed to update Pages config (${response.status})`);
            }
            return await response.json();
        }
        
        // v8.35.0: Check GitHub Pages health/DNS status
        async checkPagesHealth(repo) {
            const [owner, repoName] = repo.split('/');
            const response = await fetch(`${this.baseUrl}/repos/${owner}/${repoName}/pages/health`, {
                headers: { 'Authorization': `token ${this.token}`, 'Accept': 'application/vnd.github.v3+json' }
            });
            // First call may return 202 (async check in progress)
            if (response.status === 202) return { pending: true };
            if (!response.ok) {
                const err = await response.json().catch(() => ({}));
                throw new Error(err.message || `Pages health check failed (${response.status})`);
            }
            return await response.json();
        }
        
        // Create a new repository
        async createRepo(name, description = '', isPrivate = false) {
            const response = await fetch(`${this.baseUrl}/user/repos`, {
                method: 'POST',
                headers: { 
                    'Authorization': `token ${this.token}`, 
                    'Accept': 'application/vnd.github.v3+json', 
                    'Content-Type': 'application/json' 
                },
                body: JSON.stringify({
                    name,
                    description,
                    private: isPrivate,
                    auto_init: true, // Creates with README so we have a main branch
                    has_issues: false,
                    has_projects: false,
                    has_wiki: false
                })
            });
            
            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.message || 'Failed to create repository');
            }
            
            const repo = await response.json();
            return {
                fullName: repo.full_name,
                name: repo.name,
                owner: repo.owner.login,
                url: repo.html_url,
                pagesUrl: `https://${repo.owner.login}.github.io/${repo.name}/`
            };
        }
        
        // Check if a repo exists
        async repoExists(owner, repoName) {
            try {
                await this.request(`/repos/${owner}/${repoName}`);
                return true;
            } catch {
                return false;
            }
        }
        
        // Delete a repository (requires delete_repo scope on token)
        async deleteRepo(fullName) {
            const [owner, repoName] = fullName.split('/');
            const response = await fetch(`${this.baseUrl}/repos/${owner}/${repoName}`, {
                method: 'DELETE',
                headers: { 
                    'Authorization': `token ${this.token}`, 
                    'Accept': 'application/vnd.github.v3+json' 
                }
            });
            
            if (!response.ok) {
                if (response.status === 403) {
                    throw new Error('Token lacks delete_repo permission. Generate a new token with delete_repo scope.');
                }
                throw new Error(`Failed to delete repository: ${response.status}`);
            }
            
            return { deleted: true, repo: fullName };
        }
        
        async getPagesDeploymentStatus(repo) {
            const [owner, repoName] = repo.split('/');
            try {
                // Get latest pages build
                const build = await this.request(`/repos/${owner}/${repoName}/pages/builds/latest`);
                return {
                    status: build.status, // 'queued', 'building', 'built', 'errored'
                    createdAt: build.created_at,
                    updatedAt: build.updated_at,
                    commitSha: build.commit,
                    duration: build.duration,
                    error: build.error?.message
                };
            } catch (e) {
                console.error('Failed to get pages status:', e);
                return null;
            }
        }
        
        async triggerPagesBuild(repo) {
            const [owner, repoName] = repo.split('/');
            try {
                await this.request(`/repos/${owner}/${repoName}/pages/builds`, {
                    method: 'POST'
                });
                return true;
            } catch (e) {
                console.error('Failed to trigger pages build:', e);
                return false;
            }
        }
        
        async waitForPagesDeployment(repo, commitSha, maxWaitMs = 120000, onStatus = null) {
            const startTime = Date.now();
            let lastStatus = null;
            
            while (Date.now() - startTime < maxWaitMs) {
                const status = await this.getPagesDeploymentStatus(repo);
                
                if (status && status.status !== lastStatus) {
                    lastStatus = status.status;
                    if (onStatus) onStatus(status);
                }
                
                if (status?.status === 'built') {
                    // Verify it's the right commit
                    if (!commitSha || status.commitSha === commitSha) {
                        return { success: true, status };
                    }
                }
                
                if (status?.status === 'errored') {
                    return { success: false, error: status.error, status };
                }
                
                // Wait 3 seconds before checking again
                await new Promise(r => setTimeout(r, 3000));
            }
            
            return { success: false, error: 'Timeout waiting for deployment', status: lastStatus };
        }
        
        // Get recent workflow runs for a repo
        async getWorkflowRuns(repo, options = {}) {
            const [owner, repoName] = repo.split('/');
            const params = new URLSearchParams();
            if (options.per_page) params.append('per_page', options.per_page);
            if (options.branch) params.append('branch', options.branch);
            if (options.event) params.append('event', options.event);
            if (options.status) params.append('status', options.status);
            
            const queryString = params.toString();
            const endpoint = `/repos/${owner}/${repoName}/actions/runs${queryString ? '?' + queryString : ''}`;
            
            try {
                const result = await this.request(endpoint);
                return result.workflow_runs || [];
            } catch (e) {
                console.error('Failed to get workflow runs:', e);
                return [];
            }
        }
        
        // Get a specific workflow run
        async getWorkflowRun(repo, runId) {
            const [owner, repoName] = repo.split('/');
            try {
                return await this.request(`/repos/${owner}/${repoName}/actions/runs/${runId}`);
            } catch (e) {
                console.error('Failed to get workflow run:', e);
                return null;
            }
        }
        
        // Get workflow run logs URL (returns URL, not content - logs require redirect)
        async getWorkflowRunLogsUrl(repo, runId) {
            const [owner, repoName] = repo.split('/');
            return `https://github.com/${owner}/${repoName}/actions/runs/${runId}`;
        }
        
        // Monitor a workflow run until completion
        async waitForWorkflowRun(repo, runId, maxWaitMs = 300000, onStatus = null) {
            const startTime = Date.now();
            let lastStatus = null;
            
            while (Date.now() - startTime < maxWaitMs) {
                const run = await this.getWorkflowRun(repo, runId);
                
                if (run && run.status !== lastStatus) {
                    lastStatus = run.status;
                    if (onStatus) onStatus(run);
                }
                
                // Terminal states
                if (run?.status === 'completed') {
                    return { 
                        success: run.conclusion === 'success',
                        conclusion: run.conclusion, // success, failure, cancelled, skipped
                        run,
                        logsUrl: await this.getWorkflowRunLogsUrl(repo, runId)
                    };
                }
                
                // Wait 5 seconds before checking again
                await new Promise(r => setTimeout(r, 5000));
            }
            
            return { 
                success: false, 
                error: 'Timeout waiting for workflow', 
                logsUrl: await this.getWorkflowRunLogsUrl(repo, runId)
            };
        }
        
        // Find a workflow run triggered after a specific time
        async findRecentWorkflowRun(repo, afterTime, maxWaitMs = 30000) {
            const startTime = Date.now();
            
            while (Date.now() - startTime < maxWaitMs) {
                const runs = await this.getWorkflowRuns(repo, { per_page: 5 });
                
                // Find a run that started after our commit
                const recentRun = runs.find(run => {
                    const runTime = new Date(run.created_at).getTime();
                    return runTime >= afterTime - 5000; // 5 second tolerance
                });
                
                if (recentRun) {
                    return recentRun;
                }
                
                // Wait 3 seconds before checking again
                await new Promise(r => setTimeout(r, 3000));
            }
            
            return null;
        }
        
        // Batch commit multiple files in one commit
        async batchCommit(repo, files, message) {
            const [owner, repoName] = repo.split('/');
            
            console.log('=== BATCH COMMIT START ===');
            console.log('Repo:', repo);
            console.log('Message:', message);
            console.log('Files to commit:', files.map(f => ({ path: f.path, contentLength: f.content?.length, encoding: f.encoding })));
            
            // Get current commit SHA
            const ref = await this.request(`/repos/${owner}/${repoName}/git/ref/heads/main`);
            const commitSha = ref.object.sha;
            console.log('Current commit SHA:', commitSha);
            
            // Get current tree
            const commit = await this.request(`/repos/${owner}/${repoName}/git/commits/${commitSha}`);
            const treeSha = commit.tree.sha;
            console.log('Current tree SHA:', treeSha);
            
            // Create blobs for each file
            const treeItems = await Promise.all(files.map(async (file) => {
                console.log('Creating blob for:', file.path);
                const blob = await this.request(`/repos/${owner}/${repoName}/git/blobs`, {
                    method: 'POST',
                    body: JSON.stringify({
                        content: file.content,
                        encoding: file.encoding || 'utf-8'
                    })
                });
                console.log('Blob created:', file.path, '-> SHA:', blob.sha);
                return {
                    path: file.path,
                    mode: '100644',
                    type: 'blob',
                    sha: blob.sha
                };
            }));
            
            console.log('Tree items:', treeItems);
            
            // Create new tree
            const treePayload = {
                base_tree: treeSha,
                tree: treeItems
            };
            console.log('Creating tree with payload:', JSON.stringify(treePayload, null, 2));
            
            const newTree = await this.request(`/repos/${owner}/${repoName}/git/trees`, {
                method: 'POST',
                body: JSON.stringify(treePayload)
            });
            console.log('New tree SHA:', newTree.sha);
            
            // Create commit
            const newCommit = await this.request(`/repos/${owner}/${repoName}/git/commits`, {
                method: 'POST',
                body: JSON.stringify({
                    message,
                    tree: newTree.sha,
                    parents: [commitSha],
                    committer: { name: 'Command Center', email: 'deploy@gameshelf.app' }
                })
            });
            console.log('New commit SHA:', newCommit.sha);
            
            // Update ref (force: true handles non-fast-forward cases)
            const updatedRef = await this.request(`/repos/${owner}/${repoName}/git/refs/heads/main`, {
                method: 'PATCH',
                body: JSON.stringify({ sha: newCommit.sha, force: true })
            });
            console.log('Ref updated:', updatedRef);
            console.log('=== BATCH COMMIT COMPLETE ===');
            
            return newCommit;
        }
    }

    // =========================================================================
    // MAIN APP
    // =========================================================================
    
    function App() {
        const [view, setView] = React.useState('dashboard');
        const [cleanupInitialTab, setCleanupInitialTab] = React.useState(null);
        const [pendingGsActiveFile, setPendingGsActiveFile] = React.useState(null); // For passing gs-active zip to Smart Deploy
        const [githubToken, setGithubToken] = React.useState(() => {
            try { return localStorage.getItem('cc_token') || ''; } catch { return ''; }
        });
        
        // Token expiration tracking (v8.3.3)
        const tokenExpires = React.useMemo(() => {
            try { return localStorage.getItem('cc_token_expires') || ''; } catch { return ''; }
        }, [githubToken]);
        const daysUntilExpiry = tokenExpires ? Math.ceil((new Date(tokenExpires) - new Date()) / (1000 * 60 * 60 * 24)) : null;
        const tokenExpiryWarning = githubToken && daysUntilExpiry !== null && daysUntilExpiry <= 14;
        
        // v8.3.3: File protocol detection for local file warning
        const isFileProtocol = window.location.protocol === 'file:';
        const [fileProtocolBannerDismissed, setFileProtocolBannerDismissed] = React.useState(() => {
            try { return sessionStorage.getItem('cc_file_banner_dismissed') === 'true'; } catch { return false; }
        });
        const dismissFileProtocolBanner = () => {
            setFileProtocolBannerDismissed(true);
            try { sessionStorage.setItem('cc_file_banner_dismissed', 'true'); } catch {}
        };
        
        // Dynamic configuration (v7.0.0)
        const [config, setConfig] = React.useState(() => {
            return ConfigManager.load();
        });
        
        // v8.17.0: Firebase config sync status
        const [syncStatus, setSyncStatus] = React.useState(() => 
            FirebaseConfigSync.initialized ? 'syncing' : 'offline'
        );
        const [syncInitialized, setSyncInitialized] = React.useState(false);
        
        // Apps derived from config (legacy compatibility + v7 format)
        const [apps, setApps] = React.useState(() => {
            try { 
                const s = localStorage.getItem('cc_apps_v6'); 
                const oldApps = s ? JSON.parse(s) : null;
                if (oldApps) {
                    // Migrate old format to config
                    const cfg = ConfigManager.load();
                    const migrated = ConfigManager.migrateFromOldFormat(oldApps, cfg);
                    ConfigManager.save(migrated);
                    return ConfigManager.toLegacyAppsFormat(migrated);
                }
                return ConfigManager.toLegacyAppsFormat(ConfigManager.load()); 
            } catch { 
                return ConfigManager.toLegacyAppsFormat(ConfigManager.load()); 
            }
        });
        const [stagedFiles, setStagedFiles] = React.useState([]);
        const [deployments, setDeployments] = React.useState(() => DeployService.load());
        const [activeDeployments, setActiveDeployments] = React.useState([]);
        const [availableRepos, setAvailableRepos] = React.useState([]);
        const [repoHealthAlert, setRepoHealthAlert] = React.useState(null); // { issues: [{app, repo, target, unexpectedFiles}] }
        
        // Helper functions for managing multiple deployments
        const addActiveDeployment = (deployment) => {
            setActiveDeployments(prev => [deployment, ...prev]);
        };
        
        const updateActiveDeployment = (deploymentId, updates) => {
            setActiveDeployments(prev => prev.map(d => 
                d.id === deploymentId ? { ...d, ...updates } : d
            ));
        };
        
        const removeActiveDeployment = (deploymentId) => {
            setActiveDeployments(prev => prev.filter(d => d.id !== deploymentId));
        };
        
        // Track deployments that need auto-close
        const pendingAutoClose = React.useRef(new Set());
        
        // Auto-close successful deployments after delay
        // v8.5.0: Fixed - check both step status AND ensure deployment is truly done
        React.useEffect(() => {
            activeDeployments.forEach(deployment => {
                // Check if deployment is truly complete:
                // 1. Status is 'success' or 'error' or 'failed'
                // 2. No steps are still 'running'
                // 3. All steps are either 'complete', 'error', or 'warning'
                const hasRunningSteps = deployment.steps?.some(s => s.status === 'running');
                const allStepsDone = deployment.steps?.every(s => 
                    s.status === 'complete' || s.status === 'error' || s.status === 'warning'
                );
                const deploymentDone = deployment.status === 'success' || deployment.status === 'error' || deployment.status === 'failed';
                const isFullyComplete = deploymentDone && !hasRunningSteps && (allStepsDone || !deployment.steps?.length);
                
                console.log(`[AutoClose] ${deployment.id}: status=${deployment.status}, hasRunning=${hasRunningSteps}, allDone=${allStepsDone}, fullyComplete=${isFullyComplete}`);
                
                if (isFullyComplete && !pendingAutoClose.current.has(deployment.id)) {
                    console.log(`[AutoClose] Scheduling auto-close for ${deployment.id} in 4s`);
                    pendingAutoClose.current.add(deployment.id);
                    setTimeout(() => {
                        console.log(`[AutoClose] Removing ${deployment.id}`);
                        setActiveDeployments(prev => prev.filter(d => d.id !== deployment.id));
                        pendingAutoClose.current.delete(deployment.id);
                    }, 4000);
                }
            });
        }, [activeDeployments]);
        
        // Compatibility: Create setActiveDeployment that updates/adds to array
        // This allows existing code to work while supporting multiple deployments
        const setActiveDeployment = (deploymentOrNull) => {
            if (deploymentOrNull === null) {
                // Clear all (legacy behavior - now we auto-close instead)
                return;
            }
            
            setActiveDeployments(prev => {
                const existing = prev.find(d => d.id === deploymentOrNull.id);
                if (existing) {
                    // Update existing
                    return prev.map(d => d.id === deploymentOrNull.id ? deploymentOrNull : d);
                } else {
                    // Add new
                    return [deploymentOrNull, ...prev];
                }
            });
        };
        
        // Get most recent active deployment (for legacy code that expects single)
        const activeDeployment = activeDeployments[0] || null;
        const [modal, setModal] = React.useState(null);
        const [dialog, setDialog] = React.useState(null); // { type: 'alert'|'confirm'|'prompt', title, message, defaultValue, onConfirm, onCancel }
        const [settings, setSettings] = React.useState({ createTag: true, updateServiceWorker: true });
        
        // Config change handler
        const handleConfigChange = (newConfig) => {
            setConfig(newConfig);
            setApps(ConfigManager.toLegacyAppsFormat(newConfig));
            ConfigManager.save(newConfig);
        };
        
        // Expose apps to detection function (detectAppFromContent runs outside React)
        React.useEffect(() => { window.__CC_APPS = apps; }, [apps]);
        
        // Get active environments from config
        const activeEnvironments = config.environments.active;
        const getEnvColors = (env) => config.environments.colors[env] || config.environments.colors.test;
        const getEnvLabel = (env) => config.environments.labels[env] || env.toUpperCase();
        
        // Dialog helper functions (Promise-based for async usage)
        const showAlert = (message, title) => {
            return new Promise((resolve) => {
                setDialog({ type: 'alert', title, message, onConfirm: resolve });
            });
        };
        
        const showConfirm = (message, title) => {
            return new Promise((resolve) => {
                setDialog({ 
                    type: 'confirm', 
                    title, 
                    message, 
                    onConfirm: () => resolve(true),
                    onCancel: () => resolve(false)
                });
            });
        };
        
        const showPrompt = (message, defaultValue, title) => {
            return new Promise((resolve) => {
                setDialog({ 
                    type: 'prompt', 
                    title, 
                    message, 
                    defaultValue,
                    onConfirm: (value) => resolve(value),
                    onCancel: () => resolve(null)
                });
            });
        };
        const [refreshing, setRefreshing] = React.useState(false);
        
        // Rollback snapshots - stores last known good version for each app/repo/target
        // Format: { "appId:target": { content, version, savedAt, repo } }
        const [rollbackSnapshots, setRollbackSnapshots] = React.useState(() => RollbackService.load());
        
        React.useEffect(() => { RollbackService.save(rollbackSnapshots); }, [rollbackSnapshots]);
        
        // Save snapshot before deploy (call this before pushing new content)
        const saveRollbackSnapshot = async (appId, target, repo, targetPath) => {
            if (!github) return null;
            
            try {
                const fileData = await github.getFileContent(repo, targetPath);
                if (!fileData) return null;
                
                // Use textContent which handles both normal and large files
                const content = fileData.textContent;
                const version = extractVersionFromHTML(content);
                
                const key = `${appId}:${target}`;
                const snapshot = {
                    content,
                    version,
                    savedAt: new Date().toISOString(),
                    repo,
                    targetPath,
                    sha: fileData.sha
                };
                
                setRollbackSnapshots(prev => ({ ...prev, [key]: snapshot }));
                console.log(`📸 Saved rollback snapshot for ${appId} ${target}: v${version}`);
                return snapshot;
            } catch (err) {
                console.error('Failed to save rollback snapshot:', err);
                return null;
            }
        };
        
        // Quick rollback using saved snapshot
        const quickRollback = async (appId, target) => {
            const key = `${appId}:${target}`;
            const snapshot = rollbackSnapshots[key];
            
            if (!snapshot) {
                await showAlert('No rollback snapshot available for this app/environment.', 'Rollback Not Available');
                return;
            }
            
            const app = apps[appId];
            // Ensure subPath is set from defaults (localStorage may have empty string from old config)
            const effectiveSubPath = app.subPath || '';
            
            const confirmed = await showConfirm(
                `Roll back ${app.name} ${target.toUpperCase()} to v${snapshot.version || 'unknown'}?\n\nSaved: ${new Date(snapshot.savedAt).toLocaleString()}`,
                '⏪ Quick Rollback'
            );
            
            if (!confirmed) return;
            
            const deployment = {
                id: Date.now(), status: 'running', steps: [],
                appId, appName: app.name, repo: snapshot.repo, target,
                isRollback: true, isQuickRollback: true,
                version: snapshot.version,
                startedAt: new Date().toISOString()
            };
            
            setActiveDeployment(deployment);
            setDeployments(prev => [deployment, ...prev]);
            
            const addStep = (name, status, details = null) => {
                const idx = deployment.steps.findIndex(s => s.name === name);
                if (idx >= 0) deployment.steps[idx] = { name, status, details };
                else deployment.steps.push({ name, status, details });
                setActiveDeployment({ ...deployment });
            };
            
            try {
                addStep('Preparing rollback', 'running');
                const currentFileData = await github.getFileContent(snapshot.repo, snapshot.targetPath);
                // Use textContent which handles both normal and large files
                const currentVersion = currentFileData ? extractVersionFromHTML(currentFileData.textContent) : null;
                deployment.previousVersion = currentVersion;
                addStep('Preparing rollback', 'complete', `${formatVersion(currentVersion)} → ${formatVersion(snapshot.version)}`);
                
                addStep('Restoring snapshot', 'running');
                const result = await github.createOrUpdateFile(
                    snapshot.repo, snapshot.targetPath, snapshot.content,
                    `Quick rollback ${app.name} to v${snapshot.version} (was v${currentVersion})`,
                    currentFileData?.sha
                );
                deployment.commitSha = result.commit.sha;
                addStep('Restoring snapshot', 'complete', result.commit.sha.substring(0, 7));
                
                deployment.status = 'success';
                deployment.url = getGitHubPagesUrl(snapshot.repo, effectiveSubPath);
                
                const versionKey = target === 'prod' ? 'currentProdVersion' : 'currentTestVersion';
                updateApp(appId, { [versionKey]: snapshot.version });
                
                // Monitor deployment
                if (deployment.url && snapshot.version) {
                    addStep('GitHub Pages', 'running', 'Waiting for deploy...');
                    monitorLiveDeployment(deployment.url, snapshot.version, snapshot.repo, (status, detail) => {
                        addStep('GitHub Pages', status, detail);
                        setActiveDeployment({ ...deployment });
                        setDeployments(prev => prev.map(d => d.id === deployment.id ? { ...deployment } : d));
                    }, appId, target);
                }
                
            } catch (err) {
                console.error('Quick rollback failed:', err);
                addStep('Rollback Failed', 'error', err.message);
                deployment.status = 'error';
            }
            
            setActiveDeployment({ ...deployment });
            setDeployments(prev => prev.map(d => d.id === deployment.id ? { ...deployment } : d));
        };
        
        // Clear rollback snapshot (after successful deploy verification)
        const clearRollbackSnapshot = (appId, target) => {
            const key = `${appId}:${target}`;
            setRollbackSnapshots(prev => {
                const next = { ...prev };
                delete next[key];
                return next;
            });
        };
        const [repoFiles, setRepoFiles] = React.useState({}); // { repoFullName: { files: [], loading: bool } }
        const [selectedRepoForBrowse, setSelectedRepoForBrowse] = React.useState(null);
        const [selectedAppKeyForBrowse, setSelectedAppKeyForBrowse] = React.useState(null);
        const [markedForDeletion, setMarkedForDeletion] = React.useState([]); // [{ repo, path, sha }]
        const [deployingRepos, setDeployingRepos] = React.useState({}); // { appId: { version, startTime, repo } }
        
        // Session log state (persisted to localStorage)
        const [sessionLog, setSessionLog] = React.useState(() => SessionLogService.load());
        
        // Global issues state (synced with Firebase)
        const [globalIssues, setGlobalIssues] = React.useState([]);
        const [globalWorkItems, setGlobalWorkItems] = React.useState([]);
        const [globalSessions, setGlobalSessions] = React.useState([]);
        const [globalActivity, setGlobalActivity] = React.useState([]); // Phase 3.4: Activity log
        const [globalStreams, setGlobalStreams] = React.useState([]); // Phase 5.2: Work streams
        const [globalInterfaces, setGlobalInterfaces] = React.useState([]); // Phase 5.4: Stream interfaces
        const [globalDependencies, setGlobalDependencies] = React.useState([]); // Phase 5.4: Dependencies
        const [globalDependencyAlerts, setGlobalDependencyAlerts] = React.useState([]); // Phase 5.4: Dependency alerts
        const [firebaseUid, setFirebaseUid] = React.useState(null);
        const [firebaseUser, setFirebaseUser] = React.useState(null);
        
        // Listen for Firebase auth and load issues
        React.useEffect(() => {
            if (!firebaseAuth) return;
            
            let unsubscribeIssues = () => {};
            let unsubscribeWorkItems = () => {};
            let unsubscribeSessions = () => {};
            let unsubscribeActivity = () => {};
            let unsubscribeStreams = () => {};
            let unsubscribeInterfaces = () => {};
            let unsubscribeDependencies = () => {};
            let unsubscribeDependencyAlerts = () => {};
            
            const unsubscribe = firebaseAuth.onAuthStateChanged((u) => {
                setFirebaseUser(u);
                if (u) {
                    setFirebaseUid(u.uid);
                    // Listen for issues changes via IssueService
                    unsubscribeIssues = IssueService.listen(u.uid, setGlobalIssues);
                    // Listen for work items via WorkItemService (v8.22.0)
                    unsubscribeWorkItems = WorkItemService.listen(u.uid, setGlobalWorkItems);
                    // Listen for sessions via SessionService (v8.27.0)
                    unsubscribeSessions = SessionService.listen(u.uid, setGlobalSessions);
                    // Listen for activity via ActivityLogService (v8.39.0 — Phase 3.4)
                    unsubscribeActivity = ActivityLogService.listen(u.uid, setGlobalActivity);
                    // Listen for streams via WorkStreamService (v8.43.0 — Phase 5.2)
                    unsubscribeStreams = WorkStreamService.listen(u.uid, setGlobalStreams);
                    // Listen for interfaces via StreamInterfaceService (v8.43.0 — Phase 5.4)
                    unsubscribeInterfaces = StreamInterfaceService.listen(u.uid, setGlobalInterfaces);
                    // Listen for dependencies via DependencyService (v8.43.0 — Phase 5.4)
                    unsubscribeDependencies = DependencyService.listen(u.uid, setGlobalDependencies);
                    // Listen for dependency alerts via DependencyAlertService (v8.44.0 — Phase 5.4)
                    unsubscribeDependencyAlerts = DependencyAlertService.listen(u.uid, setGlobalDependencyAlerts);
                } else {
                    setFirebaseUid(null);
                    setGlobalIssues([]);
                    setGlobalWorkItems([]);
                    setGlobalSessions([]);
                    setGlobalActivity([]);
                    setGlobalStreams([]);
                    setGlobalInterfaces([]);
                    setGlobalDependencies([]);
                }
            });
            
            return () => {
                unsubscribe();
                unsubscribeIssues();
                unsubscribeWorkItems();
                unsubscribeSessions();
                unsubscribeActivity();
                unsubscribeStreams();
                unsubscribeInterfaces();
                unsubscribeDependencies();
                unsubscribeDependencyAlerts();
            };
        }, []);
        
        // Link issues to a deployed version
        const linkIssuesToVersion = async (issueIds, version, appId) => {
            if (!firebaseUid || !issueIds.length) return;
            await IssueService.linkToVersion(firebaseUid, issueIds, version, appId);
        };
        
        // Use ref to always have latest apps state for async operations
        const appsRef = React.useRef(apps);
        React.useEffect(() => { appsRef.current = apps; }, [apps]);
        
        const github = React.useMemo(() => githubToken ? new GitHubAPI(githubToken) : null, [githubToken]);
        
        // Persist
        React.useEffect(() => { try { if (githubToken) localStorage.setItem('cc_token', githubToken); } catch {} }, [githubToken]);
        React.useEffect(() => { try { StorageManager.safeSet('cc_apps_v6', JSON.stringify(apps)); } catch {} }, [apps]);
        React.useEffect(() => { DeployService.save(deployments); }, [deployments]);
        React.useEffect(() => { SessionLogService.save(sessionLog); }, [sessionLog]);
        
        // v8.17.0: Firebase Config Sync — startup overlay
        // Load localStorage first (instant), then pull from Firebase and overlay if newer.
        // On first run (Firebase empty), push local data up to seed Firebase.
        React.useEffect(() => {
            if (!FirebaseConfigSync.initialized || syncInitialized) return;
            
            const unsubscribe = FirebaseConfigSync.onStatusChange(setSyncStatus);
            
            const doSync = async () => {
                console.log('[ConfigSync] Starting startup overlay...');
                const remote = await FirebaseConfigSync.pullAll();
                
                if (!remote) {
                    // Firebase unreachable — stay with localStorage
                    console.log('[ConfigSync] Firebase unreachable, running offline');
                    setSyncInitialized(true);
                    return;
                }
                
                if (remote.config && remote.config._updatedAt) {
                    // Firebase has data — overlay onto local
                    // v8.18.3: Always overlay in Phase 1 (single user). Timestamp comparison
                    // was causing issues where migration bumped local timestamp, blocking overlay.
                    console.log('[ConfigSync] Firebase has config, overlaying...');
                    // Strip sync metadata before merging
                    const { _updatedAt, _updatedBy, ...cleanConfig } = remote.config;
                    const merged = ConfigManager.mergeWithDefaults(cleanConfig);
                        merged._updatedAt = _updatedAt;
                        merged._updatedBy = _updatedBy;
                        
                        // v8.18.5: Merge local apps INTO Firebase overlay — local is authoritative
                        // Preserve: local-only apps, local repos, local projects, local versions
                        const localCfg = ConfigManager.load();
                        let reposPreserved = 0;
                        let appsPreserved = 0;
                        if (localCfg.apps) {
                            if (!merged.apps) merged.apps = {};
                            for (const [id, localApp] of Object.entries(localCfg.apps)) {
                                if (!merged.apps[id]) {
                                    // App exists locally but not in Firebase — preserve it
                                    merged.apps[id] = { ...localApp };
                                    appsPreserved++;
                                } else {
                                    // App exists in both — preserve local repos (authoritative)
                                    if (localApp.repos) {
                                        if (!merged.apps[id].repos) merged.apps[id].repos = {};
                                        if (localApp.repos.test && localApp.repos.test !== merged.apps[id].repos.test) {
                                            merged.apps[id].repos.test = localApp.repos.test;
                                            reposPreserved++;
                                        }
                                        if (localApp.repos.prod && localApp.repos.prod !== merged.apps[id].repos.prod) {
                                            merged.apps[id].repos.prod = localApp.repos.prod;
                                            reposPreserved++;
                                        }
                                    }
                                    // Preserve local versions if Firebase has empty ones
                                    if (localApp.versions) {
                                        if (!merged.apps[id].versions) merged.apps[id].versions = {};
                                        for (const [env, ver] of Object.entries(localApp.versions)) {
                                            if (ver && !merged.apps[id].versions[env]) {
                                                merged.apps[id].versions[env] = ver;
                                            }
                                        }
                                    }
                                }
                            }
                            if (appsPreserved > 0) console.log(`[ConfigSync] Preserved ${appsPreserved} local-only apps during overlay`);
                            if (reposPreserved > 0) console.log(`[ConfigSync] Preserved ${reposPreserved} local repo assignments during overlay`);
                        }
                        
                        // Also preserve local-only projects
                        if (localCfg.projects && merged.projects) {
                            for (const [id, proj] of Object.entries(localCfg.projects)) {
                                if (!merged.projects[id]) {
                                    merged.projects[id] = { ...proj };
                                }
                            }
                        }
                        
                        // Save to localStorage (without re-pushing to Firebase)
                        try { localStorage.setItem(ConfigManager.STORAGE_KEY, JSON.stringify(merged)); } catch {}
                        
                        setConfig(merged);
                        setApps(ConfigManager.toLegacyAppsFormat(merged));
                        
                        // Push merged config back if we preserved local data
                        if (reposPreserved > 0 || appsPreserved > 0) {
                            FirebaseConfigSync.pushConfig(merged).catch(() => {});
                        }
                    
                    // Overlay deploy history if Firebase is newer
                    if (remote.deployHistory && Array.isArray(remote.deployHistory) && remote.deployHistory.length > 0) {
                        const remoteTs = remote.deployHistory._updatedAt || 0;
                        setDeployments(prev => {
                            if (remoteTs > 0 || remote.deployHistory.length > prev.length) {
                                DeployService.overlay(remote.deployHistory);
                                return Array.isArray(remote.deployHistory) ? remote.deployHistory : prev;
                            }
                            return prev;
                        });
                    }
                    
                    // Overlay session log if Firebase has data
                    if (remote.sessionLog && remote.sessionLog._updatedAt) {
                        const overlaid = SessionLogService.overlay(remote.sessionLog);
                        if (overlaid) {
                            setSessionLog(overlaid);
                        }
                    }
                    
                    console.log('[ConfigSync] Startup overlay complete');
                } else {
                    // Firebase is empty — first run, seed it with local data
                    console.log('[ConfigSync] Firebase empty, seeding with local data...');
                    const localConfig = ConfigManager.load();
                    const localDeployments = DeployService.load();
                    const localRulesHistory = (() => { try { return JSON.parse(localStorage.getItem('cc_rulesHistory') || '[]'); } catch { return []; } })();
                    const localSessionLog = SessionLogService.load();
                    const localDeletionHistory = (() => { try { return JSON.parse(localStorage.getItem('cc_deletion_history') || '[]'); } catch { return []; } })();
                    const localRollbackSnapshots = RollbackService.load();
                    
                    await FirebaseConfigSync.pushAll({
                        config: localConfig,
                        deployHistory: localDeployments,
                        rulesHistory: localRulesHistory,
                        sessionLog: localSessionLog,
                        deletionHistory: localDeletionHistory,
                        rollbackSnapshots: localRollbackSnapshots
                    });
                    
                    console.log('[ConfigSync] Initial seed complete');
                }
                
                setSyncInitialized(true);
            };
            
            doSync();
            
            return () => unsubscribe();
        }, [syncInitialized]);
        
        // v8.18.0: Force sync handler for Settings UI
        const handleForceSync = async (direction) => {
            if (!FirebaseConfigSync.initialized) return;
            
            if (direction === 'pull') {
                const remote = await FirebaseConfigSync.pullAll();
                if (!remote) throw new Error('Firebase unreachable');
                
                if (remote.config && remote.config._updatedAt) {
                    const { _updatedAt, _updatedBy, ...cleanConfig } = remote.config;
                    const merged = ConfigManager.mergeWithDefaults(cleanConfig);
                    merged._updatedAt = _updatedAt;
                    merged._updatedBy = _updatedBy;
                    try { localStorage.setItem(ConfigManager.STORAGE_KEY, JSON.stringify(merged)); } catch {}
                    setConfig(merged);
                    setApps(ConfigManager.toLegacyAppsFormat(merged));
                }
                
                if (remote.deployHistory && Array.isArray(remote.deployHistory) && remote.deployHistory.length > 0) {
                    DeployService.overlay(remote.deployHistory);
                    setDeployments(Array.isArray(remote.deployHistory) ? remote.deployHistory : []);
                }
                
                if (remote.sessionLog && remote.sessionLog._updatedAt) {
                    const overlaid = SessionLogService.overlay(remote.sessionLog);
                    if (overlaid) setSessionLog(overlaid);
                }
            }
        };
        
        // Monitor live site until new version appears
        const monitorLiveDeployment = async (url, expectedVersion, repo, onUpdate, appId = null, target = 'prod') => {
            const maxWaitMs = 180000; // 3 minutes max
            const pollInterval = 5000; // Check every 5 seconds
            const startTime = Date.now();
            let attempts = 0;
            let corsFailures = 0;
            const maxCorsFailures = 3; // Give up after 3 CORS errors
            
            // Key for deployingRepos - use appId:target if provided, otherwise fall back to repo
            const deployKey = appId ? `${appId}:${target}` : repo;
            
            console.log(`=== MONITORING LIVE DEPLOYMENT ===`);
            console.log(`URL: ${url}`);
            console.log(`Repo: ${repo}`);
            console.log(`Expected version: ${expectedVersion}`);
            console.log(`Deploy key: ${deployKey}`);
            
            // Mark app as deploying
            setDeployingRepos(prev => ({ ...prev, [deployKey]: { version: expectedVersion, startTime, repo } }));
            
            while (Date.now() - startTime < maxWaitMs) {
                attempts++;
                const elapsed = Math.round((Date.now() - startTime) / 1000);
                
                try {
                    // Fetch the live site with cache-busting
                    // Don't set custom headers - they trigger CORS preflight which GitHub Pages doesn't support
                    const response = await fetch(`${url}?_t=${Date.now()}`, {
                        cache: 'no-store'
                    });
                    
                    if (response.ok) {
                        const html = await response.text();
                        const liveVersion = extractVersionFromHTML(html);
                        
                        console.log(`[${elapsed}s] Live version: ${liveVersion || 'unknown'}, expecting: ${expectedVersion}`);
                        corsFailures = 0; // Reset on success
                        
                        if (liveVersion === expectedVersion) {
                            console.log(`=== DEPLOYMENT COMPLETE! Version ${liveVersion} is live ===`);
                            onUpdate('complete', `v${liveVersion} is LIVE! (${elapsed}s)`);
                            
                            // v8.3.3: Ensure indicator shows for at least 2 seconds
                            const minDisplayMs = 2000;
                            const elapsedMs = Date.now() - startTime;
                            const remainingMs = Math.max(0, minDisplayMs - elapsedMs);
                            
                            // Clear deploying state after minimum display time
                            setTimeout(() => {
                                setDeployingRepos(prev => {
                                    const next = { ...prev };
                                    delete next[deployKey];
                                    return next;
                                });
                            }, remainingMs);
                            
                            return { success: true, duration: elapsed };
                        } else {
                            onUpdate('running', `Waiting... ${elapsed}s (live: ${liveVersion || '?'})`);
                        }
                    } else {
                        onUpdate('running', `Waiting... ${elapsed}s (site loading)`);
                    }
                } catch (e) {
                    corsFailures++;
                    console.log(`[${elapsed}s] Fetch error (${corsFailures}/${maxCorsFailures}):`, e.message);
                    
                    // If we keep getting CORS/network errors, stop monitoring
                    if (corsFailures >= maxCorsFailures) {
                        console.log(`=== CORS/NETWORK ERRORS - STOPPING MONITOR ===`);
                        onUpdate('complete', `Commit pushed ✓ (verify at site)`);
                        setDeployingRepos(prev => {
                            const next = { ...prev };
                            delete next[deployKey];
                            return next;
                        });
                        return { success: true, corsBlocked: true };
                    }
                    
                    onUpdate('running', `Waiting... ${elapsed}s`);
                }
                
                await new Promise(r => setTimeout(r, pollInterval));
            }
            
            console.log(`=== DEPLOYMENT MONITORING TIMEOUT ===`);
            onUpdate('warning', `Timeout - check manually`);
            // Clear deploying state on timeout
            setDeployingRepos(prev => {
                const next = { ...prev };
                delete next[deployKey];
                return next;
            });
            return { success: false, timeout: true };
        };
        
        // Refresh repos list
        const refreshRepos = async () => {
            if (!github) return;
            try {
                const repos = await github.listRepos();
                setAvailableRepos(repos);
                // Re-run auto-mapping
                setApps(prev => autoMapRepos(prev, repos));
            } catch (e) {
                console.error('Failed to refresh repos:', e);
            }
        };
        
        // Fetch repos and auto-refresh versions on load
        React.useEffect(() => {
            if (github) {
                github.listRepos().then(async (repos) => {
                    setAvailableRepos(repos);
                    
                    // Get current apps state and map repos
                    setApps(prev => {
                        const mapped = autoMapRepos(prev, repos);
                        
                        // v8.18.1: Sync auto-detected repos back to config so Firebase gets them
                        setConfig(prevConfig => {
                            let changed = false;
                            const updatedConfig = { ...prevConfig, apps: { ...prevConfig.apps } };
                            for (const [id, app] of Object.entries(mapped)) {
                                if (updatedConfig.apps[id]) {
                                    const configApp = updatedConfig.apps[id];
                                    if (app.testRepo && configApp.repos?.test !== app.testRepo) {
                                        updatedConfig.apps[id] = { ...configApp, repos: { ...configApp.repos, test: app.testRepo } };
                                        changed = true;
                                    }
                                    if (app.prodRepo && configApp.repos?.prod !== app.prodRepo) {
                                        updatedConfig.apps[id] = { ...updatedConfig.apps[id], repos: { ...(updatedConfig.apps[id].repos || {}), prod: app.prodRepo } };
                                        changed = true;
                                    }
                                }
                            }
                            if (changed) {
                                ConfigManager.save(updatedConfig);
                            }
                            return changed ? updatedConfig : prevConfig;
                        });
                        
                        return mapped;
                    });
                    
                    // Small delay to let state settle, then refresh versions
                    await new Promise(r => setTimeout(r, 500));
                    refreshAllVersions();
                }).catch(console.error);
            }
        }, [github]);
        
        // Refresh all versions from repos
        const refreshAllVersions = async () => {
            if (!github) return;
            setRefreshing(true);
            
            // Always use latest apps state from ref
            const currentApps = appsRef.current;
            console.log('=== REFRESHING VERSIONS FROM REPOS ===');
            
            const updates = {};
            for (const [appId, app] of Object.entries(currentApps)) {
                // Ensure subPath is set from defaults (localStorage may have empty string from old config)
                const effectiveSubPath = app.subPath || '';
                const appWithSubPath = { ...app, subPath: effectiveSubPath };
                
                // Get the full path including subPath if set
                const fullTargetPath = getRepoFilePath(appWithSubPath, app.targetPath);
                
                if (app.testRepo) {
                    try {
                        console.log(`[${appId}] Fetching TEST from ${app.testRepo}/${fullTargetPath}...`);
                        const testFileData = await github.getFileContent(app.testRepo, fullTargetPath);
                        if (testFileData) {
                            // Use textContent which handles both normal and large files
                            const content = testFileData.textContent;
                            const version = extractVersionFromHTML(content);
                            console.log(`[${appId}] TEST version from REPO: ${version || 'NO VERSION'}`);
                            console.log(`[${appId}] TEST file SHA: ${testFileData.sha}`);
                            if (version) updates[appId] = { ...updates[appId], currentTestVersion: version };
                        } else {
                            console.log(`[${appId}] TEST: FILE NOT FOUND`);
                        }
                    } catch (e) {
                        console.error(`[${appId}] TEST error:`, e.message);
                    }
                }
                if (app.prodRepo) {
                    try {
                        console.log(`[${appId}] Fetching PROD from ${app.prodRepo}/${fullTargetPath}...`);
                        const prodFileData = await github.getFileContent(app.prodRepo, fullTargetPath);
                        if (prodFileData) {
                            // Use textContent which handles both normal and large files
                            const content = prodFileData.textContent;
                            const version = extractVersionFromHTML(content);
                            console.log(`[${appId}] PROD version from REPO: ${version || 'NO VERSION'}`);
                            console.log(`[${appId}] PROD file SHA: ${prodFileData.sha}`);
                            if (version) updates[appId] = { ...updates[appId], currentProdVersion: version };
                        } else {
                            console.log(`[${appId}] PROD: FILE NOT FOUND`);
                        }
                    } catch (e) {
                        console.error(`[${appId}] PROD error:`, e.message);
                    }
                }
            }
            
            setApps(prev => {
                const newApps = { ...prev };
                for (const [appId, upd] of Object.entries(updates)) {
                    newApps[appId] = { ...newApps[appId], ...upd };
                }
                console.log('Updated apps state:', Object.entries(newApps).map(([id, a]) => `${id}: TEST=${a.currentTestVersion || '—'}, PROD=${a.currentProdVersion || '—'}`));
                return newApps;
            });
            
            setRefreshing(false);
            console.log('=== REFRESH COMPLETE ===');
            
            // Run daily repo health check
            runRepoHealthCheck();
        };
        
        // Lightweight repo health check — runs once per day
        const runRepoHealthCheck = async () => {
            if (!github) return;
            
            // Check last run time
            const HEALTH_CHECK_KEY = 'cc_repo_health_last';
            const lastRun = localStorage.getItem(HEALTH_CHECK_KEY);
            const now = new Date();
            if (lastRun) {
                const lastDate = new Date(lastRun);
                const hoursSince = (now - lastDate) / (1000 * 60 * 60);
                if (hoursSince < 24) {
                    console.log(`[HealthCheck] Skipping — last ran ${hoursSince.toFixed(1)}h ago`);
                    return;
                }
            }
            
            console.log('[HealthCheck] Running daily repo health check...');
            localStorage.setItem(HEALTH_CHECK_KEY, now.toISOString());
            
            const currentApps = appsRef.current;
            const issues = [];
            
            // Only check apps deployed in the last 30 days
            const thirtyDaysAgo = new Date(now - 30 * 24 * 60 * 60 * 1000);
            let currentDeployments = DeployService.load();
            const recentlyDeployed = new Set(
                currentDeployments
                    .filter(d => d.status === 'success' && new Date(d.completedAt || d.startedAt) > thirtyDaysAgo)
                    .map(d => d.appId)
            );
            
            console.log(`[HealthCheck] Checking ${recentlyDeployed.size} recently deployed apps:`, Array.from(recentlyDeployed).join(', '));
            
            for (const [appId, app] of Object.entries(currentApps)) {
                // Skip apps not deployed in last 30 days
                if (!recentlyDeployed.has(appId)) continue;
                
                // Check both test and prod repos
                const repos = [];
                const testRepo = app.testRepo || app.repos?.test;
                const prodRepo = app.prodRepo || app.repos?.prod;
                if (testRepo) repos.push({ repo: testRepo, target: 'test' });
                if (prodRepo) repos.push({ repo: prodRepo, target: 'prod' });
                
                for (const { repo, target } of repos) {
                    try {
                        const contents = await github.listRepoContents(repo, '');
                        const subPath = app.subPath || '';
                        
                        // Build expected set
                        const expected = new Set();
                        const addExp = (f) => expected.add(subPath ? `${subPath}/${f}` : f);
                        addExp(app.targetPath || 'index.html');
                        if (app.hasServiceWorker) {
                            addExp(app.swPath || 'sw.js');
                            addExp('manifest.json');
                        }
                        // Standard files
                        ['README.md', 'LICENSE', '.gitignore', 'CNAME', 'icons'].forEach(f => expected.add(f));
                        // Doc files (root level)
                        ['CONTEXT.md', 'PROJECT_PLAN.md', 'CHANGELOG.md', 'RELEASE_NOTES.txt', 'ARCHITECTURE.md', 'CLAUDE-PREP-STANDARD.md', 'DATA_MODEL.md'].forEach(f => expected.add(f));
                        // .github dir
                        expected.add('.github');
                        
                        const unexpected = contents.filter(item => !expected.has(item.name));
                        
                        if (unexpected.length > 0) {
                            issues.push({
                                appId, appName: app.name, appIcon: app.icon,
                                repo, target,
                                unexpectedFiles: unexpected.map(f => ({ name: f.name, type: f.type }))
                            });
                        }
                    } catch (e) {
                        // Skip repos we can't access
                    }
                }
            }
            
            if (issues.length > 0) {
                console.log(`[HealthCheck] Found ${issues.length} repos with unexpected files`);
                setRepoHealthAlert({ issues });
            } else {
                console.log('[HealthCheck] All repos clean');
            }
        };
        
        // Load repo files
        const loadRepoFiles = async (repo, subPath = '') => {
            if (!github || !repo) return;
            const cacheKey = subPath ? `${repo}::${subPath}` : repo;
            setRepoFiles(prev => ({ ...prev, [cacheKey]: { files: [], loading: true } }));
            
            const files = await github.listRepoContents(repo, subPath || undefined);
            setRepoFiles(prev => ({ ...prev, [cacheKey]: { files, loading: false } }));
        };
        
        const updateApp = (appId, updates) => setApps(prev => ({ ...prev, [appId]: { ...prev[appId], ...updates } }));
        
        // File upload - now accepts multiple file types
        const handleFileDrop = (e) => {
            e.preventDefault();
            const files = e.dataTransfer?.files || e.target.files;
            
            // Capture files into array BEFORE resetting input
            // (FileList is live and gets cleared when input is reset)
            const fileArray = Array.from(files || []);
            
            // Reset file input so same file can be selected again
            // (without this, onChange won't fire for the same file twice)
            if (e.target && e.target.value) {
                e.target.value = '';
            }
            
            // Exit early if no files
            if (fileArray.length === 0) return;
            
            fileArray.forEach(async (file) => {
                // Handle ZIP files specially
                if (file.name.endsWith('.zip')) {
                    console.log('=== PROCESSING ZIP FILE ===');
                    console.log('Name:', file.name);
                    
                    if (typeof JSZip === 'undefined') {
                        await showAlert('ZIP support not available', 'Error');
                        return;
                    }
                    
                    try {
                        const zip = await JSZip.loadAsync(file);
                        
                        // Check if this is a gs-active archive
                        const allPaths = [];
                        zip.forEach((path) => { allPaths.push(path); });
                        
                        // Detect gs-active structure: has gs-active/ folder with known app folders inside
                        const gsActiveApps = ['gameshelf', 'quotle', 'slate', 'rungs', 'wordboxing', 'beta', 'command-center'];
                        const isGsActive = allPaths.some(p => p.startsWith('gs-active/')) && 
                            gsActiveApps.some(app => allPaths.some(p => p.includes(`gs-active/${app}/`) || p.includes(`/${app}/index.html`)));
                        
                        if (isGsActive) {
                            const useSmartDeploy = await showConfirm(
                                'This looks like a gs-active archive with multiple apps.\n\nWould you like to open Smart Deploy for version comparison and selective deployment?',
                                '📦 gs-active Archive Detected'
                            );
                            
                            if (useSmartDeploy) {
                                // Store the file for Smart Deploy to pick up
                                setPendingGsActiveFile(file);
                                setView('smartdeploy');
                                return;
                            }
                            // If user says no, continue with normal extraction below
                        }
                        
                        let primaryApp = null;
                        let primaryVersion = null;
                        
                        // Detect if ZIP has a root folder (common in downloads)
                        const hasRootFolder = allPaths.filter(p => !p.endsWith('/')).length > 0 && 
                            allPaths.filter(p => !p.endsWith('/')).every(p => p.includes('/'));
                        const rootFolder = hasRootFolder ? allPaths.find(p => !p.endsWith('/'))?.split('/')[0] + '/' : '';
                        
                        // === PWA PACKAGE VALIDATION ===
                        // Detect if this is a PWA deployment package (has -latest folder pattern)
                        const latestFolderPattern = /^([a-z]+-latest)\//i;
                        const expectedLatestFolders = ['gameshelf-latest', 'quotle-latest', 'slate-latest', 'rungs-latest', 'wordboxing-latest'];
                        
                        // Check for nested folder issue (extra parent folder wrapping the -latest folder)
                        const pathsAfterRoot = allPaths.map(p => rootFolder && p.startsWith(rootFolder) ? p.substring(rootFolder.length) : p);
                        const hasLatestFolder = pathsAfterRoot.some(p => expectedLatestFolders.some(f => p.startsWith(f + '/')));
                        const hasNestedLatest = allPaths.some(p => {
                            const parts = p.split('/').filter(Boolean);
                            // Check if there's a -latest folder that's NOT at the root level after stripping rootFolder
                            return parts.length >= 3 && expectedLatestFolders.includes(parts[1]);
                        });
                        
                        // Find index.html to check structure
                        const indexPath = allPaths.find(p => p.endsWith('index.html'));
                        const indexDepth = indexPath ? indexPath.split('/').filter(Boolean).length : 0;
                        
                        // Validate PWA package structure
                        if (hasLatestFolder || hasNestedLatest || (rootFolder && indexDepth > 2)) {
                            // This looks like a PWA package - validate structure
                            const expectedPaths = pathsAfterRoot.filter(p => !p.endsWith('/'));
                            const hasIndexAtRoot = expectedPaths.some(p => p === 'index.html' || p.match(/^[a-z]+-latest\/index\.html$/i));
                            const hasNestedIndex = expectedPaths.some(p => {
                                const parts = p.split('/').filter(Boolean);
                                return parts.length > 2 && parts[parts.length - 1] === 'index.html';
                            });
                            
                            if (hasNestedIndex && !hasIndexAtRoot) {
                                // Structure is wrong - extra parent folder
                                const actualPath = indexPath;
                                const expectedPath = actualPath.split('/').slice(-2).join('/'); // e.g., gameshelf-latest/index.html
                                
                                await showAlert(
                                    `⚠️ ZIP has incorrect folder structure!\n\n` +
                                    `Found: ${actualPath}\n` +
                                    `Expected: ${expectedPath}\n\n` +
                                    `The ZIP has an extra parent folder wrapping the content.\n\n` +
                                    `To fix: Re-create the ZIP so the -latest folder is at the root level, not inside another folder.`,
                                    '📦 Invalid Package Structure'
                                );
                                return;
                            }
                        }
                        
                        const extractPromises = [];
                        zip.forEach((relativePath, zipEntry) => {
                            if (zipEntry.dir || relativePath.startsWith('.') || relativePath.includes('__MACOSX')) return;
                            
                            // Strip root folder if present (e.g., 'quotle-deploy-v1_0_2/' prefix)
                            let cleanPath = relativePath;
                            if (rootFolder && relativePath.startsWith(rootFolder)) {
                                cleanPath = relativePath.substring(rootFolder.length);
                            }
                            
                            const fileName = cleanPath.split('/').pop();
                            const isText = /\.(html|js|css|json|md|txt|xml|svg|yml|yaml)$/i.test(fileName);
                            
                            // Determine target path - preserve directory structure for non-HTML files
                            let targetPath;
                            if (fileName.endsWith('.html')) {
                                // HTML files → use app's targetPath (usually index.html)
                                // The zip directory structure is for organization, not deployment
                                targetPath = fileName === 'index.html' ? 'index.html' : fileName;
                            } else if (cleanPath.includes('/')) {
                                // Files in subdirectories → preserve path (e.g., icons/icon-72.png)
                                targetPath = cleanPath;
                            } else {
                                // Root non-HTML files → keep filename
                                targetPath = fileName;
                            }
                            
                            extractPromises.push(
                                zipEntry.async(isText ? 'string' : 'binarystring').then(content => {
                                    const parsed = parseFilename(fileName);
                                    let version = null;
                                    let suggestedApp = null;
                                    let appDetection = null;
                                    let versionValidation = null;
                                    
                                    if (fileName.endsWith('.html')) {
                                        appDetection = detectAppFromContent(content);
                                        suggestedApp = appDetection?.id || parsed.app;
                                        version = extractVersionFromHTML(content) || parsed.version;
                                        versionValidation = validateVersions(content, fileName);
                                        if (appDetection) {
                                            primaryApp = suggestedApp;
                                            primaryVersion = version;
                                        }
                                    } else if (fileName === 'sw.js') {
                                        const swMatch = content.match(/CACHE_VERSION\s*=\s*['"]v?([^'"]+)['"]/);
                                        version = swMatch ? swMatch[1] : null;
                                        suggestedApp = parsed.app;
                                    } else {
                                        suggestedApp = parsed.app;
                                    }
                                    
                                    console.log('Extracted:', cleanPath, '→', targetPath, 'v' + version);
                                    
                                    const fileAction = classifyFileAction(fileName);
                                    if (fileAction === 'skip') return; // Skip SESSION_BRIEF.md etc.
                                    
                                    // For push-doc files, compute the repo target path
                                    let docTargetPath = fileName; // Default: just the filename at root
                                    if (fileAction === 'push-doc' && suggestedApp) {
                                        const docApp = apps[suggestedApp];
                                        if (docApp) {
                                            const docsPath = getDocsPath(docApp);
                                            docTargetPath = docsPath ? `${docsPath}/${fileName}` : fileName;
                                        }
                                    }
                                    
                                    setStagedFiles(prev => [...prev, {
                                        id: Date.now() + Math.random(),
                                        name: fileName,
                                        originalPath: cleanPath,
                                        size: content.length,
                                        content: isText ? content : btoa(content),
                                        encoding: isText ? 'utf-8' : 'base64',
                                        isText,
                                        suggestedApp,
                                        appDetection,
                                        version,
                                        versionSource: version ? 'extracted' : 'none',
                                        versionValidation,
                                        fileAction,
                                        targetPath: fileAction === 'push-doc' ? docTargetPath : targetPath
                                    }]);
                                })
                            );
                        });
                        
                        await Promise.all(extractPromises);
                        console.log('=== ZIP EXTRACTED ===');
                        console.log('Primary app:', primaryApp, 'v' + primaryVersion);
                        
                        // Assign primaryApp to doc files that don't have a detected app
                        if (primaryApp) {
                            setStagedFiles(currentFiles => 
                                currentFiles.map(f => {
                                    if (f.fileAction === 'push-doc' && !f.suggestedApp) {
                                        // Also recompute the doc target path now that we know the app
                                        const docApp = apps[primaryApp];
                                        const docsPath = docApp ? getDocsPath(docApp) : '';
                                        const docTargetPath = docsPath ? `${docsPath}/${f.name}` : f.name;
                                        return { ...f, suggestedApp: primaryApp, targetPath: docTargetPath };
                                    }
                                    return f;
                                })
                            );
                        }
                        
                        // Post-extraction validation is now handled by the unified
                        // validatePackage() panel in DashboardView (selection-driven)
                        
                        
                    } catch (err) {
                        console.error('ZIP extraction failed:', err);
                        showAlert('Failed to extract ZIP: ' + err.message, 'ZIP Error');
                    }
                    return;
                }
                
                // Handle regular files
                const reader = new FileReader();
                reader.onload = (e) => {
                    const content = e.target.result;
                    const isText = file.type.startsWith('text/') || 
                        /\.(html|js|css|json|md|txt|xml|svg|yml|yaml)$/i.test(file.name);
                    
                    const parsed = parseFilename(file.name);
                    let version = null;
                    let versionSource = 'none';
                    let versionValidation = null;
                    
                    // App detection: try content first, fall back to filename
                    let suggestedApp = null;
                    let appDetection = null;
                    
                    if (file.name.endsWith('.html') && isText) {
                        // Try content-based detection
                        appDetection = detectAppFromContent(content);
                        
                        if (appDetection) {
                            suggestedApp = appDetection.id;
                            console.log('=== APP DETECTED FROM CONTENT ===');
                            console.log('Detected:', appDetection.id);
                            console.log('Confidence:', appDetection.confidence);
                            console.log('Matches:', appDetection.matchCount);
                        } else {
                            // Fall back to filename
                            suggestedApp = parsed.app;
                            console.log('=== APP FROM FILENAME ===');
                            console.log('Parsed:', parsed.app);
                        }
                        
                        const htmlVersion = extractVersionFromHTML(content);
                        version = htmlVersion || parsed.version;
                        versionSource = htmlVersion ? 'html' : (parsed.version ? 'filename' : 'none');
                        
                        // Full version validation
                        versionValidation = validateVersions(content, file.name);
                        
                        console.log('=== VERSION VALIDATION ===');
                        console.log('File:', file.name);
                        console.log('Primary version:', versionValidation.primary);
                        console.log('All versions found:', versionValidation.allVersions);
                        console.log('Unique versions:', versionValidation.uniqueVersions);
                        console.log('Is valid:', versionValidation.isValid);
                        if (!versionValidation.isValid) {
                            console.warn('⚠️ VERSION ISSUES:', {
                                mismatches: versionValidation.mismatches,
                                missing: versionValidation.missing
                            });
                        }
                    } else if (file.name.endsWith('.js') && isText) {
                        // Check if this is Firebase Functions code
                        appDetection = detectAppFromContent(content);
                        if (appDetection) {
                            suggestedApp = appDetection.id;
                            console.log('=== JS FILE APP DETECTED ===');
                            console.log('Detected:', appDetection.id);
                            console.log('Confidence:', appDetection.confidence);
                        } else {
                            suggestedApp = parsed.app;
                        }
                    } else if ((file.name.endsWith('.yml') || file.name.endsWith('.yaml')) && isText) {
                        // Check if this is a Firebase/GitHub Actions workflow
                        if (/firebase-action|FIREBASE_TOKEN|deploy.*functions/i.test(content)) {
                            suggestedApp = 'firebase-functions';
                            appDetection = {
                                id: 'firebase-functions',
                                confidence: 'high',
                                method: 'workflow-pattern',
                                matchCount: 1,
                                matchedPatterns: ['GitHub Actions Firebase workflow']
                            };
                            console.log('=== YML FILE DETECTED AS FIREBASE WORKFLOW ===');
                        } else {
                            suggestedApp = parsed.app;
                        }
                    } else {
                        suggestedApp = parsed.app;
                    }
                    
                    console.log('=== FILE UPLOADED ===');
                    console.log('Name:', file.name);
                    console.log('Size:', file.size);
                    console.log('Version:', version);
                    console.log('Suggested App:', suggestedApp, appDetection ? '(from content)' : '(from filename)');
                    
                    // Clean up Claude download filenames (e.g., index_4.js → index.js)
                    let cleanedName = file.name;
                    const claudeDownloadPattern = /^(.+?)_\d+(\.[a-z]+)$/i;
                    const claudeMatch = file.name.match(claudeDownloadPattern);
                    if (claudeMatch) {
                        cleanedName = claudeMatch[1] + claudeMatch[2];
                        console.log('Cleaned filename:', file.name, '→', cleanedName);
                    }
                    
                    // Determine targetPath: use app-specific path if detected, else default logic
                    let targetPath;
                    if (suggestedApp === 'firebase-functions' && (cleanedName.endsWith('.yml') || cleanedName.endsWith('.yaml'))) {
                        // Workflow files go to .github/workflows/
                        targetPath = '.github/workflows/deploy.yml';
                    } else if (suggestedApp && apps[suggestedApp]) {
                        targetPath = apps[suggestedApp].targetPath || 'index.html';
                    } else if (file.name.endsWith('.html')) {
                        targetPath = 'index.html';
                    } else {
                        targetPath = cleanedName;
                    }
                    
                    const fileAction = classifyFileAction(cleanedName);
                    if (fileAction === 'skip') return;
                    
                    // For push-doc files, compute repo target path
                    let finalTargetPath = targetPath;
                    if (fileAction === 'push-doc' && suggestedApp) {
                        const docApp = apps[suggestedApp];
                        if (docApp) {
                            const docsPath = getDocsPath(docApp);
                            finalTargetPath = docsPath ? `${docsPath}/${cleanedName}` : cleanedName;
                        }
                    }
                    
                    setStagedFiles(prev => [...prev, {
                        id: Date.now() + Math.random(),
                        name: cleanedName,
                        originalName: file.name !== cleanedName ? file.name : undefined,
                        size: file.size,
                        content: isText ? content : btoa(content),
                        encoding: isText ? 'utf-8' : 'base64',
                        isText,
                        suggestedApp,
                        appDetection, // Store detection details
                        version,
                        versionSource,
                        versionValidation,
                        fileAction,
                        targetPath: finalTargetPath
                    }]);
                };
                
                if (file.type.startsWith('text/') || /\.(html|js|css|json|md|txt|xml|svg|yml|yaml)$/i.test(file.name)) {
                    reader.readAsText(file);
                } else {
                    reader.readAsBinaryString(file);
                }
            });
        };
        
        const removeStaged = (id) => setStagedFiles(prev => prev.filter(f => f.id !== id));
        const updateStagedFile = (id, updates) => setStagedFiles(prev => prev.map(f => f.id === id ? { ...f, ...updates } : f));
        
        // Get current deployed version from repo
        const fetchCurrentVersion = async (repo, targetPath) => {
            if (!github || !repo) return null;
            const fileData = await github.getFileContent(repo, targetPath);
            if (!fileData) return null;
            // Use textContent which handles both normal and large files
            return extractVersionFromHTML(fileData.textContent);
        };
        
        // Deploy single file (legacy support)
        const handleDeploy = async (file, appId, target, forceDeploy = false) => {
            if (!github) { await showAlert('Configure GitHub token', 'Configuration Required'); return; }
            
            const app = apps[appId];
            // Ensure subPath is set from defaults (localStorage may have empty string from old config)
            const effectiveSubPath = app.subPath || '';
            const appWithSubPath = { ...app, subPath: effectiveSubPath };
            
            const repo = target === 'prod' ? app.prodRepo : app.testRepo;
            if (!repo) { await showAlert(`Configure ${target} repo`, 'Configuration Required'); return; }
            
            // Get full path including subPath
            const fullTargetPath = getRepoFilePath(appWithSubPath, file.targetPath || app.targetPath);
            
            const newVersion = file.version;
            // Version validation is now handled pre-deploy by the unified validation panel
            
            // 📸 Save rollback snapshot BEFORE deploying
            await saveRollbackSnapshot(appId, target, repo, fullTargetPath);
            
            const deployment = {
                id: Date.now(), status: 'running', steps: [],
                appId, appName: app.name, repo, target,
                version: newVersion || 'unknown',
                previousVersion: currentVersion,
                startedAt: new Date().toISOString(),
                fileContent: file.content
            };
            
            setActiveDeployment(deployment);
            setDeployments(prev => [deployment, ...prev]);
            
            const addStep = (name, status, details = null) => {
                const existingIndex = deployment.steps.findIndex(s => s.name === name);
                if (existingIndex >= 0) {
                    deployment.steps[existingIndex] = { name, status, details };
                } else {
                    deployment.steps.push({ name, status, details });
                }
                setActiveDeployment({ ...deployment });
            };
            
            try {
                addStep('Validating', 'running');
                addStep('Validating', 'complete', `${formatVersion(newVersion)} (${formatBytes(file.size)})`);
                
                addStep('Safety Check', 'running');
                if (currentVersion) {
                    if (isNewerVersion(newVersion, currentVersion)) {
                        addStep('Safety Check', 'complete', `${formatVersion(currentVersion)} → ${formatVersion(newVersion)} ✓`);
                    } else {
                        addStep('Safety Check', 'warning', `Force deploy: ${formatVersion(currentVersion)} → ${formatVersion(newVersion)}`);
                    }
                } else {
                    addStep('Safety Check', 'complete', 'First deploy');
                }
                
                addStep('Committing', 'running');
                deployment.preCommitTime = Date.now(); // Capture time before commit for workflow search
                const currentFile = await github.getFile(repo, fullTargetPath);
                const result = await github.createOrUpdateFile(
                    repo, fullTargetPath, file.content,
                    `Deploy ${app.name} ${formatVersion(newVersion)}${currentVersion ? ` (was ${formatVersion(currentVersion)})` : ''}`,
                    currentFile?.sha
                );
                deployment.commitSha = result.commit.sha;
                addStep('Committing', 'complete', result.commit.sha.substring(0, 7));
                
                addStep('GitHub Pages', 'running');
                try {
                    const pagesResult = await github.enablePages(repo);
                    addStep('GitHub Pages', 'complete', pagesResult.alreadyEnabled ? 'Ready' : 'Enabled!');
                } catch (e) {
                    addStep('GitHub Pages', 'warning', e.message);
                }
                
                if (settings.createTag && newVersion) {
                    addStep('Tagging', 'running');
                    try {
                        const tag = target === 'prod' ? `v${newVersion}` : `v${newVersion}-test`;
                        await github.createTag(repo, tag, result.commit.sha, `Release ${newVersion}`);
                        addStep('Tagging', 'complete', tag);
                    } catch {
                        addStep('Tagging', 'warning', 'Tag may exist');
                    }
                }
                
                deployment.status = 'success';
                deployment.url = getGitHubPagesUrl(repo, effectiveSubPath);
                updateApp(appId, { [target === 'prod' ? 'currentProdVersion' : 'currentTestVersion']: newVersion, updatedAt: Date.now() });
                removeStaged(file.id);
                
                // Check for open issues that can be linked to this deploy
                const openIssues = globalIssues.filter(i => 
                    i.app === appId && 
                    (i.status === 'open' || i.status === 'in-progress')
                );
                
                if (openIssues.length > 0 && target === 'test') {
                    // Show issue linking modal after a short delay
                    setTimeout(async () => {
                        const issueList = openIssues.map(i => `${i.id}: ${i.title}`).join('\n');
                        const result = await showPrompt(
                            `This deploy may fix these issues:\n\n${issueList}\n\nEnter issue IDs to link (comma-separated), or leave blank:`,
                            '',
                            '🔗 Link Issues to v' + newVersion
                        );
                        
                        if (result && result.trim()) {
                            const issueIds = result.split(',').map(s => s.trim().toUpperCase());
                            const validIds = issueIds.filter(id => openIssues.some(i => i.id === id));
                            if (validIds.length > 0) {
                                await linkIssuesToVersion(validIds, newVersion, appId);
                            }
                        }
                    }, 500);
                }
                
                // === Phase 2.3: Work Item Completion Dialog ===
                // After successful deploy, check for in-progress and review work items for this app
                if (firebaseUid) {
                    const inProgressItems = WorkItemService.getInProgress(globalWorkItems, appId);
                    const inReviewItems = WorkItemService.getInReview(globalWorkItems, appId);
                    const completableItems = [...inProgressItems, ...inReviewItems];
                    
                    if (completableItems.length > 0) {
                        // Show completion dialog after a delay (after issue linking if any)
                        const wiDelay = openIssues.length > 0 ? 1500 : 500;
                        setTimeout(async () => {
                            const itemList = completableItems.map(wi => `${wi.id}: ${wi.title} (${wi.status})`).join('\n');
                            const confirmed = await showConfirm(
                                `This deploy (v${newVersion}) may complete these work items:\n\n${itemList}\n\nMark ${completableItems.length === 1 ? 'it' : 'them'} as done?`,
                                `✅ Complete Work Items — ${app.name}`
                            );
                            
                            if (confirmed) {
                                for (const wi of completableItems) {
                                    await WorkItemService.complete(firebaseUid, wi.id, newVersion);
                                }
                                console.log(`[Deploy] Completed ${completableItems.length} work items for ${appId} v${newVersion}`);
                            }
                        }, wiDelay);
                    }
                    
                    // === Phase 2.3: Link Deploy to Active Session ===
                    // Find the most recent active (prep status) session for this app and link it
                    const activeSessions = SessionService.getActive(globalSessions, appId);
                    if (activeSessions.length > 0) {
                        const latestSession = activeSessions[0]; // Most recent prep session
                        const deployId = `deploy-${deployment.id}`;
                        await SessionService.linkDeploy(firebaseUid, latestSession.id, deployId);
                        
                        // Enrich deployment record with session + work item data
                        deployment.sessionId = latestSession.id;
                        deployment.sessionType = latestSession.type;
                        deployment.workItemsCompleted = completableItems.map(wi => wi.id);
                        
                        console.log(`[Deploy] Linked to session ${latestSession.id} (${latestSession.type})`);
                    }
                    
                    // === Phase 3.4: Activity Logging ===
                    const actor = config?.ownerName || 'Owner';
                    ActivityLogService.logDeploy(firebaseUid, actor, app.name, newVersion, targetEnv, activeSessions[0]?.id || null).catch(e => console.warn('[Activity] Log failed:', e));
                }
                
                // Start monitoring for deployment completion
                if (app?.deployType === 'github-actions') {
                    // For github-actions apps (Firebase Functions), monitor the workflow
                    addStep('GitHub Actions', 'running', 'Finding workflow...');
                    const searchTime = (deployment.preCommitTime || Date.now()) - 10000;
                    
                    const workflowRun = await github.findRecentWorkflowRun(repo, searchTime, 60000);
                    
                    if (workflowRun) {
                        const logsUrl = await github.getWorkflowRunLogsUrl(repo, workflowRun.id);
                        addStep('GitHub Actions', 'running', `Workflow #${workflowRun.run_number} running...`);
                        deployment.workflowUrl = logsUrl;
                        setActiveDeployment({ ...deployment });
                        
                        const monitorStartTime = Date.now();
                        const result = await github.waitForWorkflowRun(repo, workflowRun.id, 300000, (run) => {
                            addStep('GitHub Actions', 'running', `${run.status}... (${Math.round((Date.now() - monitorStartTime) / 1000)}s)`);
                            setActiveDeployment({ ...deployment });
                            setDeployments(prev => prev.map(d => d.id === deployment.id ? { ...deployment } : d));
                        });
                        
                        if (result.success) {
                            addStep('GitHub Actions', 'complete', `✓ Deployed! (${result.run?.conclusion})`);
                        } else {
                            addStep('GitHub Actions', 'error', `Failed: ${result.conclusion || result.error}`);
                            deployment.status = 'failed';
                            deployment.error = result.conclusion || result.error;
                            if (result.logsUrl) {
                                deployment.workflowUrl = result.logsUrl;
                            }
                        }
                    } else {
                        addStep('GitHub Actions', 'warning', 'Workflow not found - check GitHub manually');
                        deployment.workflowUrl = `https://github.com/${repo}/actions`;
                        deployment.status = 'success'; // Code committed successfully, just couldn't track workflow
                    }
                } else if (deployment.url && newVersion) {
                    // For regular apps, monitor the live site
                    addStep('GitHub Pages', 'running', 'Waiting for deploy...');
                    monitorLiveDeployment(deployment.url, newVersion, repo, (status, detail) => {
                        addStep('GitHub Pages', status, detail);
                        setActiveDeployment({ ...deployment });
                        setDeployments(prev => prev.map(d => d.id === deployment.id ? { ...deployment } : d));
                    }, appId, target);
                }
                
            } catch (error) {
                deployment.status = 'failed';
                deployment.error = error.message;
                addStep('Error', 'error', error.message);
            }
            
            deployment.completedAt = new Date().toISOString();
            setActiveDeployment({ ...deployment });
            setDeployments(prev => prev.map(d => d.id === deployment.id ? deployment : d));
        };
        
        // Multi-file batch deploy
        const handleBatchDeploy = async (files, appId, target) => {
            if (!github) {
                await showAlert('Configure GitHub token first', 'Configuration Required');
                return;
            }
            if (files.length === 0) return;
            
            const app = apps[appId];
            const appWithDefaults = {
                ...app,
                subPath: app.subPath || ''
            };
            const repo = target === 'prod' ? appWithDefaults.prodRepo : appWithDefaults.testRepo;
            if (!repo) {
                await showAlert(`Configure ${target} repo first`, 'Configuration Required');
                return;
            }
            
            // Find version from index.html if present
            const indexFile = files.find(f => f.targetPath === 'index.html' || f.name === 'index.html');
            const newVersion = indexFile?.version || 'batch';
            
            // Version validation is now handled pre-deploy by the unified validation panel
            
            // Log file details for debugging
            console.log('handleBatchDeploy received:', files.map(f => ({
                name: f.name,
                id: f.id,
                targetPath: f.targetPath,
                version: f.version,
                validationOk: f.versionValidation?.isValid,
                contentLength: f.content?.length
            })));
            console.log('App subPath:', appWithDefaults.subPath);
            
            // 📸 Save rollback snapshot BEFORE deploying
            const fullTargetPath = getRepoFilePath(appWithDefaults, appWithDefaults.targetPath);
            await saveRollbackSnapshot(appId, target, repo, fullTargetPath);
            
            const deployment = {
                id: Date.now(), status: 'running', steps: [],
                appId, appName: appWithDefaults.name, repo, target,
                version: newVersion,
                startedAt: new Date().toISOString(),
                fileCount: files.length
            };
            
            setActiveDeployment(deployment);
            setDeployments(prev => [deployment, ...prev]);
            
            // v8.5.0: Set deploying indicator using appId:target key to avoid shared repo conflicts
            const deployKey = `${appId}:${target}`;
            setDeployingRepos(prev => ({ ...prev, [deployKey]: { version: newVersion, startTime: Date.now(), repo } }));
            
            const addStep = (name, status, details = null) => {
                const existingIndex = deployment.steps.findIndex(s => s.name === name);
                if (existingIndex >= 0) {
                    deployment.steps[existingIndex] = { name, status, details };
                } else {
                    deployment.steps.push({ name, status, details });
                }
                setActiveDeployment({ ...deployment });
            };
            
            try {
                addStep('Preparing batch', 'running');
                addStep('Preparing batch', 'complete', `${files.length} files`);
                
                addStep('Creating commit', 'running');
                // Prepend subPath to all file paths if needed
                const filesToCommit = files.map(f => ({
                    path: getRepoFilePath(appWithDefaults, f.targetPath || f.name),
                    content: f.content,
                    encoding: f.encoding
                }));
                console.log('Files to commit with paths:', filesToCommit.map(f => f.path));
                
                // Check if any file has a subdirectory that might not exist
                // Use batch commit (Git Data API) for these cases since it auto-creates directories
                const hasSubdirectories = filesToCommit.some(f => f.path.includes('/'));
                
                let result;
                // Use Git Data API (batchCommit) for:
                // 1. Multiple files
                // 2. Files with subdirectories (to auto-create directories)
                // Use Contents API only for single files at repo root (more reliable for simple cases)
                if (filesToCommit.length === 1 && !hasSubdirectories) {
                    const file = filesToCommit[0];
                    console.log('Single file at root, using Contents API for:', file.path);
                    
                    // Get current file SHA if it exists (needed for update)
                    let existingSha = null;
                    try {
                        const existingFile = await github.getFile(repo, file.path);
                        if (existingFile) {
                            existingSha = existingFile.sha;
                            console.log('Existing file SHA:', existingSha);
                        }
                    } catch (e) {
                        console.log('File does not exist yet, will create');
                    }
                    
                    // Decode content if it's base64 encoded, otherwise use as-is
                    let contentToSend = file.content;
                    if (file.encoding === 'base64') {
                        // Content is already base64, need to decode for createOrUpdateFile which re-encodes
                        try {
                            contentToSend = decodeURIComponent(escape(atob(file.content)));
                        } catch (e) {
                            console.log('Content is binary base64, using raw');
                            contentToSend = atob(file.content);
                        }
                    }
                    
                    // Capture time BEFORE commit for GitHub Actions workflow detection
                    deployment.preCommitTime = Date.now();
                    
                    result = await github.createOrUpdateFile(
                        repo,
                        file.path,
                        contentToSend,
                        `Deploy ${appWithDefaults.name} ${formatVersion(newVersion)} (${files.length} files)`,
                        existingSha
                    );
                    result.sha = result.commit.sha;
                } else {
                    // Multiple files OR files with subdirectories - use batch commit (Git Data API)
                    // Git Data API auto-creates directories, which is essential for new subdirectories
                    console.log(`Using Git Data API (batchCommit) - files: ${filesToCommit.length}, hasSubdirs: ${hasSubdirectories}`);
                    
                    // Capture time BEFORE commit for GitHub Actions workflow detection
                    deployment.preCommitTime = Date.now();
                    
                    result = await github.batchCommit(
                        repo,
                        filesToCommit,
                        `Deploy ${appWithDefaults.name} ${formatVersion(newVersion)} (${files.length} files)`
                    );
                }
                deployment.commitSha = result.sha;
                addStep('Creating commit', 'complete', result.sha.substring(0, 7));
                
                // Skip GitHub Pages for GitHub Actions deploys (Firebase Functions doesn't use Pages)
                if (appWithDefaults.deployType !== 'github-actions') {
                    addStep('GitHub Pages', 'running');
                    try {
                        await github.enablePages(repo);
                        addStep('GitHub Pages', 'complete', 'Ready');
                    } catch (e) {
                        addStep('GitHub Pages', 'warning', e.message);
                    }
                }
                
                if (settings.createTag && newVersion !== 'batch') {
                    addStep('Tagging', 'running');
                    try {
                        const tag = target === 'prod' ? `v${newVersion}` : `v${newVersion}-test`;
                        await github.createTag(repo, tag, result.sha, `Release ${newVersion}`);
                        addStep('Tagging', 'complete', tag);
                    } catch {
                        addStep('Tagging', 'warning', 'Tag may exist');
                    }
                }
                
                // For GitHub Actions deploys, don't set success yet - wait for workflow
                if (appWithDefaults.deployType !== 'github-actions') {
                    deployment.status = 'success';
                }
                deployment.url = getGitHubPagesUrl(repo, appWithDefaults.subPath);
                
                // Verify the deployment by fetching back from repo
                console.log('=== VERIFYING DEPLOYMENT ===');
                await new Promise(r => setTimeout(r, 1000)); // Wait a bit for GitHub to process
                
                // Always verify index.html (not binary files like PNGs)
                try {
                    const verifyFileData = await github.getFileContent(repo, fullTargetPath);
                    if (verifyFileData) {
                        // Use textContent which handles both normal and large files
                        const verifyContent = verifyFileData.textContent;
                        const verifyVersion = extractVersionFromHTML(verifyContent);
                        console.log('Verification - version in repo after deploy:', verifyVersion);
                        console.log('Verification - expected version:', newVersion);
                        if (verifyVersion !== newVersion && newVersion !== 'batch') {
                            console.warn('VERSION MISMATCH! Deploy may have failed.');
                            addStep('Verification', 'warning', `Expected ${newVersion}, found ${verifyVersion}`);
                        } else {
                            addStep('Verification', 'complete', `Confirmed ${verifyVersion || 'batch'} in repo`);
                        }
                    }
                } catch (verifyError) {
                    console.warn('Verification skipped:', verifyError.message);
                    addStep('Verification', 'warning', 'Could not verify (deploy likely succeeded)');
                }
                
                if (newVersion !== 'batch') {
                    updateApp(appId, { [target === 'prod' ? 'currentProdVersion' : 'currentTestVersion']: newVersion, updatedAt: Date.now() });
                }
                
                // Don't refresh immediately - GitHub's CDN needs time to propagate
                // The local state is already updated, and verification confirmed the deploy
                // Refresh will happen on next manual refresh or page load
                // setTimeout(() => refreshAllVersions(), 500); // DISABLED - causes version revert due to GitHub caching
                
                // v8.5.0: For GitHub Actions deploys (Firebase Functions), monitor workflow instead of live site
                if (app.deployType === 'github-actions') {
                    addStep('GitHub Actions', 'running', 'Finding workflow...');
                    // Use preCommitTime captured before the commit, with extra buffer
                    const searchTime = (deployment.preCommitTime || Date.now()) - 10000; // 10 second buffer before commit
                    
                    // Find the workflow run triggered by our commit (wait up to 60 seconds for it to appear)
                    const workflowRun = await github.findRecentWorkflowRun(repo, searchTime, 60000);
                    
                    if (workflowRun) {
                        const logsUrl = await github.getWorkflowRunLogsUrl(repo, workflowRun.id);
                        addStep('GitHub Actions', 'running', `Workflow #${workflowRun.run_number} running...`);
                        deployment.workflowUrl = logsUrl;
                        setActiveDeployment({ ...deployment });
                        
                        // Monitor the workflow
                        const monitorStartTime = Date.now();
                        const result = await github.waitForWorkflowRun(repo, workflowRun.id, 300000, (run) => {
                            addStep('GitHub Actions', 'running', `${run.status}... (${Math.round((Date.now() - monitorStartTime) / 1000)}s)`);
                            setActiveDeployment({ ...deployment });
                            setDeployments(prev => prev.map(d => d.id === deployment.id ? { ...deployment } : d));
                        });
                        
                        if (result.success) {
                            addStep('GitHub Actions', 'complete', `✓ Deployed! (${result.run?.conclusion})`);
                            deployment.status = 'success';
                        } else {
                            addStep('GitHub Actions', 'error', `Failed: ${result.conclusion || result.error}`);
                            deployment.status = 'failed';
                            deployment.error = result.conclusion || result.error;
                            // Show link to logs
                            if (result.logsUrl) {
                                deployment.workflowUrl = result.logsUrl;
                            }
                        }
                    } else {
                        addStep('GitHub Actions', 'warning', 'Workflow not found - check GitHub manually');
                        deployment.workflowUrl = `https://github.com/${repo}/actions`;
                    }
                }
                // Start monitoring live site for deployment completion (non-Actions deploys)
                else if (deployment.url && newVersion !== 'batch') {
                    addStep('GitHub Pages', 'running', 'Waiting for deploy...');
                    monitorLiveDeployment(deployment.url, newVersion, repo, (status, detail) => {
                        addStep('GitHub Pages', status, detail);
                        setActiveDeployment({ ...deployment });
                        setDeployments(prev => prev.map(d => d.id === deployment.id ? { ...deployment } : d));
                    }, appId, target);
                }
                
                // Remove deployed files from staged
                files.forEach(f => removeStaged(f.id));
                
            } catch (error) {
                deployment.status = 'failed';
                deployment.error = error.message;
                addStep('Error', 'error', error.message);
                console.error('Batch deployment failed:', error);
                
                // v8.3.3: Clear deploying indicator on failure
                const deployKey = `${appId}:${target}`;
                setDeployingRepos(prev => {
                    const next = { ...prev };
                    delete next[deployKey];
                    return next;
                });
                
                // Check for workflow file permission issue
                let errorMessage = error.message;
                if (error.message.includes('Not Found') && filesToCommit.some(f => f.path.includes('.github/workflows'))) {
                    errorMessage = 'Cannot update workflow files. Your GitHub token needs the "workflow" scope.\n\n' +
                        'To fix:\n' +
                        '1. Go to GitHub → Settings → Developer settings → Personal access tokens\n' +
                        '2. Edit your token and add the "workflow" scope\n' +
                        '3. Update the token in Command Center settings';
                }
                
                await showAlert(errorMessage, 'Deployment Error');
            }
            
            deployment.completedAt = new Date().toISOString();
            setActiveDeployment({ ...deployment });
            setDeployments(prev => prev.map(d => d.id === deployment.id ? deployment : d));
        };
        
        // Delete marked files
        const handleDeleteMarkedFiles = async () => {
            if (!github || markedForDeletion.length === 0) return;
            
            setModal(null);
            
            // Show loading state on affected repos
            const affectedRepos = [...new Set(markedForDeletion.map(i => i.repo))];
            for (const repo of affectedRepos) {
                setRepoFiles(prev => ({ ...prev, [repo]: { ...prev[repo], loading: true } }));
            }
            
            let successCount = 0;
            let failCount = 0;
            
            for (const item of markedForDeletion) {
                try {
                    await github.deleteFile(item.repo, item.path, `Delete ${item.path}`, item.sha);
                    successCount++;
                } catch (e) {
                    console.error(`Failed to delete ${item.path}:`, e);
                    failCount++;
                }
            }
            
            // Clear marked files
            setMarkedForDeletion([]);
            
            // Wait a moment for GitHub to process, then refresh
            await new Promise(resolve => setTimeout(resolve, 1500));
            
            for (const repo of affectedRepos) {
                await loadRepoFiles(repo);
            }
            
            // Show result
            if (failCount > 0) {
                await showAlert(`Deleted ${successCount} file(s), ${failCount} failed`, 'Delete Results');
            }
        };
        
        // Promote TEST → PROD
        const handlePromote = async (appId) => {
            const app = apps[appId];
            
            // Check for required repos - don't fail silently!
            if (!app) {
                await showAlert(`App "${appId}" not found`, 'Promote Error');
                return;
            }
            
            // Ensure subPath is set from defaults (localStorage may have empty string from old config)
            const effectiveSubPath = app.subPath || '';
            const appWithSubPath = { ...app, subPath: effectiveSubPath };
            
            if (!app.testRepo) {
                await showAlert(`No TEST repo configured for ${app.name}. Assign a test repo first.`, 'Promote Error');
                return;
            }
            if (!app.prodRepo) {
                await showAlert(`No PROD repo configured for ${app.name}. Assign a production repo first.`, 'Promote Error');
                return;
            }
            
            console.log(`[Promote] Starting promotion for ${appId}`);
            console.log(`[Promote] TEST repo: ${app.testRepo}`);
            console.log(`[Promote] PROD repo: ${app.prodRepo}`);
            console.log(`[Promote] subPath: ${effectiveSubPath || '(root)'}`);
            
            setModal(null);
            
            const deployment = {
                id: Date.now(), status: 'running', steps: [],
                appId, appName: app.name, repo: app.prodRepo, target: 'prod',
                isPromotion: true, version: app.currentTestVersion,
                startedAt: new Date().toISOString()
            };
            
            setActiveDeployment(deployment);
            setDeployments(prev => [deployment, ...prev]);
            
            const addStep = (name, status, details = null) => {
                const existingIndex = deployment.steps.findIndex(s => s.name === name);
                if (existingIndex >= 0) {
                    deployment.steps[existingIndex] = { name, status, details };
                } else {
                    deployment.steps.push({ name, status, details });
                }
                setActiveDeployment({ ...deployment });
            };
            
            try {
                // Determine which files to promote
                // For PWA apps: index.html, sw.js, manifest.json, icons/*
                // For regular apps: just the targetPath (index.html)
                const baseFilesToPromote = [app.targetPath];
                if (app.hasServiceWorker && app.swPath) {
                    baseFilesToPromote.push(app.swPath);
                }
                // Always check for manifest.json for PWA apps
                if (app.hasServiceWorker) {
                    baseFilesToPromote.push('manifest.json');
                }
                
                // Convert to full paths with subPath
                const filesToPromote = baseFilesToPromote.map(f => getRepoFilePath(appWithSubPath, f));
                
                // For PWA apps, also check for icons folder
                let iconFiles = [];
                if (app.hasServiceWorker) {
                    try {
                        const iconsPath = getRepoFilePath(appWithSubPath, 'icons');
                        const iconsContents = await github.listRepoContents(app.testRepo, iconsPath);
                        iconFiles = iconsContents
                            .filter(f => f.type === 'file' && /\.(png|ico|svg|webp)$/i.test(f.name))
                            .map(f => getRepoFilePath(appWithSubPath, `icons/${f.name}`));
                        console.log(`Found ${iconFiles.length} icon files in TEST at ${iconsPath}`);
                    } catch (e) {
                        console.log('No icons folder found in TEST');
                    }
                }
                
                addStep('Fetching from TEST', 'running', `${filesToPromote.length + iconFiles.length} files`);
                
                const filesToCommit = [];
                let testVersion = null;
                
                // Fetch main PWA files
                const fullTargetPath = getRepoFilePath(appWithSubPath, app.targetPath);
                for (const filePath of filesToPromote) {
                    try {
                        const testFile = await github.getFile(app.testRepo, filePath);
                        if (testFile) {
                            let base64Content;
                            let decodedContent = null;
                            
                            // Handle large files (>1MB) - GitHub doesn't return content in contents API
                            // Use Git Blob API instead of download_url to bypass CDN caching
                            if (!testFile.content && testFile.sha) {
                                console.log(`📦 Large file detected: ${filePath}, using Git Blob API (SHA: ${testFile.sha})`);
                                const blob = await github.getBlobContent(app.testRepo, testFile.sha);
                                if (blob && blob.content) {
                                    base64Content = github.cleanBase64(blob.content);
                                    decodedContent = github.decodeContent(blob.content);
                                    console.log(`✓ Fetched ${filePath} via Blob API (${blob.size} bytes)`);
                                } else {
                                    // Fallback to download_url if blob API fails
                                    console.log(`⚠ Blob API failed, falling back to download_url`);
                                    if (testFile.download_url) {
                                        const cacheBustUrl = testFile.download_url + (testFile.download_url.includes('?') ? '&' : '?') + '_=' + Date.now();
                                        const response = await fetch(cacheBustUrl);
                                        const textContent = await response.text();
                                        base64Content = btoa(unescape(encodeURIComponent(textContent)));
                                        decodedContent = textContent;
                                    } else {
                                        console.log(`⚠ ${filePath} has no content, no blob, and no download_url, skipping`);
                                        continue;
                                    }
                                }
                            } else if (testFile.content) {
                                // Normal file - use base64 directly
                                base64Content = github.cleanBase64(testFile.content);
                                decodedContent = github.decodeContent(testFile.content);
                            } else {
                                console.log(`⚠ ${filePath} has no content and no sha, skipping`);
                                continue;
                            }
                            
                            filesToCommit.push({
                                path: filePath,
                                content: base64Content,
                                encoding: 'base64'
                            });
                            
                            // Extract version from main HTML file
                            if (filePath === fullTargetPath && decodedContent) {
                                testVersion = extractVersionFromHTML(decodedContent);
                                deployment.fileContent = decodedContent;
                            }
                            
                            console.log(`✓ Found ${filePath} in TEST (${base64Content.length} bytes base64)`);
                        }
                    } catch (e) {
                        // File doesn't exist in TEST, skip it (manifest.json might not exist)
                        console.log(`⚠ ${filePath} not found in TEST, skipping: ${e.message}`);
                    }
                }
                
                // Fetch icon files (binary - use base64)
                for (const iconPath of iconFiles) {
                    try {
                        const iconFile = await github.getFile(app.testRepo, iconPath);
                        if (iconFile) {
                            // Icons should always have content (they're small)
                            // But check just in case
                            if (!iconFile.content) {
                                console.warn(`⚠ Icon ${iconPath} has no content (too large?), skipping`);
                                continue;
                            }
                            filesToCommit.push({
                                path: iconPath,
                                content: github.cleanBase64(iconFile.content),
                                encoding: 'base64'
                            });
                            console.log(`✓ Found ${iconPath} in TEST`);
                        }
                    } catch (e) {
                        console.log(`⚠ ${iconPath} not found in TEST, skipping`);
                    }
                }
                
                if (filesToCommit.length === 0) {
                    throw new Error('No files found in TEST repo');
                }
                
                addStep('Fetching from TEST', 'complete', `${filesToCommit.length} files, ${formatVersion(testVersion)}`);
                
                addStep('Checking PROD', 'running');
                const prodFileData = await github.getFileContent(app.prodRepo, fullTargetPath);
                const prodVersion = prodFileData ? extractVersionFromHTML(prodFileData.textContent) : null;
                deployment.previousVersion = prodVersion;
                addStep('Checking PROD', 'complete', prodVersion ? formatVersion(prodVersion) : 'Empty');
                
                // 📸 Save rollback snapshot BEFORE promoting
                await saveRollbackSnapshot(appId, 'prod', app.prodRepo, fullTargetPath);
                
                addStep('Deploying', 'running', `${filesToCommit.length} files`);
                
                // Capture time before commit for workflow search
                deployment.preCommitTime = Date.now();
                
                // Use batch commit for multiple files
                const result = await github.batchCommit(
                    app.prodRepo,
                    filesToCommit,
                    `Promote ${app.name} ${formatVersion(testVersion)} from test (${filesToCommit.length} files)`
                );
                
                deployment.commitSha = result.sha;
                deployment.fileCount = filesToCommit.length;
                addStep('Deploying', 'complete', `${result.sha.substring(0, 7)} (${filesToCommit.length} files)`);
                
                addStep('GitHub Pages', 'running');
                try {
                    await github.enablePages(app.prodRepo);
                    addStep('GitHub Pages', 'complete', 'Ready');
                } catch {
                    addStep('GitHub Pages', 'warning', 'Check settings');
                }
                
                if (settings.createTag && testVersion) {
                    addStep('Tagging', 'running');
                    try {
                        await github.createTag(app.prodRepo, `v${testVersion}`, result.sha, 'Release');
                        addStep('Tagging', 'complete', `v${testVersion}`);
                    } catch {
                        addStep('Tagging', 'warning', 'May exist');
                    }
                }
                
                deployment.status = 'success';
                deployment.version = testVersion;
                deployment.url = getGitHubPagesUrl(app.prodRepo, effectiveSubPath);
                updateApp(appId, { currentProdVersion: testVersion, updatedAt: Date.now() });
                
                // Don't refresh immediately - GitHub's CDN needs time to propagate
                // setTimeout(() => refreshAllVersions(), 1000); // DISABLED - causes version revert
                
                // Start monitoring for deployment completion
                if (app?.deployType === 'github-actions') {
                    // For github-actions apps, monitor the workflow
                    addStep('GitHub Actions', 'running', 'Finding workflow...');
                    const searchTime = (deployment.preCommitTime || Date.now()) - 10000;
                    
                    const workflowRun = await github.findRecentWorkflowRun(app.prodRepo, searchTime, 60000);
                    
                    if (workflowRun) {
                        const logsUrl = await github.getWorkflowRunLogsUrl(app.prodRepo, workflowRun.id);
                        addStep('GitHub Actions', 'running', `Workflow #${workflowRun.run_number} running...`);
                        deployment.workflowUrl = logsUrl;
                        setActiveDeployment({ ...deployment });
                        
                        const monitorStartTime = Date.now();
                        const result = await github.waitForWorkflowRun(app.prodRepo, workflowRun.id, 300000, (run) => {
                            addStep('GitHub Actions', 'running', `${run.status}... (${Math.round((Date.now() - monitorStartTime) / 1000)}s)`);
                            setActiveDeployment({ ...deployment });
                            setDeployments(prev => prev.map(d => d.id === deployment.id ? { ...deployment } : d));
                        });
                        
                        if (result.success) {
                            addStep('GitHub Actions', 'complete', `✓ Deployed! (${result.run?.conclusion})`);
                        } else {
                            addStep('GitHub Actions', 'error', `Failed: ${result.conclusion || result.error}`);
                            deployment.status = 'failed';
                            deployment.error = result.conclusion || result.error;
                        }
                    } else {
                        addStep('GitHub Actions', 'warning', 'Workflow not found - check GitHub manually');
                        deployment.workflowUrl = `https://github.com/${app.prodRepo}/actions`;
                        deployment.status = 'success'; // Code committed successfully, just couldn't track workflow
                    }
                } else if (deployment.url && testVersion) {
                    // For regular apps, monitor the live site
                    addStep('GitHub Pages', 'running', 'Waiting for deploy...');
                    monitorLiveDeployment(deployment.url, testVersion, app.prodRepo, (status, detail) => {
                        addStep('GitHub Pages', status, detail);
                        setActiveDeployment({ ...deployment });
                        setDeployments(prev => prev.map(d => d.id === deployment.id ? { ...deployment } : d));
                    }, appId, 'prod');
                }
                
            } catch (error) {
                deployment.status = 'failed';
                deployment.error = error.message;
                addStep('Error', 'error', error.message);
            }
            
            deployment.completedAt = new Date().toISOString();
            setActiveDeployment({ ...deployment });
            setDeployments(prev => prev.map(d => d.id === deployment.id ? deployment : d));
        };
        
        // Rollback
        const handleRollback = async (deploymentToRollbackTo) => {
            const app = apps[deploymentToRollbackTo.appId];
            if (!app) return;
            
            // Ensure subPath is set from defaults (localStorage may have empty string from old config)
            const effectiveSubPath = app.subPath || '';
            const appWithSubPath = { ...app, subPath: effectiveSubPath };
            
            setModal(null);
            
            const repo = deploymentToRollbackTo.repo;
            const targetVersion = deploymentToRollbackTo.version;
            
            const deployment = {
                id: Date.now(), status: 'running', steps: [],
                appId: deploymentToRollbackTo.appId, appName: app.name,
                repo, target: deploymentToRollbackTo.target,
                isRollback: true, version: targetVersion,
                rollbackFromCommit: null,
                rollbackToCommit: deploymentToRollbackTo.commitSha,
                startedAt: new Date().toISOString()
            };
            
            setActiveDeployment(deployment);
            setDeployments(prev => [deployment, ...prev]);
            
            const addStep = (name, status, details = null) => {
                const existingIndex = deployment.steps.findIndex(s => s.name === name);
                if (existingIndex >= 0) {
                    deployment.steps[existingIndex] = { name, status, details };
                } else {
                    deployment.steps.push({ name, status, details });
                }
                setActiveDeployment({ ...deployment });
            };
            
            try {
                // Get full path including subPath
                const fullTargetPath = getRepoFilePath(appWithSubPath, app.targetPath);
                
                addStep('Getting current state', 'running');
                const currentFileData = await github.getFileContent(repo, fullTargetPath);
                // Use textContent which handles both normal and large files
                const currentVersion = currentFileData ? extractVersionFromHTML(currentFileData.textContent) : null;
                deployment.previousVersion = currentVersion;
                addStep('Getting current state', 'complete', formatVersion(currentVersion));
                
                addStep('Fetching rollback version', 'running');
                const rollbackFileData = await github.getFileContentAtCommit(repo, fullTargetPath, deploymentToRollbackTo.commitSha);
                if (!rollbackFileData) throw new Error('Cannot find file at that commit');
                // Use textContent which handles both normal and large files
                const content = rollbackFileData.textContent;
                deployment.fileContent = content;
                addStep('Fetching rollback version', 'complete', formatVersion(targetVersion));
                
                addStep('Rolling back', 'running');
                deployment.preCommitTime = Date.now(); // Capture time before commit for workflow search
                const result = await github.createOrUpdateFile(
                    repo, fullTargetPath, content,
                    `Rollback ${app.name} to ${formatVersion(targetVersion)} (was ${formatVersion(currentVersion)})`,
                    currentFileData?.sha
                );
                deployment.commitSha = result.commit.sha;
                addStep('Rolling back', 'complete', result.commit.sha.substring(0, 7));
                
                deployment.status = 'success';
                deployment.url = getGitHubPagesUrl(repo, effectiveSubPath);
                const versionKey = deploymentToRollbackTo.target === 'prod' ? 'currentProdVersion' : 'currentTestVersion';
                updateApp(deploymentToRollbackTo.appId, { [versionKey]: targetVersion });
                
                // Start monitoring for deployment completion
                if (app?.deployType === 'github-actions') {
                    // For github-actions apps, monitor the workflow
                    addStep('GitHub Actions', 'running', 'Finding workflow...');
                    const searchTime = (deployment.preCommitTime || Date.now()) - 10000;
                    
                    const workflowRun = await github.findRecentWorkflowRun(repo, searchTime, 60000);
                    
                    if (workflowRun) {
                        const logsUrl = await github.getWorkflowRunLogsUrl(repo, workflowRun.id);
                        addStep('GitHub Actions', 'running', `Workflow #${workflowRun.run_number} running...`);
                        deployment.workflowUrl = logsUrl;
                        setActiveDeployment({ ...deployment });
                        
                        const monitorStartTime = Date.now();
                        const result = await github.waitForWorkflowRun(repo, workflowRun.id, 300000, (run) => {
                            addStep('GitHub Actions', 'running', `${run.status}... (${Math.round((Date.now() - monitorStartTime) / 1000)}s)`);
                            setActiveDeployment({ ...deployment });
                            setDeployments(prev => prev.map(d => d.id === deployment.id ? { ...deployment } : d));
                        });
                        
                        if (result.success) {
                            addStep('GitHub Actions', 'complete', `✓ Deployed! (${result.run?.conclusion})`);
                        } else {
                            addStep('GitHub Actions', 'error', `Failed: ${result.conclusion || result.error}`);
                            deployment.status = 'failed';
                            deployment.error = result.conclusion || result.error;
                        }
                    } else {
                        addStep('GitHub Actions', 'warning', 'Workflow not found - check GitHub manually');
                        deployment.workflowUrl = `https://github.com/${repo}/actions`;
                        deployment.status = 'success'; // Code committed successfully, just couldn't track workflow
                    }
                } else if (deployment.url && targetVersion) {
                    // For regular apps, monitor the live site
                    addStep('GitHub Pages', 'running', 'Waiting for deploy...');
                    monitorLiveDeployment(deployment.url, targetVersion, repo, (status, detail) => {
                        addStep('GitHub Pages', status, detail);
                        setActiveDeployment({ ...deployment });
                        setDeployments(prev => prev.map(d => d.id === deployment.id ? { ...deployment } : d));
                    }, deploymentToRollbackTo.appId, deploymentToRollbackTo.target);
                }
                
            } catch (error) {
                deployment.status = 'failed';
                deployment.error = error.message;
                addStep('Error', 'error', error.message);
            }
            
            deployment.completedAt = new Date().toISOString();
            setActiveDeployment({ ...deployment });
            setDeployments(prev => prev.map(d => d.id === deployment.id ? deployment : d));
        };
        
        return (
            <div className="min-h-screen">
                <header className="bg-slate-800 border-b border-slate-700 sticky top-0 z-50">
                    <div className="max-w-6xl mx-auto px-4 py-3">
                        {/* Top row: Logo and main nav */}
                        <div className="flex items-center justify-between">
                            <div className="flex items-center gap-3">
                                <Icons.GameShelfLogo size={32} />
                                <div>
                                    <h1 className="text-lg font-bold">Command Center</h1>
                                    <div className="text-xs text-slate-400 flex items-center gap-1.5">
                                        v{document.querySelector('meta[name="version"]')?.content || '8.19.0'} • Deploy & manage apps
                                        <span title={`Firebase sync: ${syncStatus}`} className="inline-flex items-center">
                                            {syncStatus === 'synced' && <span className="text-green-400" title="Synced with Firebase">☁️</span>}
                                            {syncStatus === 'syncing' && <span className="text-yellow-400 animate-pulse" title="Syncing...">🔄</span>}
                                            {syncStatus === 'offline' && <span className="text-slate-500" title="Offline — using local data">⚡</span>}
                                            {syncStatus === 'error' && <span className="text-red-400" title="Sync error">⚠️</span>}
                                        </span>
                                    </div>
                                </div>
                            </div>
                            <div className="flex items-center gap-1">
                                <button onClick={() => refreshAllVersions()} disabled={refreshing}
                                    className={`p-2 rounded hover:bg-slate-700 ${refreshing ? 'animate-spin text-indigo-400' : 'text-slate-400'}`}
                                    title="Refresh versions">
                                    <Icons.Refresh />
                                </button>
                                {/* Consolidated Navigation - 5 main sections */}
                                {[
                                    { id: 'deploy', icon: '🚀', label: 'Deploy', views: ['dashboard', 'smartdeploy', 'history'] },
                                    { id: 'projects', icon: '📂', label: 'Projects', views: ['projects'] },
                                    { id: 'backlog', icon: '📋', label: 'Backlog', views: ['backlog', 'streams', 'releases'] },
                                    { id: 'monitor', icon: '📊', label: 'Monitor', views: ['portfolio', 'optimize', 'domains', 'users', 'beta', 'firebase', 'integrations', 'issues'] },
                                    { id: 'maintain', icon: '🔧', label: 'Maintain', views: ['cleanup', 'files', 'archive', 'session'] },
                                    { id: 'configure', icon: '⚙️', label: 'Configure', views: ['config', 'setup', 'settings'] }
                                ].map(section => (
                                    <div key={section.id} className="relative group">
                                        {section.views.length === 1 ? (
                                            <button
                                                onClick={() => setView(section.views[0])}
                                                className={`px-3 py-1.5 rounded text-sm flex items-center gap-1 ${
                                                    section.views.includes(view) ? 'bg-indigo-600 text-white' : 'text-slate-400 hover:text-white hover:bg-slate-700'
                                                }`}
                                            >
                                                <span>{section.icon}</span> {section.label}
                                            </button>
                                        ) : (
                                            <>
                                        <button
                                            className={`px-3 py-1.5 rounded text-sm flex items-center gap-1 ${
                                                section.views.includes(view) ? 'bg-indigo-600 text-white' : 'text-slate-400 hover:text-white hover:bg-slate-700'
                                            }`}
                                        >
                                            <span>{section.icon}</span> {section.label}
                                            <span className="text-xs opacity-60">▼</span>
                                        </button>
                                        {/* Dropdown */}
                                        <div className="absolute top-full left-0 mt-1 bg-slate-800 border border-slate-700 rounded-lg shadow-xl opacity-0 invisible group-hover:opacity-100 group-hover:visible transition-all z-50 min-w-[160px]">
                                            {section.views.map(v => (
                                                <button
                                                    key={v}
                                                    onClick={() => setView(v)}
                                                    className={`w-full text-left px-4 py-2 text-sm capitalize hover:bg-slate-700 first:rounded-t-lg last:rounded-b-lg ${
                                                        view === v ? 'bg-indigo-600/30 text-indigo-300' : 'text-slate-300'
                                                    }`}
                                                >
                                                    {v === 'dashboard' && '📋 Dashboard'}
                                                    {v === 'smartdeploy' && '📦 Smart Deploy'}
                                                    {v === 'history' && '📜 Deploy History'}
                                                    {v === 'users' && '👥 Users'}
                                                    {v === 'beta' && '🧪 Beta Program'}
                                                    {v === 'firebase' && '🔥 Firebase'}
                                                    {v === 'integrations' && '⚡ Integrations'}
                                                    {v === 'issues' && '🐛 Issues'}
                                                    {v === 'portfolio' && '📊 Portfolio'}
                                                    {v === 'optimize' && '🎯 Setup Guide'}
                                                    {v === 'domains' && '🌐 Domains'}
                                                    {v === 'cleanup' && '🗑️ Cleanup'}
                                                    {v === 'files' && '📁 Files'}
                                                    {v === 'archive' && '📦 Archive'}
                                                    {v === 'session' && '📝 Session Log'}
                                                    {v === 'config' && '🌍 Environments'}
                                                    {v === 'releases' && '🚢 Releases'}
                                                    {v === 'streams' && '🔀 Streams'}
                                                    {v === 'setup' && '🆕 Setup New App'}
                                                    {v === 'settings' && '🔑 Settings'}
                                                </button>
                                            ))}
                                        </div>
                                            </>
                                        )}
                                    </div>
                                ))}
                            </div>
                        </div>
                        
                        {/* Quick Actions Bar (Phase 4.2) */}
                        <div className="mt-3 pt-3 border-t border-slate-700 flex items-center gap-2 flex-wrap">
                            <span className="text-xs text-slate-500 mr-2">⚡ Quick:</span>
                            <button
                                onClick={() => setView('backlog')}
                                className="px-3 py-1 text-xs bg-indigo-600 hover:bg-indigo-500 rounded-full font-medium transition-colors"
                            >
                                💡 Add Idea
                            </button>
                            <button
                                onClick={() => setView('smartdeploy')}
                                className="px-3 py-1 text-xs bg-green-600 hover:bg-green-500 rounded-full font-medium transition-colors"
                            >
                                🚀 Smart Deploy
                            </button>
                            {stagedFiles.length > 0 && (
                                <button
                                    onClick={() => setModal({ type: 'deployAll' })}
                                    className="px-3 py-1 text-xs bg-green-700 hover:bg-green-600 rounded-full font-medium transition-colors"
                                >
                                    📦 Deploy Staged ({stagedFiles.filter(f => f.fileAction !== 'push-doc').length})
                                </button>
                            )}
                            <button
                                onClick={() => setModal({ type: 'syncEnvs' })}
                                className="px-3 py-1 text-xs bg-slate-700 hover:bg-slate-600 rounded-full font-medium transition-colors"
                            >
                                🔄 Sync TEST→PROD
                            </button>
                            <button
                                onClick={() => setView('portfolio')}
                                className="px-3 py-1 text-xs bg-slate-700 hover:bg-slate-600 rounded-full font-medium transition-colors"
                            >
                                📊 Portfolio
                            </button>
                            
                            {/* Status indicators */}
                            <div className="ml-auto flex items-center gap-3 text-xs">
                                {isFileProtocol && (
                                    <span className="flex items-center gap-1 text-blue-400" title="Running from local file - some features limited">
                                        <span className="w-2 h-2 rounded-full bg-blue-400"></span>
                                        Local
                                    </span>
                                )}
                                <span className={`flex items-center gap-1 ${github ? 'text-green-400' : 'text-red-400'}`}>
                                    <span className={`w-2 h-2 rounded-full ${github ? 'bg-green-400' : 'bg-red-400'}`}></span>
                                    GitHub
                                </span>
                                <span className={`flex items-center gap-1 ${firebaseDb ? 'text-green-400' : 'text-amber-400'}`}>
                                    <span className={`w-2 h-2 rounded-full ${firebaseDb ? 'bg-green-400' : 'bg-amber-400'}`}></span>
                                    Firebase
                                </span>
                                <span className="text-slate-500">
                                    {availableRepos.length} repos
                                </span>
                                
                                {/* Google Auth */}
                                {firebaseAuth && (
                                    firebaseUser ? (
                                        <button onClick={async () => { try { await firebaseAuth.signOut(); } catch {} }}
                                            className="flex items-center gap-1.5 text-green-400 hover:text-green-300 transition-colors"
                                            title={`Signed in as ${firebaseUser.email}\nClick to sign out`}>
                                            <img src={firebaseUser.photoURL || ''} className="w-5 h-5 rounded-full" 
                                                onError={(e) => { e.target.style.display = 'none'; }}
                                            />
                                            <span className="max-w-[100px] truncate">{firebaseUser.displayName?.split(' ')[0] || firebaseUser.email?.split('@')[0]}</span>
                                        </button>
                                    ) : (
                                        <button onClick={async () => {
                                                if (isFileProtocol) return;
                                                try {
                                                    const provider = new firebase.auth.GoogleAuthProvider();
                                                    await firebaseAuth.signInWithPopup(provider);
                                                } catch (e) {
                                                    console.error('Sign in error:', e);
                                                }
                                            }}
                                            disabled={isFileProtocol}
                                            className={`flex items-center gap-1 ${isFileProtocol ? 'text-slate-600 cursor-not-allowed' : 'text-slate-400 hover:text-white'} transition-colors`}
                                            title={isFileProtocol ? 'Google Sign-in requires HTTPS' : 'Sign in with Google'}>
                                            <span className="w-2 h-2 rounded-full bg-slate-500"></span>
                                            Sign In
                                        </button>
                                    )
                                )}
                            </div>
                        </div>
                    </div>
                </header>
                
                <main className="max-w-6xl mx-auto px-4 py-6">
                    {!githubToken && (
                        <div className="mb-6 p-4 bg-amber-900/50 border border-amber-700 rounded-lg">
                            ⚠️ <strong>GitHub Token Required</strong> - Go to Settings
                        </div>
                    )}
                    
                    {tokenExpiryWarning && (
                        <div className={`mb-6 p-4 rounded-lg border flex items-center justify-between ${
                            daysUntilExpiry <= 3 
                                ? 'bg-red-900/50 border-red-700 text-red-200'
                                : 'bg-amber-900/50 border-amber-700 text-amber-200'
                        }`}>
                            <div>
                                {daysUntilExpiry <= 0 
                                    ? <><span className="text-lg mr-2">🚨</span><strong>GitHub token may have expired!</strong></>
                                    : <><span className="text-lg mr-2">{daysUntilExpiry <= 3 ? '🚨' : '⚠️'}</span><strong>GitHub token expires in {daysUntilExpiry} days</strong> ({new Date(tokenExpires).toLocaleDateString()})</>
                                }
                            </div>
                            <button onClick={() => setView('settings')} className="px-3 py-1 bg-slate-700 rounded text-sm hover:bg-slate-600">
                                Go to Settings →
                            </button>
                        </div>
                    )}
                    
                    {/* v8.3.3: Local file protocol warning */}
                    {isFileProtocol && !fileProtocolBannerDismissed && (
                        <div className="mb-6 p-4 rounded-lg border bg-blue-900/30 border-blue-700 text-blue-200">
                            <div className="flex items-start justify-between gap-4">
                                <div className="flex-1">
                                    <div className="flex items-center gap-2 mb-1">
                                        <span className="text-lg">🌐</span>
                                        <strong>Running Locally</strong>
                                    </div>
                                    <p className="text-sm text-blue-300">
                                        Some features require HTTPS (Google Auth, Firebase sync). 
                                        For full functionality, use the deployed version at{' '}
                                        <a href={(() => {
                                                const ccApp = apps['command-center'];
                                                const prodRepo = ccApp?.prodRepo || ccApp?.repos?.prod || '';
                                                if (prodRepo) {
                                                    const [owner, repo] = prodRepo.split('/');
                                                    return `https://${owner}.github.io/${repo}/`;
                                                }
                                                return '#';
                                            })()}
                                            target="_blank" 
                                            className="underline text-blue-200 hover:text-white">
                                            Command Center on GitHub Pages
                                        </a>
                                    </p>
                                </div>
                                <button 
                                    onClick={dismissFileProtocolBanner}
                                    className="px-2 py-1 bg-slate-700 rounded text-xs hover:bg-slate-600 text-slate-300">
                                    Dismiss
                                </button>
                            </div>
                        </div>
                    )}
                    
                    {view === 'dashboard' && (
                        <>
                        {/* Repo Health Alert */}
                        {repoHealthAlert && (
                            <div className="mb-4 p-4 bg-amber-900/20 rounded-xl border border-amber-700/50">
                                <div className="flex items-center justify-between mb-2">
                                    <div className="text-sm font-medium text-amber-300 flex items-center gap-2">
                                        ⚠️ Repo Health Check — {repoHealthAlert.issues.length} repo{repoHealthAlert.issues.length > 1 ? 's' : ''} with unexpected files
                                    </div>
                                    <div className="flex gap-2">
                                        <button onClick={() => { setCleanupInitialTab('reset'); setView('cleanup'); setRepoHealthAlert(null); }}
                                            className="px-3 py-1 text-xs bg-amber-700 hover:bg-amber-600 text-amber-100 rounded font-medium">
                                            🔄 Open Repo Reset
                                        </button>
                                        <button onClick={() => setRepoHealthAlert(null)}
                                            className="px-2 py-1 text-xs text-slate-400 hover:text-white">
                                            ✕ Dismiss
                                        </button>
                                    </div>
                                </div>
                                <div className="space-y-1 text-xs">
                                    {repoHealthAlert.issues.map((issue, i) => (
                                        <div key={i} className="flex items-center gap-2 text-amber-400/80">
                                            <span>{issue.appIcon === 'gs-logo' ? '🎮' : issue.appIcon}</span>
                                            <span className="font-medium">{issue.appName}</span>
                                            <span className="text-amber-600">({issue.target})</span>
                                            <span className="text-slate-500">—</span>
                                            <span>{issue.unexpectedFiles.length} unexpected: {issue.unexpectedFiles.slice(0, 3).map(f => f.name).join(', ')}{issue.unexpectedFiles.length > 3 ? ` +${issue.unexpectedFiles.length - 3} more` : ''}</span>
                                        </div>
                                    ))}
                                </div>
                            </div>
                        )}
                        <DashboardView
                            apps={apps} config={config} stagedFiles={stagedFiles} setStagedFiles={setStagedFiles} github={github}
                            onFileDrop={handleFileDrop} onRemove={removeStaged}
                            onDeploy={handleDeploy} onBatchDeploy={handleBatchDeploy}
                            onPromote={(id) => {
                                console.log('[Promote Modal] Opening for:', id);
                                console.log('[Promote Modal] App state:', apps[id]);
                                console.log('[Promote Modal] testRepo:', apps[id]?.testRepo);
                                console.log('[Promote Modal] prodRepo:', apps[id]?.prodRepo);
                                setModal({ type: 'promote', data: { appId: id } });
                            }}
                            activeDeployments={activeDeployments}
                            removeActiveDeployment={removeActiveDeployment}
                            refreshing={refreshing}
                            onUpdateStagedFile={updateStagedFile}
                            deployingRepos={deployingRepos}
                            showConfirm={showConfirm}
                            showAlert={showAlert}
                            showPrompt={showPrompt}
                            globalIssues={globalIssues}
                            globalWorkItems={globalWorkItems}
                            globalSessions={globalSessions}
                            globalActivity={globalActivity}
                            deployments={deployments}
                            firebaseUid={firebaseUid}
                            setModal={setModal}
                            linkIssuesToVersion={linkIssuesToVersion}
                            setView={setView}
                            rollbackSnapshots={rollbackSnapshots}
                            onQuickRollback={quickRollback}
                        />
                        </>
                    )}
                    
                    {view === 'archive' && (
                        <ArchiveView
                            apps={apps}
                            config={config}
                            github={github}
                            showAlert={showAlert}
                            showConfirm={showConfirm}
                            showPrompt={showPrompt}
                            globalIssues={globalIssues}
                            sessionLog={sessionLog}
                            deployments={deployments}
                        />
                    )}
                    
                    {view === 'files' && (
                        <RepoFilesView
                            apps={apps} github={github}
                            repoFiles={repoFiles} onLoadRepo={loadRepoFiles}
                            selectedRepo={selectedRepoForBrowse} onSelectRepo={setSelectedRepoForBrowse}
                            selectedAppKey={selectedAppKeyForBrowse} onSelectAppKey={setSelectedAppKeyForBrowse}
                            markedForDeletion={markedForDeletion} setMarkedForDeletion={setMarkedForDeletion}
                            onDeleteMarked={() => setModal({ type: 'confirmDelete' })}
                            showAlert={showAlert}
                        />
                    )}
                    
                    {view === 'firebase' && (
                        <FirebaseView showAlert={showAlert} showConfirm={showConfirm} showPrompt={showPrompt} />
                    )}
                    
                    {view === 'portfolio' && (
                        <PortfolioView
                            apps={apps}
                            config={config}
                            globalWorkItems={globalWorkItems}
                            globalSessions={globalSessions}
                            deployments={deployments}
                            showAlert={showAlert}
                        />
                    )}
                    
                    {view === 'optimize' && (
                        <EnvironmentOptimizationView
                            apps={apps}
                            config={config}
                            globalSessions={globalSessions}
                            showAlert={showAlert}
                        />
                    )}
                    
                    {view === 'domains' && (
                        <DomainsView
                            apps={apps}
                            config={config}
                            showAlert={showAlert}
                            showConfirm={showConfirm}
                        />
                    )}
                    
                    {view === 'users' && (
                        <UsersView showAlert={showAlert} />
                    )}
                    
                    {view === 'beta' && (
                        <BetaAnalyticsView showAlert={showAlert} />
                    )}
                    
                    {view === 'integrations' && (
                        <IntegrationsView showAlert={showAlert} showConfirm={showConfirm} showPrompt={showPrompt} />
                    )}
                    
                    {view === 'cleanup' && (
                        <CleanupView 
                            github={github} 
                            config={config}
                            apps={apps}
                            availableRepos={availableRepos}
                            showAlert={showAlert} 
                            showConfirm={showConfirm}
                            initialTab={cleanupInitialTab}
                            onTabConsumed={() => setCleanupInitialTab(null)}
                        />
                    )}
                    
                    {view === 'projects' && (
                        <div className="max-w-6xl mx-auto">
                            <div className="flex items-center gap-3 mb-6">
                                <span className="text-2xl">📂</span>
                                <div>
                                    <h1 className="text-2xl font-bold">Projects & Apps</h1>
                                    <p className="text-slate-400 text-sm">Manage project groupings and app configurations</p>
                                </div>
                            </div>
                            <ProjectsTab 
                                config={config}
                                updateConfig={handleConfigChange}
                                activeEnvs={ConfigManager.getActiveEnvironments(config)}
                                envColors={{
                                    test: { text: 'text-blue-400', border: 'border-blue-700' },
                                    prod: { text: 'text-green-400', border: 'border-green-700' },
                                    dev: { text: 'text-yellow-400', border: 'border-yellow-700' },
                                    beta: { text: 'text-purple-400', border: 'border-purple-700' }
                                }}
                                github={github}
                                githubOwner={availableRepos[0]?.owner || 'stewartdavidp-ship-it'}
                                availableRepos={availableRepos}
                                showAlert={showAlert}
                                showConfirm={showConfirm}
                                onRefreshRepos={refreshRepos}
                                deployments={deployments}
                                globalWorkItems={globalWorkItems}
                                firebaseUid={firebaseUid}
                                globalStreams={globalStreams}
                            />
                        </div>
                    )}
                    
                    {view === 'history' && (
                        <HistoryView 
                            deployments={deployments} apps={apps}
                            onRollback={(d) => setModal({ type: 'rollback', data: d })}
                            globalWorkItems={globalWorkItems}
                            globalSessions={globalSessions}
                        />
                    )}
                    
                    {view === 'smartdeploy' && (
                        <SmartDeployView
                            apps={apps}
                            github={github}
                            onDeploy={handleDeploy}
                            onBatchDeploy={handleBatchDeploy}
                            showAlert={showAlert}
                            showConfirm={showConfirm}
                            activeDeployments={activeDeployments}
                            removeActiveDeployment={removeActiveDeployment}
                            pendingFile={pendingGsActiveFile}
                            clearPendingFile={() => setPendingGsActiveFile(null)}
                        />
                    )}
                    
                    {view === 'session' && (
                        <SessionLogView 
                            apps={apps}
                            sessionLog={sessionLog}
                            setSessionLog={setSessionLog}
                            deployments={deployments}
                            github={github}
                            onFileDrop={handleFileDrop}
                            showAlert={showAlert}
                            globalSessions={globalSessions}
                            globalWorkItems={globalWorkItems}
                            firebaseUid={firebaseUid}
                            config={config}
                            globalStreams={globalStreams}
                            globalInterfaces={globalInterfaces}
                            globalDependencies={globalDependencies}
                            globalDependencyAlerts={globalDependencyAlerts}
                        />
                    )}
                    
                    {view === 'issues' && (
                        <IssuesView apps={apps} deployments={deployments} showAlert={showAlert} showConfirm={showConfirm} showPrompt={showPrompt} setView={setView} globalWorkItems={globalWorkItems} />
                    )}
                    
                    {view === 'backlog' && (
                        <BacklogView apps={apps} showAlert={showAlert} showConfirm={showConfirm} showPrompt={showPrompt} setView={setView} config={config} globalStreams={globalStreams} />
                    )}
                    
                    {view === 'releases' && (
                        <ReleaseCoordinationView apps={apps} config={config} globalWorkItems={globalWorkItems} globalSessions={globalSessions} deployments={deployments} showAlert={showAlert} showConfirm={showConfirm} showPrompt={showPrompt} setView={setView} />
                    )}
                    
                    {view === 'streams' && (
                        <WorkStreamsView apps={apps} config={config} globalWorkItems={globalWorkItems} globalStreams={globalStreams} globalInterfaces={globalInterfaces} globalDependencies={globalDependencies} globalDependencyAlerts={globalDependencyAlerts || []} showAlert={showAlert} showConfirm={showConfirm} showPrompt={showPrompt} setView={setView} />
                    )}
                    
                    {view === 'config' && (
                        <ConfigView 
                            config={config} 
                            onConfigChange={handleConfigChange}
                            showAlert={showAlert}
                            showConfirm={showConfirm}
                            github={github}
                            availableRepos={availableRepos}
                            onRefreshRepos={refreshRepos}
                        />
                    )}
                    
                    {view === 'settings' && (
                        <SettingsView token={githubToken} setToken={setGithubToken} settings={settings} setSettings={setSettings} repoCount={availableRepos.length} syncStatus={syncStatus} onForceSync={handleForceSync} config={config} onConfigChange={handleConfigChange} />
                    )}
                    
                    {view === 'setup' && (
                        <SetupNewAppView
                            apps={apps}
                            github={github}
                            config={config}
                            updateConfig={handleConfigChange}
                            showAlert={showAlert}
                            showConfirm={showConfirm}
                            onRefreshRepos={refreshRepos}
                            githubOwner={availableRepos[0]?.owner || availableRepos[0]?.fullName?.split('/')[0] || 'stewartdavidp-ship-it'}
                            firebaseUid={firebaseUid}
                        />
                    )}
                    
                    {/* Modals */}
                    {modal?.type === 'promote' && (
                        <PromoteModal app={apps[modal.data.appId]} onConfirm={() => handlePromote(modal.data.appId)} onCancel={() => setModal(null)} />
                    )}
                    
                    {modal?.type === 'rollback' && (
                        <RollbackModal deployment={modal.data} apps={apps} onConfirm={() => handleRollback(modal.data)} onCancel={() => setModal(null)} />
                    )}
                    
                    {modal?.type === 'versionWarning' && (
                        <VersionWarningModal
                            data={modal.data}
                            onForce={() => { setModal(null); handleDeploy(modal.data.file, modal.data.appId, modal.data.target, true); }}
                            onCancel={() => setModal(null)}
                        />
                    )}
                    
                    {modal?.type === 'confirmDelete' && (
                        <ConfirmDeleteModal
                            files={markedForDeletion}
                            onConfirm={handleDeleteMarkedFiles}
                            onCancel={() => setModal(null)}
                        />
                    )}
                    
                    {/* Deploy All Modal */}
                    {modal?.type === 'deployAll' && (
                        <DeployAllModal
                            stagedFiles={stagedFiles}
                            apps={apps}
                            onConfirm={async (files) => {
                                setModal(null);
                                
                                // Split files by action type
                                const deployFiles = files.filter(f => f.fileAction !== 'push-doc');
                                const docFiles = files.filter(f => f.fileAction === 'push-doc');
                                
                                // Deploy files to GitHub Pages
                                for (const file of deployFiles) {
                                    await handleDeploy(file, file.suggestedApp || file.appId, file.target || 'test');
                                }
                                
                                // Push doc files to source repo
                                if (docFiles.length > 0 && github) {
                                    // Group docs by app
                                    const docsByApp = {};
                                    for (const doc of docFiles) {
                                        const appId = doc.suggestedApp || doc.appId;
                                        if (!docsByApp[appId]) docsByApp[appId] = [];
                                        docsByApp[appId].push(doc);
                                    }
                                    
                                    const pushedDocIds = [];
                                    for (const [appId, appDocs] of Object.entries(docsByApp)) {
                                        const app = apps[appId];
                                        if (!app) continue;
                                        const repo = app.repos?.prod || app.prodRepo || app.repos?.test || app.testRepo;
                                        if (!repo) {
                                            console.warn(`No repo configured for ${appId}, skipping doc push`);
                                            continue;
                                        }
                                        
                                        for (const doc of appDocs) {
                                            try {
                                                // Check for existing file to get SHA
                                                const existing = await github.getFile(repo, doc.targetPath);
                                                const sha = existing?.sha || null;
                                                const action = sha ? 'Update' : 'Add';
                                                
                                                await github.createOrUpdateFile(
                                                    repo,
                                                    doc.targetPath,
                                                    doc.content,
                                                    `${action} ${doc.name} via Command Center`,
                                                    sha
                                                );
                                                console.log(`✅ Pushed ${doc.name} → ${repo}/${doc.targetPath}`);
                                                pushedDocIds.push(doc.id);
                                            } catch (e) {
                                                console.error(`❌ Failed to push ${doc.name}:`, e.message);
                                            }
                                        }
                                    }
                                    // Remove successfully pushed docs from staged files
                                    if (pushedDocIds.length > 0) {
                                        setStagedFiles(prev => prev.filter(f => !pushedDocIds.includes(f.id)));
                                    }
                                }
                            }}
                            onCancel={() => setModal(null)}
                        />
                    )}
                    
                    {/* Sync Environments Modal */}
                    {modal?.type === 'syncEnvs' && (
                        <SyncEnvsModal
                            apps={apps}
                            github={github}
                            onConfirm={async (selectedApps) => {
                                setModal(null);
                                for (const appId of selectedApps) {
                                    await handlePromote(appId);
                                }
                            }}
                            onCancel={() => setModal(null)}
                            showAlert={showAlert}
                        />
                    )}
                    
                    {/* Version Bump Modal */}
                    {modal?.type === 'versionBump' && (
                        <VersionBumpModal
                            apps={apps}
                            onConfirm={async (bumps) => {
                                setModal(null);
                                await showAlert(`Version bumps prepared!\n\nTo apply, you'll need to update the source files and redeploy.\n\n${bumps.map(b => `${b.app}: ${b.current} → ${b.new}`).join('\n')}`, 'Version Bump Preview');
                            }}
                            onCancel={() => setModal(null)}
                        />
                    )}
                    
                    {/* Custom Dialog Modal (replaces native alert/confirm/prompt) */}
                    {dialog && (
                        <DialogModal
                            type={dialog.type}
                            title={dialog.title}
                            message={dialog.message}
                            defaultValue={dialog.defaultValue}
                            confirmText={dialog.confirmText}
                            cancelText={dialog.cancelText}
                            onConfirm={(value) => {
                                if (dialog.onConfirm) dialog.onConfirm(value);
                                setDialog(null);
                            }}
                            onCancel={() => {
                                if (dialog.onCancel) dialog.onCancel();
                                setDialog(null);
                            }}
                        />
                    )}
                </main>
            </div>
        );
    }

    // =========================================================================
    // VERSION WARNING MODAL
    // =========================================================================
    
    function VersionWarningModal({ data, onForce, onCancel }) {
        const { currentVersion, newVersion, target } = data;
        const isEqual = compareVersions(newVersion, currentVersion) === 0;
        
        return (
            <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
                <div className="bg-slate-800 rounded-xl border border-red-700 p-6 max-w-md w-full fade-in">
                    <h2 className="text-xl font-bold mb-4 flex items-center gap-2 text-red-400">
                        <Icons.AlertTriangle /> Version Conflict
                    </h2>
                    
                    <div className="mb-4 p-4 bg-red-900/30 rounded-lg">
                        <div className="text-center mb-3">
                            <div className="text-sm text-slate-400">Currently Deployed</div>
                            <div className="text-2xl font-mono text-green-400">{formatVersion(currentVersion)}</div>
                        </div>
                        <div className="text-center text-2xl">↓</div>
                        <div className="text-center mt-3">
                            <div className="text-sm text-slate-400">Trying to Deploy</div>
                            <div className="text-2xl font-mono text-red-400">{formatVersion(newVersion)}</div>
                        </div>
                    </div>
                    
                    <p className="text-slate-300 mb-4">
                        {isEqual 
                            ? `You're deploying the same version that's already on ${target.toUpperCase()}.`
                            : `You're deploying an older version than what's currently on ${target.toUpperCase()}.`
                        }
                    </p>
                    
                    <div className="flex gap-3">
                        <button onClick={onCancel} className="flex-1 p-2 bg-slate-700 rounded">Cancel</button>
                        <button onClick={onForce} className="flex-1 p-2 bg-red-600 rounded flex items-center justify-center gap-2">
                            <Icons.AlertTriangle className="w-4 h-4" /> Force Deploy
                        </button>
                    </div>
                </div>
            </div>
        );
    }

    // =========================================================================
    // DEPLOY ALL MODAL (v8.0)
    // =========================================================================
    
    function DeployAllModal({ stagedFiles, apps, onConfirm, onCancel }) {
        const [selectedFiles, setSelectedFiles] = React.useState(new Set(stagedFiles.map((_, i) => i)));
        const [target, setTarget] = React.useState('test');
        
        const deployFiles = stagedFiles.filter(f => f.fileAction !== 'push-doc');
        const docFiles = stagedFiles.filter(f => f.fileAction === 'push-doc');
        
        const toggleFile = (idx) => {
            setSelectedFiles(prev => {
                const newSet = new Set(prev);
                if (newSet.has(idx)) newSet.delete(idx);
                else newSet.add(idx);
                return newSet;
            });
        };
        
        const handleConfirm = () => {
            const files = stagedFiles.filter((_, i) => selectedFiles.has(i)).map(f => ({ ...f, target }));
            onConfirm(files);
        };
        
        const selectedDeployCount = deployFiles.filter((_, i) => selectedFiles.has(stagedFiles.indexOf(deployFiles[i]))).length;
        const selectedDocCount = docFiles.filter(f => selectedFiles.has(stagedFiles.indexOf(f))).length;
        
        return (
            <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
                <div className="bg-slate-800 rounded-xl border border-green-700 p-6 max-w-lg w-full fade-in">
                    <h2 className="text-xl font-bold mb-4 flex items-center gap-2 text-green-400">
                        🚀 Deploy & Push All Files
                    </h2>
                    
                    <div className="mb-4">
                        <label className="text-sm text-slate-400 block mb-2">Deploy Target Environment</label>
                        <div className="flex gap-2">
                            {['test', 'prod'].map(t => (
                                <button
                                    key={t}
                                    onClick={() => setTarget(t)}
                                    className={`flex-1 py-2 rounded font-medium ${
                                        target === t 
                                            ? t === 'prod' ? 'bg-green-600' : 'bg-blue-600'
                                            : 'bg-slate-700'
                                    }`}
                                >
                                    {t.toUpperCase()}
                                </button>
                            ))}
                        </div>
                    </div>
                    
                    <div className="mb-4 max-h-64 overflow-y-auto bg-slate-900 rounded-lg">
                        {deployFiles.length > 0 && (
                            <div className="px-3 py-1.5 bg-slate-800 text-xs font-medium text-slate-400 border-b border-slate-700 sticky top-0">
                                🚀 Deploy to GitHub Pages ({deployFiles.length})
                            </div>
                        )}
                        {deployFiles.map((file) => {
                            const idx = stagedFiles.indexOf(file);
                            return (
                            <div
                                key={idx}
                                onClick={() => toggleFile(idx)}
                                className={`flex items-center gap-3 p-3 border-b border-slate-800 cursor-pointer hover:bg-slate-800 ${
                                    selectedFiles.has(idx) ? 'bg-slate-800/50' : ''
                                }`}
                            >
                                <input type="checkbox" checked={selectedFiles.has(idx)} readOnly className="w-4 h-4" />
                                <span className="text-lg">{apps[file.suggestedApp]?.icon ? (() => { const icon = apps[file.suggestedApp].icon; return icon === 'gs-logo' ? '🎮' : icon; })() : '📄'}</span>
                                <div className="flex-1 min-w-0">
                                    <div className="font-medium truncate">{file.name}</div>
                                    <div className="text-xs text-slate-500">{apps[file.suggestedApp]?.name || 'Unknown'} • {file.version ? `v${file.version}` : file.targetPath}</div>
                                </div>
                            </div>
                            );
                        })}
                        {docFiles.length > 0 && (
                            <div className="px-3 py-1.5 bg-cyan-900/30 text-xs font-medium text-cyan-400 border-b border-slate-700 sticky top-0">
                                📄 Push docs to repo ({docFiles.length})
                            </div>
                        )}
                        {docFiles.map((file) => {
                            const idx = stagedFiles.indexOf(file);
                            return (
                            <div
                                key={idx}
                                onClick={() => toggleFile(idx)}
                                className={`flex items-center gap-3 p-3 border-b border-slate-800 cursor-pointer hover:bg-slate-800 ${
                                    selectedFiles.has(idx) ? 'bg-cyan-900/20' : ''
                                }`}
                            >
                                <input type="checkbox" checked={selectedFiles.has(idx)} readOnly className="w-4 h-4" />
                                <span className="text-lg">📄</span>
                                <div className="flex-1 min-w-0">
                                    <div className="font-medium truncate">{file.name}</div>
                                    <div className="text-xs text-cyan-400/70">{file.targetPath}</div>
                                </div>
                            </div>
                            );
                        })}
                    </div>
                    
                    <div className="flex gap-3">
                        <button onClick={onCancel} className="flex-1 p-2 bg-slate-700 rounded">Cancel</button>
                        <button
                            onClick={handleConfirm}
                            disabled={selectedFiles.size === 0}
                            className="flex-1 p-2 bg-green-600 hover:bg-green-500 disabled:opacity-50 rounded font-medium"
                        >
                            {selectedDeployCount > 0 && selectedDocCount > 0
                                ? `Deploy ${selectedDeployCount} + Push ${selectedDocCount} Docs`
                                : selectedDocCount > 0
                                    ? `Push ${selectedDocCount} Doc(s) to Repo`
                                    : `Deploy ${selectedDeployCount} File(s) to ${target.toUpperCase()}`
                            }
                        </button>
                    </div>
                </div>
            </div>
        );
    }

    // =========================================================================
    // SYNC ENVIRONMENTS MODAL (v8.0)
    // =========================================================================
    
    function SyncEnvsModal({ apps, github, onConfirm, onCancel, showAlert }) {
        const [selectedApps, setSelectedApps] = React.useState(new Set());
        const [loading, setLoading] = React.useState(false);
        
        // Filter to apps that have both test and prod repos
        const syncableApps = Object.values(apps).filter(app => 
            app.repos?.test && app.repos?.prod && app.versions?.test
        );
        
        const toggleApp = (appId) => {
            setSelectedApps(prev => {
                const newSet = new Set(prev);
                if (newSet.has(appId)) newSet.delete(appId);
                else newSet.add(appId);
                return newSet;
            });
        };
        
        const selectAll = () => {
            setSelectedApps(new Set(syncableApps.map(a => a.id)));
        };
        
        return (
            <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
                <div className="bg-slate-800 rounded-xl border border-blue-700 p-6 max-w-lg w-full fade-in">
                    <h2 className="text-xl font-bold mb-4 flex items-center gap-2 text-blue-400">
                        🔄 Sync TEST → PROD
                    </h2>
                    
                    <p className="text-sm text-slate-400 mb-4">
                        Promote TEST versions to PROD for selected apps.
                    </p>
                    
                    <div className="flex justify-end mb-2">
                        <button onClick={selectAll} className="text-xs text-indigo-400 hover:text-indigo-300">
                            Select All
                        </button>
                    </div>
                    
                    <div className="mb-4 max-h-64 overflow-y-auto bg-slate-900 rounded-lg">
                        {syncableApps.length === 0 ? (
                            <div className="p-4 text-center text-slate-500">
                                No apps with TEST→PROD repos configured
                            </div>
                        ) : (
                            syncableApps.map(app => {
                                const testV = app.versions?.test || '?';
                                const prodV = app.versions?.prod || '?';
                                const needsSync = testV !== prodV;
                                
                                return (
                                    <div
                                        key={app.id}
                                        onClick={() => toggleApp(app.id)}
                                        className={`flex items-center gap-3 p-3 border-b border-slate-800 cursor-pointer hover:bg-slate-800 ${
                                            selectedApps.has(app.id) ? 'bg-slate-800/50' : ''
                                        }`}
                                    >
                                        <input type="checkbox" checked={selectedApps.has(app.id)} readOnly className="w-4 h-4" />
                                        <span className="text-lg">{app.icon}</span>
                                        <div className="flex-1">
                                            <div className="font-medium">{app.name}</div>
                                            <div className="text-xs">
                                                <span className="text-blue-400">TEST: {testV}</span>
                                                <span className="mx-2">→</span>
                                                <span className="text-green-400">PROD: {prodV}</span>
                                                {needsSync && <span className="ml-2 text-amber-400">(out of sync)</span>}
                                            </div>
                                        </div>
                                    </div>
                                );
                            })
                        )}
                    </div>
                    
                    <div className="flex gap-3">
                        <button onClick={onCancel} className="flex-1 p-2 bg-slate-700 rounded">Cancel</button>
                        <button
                            onClick={() => onConfirm(Array.from(selectedApps))}
                            disabled={selectedApps.size === 0 || loading}
                            className="flex-1 p-2 bg-blue-600 hover:bg-blue-500 disabled:opacity-50 rounded font-medium"
                        >
                            Sync {selectedApps.size} App(s)
                        </button>
                    </div>
                </div>
            </div>
        );
    }

    // =========================================================================
    // VERSION BUMP MODAL (v8.0)
    // =========================================================================
    
    function VersionBumpModal({ apps, onConfirm, onCancel }) {
        const [bumpType, setBumpType] = React.useState('patch'); // patch, minor, major
        const [selectedApps, setSelectedApps] = React.useState(new Set());
        
        const bumpableApps = Object.values(apps).filter(app => app.versions?.prod || app.versions?.test);
        
        const toggleApp = (appId) => {
            setSelectedApps(prev => {
                const newSet = new Set(prev);
                if (newSet.has(appId)) newSet.delete(appId);
                else newSet.add(appId);
                return newSet;
            });
        };
        
        const selectAll = () => {
            setSelectedApps(new Set(bumpableApps.map(a => a.id)));
        };
        
        const bumpVersion = (version, type) => {
            if (!version) return '1.0.0';
            const parts = version.split('.').map(Number);
            while (parts.length < 3) parts.push(0);
            
            if (type === 'major') {
                parts[0]++;
                parts[1] = 0;
                parts[2] = 0;
            } else if (type === 'minor') {
                parts[1]++;
                parts[2] = 0;
            } else {
                parts[2]++;
            }
            
            return parts.join('.');
        };
        
        const handleConfirm = () => {
            const bumps = Array.from(selectedApps).map(appId => {
                const app = apps[appId];
                const current = app.versions?.prod || app.versions?.test || '1.0.0';
                return {
                    appId,
                    app: app.name,
                    current,
                    new: bumpVersion(current, bumpType)
                };
            });
            onConfirm(bumps);
        };
        
        return (
            <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
                <div className="bg-slate-800 rounded-xl border border-purple-700 p-6 max-w-lg w-full fade-in">
                    <h2 className="text-xl font-bold mb-4 flex items-center gap-2 text-purple-400">
                        📈 Version Bump
                    </h2>
                    
                    <div className="mb-4">
                        <label className="text-sm text-slate-400 block mb-2">Bump Type</label>
                        <div className="flex gap-2">
                            {[
                                { id: 'patch', label: 'Patch', desc: '1.0.0 → 1.0.1' },
                                { id: 'minor', label: 'Minor', desc: '1.0.0 → 1.1.0' },
                                { id: 'major', label: 'Major', desc: '1.0.0 → 2.0.0' }
                            ].map(t => (
                                <button
                                    key={t.id}
                                    onClick={() => setBumpType(t.id)}
                                    className={`flex-1 py-2 px-3 rounded text-sm ${
                                        bumpType === t.id ? 'bg-purple-600' : 'bg-slate-700'
                                    }`}
                                >
                                    <div className="font-medium">{t.label}</div>
                                    <div className="text-xs opacity-60">{t.desc}</div>
                                </button>
                            ))}
                        </div>
                    </div>
                    
                    <div className="flex justify-end mb-2">
                        <button onClick={selectAll} className="text-xs text-indigo-400 hover:text-indigo-300">
                            Select All
                        </button>
                    </div>
                    
                    <div className="mb-4 max-h-64 overflow-y-auto bg-slate-900 rounded-lg">
                        {bumpableApps.map(app => {
                            const current = app.versions?.prod || app.versions?.test || '1.0.0';
                            const newV = bumpVersion(current, bumpType);
                            
                            return (
                                <div
                                    key={app.id}
                                    onClick={() => toggleApp(app.id)}
                                    className={`flex items-center gap-3 p-3 border-b border-slate-800 cursor-pointer hover:bg-slate-800 ${
                                        selectedApps.has(app.id) ? 'bg-slate-800/50' : ''
                                    }`}
                                >
                                    <input type="checkbox" checked={selectedApps.has(app.id)} readOnly className="w-4 h-4" />
                                    <span className="text-lg">{app.icon}</span>
                                    <div className="flex-1">
                                        <div className="font-medium">{app.name}</div>
                                    </div>
                                    <div className="text-sm font-mono">
                                        <span className="text-slate-400">{current}</span>
                                        <span className="mx-2 text-purple-400">→</span>
                                        <span className="text-purple-300">{newV}</span>
                                    </div>
                                </div>
                            );
                        })}
                    </div>
                    
                    <div className="p-3 bg-amber-900/30 border border-amber-700 rounded-lg mb-4 text-sm">
                        <strong>Note:</strong> This generates a preview. To apply version bumps, 
                        update the source files (index.html, sw.js) and redeploy.
                    </div>
                    
                    <div className="flex gap-3">
                        <button onClick={onCancel} className="flex-1 p-2 bg-slate-700 rounded">Cancel</button>
                        <button
                            onClick={handleConfirm}
                            disabled={selectedApps.size === 0}
                            className="flex-1 p-2 bg-purple-600 hover:bg-purple-500 disabled:opacity-50 rounded font-medium"
                        >
                            Preview Bumps ({selectedApps.size})
                        </button>
                    </div>
                </div>
            </div>
        );
    }

    // =========================================================================
    // ROLLBACK MODAL
    // =========================================================================
    
    function RollbackModal({ deployment, apps, onConfirm, onCancel }) {
        const app = apps[deployment.appId];
        
        return (
            <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
                <div className="bg-slate-800 rounded-xl border border-amber-700 p-6 max-w-md w-full fade-in">
                    <h2 className="text-xl font-bold mb-4 flex items-center gap-2 text-amber-400">
                        <Icons.Rewind /> Rollback
                    </h2>
                    
                    <div className="mb-4 p-4 bg-slate-900 rounded-lg">
                        <div className="flex items-center gap-2 mb-2">
                            <AppIcon icon={app?.icon} size={24} />
                            <span className="font-semibold">{app?.name}</span>
                            <span className={`text-xs px-1.5 rounded ${deployment.target === 'prod' ? 'bg-green-900 text-green-300' : 'bg-blue-900 text-blue-300'}`}>
                                {deployment.target?.toUpperCase()}
                            </span>
                        </div>
                        <div className="text-sm text-slate-400">
                            Rolling back to <span className="text-amber-400 font-mono">{formatVersion(deployment.version)}</span>
                        </div>
                        <div className="text-xs text-slate-500 mt-1">
                            Commit: {deployment.commitSha?.substring(0, 7)} • {formatDate(deployment.completedAt)}
                        </div>
                    </div>
                    
                    <p className="text-slate-300 text-sm mb-4">
                        This will restore the exact code from this deployment. A new commit will be created for audit purposes.
                    </p>
                    
                    <div className="flex gap-3">
                        <button onClick={onCancel} className="flex-1 p-2 bg-slate-700 rounded">Cancel</button>
                        <button onClick={onConfirm} className="flex-1 p-2 bg-amber-600 rounded flex items-center justify-center gap-2">
                            <Icons.Rewind className="w-4 h-4" /> Rollback
                        </button>
                    </div>
                </div>
            </div>
        );
    }

    // =========================================================================
    // PROMOTE MODAL
    // =========================================================================
    
    function PromoteModal({ app, onConfirm, onCancel }) {
        if (!app) return null;
        return (
            <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
                <div className="bg-slate-800 rounded-xl border border-slate-700 p-6 max-w-lg w-full fade-in">
                    <h2 className="text-xl font-bold mb-4">⚡ Promote to Production</h2>
                    
                    <div className="flex items-center justify-center gap-4 mb-4">
                        <div className="p-3 bg-blue-900/30 border border-blue-700 rounded text-center">
                            <div className="text-xs text-blue-400">TEST</div>
                            <div className="font-mono">{app.testRepo?.split('/')[1]}</div>
                            <div className="text-sm text-slate-400">{formatVersion(app.currentTestVersion)}</div>
                        </div>
                        <div className="text-2xl">→</div>
                        <div className="p-3 bg-green-900/30 border border-green-700 rounded text-center">
                            <div className="text-xs text-green-400">PROD</div>
                            <div className="font-mono">{app.prodRepo?.split('/')[1]}</div>
                            <div className="text-sm text-slate-400">{formatVersion(app.currentProdVersion)}</div>
                        </div>
                    </div>
                    
                    <div className="bg-slate-900 rounded p-3 mb-4 text-sm">
                        <strong>This will:</strong>
                        <ol className="list-decimal list-inside mt-2 space-y-1 text-slate-300">
                            <li>Copy {app.targetPath} from TEST to PROD</li>
                            <li>Create release tag {formatVersion(app.currentTestVersion)}</li>
                            <li>GitHub Pages will deploy (~30s)</li>
                        </ol>
                    </div>
                    
                    <div className="flex gap-3">
                        <button onClick={onCancel} className="flex-1 p-2 bg-slate-700 rounded">Cancel</button>
                        <button onClick={onConfirm} className="flex-1 p-2 bg-green-600 rounded">
                            🚀 Promote {formatVersion(app.currentTestVersion)}
                        </button>
                    </div>
                </div>
            </div>
        );
    }

    // =========================================================================
    // CONFIRM DELETE MODAL
    // =========================================================================
    
    function ConfirmDeleteModal({ files, onConfirm, onCancel }) {
        return (
            <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
                <div className="bg-slate-800 rounded-xl border border-red-700 p-6 max-w-md w-full fade-in">
                    <h2 className="text-xl font-bold mb-4 flex items-center gap-2 text-red-400">
                        <Icons.Trash /> Confirm Deletion
                    </h2>
                    
                    <p className="text-slate-300 mb-4">
                        Delete {files.length} file{files.length !== 1 ? 's' : ''}? This cannot be undone.
                    </p>
                    
                    <div className="max-h-40 overflow-y-auto mb-4 space-y-1">
                        {files.map((f, i) => (
                            <div key={i} className="text-sm text-slate-400 flex items-center gap-2">
                                <Icons.File /> {f.path}
                            </div>
                        ))}
                    </div>
                    
                    <div className="flex gap-3">
                        <button onClick={onCancel} className="flex-1 p-2 bg-slate-700 rounded">Cancel</button>
                        <button onClick={onConfirm} className="flex-1 p-2 bg-red-600 rounded flex items-center justify-center gap-2">
                            <Icons.Trash /> Delete Files
                        </button>
                    </div>
                </div>
            </div>
        );
    }

    // =========================================================================
    // DIALOG MODAL (replaces native alert/confirm/prompt)
    // =========================================================================
    
    function DialogModal({ type, title, message, defaultValue, confirmText, cancelText, onConfirm, onCancel }) {
        const [inputValue, setInputValue] = React.useState(defaultValue || '');
        const inputRef = React.useRef(null);
        
        React.useEffect(() => {
            if (type === 'prompt' && inputRef.current) {
                inputRef.current.focus();
                inputRef.current.select();
            }
        }, [type]);
        
        const handleKeyDown = (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                onConfirm(type === 'prompt' ? inputValue : true);
            } else if (e.key === 'Escape') {
                onCancel();
            }
        };
        
        // Determine icon and colors based on message content
        const isError = message?.toLowerCase().includes('error') || message?.toLowerCase().includes('failed');
        const isWarning = message?.toLowerCase().includes('warning') || message?.toLowerCase().includes('⚠');
        const isSuccess = message?.toLowerCase().includes('✓') || message?.toLowerCase().includes('success');
        
        const borderColor = isError ? 'border-red-700' : isWarning ? 'border-amber-700' : isSuccess ? 'border-green-700' : 'border-slate-600';
        const iconColor = isError ? 'text-red-400' : isWarning ? 'text-amber-400' : isSuccess ? 'text-green-400' : 'text-indigo-400';
        
        return (
            <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-[100] p-4" onKeyDown={handleKeyDown}>
                <div className={`bg-slate-800 rounded-xl border ${borderColor} p-6 max-w-md w-full fade-in shadow-2xl`}>
                    {title && (
                        <h2 className={`text-lg font-bold mb-3 flex items-center gap-2 ${iconColor}`}>
                            {isError ? <Icons.AlertTriangle /> : isWarning ? '⚠️' : isSuccess ? '✓' : 'ℹ️'}
                            {title}
                        </h2>
                    )}
                    
                    <div className="text-slate-300 mb-4 whitespace-pre-wrap">{message}</div>
                    
                    {type === 'prompt' && (
                        <input
                            ref={inputRef}
                            type="text"
                            value={inputValue}
                            onChange={(e) => setInputValue(e.target.value)}
                            className="w-full p-3 bg-slate-900 border border-slate-600 rounded-lg mb-4 text-white focus:border-indigo-500 focus:outline-none"
                            placeholder="Enter value..."
                        />
                    )}
                    
                    <div className="flex gap-3">
                        {type !== 'alert' && (
                            <button 
                                onClick={onCancel} 
                                className="flex-1 p-2.5 bg-slate-700 hover:bg-slate-600 rounded-lg transition-colors">
                                {cancelText || 'Cancel'}
                            </button>
                        )}
                        <button 
                            onClick={() => onConfirm(type === 'prompt' ? inputValue : true)} 
                            className={`flex-1 p-2.5 rounded-lg transition-colors ${
                                isError ? 'bg-red-600 hover:bg-red-500' :
                                isWarning ? 'bg-amber-600 hover:bg-amber-500' :
                                'bg-indigo-600 hover:bg-indigo-500'
                            }`}>
                            {confirmText || 'OK'}
                        </button>
                    </div>
                </div>
            </div>
        );
    }

    // =========================================================================
    // DASHBOARD VIEW
    // =========================================================================
    
    function DashboardView({ apps, config, stagedFiles, setStagedFiles, github, onFileDrop, onRemove, onDeploy, onBatchDeploy, onPromote, activeDeployments, removeActiveDeployment, refreshing, onUpdateStagedFile, deployingRepos, showConfirm, showAlert, showPrompt, globalIssues, globalWorkItems, globalSessions, globalActivity, deployments, firebaseUid, setModal, linkIssuesToVersion, setView, rollbackSnapshots, onQuickRollback }) {
        const [selectedFileIds, setSelectedFileIds] = React.useState(new Set());
        const [deployTarget, setDeployTarget] = React.useState({ appId: 'command-center', target: 'test' });
        const [isDeploying, setIsDeploying] = React.useState(false);
        const [deployCompleted, setDeployCompleted] = React.useState(false);
        const [lastCompletedDeployId, setLastCompletedDeployId] = React.useState(null);
        const [errorOverride, setErrorOverride] = React.useState(false);
        // Track if deploy button was clicked in this session (prevents history-based false positive)
        const deployClickedThisSession = React.useRef(false);
        // Track if the full batch action (deploy + doc push) is still running
        const [batchActionRunning, setBatchActionRunning] = React.useState(false);
        
        const [otherCollapsed, setOtherCollapsed] = React.useState(true); // v8.3.3: Collapse "Other" by default
        
        // v8.8.0: Project-based grouping with collapse state
        const [collapsedProjects, setCollapsedProjects] = React.useState(() => {
            // Default: all collapsed except first project with active deployments
            const saved = localStorage.getItem('cc_collapsedProjects');
            return saved ? JSON.parse(saved) : {};
        });
        
        const toggleProject = (projId) => {
            setCollapsedProjects(prev => {
                const next = { ...prev, [projId]: !prev[projId] };
                localStorage.setItem('cc_collapsedProjects', JSON.stringify(next));
                return next;
            });
        };
        
        // v8.36.1: Intelligent deploy target selection
        // Two-repo apps → TEST (safe default), prod-only → PROD, test-only → TEST
        const getSmartTarget = (appId) => {
            const app = apps[appId];
            if (!app) return 'test';
            const hasTest = !!(app.testRepo || app.repos?.test || (app.repoPatterns?.test?.length > 0));
            const hasProd = !!(app.prodRepo || app.repos?.prod || (app.repoPatterns?.prod?.length > 0));
            if (hasTest && hasProd) return 'test';   // Two-repo: safe default to TEST
            if (hasProd && !hasTest) return 'prod';   // Prod-only: must be PROD
            if (hasTest && !hasProd) return 'test';   // Test-only: must be TEST
            return 'test'; // Fallback
        };
        
        // Get available environments for an app (for dropdown filtering)
        const getAvailableTargets = (appId) => {
            const app = apps[appId];
            if (!app) return ['test', 'prod'];
            const hasTest = !!(app.testRepo || app.repos?.test || (app.repoPatterns?.test?.length > 0));
            const hasProd = !!(app.prodRepo || app.repos?.prod || (app.repoPatterns?.prod?.length > 0));
            const targets = [];
            if (hasTest) targets.push('test');
            if (hasProd) targets.push('prod');
            return targets.length > 0 ? targets : ['test', 'prod']; // Fallback to both
        };
        
        // Compatibility: get first deployment for legacy code
        const activeDeployment = activeDeployments?.[0] || null;
        
        // v8.8.0: Group configured apps by project
        const configuredApps = Object.values(apps).filter(a => a.testRepo || a.prodRepo);
        const projects = getProjectsWithApps(apps, config?.projects);
        
        // Legacy grouping (still used by some references)
        const publicApps = configuredApps.filter(a => a.appType === 'public' || !a.appType);
        const internalApps = configuredApps.filter(a => a.appType === 'internal');
        const otherApps = configuredApps.filter(a => a.appType === 'other');
        
        // Doc package validation — runs whenever staged files change
        // Unified package validation — runs on selected files (selection-driven)
        // Note: actual validation computed inside deploy controls where selectedFiles is available
        
        // Config ↔ code drift detection — only when deploying CC itself
        const configDrift = React.useMemo(() => {
            const ccFile = stagedFiles.find(f => 
                f.fileAction === 'deploy' && 
                (f.suggestedApp === 'command-center' || f.name === 'index.html') &&
                f.content?.includes('CC_SEED_MANIFEST')
            );
            if (!ccFile) return null;
            return detectConfigDrift(ccFile.content, config);
        }, [stagedFiles, config]);
        
        // v8.8.0: Auto-expand project when deploy is active
        React.useEffect(() => {
            if (!activeDeployments?.length) return;
            for (const dep of activeDeployments) {
                if (dep.status === 'running' && dep.appId) {
                    const app = apps[dep.appId];
                    const projId = app?.project || 'other';
                    if (collapsedProjects[projId]) {
                        setCollapsedProjects(prev => {
                            const next = { ...prev, [projId]: false };
                            localStorage.setItem('cc_collapsedProjects', JSON.stringify(next));
                            return next;
                        });
                    }
                }
            }
        }, [activeDeployments]);
        
        // Auto-select detected app when staging new files
        React.useEffect(() => {
            if (stagedFiles.length === 0) return;
            
            // Find the most recently added file with high-confidence detection
            const filesWithDetection = stagedFiles.filter(f => f.appDetection?.confidence === 'high' || f.appDetection?.confidence === 'definite');
            if (filesWithDetection.length > 0) {
                const detected = filesWithDetection[filesWithDetection.length - 1].suggestedApp;
                if (detected && apps[detected]) {
                    // v8.36.1: Intelligently select target based on app's repo configuration
                    const targetEnv = getSmartTarget(detected);
                    setDeployTarget(prev => ({ ...prev, appId: detected, target: targetEnv }));
                    console.log(`🎯 Auto-selected app: ${detected}, target: ${targetEnv} (smart default)`);
                    
                    // If app has no repo assigned, try to auto-assign from available repos
                    const app = apps[detected];
                    if (!app.prodRepo && github) {
                        console.log('🔍 No prod repo for', detected, '- attempting auto-assignment...');
                        // Find repo matching this app's patterns
                        github.listRepos().then(repos => {
                            const patterns = app.repoPatterns?.prod || [];
                            for (const pattern of patterns) {
                                const found = repos.find(r => r.name.toLowerCase() === pattern.toLowerCase() && !r.name.toLowerCase().includes('test'));
                                if (found) {
                                    console.log('✅ Auto-assigned prod repo:', found.fullName);
                                    updateApp(detected, { prodRepo: found.fullName });
                                    break;
                                }
                            }
                        }).catch(e => console.warn('Could not auto-assign repo:', e));
                    }
                }
            }
        }, [stagedFiles.length]); // Only when file count changes (new file added)
        
        // Keep deploying state while deployment is running, reset when complete
        React.useEffect(() => {
            if (activeDeployment) {
                if (activeDeployment.status === 'running') {
                    // Keep spinner going while deployment is in progress
                    setIsDeploying(true);
                } else if (activeDeployment.status === 'success' || activeDeployment.status === 'failed' || activeDeployment.status === 'error') {
                    // Only stop spinner when deployment finishes (success or failure)
                    setIsDeploying(false);
                    // Only set deployCompleted if deploy was clicked this session
                    if (activeDeployment.status === 'success' && 
                        activeDeployment.id !== lastCompletedDeployId &&
                        deployClickedThisSession.current) {
                        setDeployCompleted(true);
                        setLastCompletedDeployId(activeDeployment.id);
                    }
                }
            }
        }, [activeDeployment, activeDeployment?.status, activeDeployment?.id, lastCompletedDeployId]);
        
        // Reset deployCompleted when staging new files or files change
        const stagedFileIds = stagedFiles.map(f => f.id).join(',');
        React.useEffect(() => {
            // Reset whenever staged files change (new files, different files, or cleared)
            setDeployCompleted(false);
        }, [stagedFileIds]);
        
        // Expanded app menus state
        const [expandedApps, setExpandedApps] = React.useState({});
        const [appInfo, setAppInfo] = React.useState({}); // { appId: { test: {...}, prod: {...} } }
        const [loadingAppInfo, setLoadingAppInfo] = React.useState({});
        
        // Toggle app menu expansion
        const toggleAppExpanded = async (appId) => {
            const newExpanded = !expandedApps[appId];
            setExpandedApps(prev => ({ ...prev, [appId]: newExpanded }));
            
            // Fetch app info if expanding and not already loaded
            if (newExpanded && !appInfo[appId] && github) {
                await fetchAppInfo(appId);
            }
        };
        
        // Fetch commit history and info for an app
        const fetchAppInfo = async (appId) => {
            const app = apps[appId];
            if (!app || !github) return;
            
            setLoadingAppInfo(prev => ({ ...prev, [appId]: true }));
            
            const info = { test: null, prod: null };
            
            try {
                if (app.testRepo) {
                    const [owner, repo] = app.testRepo.split('/');
                    const commits = await github.request(`/repos/${owner}/${repo}/commits?per_page=5`);
                    const repoData = await github.request(`/repos/${owner}/${repo}`);
                    info.test = {
                        lastCommit: commits[0],
                        recentCommits: commits,
                        pushedAt: repoData.pushed_at
                    };
                }
            } catch (e) {
                console.error('Error fetching test repo info:', e);
            }
            
            try {
                if (app.prodRepo) {
                    const [owner, repo] = app.prodRepo.split('/');
                    const commits = await github.request(`/repos/${owner}/${repo}/commits?per_page=5`);
                    const repoData = await github.request(`/repos/${owner}/${repo}`);
                    info.prod = {
                        lastCommit: commits[0],
                        recentCommits: commits,
                        pushedAt: repoData.pushed_at
                    };
                }
            } catch (e) {
                console.error('Error fetching prod repo info:', e);
            }
            
            setAppInfo(prev => ({ ...prev, [appId]: info }));
            setLoadingAppInfo(prev => ({ ...prev, [appId]: false }));
        };
        
        // Force GitHub Pages rebuild by creating an empty commit
        const forceRebuild = async (repo, target, silent = false) => {
            if (!github || !repo) return;
            
            if (!silent) {
                const confirmed = await showConfirm(
                    `This creates an empty commit to trigger GitHub Pages deployment.\n\nThe site should update in 30-90 seconds.`,
                    `Force Rebuild ${target.toUpperCase()}?`
                );
                if (!confirmed) return;
            }
            
            try {
                const [owner, repoName] = repo.split('/');
                
                // Get current commit
                const ref = await github.request(`/repos/${owner}/${repoName}/git/ref/heads/main`);
                const currentSha = ref.object.sha;
                
                // Get current commit details
                const commit = await github.request(`/repos/${owner}/${repoName}/git/commits/${currentSha}`);
                
                // Create new commit with same tree (empty commit)
                const newCommit = await github.request(`/repos/${owner}/${repoName}/git/commits`, {
                    method: 'POST',
                    body: JSON.stringify({
                        message: `Force rebuild - ${new Date().toISOString()}`,
                        tree: commit.tree.sha,
                        parents: [currentSha]
                    })
                });
                
                // Update ref (force: true handles non-fast-forward cases)
                await github.request(`/repos/${owner}/${repoName}/git/refs/heads/main`, {
                    method: 'PATCH',
                    body: JSON.stringify({ sha: newCommit.sha, force: true })
                });
                
                if (!silent) {
                    await showAlert(
                        `GitHub Pages should update in 30-90 seconds.`,
                        `✓ Rebuild Triggered for ${target.toUpperCase()}`
                    );
                }
                
                // Refresh app info
                const appId = Object.entries(apps).find(([id, a]) => a.testRepo === repo || a.prodRepo === repo)?.[0];
                if (appId) {
                    setAppInfo(prev => ({ ...prev, [appId]: null }));
                    fetchAppInfo(appId);
                }
                
                return true;
                
            } catch (e) {
                if (!silent) {
                    await showAlert(`Error: ${e.message}`, 'Rebuild Failed');
                }
                return false;
            }
        };
        
        // Format relative time
        const formatRelativeTime = (dateStr) => {
            if (!dateStr) return '—';
            const date = new Date(dateStr);
            const now = new Date();
            const diffMs = now - date;
            const diffMins = Math.floor(diffMs / 60000);
            const diffHours = Math.floor(diffMs / 3600000);
            const diffDays = Math.floor(diffMs / 86400000);
            
            if (diffMins < 1) return 'just now';
            if (diffMins < 60) return `${diffMins}m ago`;
            if (diffHours < 24) return `${diffHours}h ago`;
            if (diffDays < 7) return `${diffDays}d ago`;
            return date.toLocaleDateString();
        };
        
        // Get actual selected files from staged (ensures fresh content)
        const selectedFiles = stagedFiles.filter(f => selectedFileIds.has(f.id));
        
        // Clean up selections when staged files change
        React.useEffect(() => {
            setSelectedFileIds(prev => {
                const validIds = new Set(stagedFiles.map(f => f.id));
                const newSet = new Set([...prev].filter(id => validIds.has(id)));
                return newSet.size !== prev.size ? newSet : prev;
            });
            setErrorOverride(false); // Reset error override when files change
        }, [stagedFiles]);
        
        // Reset error override when selection changes
        React.useEffect(() => {
            setErrorOverride(false);
        }, [selectedFileIds]);
        
        const toggleFileSelection = (file) => {
            setSelectedFileIds(prev => {
                const newSet = new Set(prev);
                if (newSet.has(file.id)) {
                    newSet.delete(file.id);
                } else {
                    newSet.add(file.id);
                }
                return newSet;
            });
        };
        
        const selectAll = () => setSelectedFileIds(new Set(stagedFiles.map(f => f.id)));
        const selectNone = () => setSelectedFileIds(new Set());
        
        // === Phase 4.1: Product Health Metrics ===
        const productMetrics = React.useMemo(() => {
            const items = globalWorkItems || [];
            const sessions = globalSessions || [];
            const deps = deployments || [];
            const now = Date.now();
            const thirtyDaysAgo = now - (30 * 24 * 60 * 60 * 1000);
            
            // Features shipped this month (done items in last 30 days)
            const shippedThisMonth = items.filter(wi => {
                if (wi.status !== 'done') return false;
                const completedAt = wi.completedAt || wi.updatedAt;
                return completedAt && new Date(completedAt).getTime() > thirtyDaysAgo;
            });
            
            // Pipeline health: items in each active stage
            const pipeline = { idea: 0, ready: 0, 'in-progress': 0, review: 0 };
            const staleItems = [];
            items.forEach(wi => {
                if (pipeline.hasOwnProperty(wi.status)) pipeline[wi.status]++;
                if (WorkItemService.isStale && WorkItemService.isStale(wi)) staleItems.push(wi);
            });
            
            // Session readiness: apps with ready items that have acceptance criteria
            const readyByApp = {};
            items.filter(wi => wi.status === 'ready').forEach(wi => {
                if (!readyByApp[wi.appId]) readyByApp[wi.appId] = { count: 0, withCriteria: 0 };
                readyByApp[wi.appId].count++;
                if (wi.acceptanceCriteria?.length > 0) readyByApp[wi.appId].withCriteria++;
            });
            const readyApps = Object.entries(readyByApp)
                .map(([appId, data]) => ({ appId, ...data, app: apps[appId] }))
                .filter(a => a.app)
                .sort((a, b) => b.withCriteria - a.withCriteria || b.count - a.count);
            
            // Cost per feature (sessions in last 30 days)
            const recentSessions = sessions.filter(s => new Date(s.createdAt).getTime() > thirtyDaysAgo);
            let totalCost = 0;
            recentSessions.forEach(s => {
                const tokens = s.packageTokens || 0;
                const engineId = s.engineId || 'claude-sonnet-4.5';
                const engine = EngineRegistryService.ENGINES[engineId];
                if (engine && tokens > 0) {
                    const inputCost = (tokens / 1000000) * engine.cost.input;
                    const outputCost = ((tokens * 0.3) / 1000000) * engine.cost.output;
                    totalCost += inputCost + outputCost;
                }
            });
            const costPerFeature = shippedThisMonth.length > 0 ? totalCost / shippedThisMonth.length : 0;
            
            // Recent deploys count
            const recentDeploys = deps.filter(d => new Date(d.timestamp || d.date).getTime() > thirtyDaysAgo);
            
            // In-progress sessions (sessions without deploy link)
            const activeSessions = sessions.filter(s => s.status === 'prep' || s.status === 'active');
            
            return { 
                shippedThisMonth, pipeline, staleItems, readyApps, 
                recentSessions, totalCost, costPerFeature, 
                recentDeploys, activeSessions,
                totalActive: pipeline.idea + pipeline.ready + pipeline['in-progress'] + pipeline.review
            };
        }, [globalWorkItems, globalSessions, deployments, apps]);
        
        // Most-ready app for quick session action
        const mostReadyApp = productMetrics.readyApps[0];
        
        return (
            <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
                <div className="lg:col-span-2 space-y-6">
                    {/* Upload */}
                    <div className="bg-slate-800 rounded-xl border border-slate-700 p-6">
                        <h2 className="text-lg font-semibold mb-4 flex items-center gap-2">
                            <Icons.Upload /> Upload Files
                        </h2>
                        <div onDrop={onFileDrop} onDragOver={e => e.preventDefault()}
                            className="border-2 border-dashed border-slate-600 rounded-lg p-8 text-center hover:border-indigo-500 cursor-pointer">
                            <input type="file" multiple accept=".html,.js,.css,.json,.zip,.yml,.yaml,.md,.txt" onChange={onFileDrop} className="hidden" id="upload" />
                            <label htmlFor="upload" className="cursor-pointer">
                                <div className="text-4xl mb-3">📁</div>
                                <div>Drop files here (HTML, JS, docs, project zips...)</div>
                                <div className="text-xs text-slate-500 mt-2">
                                    Multi-file deploy supported • Version from <code>&lt;meta name="version"&gt;</code>
                                </div>
                            </label>
                        </div>
                    </div>
                    
                    {/* Staged Files */}
                    {stagedFiles.length > 0 && (
                        <div className="bg-slate-800 rounded-xl border border-slate-700 p-6">
                            <div className="flex items-center justify-between mb-4">
                                <h2 className="text-lg font-semibold">Staged ({stagedFiles.length})</h2>
                                <div className="flex gap-2 text-xs">
                                    <button onClick={selectAll} className="px-2 py-1 bg-slate-700 rounded hover:bg-slate-600">Select All</button>
                                    <button onClick={selectNone} className="px-2 py-1 bg-slate-700 rounded hover:bg-slate-600">Select None</button>
                                    <button onClick={() => {
                                        setSelectedFileIds(new Set());
                                        stagedFiles.forEach(f => onRemove(f.id));
                                    }} className="px-2 py-1 bg-red-700 hover:bg-red-600 rounded flex items-center gap-1">
                                        <Icons.Trash /> Clear All
                                    </button>
                                </div>
                            </div>
                            
                            {/* Doc validation now handled by unified panel in deploy controls */}
                            
                            {/* Config ↔ Code Drift Banner (CC self-deploy only) */}
                            {configDrift && configDrift.drifts.length > 0 && (() => {
                                const hasCritical = configDrift.errorCount > 0 || configDrift.warnCount > 0;
                                const borderColor = configDrift.errorCount > 0 
                                    ? 'bg-red-900/20 border-red-700/50' 
                                    : configDrift.warnCount > 0 
                                        ? 'bg-orange-900/20 border-orange-700/50'
                                        : 'bg-slate-800/50 border-slate-700/50';
                                const textColor = configDrift.errorCount > 0 ? 'text-red-300' : configDrift.warnCount > 0 ? 'text-orange-300' : 'text-slate-400';
                                
                                return (
                                    <details className={`mb-4 rounded-lg border ${borderColor}`} open={hasCritical || undefined}>
                                        <summary className={`p-3 cursor-pointer select-none flex items-center justify-between ${textColor}`}>
                                            <div className="text-sm font-medium flex items-center gap-2">
                                                {configDrift.errorCount > 0 ? '🔴' : configDrift.warnCount > 0 ? '⚠️' : 'ℹ️'} Config ↔ Code Drift
                                                <span className="text-xs opacity-70">
                                                    ({configDrift.errorCount > 0 ? `${configDrift.errorCount} errors, ` : ''}{configDrift.warnCount > 0 ? `${configDrift.warnCount} mismatches, ` : ''}{configDrift.infoCount} info)
                                                </span>
                                            </div>
                                            {hasCritical && configDrift.claudePrompt && (
                                                <button
                                                    onClick={(e) => {
                                                        e.preventDefault();
                                                        navigator.clipboard.writeText(configDrift.claudePrompt);
                                                        showAlert('Copied to clipboard! Paste this into Claude to fix the seed values.', '📋 Drift Fix Prompt Copied');
                                                    }}
                                                    className={`px-2 py-1 text-xs rounded flex items-center gap-1 ${
                                                        configDrift.errorCount > 0 ? 'bg-red-700 hover:bg-red-600 text-red-100' : 'bg-orange-700 hover:bg-orange-600 text-orange-100'
                                                    }`}
                                                >
                                                    📋 Copy Fix Prompt
                                                </button>
                                            )}
                                        </summary>
                                        
                                        <div className="px-3 pb-3">
                                            <div className="text-xs space-y-0.5 max-h-32 overflow-y-auto">
                                                {configDrift.drifts.filter(d => d.severity === 'error').map((d, i) => (
                                                    <div key={`e${i}`} className="text-red-400">🔴 {d.detail}</div>
                                                ))}
                                                {configDrift.drifts.filter(d => d.severity === 'warn').map((d, i) => (
                                                    <div key={`w${i}`} className="text-orange-400">⚠️ {d.detail}</div>
                                                ))}
                                                {configDrift.drifts.filter(d => d.severity === 'info').map((d, i) => (
                                                    <div key={`i${i}`} className="text-blue-400">ℹ️ {d.detail}</div>
                                                ))}
                                            </div>
                                            
                                            {configDrift.claudePrompt && (
                                                <details className="mt-2">
                                                    <summary className="text-xs text-slate-500 cursor-pointer hover:text-slate-400">Show Claude fix prompt</summary>
                                                    <div className="relative mt-1.5">
                                                        <pre className="p-2 pr-16 bg-slate-900 rounded text-xs text-slate-300 whitespace-pre-wrap overflow-x-auto border border-slate-700">{configDrift.claudePrompt}</pre>
                                                        <button onClick={() => { navigator.clipboard.writeText(configDrift.claudePrompt); showAlert('Copied!', '📋'); }}
                                                            className="absolute top-2 right-2 px-2 py-1 text-xs bg-slate-700 hover:bg-slate-600 rounded text-slate-300">
                                                            📋 Copy
                                                        </button>
                                                    </div>
                                                </details>
                                            )}
                                        </div>
                                    </details>
                                );
                            })()}
                            
                            {/* Batch Deploy Controls - At top for easy access */}
                            {selectedFiles.length > 0 && (() => {
                                // Only show deploy controls for deploy-type files
                                const selectedDeployFiles = selectedFiles.filter(f => f.fileAction !== 'push-doc');
                                const selectedDocFiles = selectedFiles.filter(f => f.fileAction === 'push-doc');
                                
                                if (selectedDeployFiles.length === 0 && selectedDocFiles.length === 0) return null;
                                
                                // Check if selected deploy files have detected apps
                                const detectedApps = selectedDeployFiles
                                    .filter(f => f.appDetection)
                                    .map(f => ({ file: f.name, app: f.suggestedApp, confidence: f.appDetection.confidence }));
                                
                                const uniqueDetected = [...new Set(detectedApps.map(d => d.app))];
                                const primaryDetected = detectedApps.find(d => d.confidence === 'high')?.app || uniqueDetected[0];
                                
                                // Check for mismatch
                                const hasMismatch = primaryDetected && deployTarget.appId !== primaryDetected;
                                const hasConflict = uniqueDetected.length > 1;
                                
                                // Unified validation — computed once, used by panel and deploy button
                                const valAppConfig = apps[deployTarget.appId] || null;
                                const valDeployedVersion = deployTarget.target === 'prod'
                                    ? valAppConfig?.currentProdVersion
                                    : valAppConfig?.currentTestVersion;
                                const validation = validatePackage(selectedFiles, stagedFiles, valAppConfig, valDeployedVersion);
                                
                                return (
                                <div className="mb-4 p-4 bg-slate-900 rounded-lg border border-indigo-500">
                                    <div className="text-sm font-medium mb-3 flex items-center gap-2">
                                        <Icons.Upload /> {selectedDeployFiles.length > 0 ? `Deploy ${selectedDeployFiles.length} file${selectedDeployFiles.length !== 1 ? 's' : ''}` : ''}{selectedDeployFiles.length > 0 && selectedDocFiles.length > 0 ? ' + ' : ''}{selectedDocFiles.length > 0 ? `Push ${selectedDocFiles.length} doc${selectedDocFiles.length !== 1 ? 's' : ''}` : ''}
                                    </div>
                                    
                                    {/* Auto-detected app suggestion */}
                                    {primaryDetected && !hasConflict && (
                                        <div className={`mb-3 p-2 rounded text-sm flex items-center justify-between ${
                                            hasMismatch ? 'bg-amber-900/50 border border-amber-600' : 'bg-green-900/50 border border-green-600'
                                        }`}>
                                            <span className="flex items-center gap-2">
                                                {hasMismatch ? '⚠️' : '🎯'} Detected: <strong className="flex items-center gap-1"><AppIcon icon={apps[primaryDetected]?.icon} size={18} /> {apps[primaryDetected]?.name}</strong>
                                            </span>
                                            {hasMismatch && (
                                                <button 
                                                    onClick={() => setDeployTarget(p => ({ ...p, appId: primaryDetected }))}
                                                    className="px-2 py-1 bg-green-700 hover:bg-green-600 rounded text-xs">
                                                    Use Detected
                                                </button>
                                            )}
                                        </div>
                                    )}
                                    
                                    {/* Conflict warning */}
                                    {hasConflict && (
                                        <div className="mb-3 p-2 bg-red-900/50 border border-red-600 rounded text-sm">
                                            ⚠️ Multiple apps detected in selection: {uniqueDetected.map(a => apps[a]?.name).join(', ')}
                                        </div>
                                    )}
                                    
                                    <div className="grid grid-cols-2 gap-3 mb-3">
                                        <select value={deployTarget.appId} onChange={e => {
                                            const newAppId = e.target.value;
                                            // v8.36.1: Smart default based on app's repo configuration
                                            setDeployTarget({ appId: newAppId, target: getSmartTarget(newAppId) });
                                        }}
                                            className={`p-2 border rounded text-sm ${
                                                hasMismatch 
                                                    ? 'bg-amber-900 border-amber-500' 
                                                    : 'bg-slate-700 border-slate-600'
                                            }`}>
                                            {Object.values(apps).map(a => <option key={a.id} value={a.id}>{getAppEmoji(a.icon)} {a.name}</option>)}
                                        </select>
                                        <select value={deployTarget.target} onChange={e => setDeployTarget(p => ({ ...p, target: e.target.value }))}
                                            className="p-2 bg-slate-700 border border-slate-600 rounded text-sm">
                                            {getAvailableTargets(deployTarget.appId).map(t => (
                                                <option key={t} value={t}>{t === 'test' ? '🧪 TEST' : '🚀 PROD'}</option>
                                            ))}
                                        </select>
                                    </div>
                                    
                                    {/* Mismatch warning on deploy button */}
                                    {hasMismatch && (
                                        <div className="mb-2 text-xs text-amber-400">
                                            ⚠️ You're deploying to {apps[deployTarget.appId]?.name} but file appears to be {apps[primaryDetected]?.name}
                                        </div>
                                    )}
                                    
                                    {/* === UNIFIED VALIDATION PANEL === */}
                                    {(() => {
                                        if (!validation) return null;
                                        
                                        const panelBg = validation.severity === 'error'
                                            ? 'bg-red-900/20 border-red-700/50'
                                            : validation.severity === 'warning'
                                                ? 'bg-amber-900/20 border-amber-700/50'
                                                : 'bg-slate-800/50 border-slate-600/50';
                                        const panelText = validation.severity === 'error'
                                            ? 'text-red-300'
                                            : validation.severity === 'warning'
                                                ? 'text-amber-300'
                                                : 'text-slate-400';
                                        const isInfoOnly = validation.severity === 'info';
                                        
                                        const errorIssues = validation.issues.filter(i => i.severity === 'error');
                                        const warnIssues = validation.issues.filter(i => i.severity === 'warning');
                                        const infoIssues = validation.issues.filter(i => i.severity === 'info');
                                        
                                        
                                        return isInfoOnly ? (
                                            // Info: single collapsed line
                                            <details className={`mb-3 rounded-lg border ${panelBg}`}>
                                                <summary className={`p-2 cursor-pointer select-none text-xs ${panelText} flex items-center gap-1.5`}>
                                                    ℹ️ {infoIssues.map(i => i.detail).join('; ')}
                                                </summary>
                                                {validation.claudePrompt && (
                                                    <div className="px-2 pb-2">
                                                        <pre className="p-2 bg-slate-900 rounded text-xs text-slate-400 whitespace-pre-wrap border border-slate-700">{validation.claudePrompt}</pre>
                                                    </div>
                                                )}
                                            </details>
                                        ) : (
                                            // Warning/Error: expanded panel
                                            <div className={`mb-3 p-3 rounded-lg border ${panelBg}`}>
                                                <div className="flex items-center justify-between mb-2">
                                                    <div className={`text-xs font-medium ${panelText} flex items-center gap-1.5`}>
                                                        {validation.severity === 'error' ? '⛔' : '⚠️'} {validation.summary}
                                                    </div>
                                                    {validation.claudePrompt && (
                                                        <button
                                                            onClick={() => {
                                                                navigator.clipboard.writeText(validation.claudePrompt);
                                                                showAlert('Copied to clipboard! Paste into Claude to fix.', '📋 Fix Prompt Copied');
                                                            }}
                                                            className={`px-2 py-1 text-xs rounded flex items-center gap-1 ${
                                                                validation.severity === 'error' 
                                                                    ? 'bg-red-700 hover:bg-red-600 text-red-100' 
                                                                    : 'bg-amber-700 hover:bg-amber-600 text-amber-100'
                                                            }`}
                                                        >
                                                            📋 Copy Fix Prompt
                                                        </button>
                                                    )}
                                                </div>
                                                
                                                <div className="text-xs space-y-1.5">
                                                    {errorIssues.map((issue, i) => (
                                                        <div key={`e${i}`} className="text-red-400 flex items-start gap-1.5">
                                                            <span className="flex-shrink-0">🔴</span>
                                                            <span>{issue.detail}</span>
                                                        </div>
                                                    ))}
                                                    {warnIssues.map((issue, i) => (
                                                        <div key={`w${i}`}>
                                                            <div className="text-amber-400 flex items-start gap-1.5">
                                                                <span className="flex-shrink-0">🟡</span>
                                                                <span>{issue.detail}</span>
                                                            </div>
                                                            {/* Version bump action (code-only flow) */}
                                                            {issue.action?.type === 'bump-version' && (
                                                                <div className="ml-5 mt-1.5 flex items-center gap-2 flex-wrap">
                                                                    <button
                                                                        onClick={() => {
                                                                            const newV = issue.action.suggested;
                                                                            // Bump index.html
                                                                            const idxFile = stagedFiles.find(f => f.name === 'index.html' && f.fileAction === 'deploy');
                                                                            if (idxFile) {
                                                                                const fixedHtml = fixVersionsInContent(idxFile.content, newV);
                                                                                const newValidation = validateVersions(fixedHtml, idxFile.name);
                                                                                onUpdateStagedFile(idxFile.id, { content: fixedHtml, version: newV, versionValidation: newValidation });
                                                                            }
                                                                            // Bump sw.js
                                                                            const swFile = stagedFiles.find(f => f.name === 'sw.js' && f.fileAction === 'deploy');
                                                                            if (swFile && swFile.content) {
                                                                                const fixedSw = swFile.content.replace(
                                                                                    /(CACHE_VERSION\s*=\s*['"])v?[^'"]*(['"])/g,
                                                                                    `$1v${newV}$2`
                                                                                );
                                                                                onUpdateStagedFile(swFile.id, { content: fixedSw, version: newV });
                                                                            }
                                                                            showAlert(`Bumped to v${newV}`, '✅ Version Updated');
                                                                        }}
                                                                        className="px-2 py-1 bg-green-700 hover:bg-green-600 text-xs rounded text-green-100 flex items-center gap-1"
                                                                    >
                                                                        🔧 Bump to v{issue.action.suggested}
                                                                    </button>
                                                                    <span className="text-slate-500 text-xs">or</span>
                                                                    <input
                                                                        type="text"
                                                                        placeholder="x.x.x"
                                                                        className="w-20 px-2 py-1 bg-slate-900 border border-slate-600 rounded text-xs text-white"
                                                                        onKeyDown={(e) => {
                                                                            if (e.key === 'Enter' && e.target.value.match(/^\d+\.\d+\.\d+$/)) {
                                                                                const newV = e.target.value;
                                                                                const idxFile = stagedFiles.find(f => f.name === 'index.html' && f.fileAction === 'deploy');
                                                                                if (idxFile) {
                                                                                    const fixedHtml = fixVersionsInContent(idxFile.content, newV);
                                                                                    const newValidation = validateVersions(fixedHtml, idxFile.name);
                                                                                    onUpdateStagedFile(idxFile.id, { content: fixedHtml, version: newV, versionValidation: newValidation });
                                                                                }
                                                                                const swFile = stagedFiles.find(f => f.name === 'sw.js' && f.fileAction === 'deploy');
                                                                                if (swFile && swFile.content) {
                                                                                    const fixedSw = swFile.content.replace(
                                                                                        /(CACHE_VERSION\s*=\s*['"])v?[^'"]*(['"])/g,
                                                                                        `$1v${newV}$2`
                                                                                    );
                                                                                    onUpdateStagedFile(swFile.id, { content: fixedSw, version: newV });
                                                                                }
                                                                                showAlert(`Bumped to v${newV}`, '✅ Version Updated');
                                                                                e.target.value = '';
                                                                            }
                                                                        }}
                                                                    />
                                                                    <button
                                                                        onClick={() => {
                                                                            // Mark as dismissed — just deploy as-is
                                                                            // The deploy button already works, this is just UX clarity
                                                                        }}
                                                                        className="px-2 py-1 text-slate-500 hover:text-slate-300 text-xs"
                                                                    >
                                                                        Deploy as-is
                                                                    </button>
                                                                </div>
                                                            )}
                                                        </div>
                                                    ))}
                                                    {infoIssues.map((issue, i) => (
                                                        <div key={`i${i}`} className="text-slate-500 flex items-start gap-1.5">
                                                            <span className="flex-shrink-0">ℹ️</span>
                                                            <span>{issue.detail}</span>
                                                        </div>
                                                    ))}
                                                </div>
                                                
                                                {/* Claude prompt expandable */}
                                                {validation.claudePrompt && (
                                                    <details className="mt-2">
                                                        <summary className={`text-xs cursor-pointer hover:opacity-80 ${
                                                            validation.severity === 'error' ? 'text-red-500' : 'text-amber-500'
                                                        }`}>Show Claude fix prompt</summary>
                                                        <div className="relative mt-1.5">
                                                            <pre className="p-2 pr-16 bg-slate-900 rounded text-xs text-slate-300 whitespace-pre-wrap overflow-x-auto border border-slate-700">{validation.claudePrompt}</pre>
                                                            <button onClick={() => { navigator.clipboard.writeText(validation.claudePrompt); showAlert('Copied!', '📋'); }}
                                                                className="absolute top-2 right-2 px-2 py-1 text-xs bg-slate-700 hover:bg-slate-600 rounded text-slate-300">
                                                                📋 Copy
                                                            </button>
                                                        </div>
                                                    </details>
                                                )}
                                                
                                                {/* Error override checkbox */}
                                                {validation.severity === 'error' && (
                                                    <label className="mt-2 flex items-start gap-2 text-xs text-red-400 cursor-pointer select-none">
                                                        <input type="checkbox" className="mt-0.5"
                                                            checked={errorOverride}
                                                            onChange={e => setErrorOverride(e.target.checked)}
                                                        />
                                                        <span>I understand these issues may break the app for users — deploy anyway</span>
                                                    </label>
                                                )}
                                            </div>
                                        );
                                    })()}
                                    
                                    {/* Deploy Button */}
                                    {(() => {
                                        const hasValidationError = validation?.severity === 'error' && !errorOverride;
                                        
                                        const buttonDisabled = !github || isDeploying || batchActionRunning || hasValidationError;
                                        const buttonStyle = (() => {
                                            if (isDeploying || batchActionRunning) return 'bg-emerald-700 cursor-wait';
                                            if (deployCompleted) return 'bg-orange-500 hover:bg-orange-600';
                                            if (hasValidationError) return 'bg-slate-600 cursor-not-allowed opacity-50';
                                            if (validation?.severity === 'error' && errorOverride) return 'bg-red-600 hover:bg-red-700';
                                            if (validation?.severity === 'warning') return 'bg-amber-600 hover:bg-amber-700';
                                            if (hasMismatch) return 'bg-amber-600 hover:bg-amber-700';
                                            return deployTarget.target === 'prod' ? 'bg-green-600 hover:bg-green-700' : 'bg-blue-600 hover:bg-blue-700';
                                        })();
                                        
                                        const buttonPrefix = (() => {
                                            if (isDeploying || deployCompleted || batchActionRunning) return '';
                                            if (hasValidationError) return '🚫 ';
                                            if (validation?.severity === 'error' && errorOverride) return '⚠️ ';
                                            if (validation?.severity === 'warning') return '⚠️ ';
                                            if (hasMismatch) return '⚠️ ';
                                            return '';
                                        })();
                                        
                                        return (
                                        <button onClick={async () => {
                                            setDeployCompleted(false);
                                            
                                            const executeBatchAction = async () => {
                                                setIsDeploying(true);
                                                setBatchActionRunning(true);
                                                deployClickedThisSession.current = true;
                                                
                                                try {
                                                if (selectedDeployFiles.length > 0) {
                                                    console.log('Deploying files:', selectedDeployFiles.map(f => ({ name: f.name, id: f.id, size: f.content?.length })));
                                                    await onBatchDeploy(selectedDeployFiles, deployTarget.appId, deployTarget.target);
                                                }
                                                
                                                if (selectedDocFiles.length > 0 && github) {
                                                    const app = apps[deployTarget.appId];
                                                    const repo = app?.repos?.prod || app?.prodRepo || app?.repos?.test || app?.testRepo;
                                                    if (repo) {
                                                        console.log('Pushing docs to:', repo);
                                                        const pushedDocIds = [];
                                                        for (const doc of selectedDocFiles) {
                                                            try {
                                                                const existing = await github.getFile(repo, doc.targetPath);
                                                                const sha = existing?.sha || null;
                                                                await github.createOrUpdateFile(
                                                                    repo,
                                                                    doc.targetPath,
                                                                    doc.content,
                                                                    `${sha ? 'Update' : 'Add'} ${doc.name} via Command Center`,
                                                                    sha
                                                                );
                                                                console.log(`✅ Pushed ${doc.name} → ${repo}/${doc.targetPath}`);
                                                                pushedDocIds.push(doc.id);
                                                            } catch (e) {
                                                                console.error(`❌ Failed to push ${doc.name}:`, e.message);
                                                            }
                                                        }
                                                        if (pushedDocIds.length > 0) {
                                                            setStagedFiles(prev => prev.filter(f => !pushedDocIds.includes(f.id)));
                                                        }
                                                    }
                                                }
                                                } finally {
                                                    setBatchActionRunning(false);
                                                }
                                                
                                                // v8.36.1: Smart reset — use app's intelligent default, not always TEST
                                                setDeployTarget(prev => ({ ...prev, target: getSmartTarget(prev.appId) }));
                                            };
                                            
                                            if (hasMismatch) {
                                                const confirmed = await showConfirm(
                                                    `File detected as ${apps[primaryDetected]?.name} but deploying to ${apps[deployTarget.appId]?.name}. Continue anyway?`,
                                                    'Deploy Mismatch Warning'
                                                );
                                                if (confirmed) await executeBatchAction();
                                            } else {
                                                await executeBatchAction();
                                            }
                                        }}
                                            disabled={buttonDisabled}
                                            className={`w-full p-3 rounded font-medium flex items-center justify-center gap-2 transition-all ${buttonStyle}`}>
                                            {isDeploying || batchActionRunning ? (
                                                <>
                                                    <div className="w-4 h-4 border-2 border-white border-t-transparent rounded-full animate-spin" />
                                                    {batchActionRunning && !isDeploying ? 'Pushing docs...' : 'Deploying...'}
                                                </>
                                            ) : deployCompleted ? (
                                                <>
                                                    ✓ Deployed! Click to deploy again
                                                </>
                                            ) : hasValidationError ? (
                                                <>
                                                    🚫 Fix errors to deploy
                                                </>
                                            ) : (
                                                <>
                                                    {buttonPrefix}{selectedDeployFiles.length > 0 
                                                        ? (selectedDeployFiles.length === 1 ? 'Deploy File' : `Batch Deploy ${selectedDeployFiles.length} Files`)
                                                        : ''}{selectedDeployFiles.length > 0 && selectedDocFiles.length > 0 ? ' + ' : ''}{selectedDocFiles.length > 0 ? `Push ${selectedDocFiles.length} Docs` : ''}
                                                    {' → '}{deployTarget.target.toUpperCase()}
                                                </>
                                            )}
                                        </button>
                                        );
                                    })()}
                                </div>
                                );
                            })()}
                            
                            {/* File List */}
                            <div className="space-y-2">
                                {stagedFiles.map(f => {
                                    const isHtml = f.name.endsWith('.html');
                                    const willRename = isHtml && f.targetPath === 'index.html' && f.name !== 'index.html';
                                    
                                    return (
                                    <div key={f.id} className={`p-3 rounded-lg border ${
                                        selectedFileIds.has(f.id) ? 'bg-indigo-900/50 border-indigo-500' : 'bg-slate-700/50 border-slate-600'
                                    }`}>
                                        <div className="flex items-center gap-3">
                                            <input type="checkbox" checked={selectedFileIds.has(f.id)}
                                                onChange={() => toggleFileSelection(f)} className="w-4 h-4" />
                                            <span className="text-xl">{getFileIcon(f.name)}</span>
                                            <div className="flex-1 min-w-0">
                                                {/* Source filename */}
                                                <div className="font-medium truncate text-slate-300">{f.name}</div>
                                                
                                                {/* File info */}
                                                <div className="text-xs text-slate-400 flex items-center gap-2 flex-wrap mt-0.5">
                                                    {formatBytes(f.size)}
                                                    {f.version && (
                                                        <span className="px-1.5 py-0.5 bg-slate-600 rounded">
                                                            {formatVersion(f.version)}
                                                            {f.versionSource === 'html' && <span className="text-green-400 ml-1">✓</span>}
                                                        </span>
                                                    )}
                                                    {/* App detection badge */}
                                                    {f.suggestedApp && apps[f.suggestedApp] && (
                                                        <span className={`px-1.5 py-0.5 rounded flex items-center gap-1 ${
                                                            f.appDetection 
                                                                ? f.appDetection.method === 'gs-app-id'
                                                                    ? 'bg-emerald-700 text-emerald-100'
                                                                    : f.appDetection.confidence === 'high' 
                                                                        ? 'bg-green-700 text-green-100' 
                                                                        : 'bg-yellow-700 text-yellow-100'
                                                                : 'bg-slate-600 text-slate-300'
                                                        }`} title={f.appDetection 
                                                            ? f.appDetection.method === 'gs-app-id'
                                                                ? 'Identified by gs-app-id meta tag (definite)'
                                                                : `Detected by pattern matching (${f.appDetection.matchCount} matches)`
                                                            : 'From filename'}>
                                                            <AppIcon icon={apps[f.suggestedApp].icon} size={16} />
                                                            <span>{apps[f.suggestedApp].name}</span>
                                                            {f.appDetection && (
                                                                <span className="text-xs opacity-75">
                                                                    {f.appDetection.method === 'gs-app-id' ? '✓' : f.appDetection.confidence === 'high' ? '🎯' : '❓'}
                                                                </span>
                                                            )}
                                                        </span>
                                                    )}
                                                    {!f.isText && <span className="text-amber-400">binary</span>}
                                                </div>
                                                
                                                {/* Target path section */}
                                                <div className={`mt-2 p-2 rounded border ${
                                                    f.fileAction === 'push-doc' 
                                                        ? 'bg-cyan-900/20 border-cyan-700/50' 
                                                        : 'bg-slate-800 border-slate-600'
                                                }`}>
                                                    <div className="text-xs text-slate-500 mb-1">
                                                        {f.fileAction === 'push-doc' ? '📄 Push to repo:' : 'Deploy as:'}
                                                    </div>
                                                    <div className="flex items-center gap-2">
                                                        <input type="text" value={f.targetPath} 
                                                            onChange={e => onUpdateStagedFile(f.id, { targetPath: e.target.value })}
                                                            onClick={e => e.stopPropagation()}
                                                            className="flex-1 text-sm bg-slate-900 border border-slate-500 rounded px-2 py-1 font-mono text-white"
                                                            placeholder="index.html" />
                                                        {isHtml && f.name !== 'index.html' && (
                                                            <button 
                                                                onClick={(e) => {
                                                                    e.stopPropagation();
                                                                    onUpdateStagedFile(f.id, { 
                                                                        targetPath: f.targetPath === 'index.html' ? f.name : 'index.html' 
                                                                    });
                                                                }}
                                                                className={`px-2 py-1 text-xs rounded whitespace-nowrap ${
                                                                    f.targetPath === 'index.html' 
                                                                        ? 'bg-green-700 text-green-100' 
                                                                        : 'bg-slate-600 text-slate-300 hover:bg-slate-500'
                                                                }`}>
                                                                {f.targetPath === 'index.html' ? '✓ Replace index.html' : 'Use index.html'}
                                                            </button>
                                                        )}
                                                    </div>
                                                    {willRename && (
                                                        <div className="mt-1.5 text-xs text-green-400 flex items-center gap-1">
                                                            <span>📝</span> Will replace existing index.html
                                                        </div>
                                                    )}
                                                    {isHtml && f.targetPath !== 'index.html' && f.name !== 'index.html' && (
                                                        <div className="mt-1.5 text-xs text-amber-400 flex items-center gap-1">
                                                            <span>⚠️</span> Will create new file (won't replace index.html)
                                                        </div>
                                                    )}
                                                    
                                                    {/* Version warnings */}
                                                    {f.versionValidation && !f.versionValidation.isValid && (
                                                        <div className="mt-2 p-2 bg-red-900/30 border border-red-700 rounded">
                                                            <div className="flex items-center justify-between mb-2">
                                                                <div className="text-xs font-medium text-red-300 flex items-center gap-1">
                                                                    🔴 Version Issues Detected
                                                                </div>
                                                                <button 
                                                                    onClick={async (e) => {
                                                                        e.stopPropagation();
                                                                        let targetVersion = f.version;
                                                                        if (!targetVersion) {
                                                                            targetVersion = await showPrompt(
                                                                                'What version should all version strings be set to?',
                                                                                '1.0.0',
                                                                                'Enter Target Version'
                                                                            );
                                                                        }
                                                                        if (targetVersion) {
                                                                            const fixedContent = fixVersionsInContent(f.content, targetVersion);
                                                                            const newValidation = validateVersions(fixedContent, f.name);
                                                                            onUpdateStagedFile(f.id, { 
                                                                                content: fixedContent,
                                                                                version: targetVersion,
                                                                                versionValidation: newValidation
                                                                            });
                                                                        }
                                                                    }}
                                                                    className="px-2 py-1 bg-green-700 hover:bg-green-600 text-xs rounded flex items-center gap-1">
                                                                    🔧 Fix to v{f.version || '?'}
                                                                </button>
                                                            </div>
                                                            
                                                            {f.versionValidation.missing.length > 0 && (
                                                                <div className="text-xs text-amber-300 mb-1">
                                                                    Missing: {f.versionValidation.missing.join(', ')}
                                                                </div>
                                                            )}
                                                            
                                                            {f.versionValidation.uniqueVersions.length > 1 && (
                                                                <div className="text-xs text-red-300 mb-1">
                                                                    Found {f.versionValidation.uniqueVersions.length} different versions: {f.versionValidation.uniqueVersions.join(', ')}
                                                                </div>
                                                            )}
                                                            
                                                            <div className="text-xs text-slate-400 space-y-0.5 max-h-24 overflow-auto">
                                                                {f.versionValidation.allVersions.map((v, i) => (
                                                                    <div key={i} className={v.value === f.versionValidation.primary ? 'text-green-400' : 'text-red-300'}>
                                                                        {v.value} ← {v.source} (line {v.line})
                                                                    </div>
                                                                ))}
                                                            </div>
                                                        </div>
                                                    )}
                                                    
                                                    {f.versionValidation && f.versionValidation.isValid && (
                                                        <div className="mt-2 text-xs text-green-400 flex items-center gap-1">
                                                            ✓ All {f.versionValidation.allVersions.length} version strings match (v{f.versionValidation.primary})
                                                        </div>
                                                    )}
                                                </div>
                                            </div>
                                            <button onClick={e => { 
                                                e.stopPropagation(); 
                                                setSelectedFileIds(prev => {
                                                    const newSet = new Set(prev);
                                                    newSet.delete(f.id);
                                                    return newSet;
                                                });
                                                onRemove(f.id); 
                                            }} className="px-2 py-1 text-slate-400 hover:text-white hover:bg-red-600 rounded self-start flex items-center gap-1 transition-colors" title="Remove file">
                                                <Icons.X /> <span className="text-xs">Remove</span>
                                            </button>
                                        </div>
                                    </div>
                                    );
                                })}
                            </div>
                        </div>
                    )}
                    
                    {/* Active Deployments - Multiple Status Boxes */}
                    {activeDeployments && activeDeployments.length > 0 && (
                        <div className="space-y-3">
                            {activeDeployments.map(deployment => (
                                <div key={deployment.id} className={`bg-slate-800 rounded-xl border p-4 fade-in ${
                                    deployment.status === 'running' ? 'border-indigo-500' :
                                    deployment.status === 'success' ? 'border-green-500' : 'border-red-500'
                                }`}>
                                    <h2 className="text-sm font-semibold mb-3 flex items-center gap-2">
                                        {deployment.status === 'running' ? (
                                            <div className="w-4 h-4 border-2 border-indigo-500 border-t-transparent rounded-full animate-spin" />
                                        ) : deployment.status === 'success' ? (
                                            <span className="text-green-400">✓</span>
                                        ) : (
                                            <span className="text-red-400">✗</span>
                                        )}
                                        <span className="text-slate-300">{deployment.appName || 'Deploy'}</span>
                                        {deployment.target && <span className="text-xs px-1.5 py-0.5 rounded bg-slate-700 text-slate-400">{deployment.target.toUpperCase()}</span>}
                                        {deployment.status === 'running' 
                                            ? <span className="text-indigo-300">{deployment.isRollback ? 'Rolling back' : deployment.isPromotion ? 'Promoting' : 'Deploying'}...</span>
                                            : deployment.status === 'success' ? <span className="text-green-400">Complete!</span> : <span className="text-red-400">Failed</span>
                                        }
                                        {deployment.fileCount && <span className="text-xs text-slate-500">({deployment.fileCount} files)</span>}
                                        <span className="flex-1" />
                                        {/* Show close button for errors, success auto-closes */}
                                        {deployment.status !== 'running' && deployment.status !== 'success' && (
                                            <button onClick={() => removeActiveDeployment(deployment.id)} className="text-slate-400 hover:text-white">
                                                <Icons.X />
                                            </button>
                                        )}
                                        {/* Show manual close for success too */}
                                        {deployment.status === 'success' && (
                                            <button onClick={() => removeActiveDeployment(deployment.id)} className="text-slate-500 hover:text-white text-xs">
                                                ✕
                                            </button>
                                        )}
                                    </h2>
                                    <div className="space-y-1.5">
                                        {deployment.steps.map((s, i) => (
                                            <div key={i} className="flex items-center gap-2 text-sm">
                                                <div className={`w-4 h-4 rounded-full flex items-center justify-center text-xs ${
                                                    s.status === 'complete' ? 'bg-green-500' :
                                                    s.status === 'running' ? 'bg-indigo-500' :
                                                    s.status === 'error' ? 'bg-red-500' : 'bg-amber-500'
                                                }`}>
                                                    {s.status === 'complete' ? '✓' : s.status === 'running' ? '•' : '!'}
                                                </div>
                                                <span className={s.status === 'error' ? 'text-red-400' : 'text-slate-300'}>{s.name}</span>
                                                {s.details && <span className="text-slate-500 text-xs">({s.details})</span>}
                                            </div>
                                        ))}
                                    </div>
                                    {deployment.status === 'success' && deployment.url && (
                                        <a href={deployment.url} target="_blank" className="mt-2 inline-flex items-center gap-1 text-indigo-400 hover:underline text-sm">
                                            <Icons.ExternalLink /> Open Site
                                        </a>
                                    )}
                                    {deployment.workflowUrl && (
                                        <a href={deployment.workflowUrl} target="_blank" className="mt-2 ml-3 inline-flex items-center gap-1 text-amber-400 hover:underline text-sm">
                                            <Icons.ExternalLink /> View Workflow
                                        </a>
                                    )}
                                </div>
                            ))}
                        </div>
                    )}
                </div>
                
                {/* Right Column - Product Health (Phase 4.1) */}
                <div className="space-y-6">
                    {/* Phase 4.1: Product Health Summary */}
                    <div className="bg-slate-800 rounded-xl border border-slate-700 p-4">
                        <h3 className="font-semibold mb-3 flex items-center gap-2 text-sm">
                            🏥 Product Health
                            <span className="text-xs text-slate-500 font-normal ml-auto">Last 30 days</span>
                        </h3>
                        <div className="grid grid-cols-2 gap-3 mb-3">
                            <div className="bg-green-900/20 border border-green-800/30 rounded-lg p-3 text-center">
                                <div className="text-2xl font-bold text-green-400">{productMetrics.shippedThisMonth.length}</div>
                                <div className="text-xs text-slate-400">Features Shipped</div>
                            </div>
                            <div className="bg-indigo-900/20 border border-indigo-800/30 rounded-lg p-3 text-center">
                                <div className="text-2xl font-bold text-indigo-400">{productMetrics.totalActive}</div>
                                <div className="text-xs text-slate-400">In Pipeline</div>
                            </div>
                            <div className="bg-blue-900/20 border border-blue-800/30 rounded-lg p-3 text-center group relative">
                                <div className="text-2xl font-bold text-blue-400">{productMetrics.readyApps.length}</div>
                                <div className="text-xs text-slate-400">Apps Session-Ready</div>
                                {/* Progressive disclosure tooltip */}
                                {productMetrics.readyApps.length > 0 && (
                                    <div className="absolute bottom-full left-1/2 -translate-x-1/2 mb-2 hidden group-hover:block z-20 w-48">
                                        <div className="bg-slate-900 border border-slate-600 rounded-lg p-2 text-xs text-left shadow-xl">
                                            {productMetrics.readyApps.slice(0, 5).map(ra => (
                                                <div key={ra.appId} className="flex items-center gap-1.5 py-0.5">
                                                    <AppIcon icon={ra.app?.icon} size={14} />
                                                    <span className="text-slate-300">{ra.app?.name}</span>
                                                    <span className="text-slate-500 ml-auto">{ra.withCriteria}/{ra.count} ready</span>
                                                </div>
                                            ))}
                                        </div>
                                    </div>
                                )}
                            </div>
                            <div className="bg-slate-700/50 border border-slate-600/30 rounded-lg p-3 text-center group relative">
                                <div className="text-2xl font-bold text-slate-300">{productMetrics.costPerFeature > 0 ? `$${productMetrics.costPerFeature.toFixed(2)}` : '—'}</div>
                                <div className="text-xs text-slate-400">Cost / Feature</div>
                                {/* Progressive disclosure tooltip */}
                                <div className="absolute bottom-full left-1/2 -translate-x-1/2 mb-2 hidden group-hover:block z-20 w-52">
                                    <div className="bg-slate-900 border border-slate-600 rounded-lg p-2 text-xs text-left shadow-xl">
                                        <div className="flex justify-between py-0.5"><span className="text-slate-400">Sessions</span><span>{productMetrics.recentSessions.length}</span></div>
                                        <div className="flex justify-between py-0.5"><span className="text-slate-400">Total cost</span><span>${productMetrics.totalCost.toFixed(2)}</span></div>
                                        <div className="flex justify-between py-0.5"><span className="text-slate-400">Deploys</span><span>{productMetrics.recentDeploys.length}</span></div>
                                        <div className="flex justify-between py-0.5"><span className="text-slate-400">Features done</span><span>{productMetrics.shippedThisMonth.length}</span></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        {/* Stale warning */}
                        {productMetrics.staleItems.length > 0 && (
                            <div className="flex items-center gap-2 text-xs text-amber-400 bg-amber-900/20 rounded-lg px-3 py-2">
                                ⚠️ {productMetrics.staleItems.length} item{productMetrics.staleItems.length !== 1 ? 's' : ''} stale (7+ days in-progress)
                            </div>
                        )}
                    </div>
                    
                    {/* Phase 4.2: Smart Quick Actions */}
                    <div className="bg-slate-800 rounded-xl border border-slate-700 p-4">
                        <h3 className="font-semibold mb-3 text-sm">⚡ Quick Actions</h3>
                        <div className="space-y-2">
                            {/* Start Session - links to most-ready app */}
                            <button
                                onClick={() => {
                                    if (mostReadyApp) {
                                        setView('projects');
                                        // Trigger Claude Prep for the most ready app
                                        setTimeout(() => {
                                            setModal({ type: 'claudePrep', data: { appId: mostReadyApp.appId } });
                                        }, 100);
                                    } else {
                                        setView('backlog');
                                    }
                                }}
                                className="w-full flex items-center gap-3 p-3 bg-indigo-600/20 border border-indigo-500/30 hover:bg-indigo-600/30 rounded-lg text-left transition-colors group"
                            >
                                <span className="text-lg">🤖</span>
                                <div className="flex-1">
                                    <div className="text-sm font-medium text-indigo-300">Start Session</div>
                                    <div className="text-xs text-slate-400">
                                        {mostReadyApp 
                                            ? `${mostReadyApp.app?.name} — ${mostReadyApp.withCriteria} item${mostReadyApp.withCriteria !== 1 ? 's' : ''} ready`
                                            : 'No items ready — add work items first'}
                                    </div>
                                </div>
                                <span className="text-slate-500 group-hover:text-indigo-400 transition-colors">→</span>
                            </button>
                            
                            {/* Add Idea */}
                            <button
                                onClick={() => setView('backlog')}
                                className="w-full flex items-center gap-3 p-3 bg-slate-700/50 hover:bg-slate-700 rounded-lg text-left transition-colors group"
                            >
                                <span className="text-lg">💡</span>
                                <div className="flex-1">
                                    <div className="text-sm font-medium">Add Idea</div>
                                    <div className="text-xs text-slate-400">Capture a new feature or improvement</div>
                                </div>
                                <span className="text-slate-500 group-hover:text-white transition-colors">→</span>
                            </button>
                            
                            {/* Review - show if sessions need review */}
                            {productMetrics.activeSessions.length > 0 && (
                                <button
                                    onClick={() => setView('session')}
                                    className="w-full flex items-center gap-3 p-3 bg-purple-900/20 border border-purple-500/20 hover:bg-purple-900/30 rounded-lg text-left transition-colors group"
                                >
                                    <span className="text-lg">📝</span>
                                    <div className="flex-1">
                                        <div className="text-sm font-medium text-purple-300">Review Session</div>
                                        <div className="text-xs text-slate-400">{productMetrics.activeSessions.length} session{productMetrics.activeSessions.length !== 1 ? 's' : ''} awaiting review</div>
                                    </div>
                                    <span className="text-slate-500 group-hover:text-purple-400 transition-colors">→</span>
                                </button>
                            )}
                            
                            {/* Deploy */}
                            <button
                                onClick={() => setView('smartdeploy')}
                                className="w-full flex items-center gap-3 p-3 bg-slate-700/50 hover:bg-slate-700 rounded-lg text-left transition-colors group"
                            >
                                <span className="text-lg">🚀</span>
                                <div className="flex-1">
                                    <div className="text-sm font-medium">Smart Deploy</div>
                                    <div className="text-xs text-slate-400">Deploy from archive package</div>
                                </div>
                                <span className="text-slate-500 group-hover:text-white transition-colors">→</span>
                            </button>
                        </div>
                    </div>
                    
                    {/* Pipeline Health (Phase 4.1 — progressive disclosure) */}
                    <div className="bg-slate-800 rounded-xl border border-slate-700 p-4">
                        <h3 className="font-semibold mb-3 flex items-center gap-2 text-sm">
                            📋 Pipeline
                            <button 
                                onClick={() => setView('backlog')}
                                className="ml-auto text-xs text-indigo-400 hover:text-indigo-300">
                                View All →
                            </button>
                        </h3>
                        {/* Pipeline bar */}
                        {productMetrics.totalActive > 0 ? (
                            <div className="mb-3">
                                <div className="h-4 rounded-full overflow-hidden flex bg-slate-700">
                                    {[
                                        { key: 'idea', label: 'Ideas', count: productMetrics.pipeline.idea, color: '#64748b' },
                                        { key: 'ready', label: 'Ready', count: productMetrics.pipeline.ready, color: '#3b82f6' },
                                        { key: 'in-progress', label: 'In Progress', count: productMetrics.pipeline['in-progress'], color: '#f59e0b' },
                                        { key: 'review', label: 'Review', count: productMetrics.pipeline.review, color: '#a855f7' },
                                    ].filter(s => s.count > 0).map(s => (
                                        <div key={s.key} 
                                            style={{ width: `${(s.count / productMetrics.totalActive) * 100}%`, backgroundColor: s.color }}
                                            className="h-full flex items-center justify-center text-[10px] font-medium text-white/90 min-w-[18px]"
                                            title={`${s.label}: ${s.count}`}>
                                            {(s.count / productMetrics.totalActive) > 0.12 ? s.count : ''}
                                        </div>
                                    ))}
                                </div>
                                <div className="flex flex-wrap gap-3 mt-2 text-xs">
                                    {Object.entries(productMetrics.pipeline).filter(([_, v]) => v > 0).map(([status, count]) => {
                                        const colors = { idea: 'text-slate-400', ready: 'text-blue-400', 'in-progress': 'text-amber-400', review: 'text-purple-400' };
                                        return (
                                            <span key={status} className={colors[status] || 'text-slate-400'}>
                                                {status === 'in-progress' ? 'WIP' : status.charAt(0).toUpperCase() + status.slice(1)}: {count}
                                            </span>
                                        );
                                    })}
                                </div>
                            </div>
                        ) : (
                            <div className="text-xs text-slate-500 py-2">No active work items in pipeline</div>
                        )}
                        {/* Active work items list */}
                        <div className="space-y-1">
                            {(globalWorkItems || [])
                                .filter(i => i.status === 'in-progress' || i.status === 'review' || i.status === 'ready')
                                .slice(0, 5)
                                .map(item => {
                                    const app = Object.values(apps).find(a => a.id === item.appId);
                                    const statusColors = {
                                        'in-progress': 'bg-amber-900/50 text-amber-300',
                                        review: 'bg-purple-900/50 text-purple-300',
                                        ready: 'bg-blue-900/50 text-blue-300'
                                    };
                                    return (
                                        <div key={item.id} className="flex items-center gap-2 text-sm p-2 bg-slate-700/50 rounded">
                                            {app && <AppIcon icon={app.icon} size={14} />}
                                            <span className="flex-1 truncate text-xs">{item.title}</span>
                                            <span className={`px-1.5 py-0.5 rounded text-[10px] ${statusColors[item.status] || 'bg-slate-700 text-slate-300'}`}>
                                                {item.status === 'in-progress' ? 'WIP' : item.status}
                                            </span>
                                        </div>
                                    );
                                })
                            }
                        </div>
                    </div>
                    
                    {/* Recent Activity (Phase 4.1) */}
                    {(globalActivity || []).length > 0 && (
                        <div className="bg-slate-800 rounded-xl border border-slate-700 p-4">
                            <h3 className="font-semibold mb-3 flex items-center gap-2 text-sm">
                                📡 Recent Activity
                                <button 
                                    onClick={() => setView('session')}
                                    className="ml-auto text-xs text-indigo-400 hover:text-indigo-300">
                                    Full Log →
                                </button>
                            </h3>
                            <div className="space-y-2">
                                {(globalActivity || []).slice(0, 6).map(evt => {
                                    const actionIcons = {
                                        deploy: '🚀', session_create: '🤖', session_complete: '✅',
                                        item_transition: '📋', review: '📝', scope: '🎯'
                                    };
                                    const timeAgo = (() => {
                                        const diff = Date.now() - new Date(evt.timestamp).getTime();
                                        const mins = Math.floor(diff / 60000);
                                        if (mins < 1) return 'now';
                                        if (mins < 60) return `${mins}m`;
                                        const hrs = Math.floor(mins / 60);
                                        if (hrs < 24) return `${hrs}h`;
                                        return `${Math.floor(hrs / 24)}d`;
                                    })();
                                    return (
                                        <div key={evt.id} className="flex items-start gap-2 text-xs">
                                            <span>{actionIcons[evt.action] || '•'}</span>
                                            <span className="flex-1 text-slate-300 leading-relaxed">{evt.summary}</span>
                                            <span className="text-slate-500 whitespace-nowrap">{timeAgo}</span>
                                        </div>
                                    );
                                })}
                            </div>
                        </div>
                    )}
                    
                    {/* App Pipeline — Collapsed by default (Phase 4.3 progressive disclosure: detail tier) */}
                    <details className="bg-slate-800 rounded-xl border border-slate-700 overflow-hidden">
                        <summary className="p-4 cursor-pointer hover:bg-slate-700/50 flex items-center gap-2 text-sm font-semibold select-none">
                            <Icons.Shield className="text-green-400" /> App Pipeline
                            {refreshing && <div className="w-3 h-3 border border-indigo-400 border-t-transparent rounded-full animate-spin ml-1" />}
                            <span className="ml-auto text-xs text-slate-500 font-normal">
                                {Object.values(apps).filter(a => a.testRepo || a.prodRepo).length} apps
                            </span>
                        </summary>
                        <div className="px-4 pb-4 space-y-3">
                            {/* v8.8.0: Project-based grouping */}
                            {projects.filter(proj => {
                                const projDef = config?.projects?.[proj.id];
                                return (projDef?.state || 'active') !== 'hidden';
                            }).map(proj => {
                                const colors = getProjectColor(proj.color);
                                const isCollapsed = collapsedProjects[proj.id] !== false && proj.id !== projects[0]?.id && !collapsedProjects.hasOwnProperty(proj.id);
                                // Auto-show if deploy active for any app in this project
                                const hasActiveDeploy = proj.apps.some(a => 
                                    activeDeployments?.some(d => d.appId === a.id && d.status === 'running') ||
                                    (deployingRepos && Object.keys(deployingRepos).some(k => k.startsWith(a.id + ':')))
                                );
                                const effectiveCollapsed = hasActiveDeploy ? false : (collapsedProjects[proj.id] ?? (proj.id !== projects[0]?.id));
                                const appCount = proj.apps.length;
                                const deployedCount = proj.apps.filter(a => a.currentProdVersion).length;
                                
                                return (
                                    <div key={proj.id} className={`rounded-xl border overflow-hidden ${colors.border} ${effectiveCollapsed ? '' : colors.bg}`}>
                                        {/* Project Header */}
                                        <div 
                                            className={`p-3 cursor-pointer hover:bg-white/5 flex items-center gap-3 transition-colors`}
                                            onClick={() => {
                                                setCollapsedProjects(prev => {
                                                    const next = { ...prev, [proj.id]: !effectiveCollapsed };
                                                    localStorage.setItem('cc_collapsedProjects', JSON.stringify(next));
                                                    return next;
                                                });
                                            }}
                                        >
                                            <span className={`transform transition-transform text-xs ${effectiveCollapsed ? '' : 'rotate-90'}`}>▶</span>
                                            <AppIcon icon={proj.icon} size={22} />
                                            <div className="flex-1">
                                                <span className={`font-semibold text-sm ${colors.text}`}>{proj.name}</span>
                                                <span className="text-xs text-slate-500 ml-2">{appCount} app{appCount !== 1 ? 's' : ''}</span>
                                            </div>
                                            {/* Compact version badges when collapsed */}
                                            {effectiveCollapsed && (
                                                <div className="flex items-center gap-1">
                                                    <span className="text-xs text-slate-500">{deployedCount}/{appCount} deployed</span>
                                                    {hasActiveDeploy && <span className="text-xs text-amber-400 animate-pulse">● deploying</span>}
                                                </div>
                                            )}
                                        </div>
                                        
                                        {/* Expanded: Show all apps */}
                                        {!effectiveCollapsed && (
                                            <div className="px-3 pb-3 space-y-2">
                                                {proj.apps.map(app => {
                                                    const isPublicStyle = app.appType === 'public' || !app.appType;
                                                    const isInternal = app.appType === 'internal';
                                                    const canPromote = app.testRepo && app.prodRepo && app.currentTestVersion && app.currentTestVersion !== app.currentProdVersion;
                                                    const effectiveSubPath = getEffectiveSubPath(app, app.id);
                                                    const testUrl = getGitHubPagesUrl(app.testRepo, effectiveSubPath);
                                                    const prodUrl = getGitHubPagesUrl(app.prodRepo, effectiveSubPath);
                                                    const testDeploying = deployingRepos && deployingRepos[`${app.id}:test`];
                                                    const prodDeploying = deployingRepos && deployingRepos[`${app.id}:prod`];
                                                    const isExpanded = expandedApps[app.id];
                                                    const info = appInfo[app.id];
                                                    const isLoadingInfo = loadingAppInfo[app.id];
                                                    
                                                    return (
                                                        <div key={app.id} className="bg-slate-700/50 rounded-lg overflow-hidden">
                                                            <div className="p-3 cursor-pointer hover:bg-slate-700/70" onClick={() => toggleAppExpanded(app.id)}>
                                                                <div className="flex items-center gap-2 mb-2">
                                                                    <span className={`transform transition-transform ${isExpanded ? 'rotate-90' : ''}`}>▶</span>
                                                                    <AppIcon icon={app.icon} size={20} />
                                                                    <span className="font-medium flex-1">{app.name}</span>
                                                                    {/* Maturity badge */}
                                                                    {app.lifecycle?.currentMaturity && (() => {
                                                                        const m = app.lifecycle.currentMaturity;
                                                                        const maturityStyles = {
                                                                            seed: 'bg-slate-700 text-slate-300',
                                                                            prototype: 'bg-amber-900/50 text-amber-300',
                                                                            alpha: 'bg-orange-900/50 text-orange-300',
                                                                            beta: 'bg-blue-900/50 text-blue-300',
                                                                            production: 'bg-green-900/50 text-green-300'
                                                                        };
                                                                        return (
                                                                            <span className={`px-1.5 py-0.5 rounded text-xs font-medium ${maturityStyles[m] || maturityStyles.seed}`} title={`Maturity: ${m}${app.lifecycle.maturityTarget ? ' → ' + app.lifecycle.maturityTarget : ''}`}>
                                                                                {m}
                                                                            </span>
                                                                        );
                                                                    })()}
                                                                    {(() => {
                                                                        const activeWI = (globalWorkItems || []).filter(wi => wi.appId === app.id && ['idea','ready','in-progress'].includes(wi.status));
                                                                        return activeWI.length > 0 ? (
                                                                            <span className="px-1.5 py-0.5 bg-indigo-900/50 text-indigo-300 rounded text-xs" title={`${activeWI.length} active work items`}>
                                                                                📋 {activeWI.length}
                                                                            </span>
                                                                        ) : null;
                                                                    })()}
                                                                    {isInternal && <span className="text-xs text-slate-500">internal</span>}
                                                                    {canPromote && (
                                                                        <button onClick={(e) => { e.stopPropagation(); onPromote(app.id); }}
                                                                            className="px-2 py-1 bg-amber-600 text-xs rounded flex items-center gap-1">
                                                                            <Icons.Zap className="w-3 h-3" /> Promote
                                                                        </button>
                                                                    )}
                                                                </div>
                                                                {/* Repo info */}
                                                                {isPublicStyle && app.testRepo && (
                                                                    <div className="text-xs text-slate-500 mb-2 font-mono ml-6">
                                                                        {app.testRepo ? app.testRepo.split('/')[1] : '(no test)'} → {app.prodRepo ? app.prodRepo.split('/')[1] : '(no prod)'}
                                                                    </div>
                                                                )}
                                                                {/* Version badges */}
                                                                <div className="flex items-center gap-2 text-xs ml-6">
                                                                    {app.testRepo && (
                                                                        <div className="flex items-center gap-1">
                                                                            <span className={`px-2 py-0.5 rounded ${app.currentTestVersion ? 'bg-blue-900/50 text-blue-300' : 'bg-slate-600 text-slate-400'}`}>
                                                                                TEST: {formatVersion(app.currentTestVersion)}
                                                                            </span>
                                                                            {testUrl && (
                                                                                <a href={testUrl} target="_blank" onClick={e => e.stopPropagation()}
                                                                                    className={`p-1 rounded flex items-center ${testDeploying ? 'bg-red-900/50 text-red-400 animate-pulse' : 'hover:bg-slate-600 text-slate-400'}`}
                                                                                    title={testDeploying ? `Deploying v${testDeploying.version}...` : 'Open TEST'}>
                                                                                    <Icons.Play />
                                                                                </a>
                                                                            )}
                                                                        </div>
                                                                    )}
                                                                    {app.testRepo && app.prodRepo && <Icons.ArrowRight className="w-4 h-4 text-slate-500" />}
                                                                    <div className="flex items-center gap-1">
                                                                        <span className={`px-2 py-0.5 rounded ${app.currentProdVersion ? 'bg-green-900/50 text-green-300' : 'bg-slate-600 text-slate-400'}`}>
                                                                            {app.testRepo ? 'PROD' : ''}: {formatVersion(app.currentProdVersion)}
                                                                        </span>
                                                                        {prodUrl && (
                                                                            <a href={prodUrl} target="_blank" onClick={e => e.stopPropagation()}
                                                                                className={`p-1 rounded flex items-center ${prodDeploying ? 'bg-red-900/50 text-red-400 animate-pulse' : 'hover:bg-slate-600 text-slate-400'}`}
                                                                                title={prodDeploying ? `Deploying v${prodDeploying.version}...` : 'Open PROD'}>
                                                                                <Icons.Play />
                                                                            </a>
                                                                        )}
                                                                    </div>
                                                                </div>
                                                            </div>
                                                            {isExpanded && (
                                                                <div className="px-3 pb-3 border-t border-slate-600 pt-2 ml-6 text-xs space-y-3">
                                                                    {isLoadingInfo ? (
                                                                        <div className="text-slate-400 flex items-center gap-2">
                                                                            <div className="w-3 h-3 border border-slate-400 border-t-transparent rounded-full animate-spin" />
                                                                            Loading...
                                                                        </div>
                                                                    ) : info ? (
                                                                        <div className="space-y-2">
                                                                            {info.test && <div className="text-slate-400">Test push: {formatRelativeTime(info.test.pushedAt)}</div>}
                                                                            {info.prod && <div className="text-slate-400">Prod push: {formatRelativeTime(info.prod.pushedAt)}</div>}
                                                                        </div>
                                                                    ) : null}
                                                                    <div className="flex items-center gap-2 flex-wrap">
                                                                        {app.prodRepo && (
                                                                            <button onClick={() => forceRebuild(app.prodRepo, 'prod')}
                                                                                className="px-2 py-1 bg-green-700 hover:bg-green-600 rounded">🔄 Force Rebuild</button>
                                                                        )}
                                                                        <button onClick={() => fetchAppInfo(app.id)}
                                                                            className="px-2 py-1 bg-slate-700 hover:bg-slate-600 rounded">
                                                                            <Icons.Refresh className="w-3 h-3" />
                                                                        </button>
                                                                        {rollbackSnapshots[`${app.id}:prod`] && (
                                                                            <button onClick={() => onQuickRollback(app.id, 'prod')}
                                                                                className="px-2 py-1 bg-amber-700 hover:bg-amber-600 rounded">
                                                                                ⏪ Rollback to v{rollbackSnapshots[`${app.id}:prod`].version}
                                                                            </button>
                                                                        )}
                                                                    </div>
                                                                </div>
                                                            )}
                                                        </div>
                                                    );
                                                })}
                                            </div>
                                        )}
                                    </div>
                                );
                            })}
                            {configuredApps.length === 0 && <div className="text-slate-400 text-sm">Add token in Settings</div>}
                        </div>
                    </details>
                    
                    {/* Issues - Demoted below fold (Phase 4.1) */}
                    {globalIssues.filter(i => i.status === 'open' || i.status === 'in-progress').length > 0 && (
                        <details className="bg-slate-800 rounded-xl border border-slate-700 overflow-hidden">
                            <summary className="p-4 cursor-pointer hover:bg-slate-700/50 flex items-center gap-2 text-sm font-semibold select-none">
                                <Icons.AlertCircle className="text-red-400" /> Issues
                                <span className="ml-auto text-xs font-normal">
                                    <span className="text-red-400">{globalIssues.filter(i => i.status === 'open').length} open</span>
                                    {globalIssues.filter(i => i.status === 'in-progress').length > 0 && (
                                        <span className="text-amber-400 ml-2">{globalIssues.filter(i => i.status === 'in-progress').length} WIP</span>
                                    )}
                                </span>
                            </summary>
                            <div className="px-4 pb-4">
                                <div className="space-y-1">
                                    {globalIssues
                                        .filter(i => i.status === 'open' || i.status === 'in-progress')
                                        .slice(0, 5)
                                        .map(issue => (
                                            <div key={issue.id} className="flex items-center gap-2 text-sm p-2 bg-slate-700/50 rounded">
                                                <span className="font-mono text-xs text-indigo-400">{issue.id}</span>
                                                <span className="flex-1 truncate text-xs">{issue.title}</span>
                                                <span className={`w-2 h-2 rounded-full ${
                                                    issue.status === 'open' ? 'bg-red-500' : 'bg-yellow-500'
                                                }`} />
                                            </div>
                                        ))
                                    }
                                </div>
                                <button 
                                    onClick={() => setView('issues')}
                                    className="mt-2 text-xs text-indigo-400 hover:text-indigo-300">
                                    View All Issues →
                                </button>
                            </div>
                        </details>
                    )}
                    
                    {/* Backlog breakdown - Demoted below fold (Phase 4.1) */}
                    {(globalWorkItems || []).filter(wi => wi.status === 'done').length > 0 && (
                        <details className="bg-slate-800 rounded-xl border border-slate-700 overflow-hidden">
                            <summary className="p-4 cursor-pointer hover:bg-slate-700/50 flex items-center gap-2 text-sm font-semibold select-none">
                                ✅ Recently Shipped
                                <span className="ml-auto text-xs text-green-400 font-normal">
                                    {(globalWorkItems || []).filter(wi => wi.status === 'done').length} completed
                                </span>
                            </summary>
                            <div className="px-4 pb-4 space-y-1">
                                {(globalWorkItems || [])
                                    .filter(wi => wi.status === 'done')
                                    .sort((a, b) => new Date(b.completedAt || b.updatedAt || 0) - new Date(a.completedAt || a.updatedAt || 0))
                                    .slice(0, 8)
                                    .map(item => {
                                        const app = Object.values(apps).find(a => a.id === item.appId);
                                        return (
                                            <div key={item.id} className="flex items-center gap-2 text-xs p-2 bg-slate-700/50 rounded">
                                                {app && <AppIcon icon={app.icon} size={14} />}
                                                <span className="flex-1 truncate text-slate-300">{item.title}</span>
                                                <span className="text-green-400">✓</span>
                                            </div>
                                        );
                                    })
                                }
                            </div>
                        </details>
                    )}
                </div>
            </div>
        );
    }

    // =========================================================================
    // REPO FILES VIEW
    // =========================================================================
    
    function RepoFilesView({ apps, github, repoFiles, onLoadRepo, selectedRepo, onSelectRepo, selectedAppKey, onSelectAppKey, markedForDeletion, setMarkedForDeletion, onDeleteMarked, showAlert }) {
        const configuredApps = Object.values(apps).filter(a => a.testRepo || a.prodRepo);
        const allRepos = [...new Set(configuredApps.flatMap(a => [a.testRepo, a.prodRepo].filter(Boolean)))];
        
        // v8.35.0: Derive selected app and subPath from selectedAppKey
        const selectedAppId = selectedAppKey ? selectedAppKey.split('::')[0] : null;
        const selectedApp = selectedAppId ? configuredApps.find(a => a.id === selectedAppId) : null;
        const selectedSubPath = selectedApp?.subPath || '';
        const cacheKey = selectedRepo ? (selectedSubPath ? `${selectedRepo}::${selectedSubPath}` : selectedRepo) : null;
        
        const currentFiles = repoFiles[cacheKey]?.files || [];
        const isLoading = repoFiles[cacheKey]?.loading;
        
        const [versionAudit, setVersionAudit] = React.useState(null);
        const [expandedDirs, setExpandedDirs] = React.useState([]);
        
        const toggleMarkForDeletion = (file) => {
            const existing = markedForDeletion.find(m => m.repo === selectedRepo && m.path === file.path);
            if (existing) {
                setMarkedForDeletion(prev => prev.filter(m => !(m.repo === selectedRepo && m.path === file.path)));
            } else {
                setMarkedForDeletion(prev => [...prev, { repo: selectedRepo, path: file.path, sha: file.sha, name: file.name }]);
            }
        };
        
        const isMarked = (file) => markedForDeletion.some(m => m.repo === selectedRepo && m.path === file.path);
        
        // Download file to user's Downloads folder
        const downloadFile = async (file) => {
            try {
                // Fetch the raw file content
                const response = await fetch(file.download_url);
                const blob = await response.blob();
                
                // Create download link
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = file.name; // Forces download with filename
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            } catch (err) {
                console.error('Download failed:', err);
                showAlert('Download failed: ' + err.message, 'Download Error');
            }
        };
        
        // Download entire repo as deploy package zip
        const [downloadingPackage, setDownloadingPackage] = React.useState(false);
        
        const downloadDeployPackage = async () => {
            if (!selectedRepo || !github) return;
            
            setDownloadingPackage(true);
            try {
                // Get app info for naming and subPath
                // v8.35.0: Use selectedAppKey to find exact app (handles shared repos)
                let app = null;
                if (selectedAppKey) {
                    const appId = selectedAppKey.split('::')[0];
                    app = configuredApps.find(a => a.id === appId);
                }
                if (!app) {
                    // Fallback: When multiple apps share a repo, prefer ones with subPath (more specific)
                    const matchingApps = configuredApps.filter(a => a.testRepo === selectedRepo || a.prodRepo === selectedRepo);
                    app = matchingApps.find(a => a.subPath) || matchingApps[0];
                }
                const repoName = selectedRepo.split('/')[1];
                const subPath = app?.subPath || '';
                
                // WHITELIST: Only include files that belong in deploy packages
                // Based on gs-active skill deploy structure
                const deployFiles = [
                    'index.html',
                    'sw.js',
                    'manifest.json',
                    'manifest-test.json',  // Test environment manifest
                    'RELEASE_NOTES.txt'  // Optional but include if present
                ];
                
                // Valid icon files for deploy packages
                const validIcons = [
                    'icon-72.png', 'icon-96.png', 'icon-128.png', 'icon-144.png',
                    'icon-152.png', 'icon-192.png', 'icon-384.png', 'icon-512.png',
                    'icon-maskable-192.png', 'icon-maskable-512.png',
                    'icon-source.svg', 'apple-touch-icon.png'
                ];
                
                // Check if a file should be included in deploy package
                // v8.7.5: Handle subPath - strip it from path before checking
                const shouldInclude = (fullPath) => {
                    // Remove subPath prefix if present to get relative path
                    let path = fullPath;
                    if (subPath && fullPath.startsWith(subPath + '/')) {
                        path = fullPath.substring(subPath.length + 1);
                    }
                    const filename = path.split('/').pop();
                    // Root level deploy files (relative to app folder)
                    if (deployFiles.includes(filename) && !path.includes('/')) return true;
                    // Icons folder files (both prod and test)
                    if ((path.startsWith('icons/') || path.startsWith('icons-test/')) && validIcons.includes(filename)) return true;
                    return false;
                };
                
                // Fetch repo contents - v8.7.5: Start from subPath if set
                const fetchAllFiles = async (path = subPath) => {
                    const contents = await github.listRepoContents(selectedRepo, path);
                    let files = [];
                    
                    for (const item of contents) {
                        if (item.type === 'file') {
                            // Only include whitelisted deploy files
                            if (shouldInclude(item.path)) {
                                files.push(item);
                            }
                        } else if (item.type === 'dir' && (item.name === 'icons' || item.name === 'icons-test')) {
                            // Recurse into icons and icons-test folders
                            const subFiles = await fetchAllFiles(item.path);
                            files = files.concat(subFiles);
                        }
                    }
                    return files;
                };
                
                const allFiles = await fetchAllFiles();
                
                // Get version from index.html if present
                let version = 'unknown';
                const indexFile = allFiles.find(f => f.name === 'index.html');
                if (indexFile) {
                    try {
                        // For large files (>1MB), GitHub API doesn't return content
                        // Use download_url instead which always works
                        const response = await fetch(indexFile.download_url);
                        const content = await response.text();
                        version = extractVersionFromHTML(content) || 'unknown';
                    } catch (e) {
                        console.warn('Could not extract version:', e);
                    }
                }
                
                // Determine folder name for zip structure: {app}-latest/
                // v8.35.0: Use app name for zip folder, not repo name
                let appName = (app?.id || repoName).replace(/test$/i, '');
                const folderName = `${appName}-latest`;
                
                // Create zip with proper structure: {app}-latest/{files}
                const zip = new JSZip();
                const folder = zip.folder(folderName);
                
                for (const file of allFiles) {
                    try {
                        const response = await fetch(file.download_url);
                        const blob = await response.blob();
                        // v8.35.0: Strip subPath prefix for correct zip structure
                        let relativePath = file.path;
                        if (subPath && relativePath.startsWith(subPath + '/')) {
                            relativePath = relativePath.substring(subPath.length + 1);
                        }
                        folder.file(relativePath, blob);
                    } catch (e) {
                        console.warn(`Failed to fetch ${file.path}:`, e);
                    }
                }
                
                // Generate zip and download
                const versionStr = version.replace(/\./g, '_');
                const filename = `${appName}-deploy-v${versionStr}.zip`;
                
                const content = await zip.generateAsync({ type: 'blob' });
                const url = URL.createObjectURL(content);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                setDownloadingPackage(false);
                
                // Show what was included
                const includedFiles = allFiles.map(f => f.path).join(', ');
                console.log(`Deploy package created: ${filename}`);
                console.log(`Included files: ${includedFiles}`);
                
            } catch (err) {
                console.error('Deploy package download failed:', err);
                showAlert('Deploy package download failed: ' + err.message, 'Download Error');
                setDownloadingPackage(false);
            }
        };
        
        const handleVersionAudit = async () => {
            if (!github || !selectedRepo) return;
            setVersionAudit({ loading: true });
            
            try {
                // v8.35.0: Use selectedAppKey to find exact app (handles shared repos)
                let app = null;
                if (selectedAppKey) {
                    const appId = selectedAppKey.split('::')[0];
                    app = configuredApps.find(a => a.id === appId);
                }
                if (!app) {
                    const matchingApps = configuredApps.filter(a => a.testRepo === selectedRepo || a.prodRepo === selectedRepo);
                    app = matchingApps.find(a => a.subPath) || matchingApps[0];
                }
                const indexPath = app?.subPath ? `${app.subPath}/index.html` : 'index.html';
                
                const fileData = await github.getFileContent(selectedRepo, indexPath);
                if (fileData) {
                    // Use textContent which handles both normal and large files
                    const content = fileData.textContent;
                    const versions = findAllVersionStrings(content);
                    const primary = extractVersionFromHTML(content);
                    
                    // Check for mismatches
                    const uniqueVersions = [...new Set(versions.map(v => v.value))];
                    const hasMismatch = uniqueVersions.length > 1;
                    
                    setVersionAudit({ loading: false, versions, primary, hasMismatch, uniqueVersions });
                } else {
                    setVersionAudit({ loading: false, error: 'index.html not found' });
                }
            } catch (e) {
                setVersionAudit({ loading: false, error: e.message });
            }
        };
        
        return (
            <div className="space-y-6">
                <div className="bg-slate-800 rounded-xl border border-slate-700 p-6">
                    <h2 className="text-lg font-semibold mb-4 flex items-center gap-2">
                        <Icons.Folder /> App Files
                    </h2>
                    
                    <div className="flex gap-4 mb-4">
                        <select value={selectedAppKey || ''} onChange={e => {
                            const val = e.target.value;
                            if (!val) { onSelectRepo(''); onSelectAppKey(''); return; }
                            const appId = val.split('::')[0];
                            const repo = val.split('::').slice(2).join('::');
                            const app = configuredApps.find(a => a.id === appId);
                            const subPath = app?.subPath || '';
                            onSelectAppKey(val);
                            onSelectRepo(repo);
                            setExpandedDirs([]);
                            if (repo) onLoadRepo(repo, subPath);
                        }}
                            className="flex-1 p-2 bg-slate-700 border border-slate-600 rounded">
                            <option value="">Select app...</option>
                            {configuredApps
                                .sort((a, b) => (a.name || a.id).localeCompare(b.name || b.id))
                                .flatMap(app => {
                                    const options = [];
                                    if (app.prodRepo) options.push({ label: `${getAppEmoji(app.icon)} ${app.name || app.id} — PROD`, key: `${app.id}::prod::${app.prodRepo}` });
                                    if (app.testRepo) options.push({ label: `${getAppEmoji(app.icon)} ${app.name || app.id} — TEST`, key: `${app.id}::test::${app.testRepo}` });
                                    return options;
                                })
                                .map(opt => <option key={opt.key} value={opt.key}>{opt.label}</option>)
                            }
                        </select>
                        
                        {selectedRepo && (
                            <button onClick={() => onLoadRepo(selectedRepo, selectedSubPath)} className="px-4 py-2 bg-slate-700 rounded flex items-center gap-2">
                                <Icons.Refresh className={isLoading ? 'animate-spin' : ''} /> Refresh
                            </button>
                        )}
                    </div>
                    
                    {selectedRepo && (
                        <div className="flex gap-2 mb-4 flex-wrap">
                            <a href={getGitHubPagesUrl(selectedRepo)} target="_blank" 
                                className="px-3 py-1.5 bg-indigo-600 rounded text-sm flex items-center gap-1">
                                <Icons.Play /> Open Site
                            </a>
                            <a href={`https://github.com/${selectedRepo}`} target="_blank"
                                className="px-3 py-1.5 bg-slate-700 rounded text-sm flex items-center gap-1">
                                <Icons.ExternalLink /> GitHub
                            </a>
                            <button onClick={handleVersionAudit}
                                className="px-3 py-1.5 bg-amber-700 rounded text-sm flex items-center gap-1">
                                🔍 Version Audit
                            </button>
                            <button onClick={downloadDeployPackage} disabled={downloadingPackage}
                                className="px-3 py-1.5 bg-green-700 hover:bg-green-600 disabled:bg-green-900 disabled:cursor-wait rounded text-sm flex items-center gap-1">
                                {downloadingPackage ? (
                                    <><div className="w-3 h-3 border-2 border-white border-t-transparent rounded-full animate-spin" /> Creating...</>
                                ) : (
                                    <><Icons.Download /> Download Package</>
                                )}
                            </button>
                        </div>
                    )}
                    
                    {/* Version Audit Results */}
                    {versionAudit && (
                        <div className={`mb-4 p-4 rounded-lg border ${versionAudit.hasMismatch ? 'bg-red-900/30 border-red-700' : 'bg-slate-700/50 border-slate-600'}`}>
                            <div className="flex items-center justify-between mb-3">
                                <h3 className="font-semibold flex items-center gap-2">
                                    {versionAudit.loading ? (
                                        <>
                                            <div className="w-4 h-4 border-2 border-amber-400 border-t-transparent rounded-full animate-spin" />
                                            Scanning...
                                        </>
                                    ) : versionAudit.hasMismatch ? (
                                        <><span className="text-red-400">⚠️ Version Mismatch Found!</span></>
                                    ) : (
                                        <><span className="text-green-400">✓ Versions Consistent</span></>
                                    )}
                                </h3>
                                <button onClick={() => setVersionAudit(null)} className="text-slate-400 hover:text-white">
                                    <Icons.X />
                                </button>
                            </div>
                            
                            {versionAudit.error && (
                                <div className="text-red-400 text-sm">{versionAudit.error}</div>
                            )}
                            
                            {versionAudit.versions && (
                                <>
                                    <div className="text-sm mb-2">
                                        <span className="text-slate-400">Primary version (meta tag): </span>
                                        <span className="font-mono text-green-400">{versionAudit.primary || 'Not found'}</span>
                                    </div>
                                    
                                    {versionAudit.hasMismatch && (
                                        <div className="text-sm mb-2 text-amber-400">
                                            Found {versionAudit.uniqueVersions.length} different versions: {versionAudit.uniqueVersions.join(', ')}
                                        </div>
                                    )}
                                    
                                    <div className="text-xs text-slate-400 mb-2">Found {versionAudit.versions.length} version string(s):</div>
                                    <div className="space-y-1 max-h-48 overflow-auto">
                                        {versionAudit.versions.map((v, i) => (
                                            <div key={i} className={`text-xs p-2 rounded ${v.value === versionAudit.primary ? 'bg-green-900/30' : 'bg-red-900/30'}`}>
                                                <div className="flex items-center gap-2">
                                                    <span className={`font-mono ${v.value === versionAudit.primary ? 'text-green-400' : 'text-red-400'}`}>
                                                        {v.value}
                                                    </span>
                                                    <span className="text-slate-500">← {v.source}</span>
                                                </div>
                                                <div className="text-slate-500 font-mono truncate mt-1">{v.context}</div>
                                            </div>
                                        ))}
                                    </div>
                                </>
                            )}
                        </div>
                    )}
                    
                    {isLoading && (
                        <div className="text-center py-8 text-slate-400">
                            <div className="w-6 h-6 border-2 border-indigo-500 border-t-transparent rounded-full animate-spin mx-auto mb-2" />
                            Loading files...
                        </div>
                    )}
                    
                    {!isLoading && currentFiles.length > 0 && (
                        <div className="space-y-1">
                            {/* Directories first */}
                            {currentFiles.filter(f => f.type === 'dir').map(dir => (
                                <div key={dir.path} className="bg-slate-700/30 rounded">
                                    <div className="p-2 flex items-center gap-3 cursor-pointer hover:bg-slate-700/50" 
                                        onClick={() => {
                                            const dirCacheKey = `${selectedRepo}::${dir.path}`;
                                            if (repoFiles[dirCacheKey]?.files) {
                                                setExpandedDirs(prev => prev.includes(dir.path) ? prev.filter(d => d !== dir.path) : [...prev, dir.path]);
                                            } else {
                                                onLoadRepo(selectedRepo, dir.path);
                                                setExpandedDirs(prev => [...prev, dir.path]);
                                            }
                                        }}>
                                        <span>{expandedDirs.includes(dir.path) ? '📂' : '📁'}</span>
                                        <span className="flex-1 font-mono text-sm font-semibold">{dir.name}/</span>
                                        <span className="text-xs text-slate-500">folder</span>
                                    </div>
                                    {expandedDirs.includes(dir.path) && (() => {
                                        const dirCacheKey = `${selectedRepo}::${dir.path}`;
                                        const dirFiles = repoFiles[dirCacheKey]?.files || [];
                                        const dirLoading = repoFiles[dirCacheKey]?.loading;
                                        return (
                                            <div className="ml-6 border-l border-slate-600 pl-2 pb-1">
                                                {dirLoading && <div className="p-2 text-xs text-slate-500">Loading...</div>}
                                                {dirFiles.filter(f => f.type === 'file').map(file => (
                                                    <div key={file.path} className={`p-1.5 rounded flex items-center gap-3 ${isMarked(file) ? 'bg-red-900/30 border border-red-700' : 'hover:bg-slate-700/50'}`}>
                                                        <span>{getFileIcon(file.name)}</span>
                                                        <span className="flex-1 font-mono text-sm">{file.name}</span>
                                                        <span className="text-xs text-slate-500">{formatBytes(file.size)}</span>
                                                        <div className="flex gap-1">
                                                            <a href={file.download_url} target="_blank" className="p-1 hover:bg-slate-600 rounded" title="View"><Icons.Eye /></a>
                                                            <button onClick={() => downloadFile(file)} className="p-1 hover:bg-slate-600 rounded" title="Download"><Icons.Download /></button>
                                                            <button onClick={() => toggleMarkForDeletion(file)} 
                                                                className={`p-1 rounded ${isMarked(file) ? 'bg-red-600 text-white' : 'hover:bg-red-900/50 text-slate-400 hover:text-red-400'}`}
                                                                title={isMarked(file) ? 'Unmark' : 'Mark for deletion'}><Icons.Trash /></button>
                                                        </div>
                                                    </div>
                                                ))}
                                                {!dirLoading && dirFiles.length === 0 && <div className="p-2 text-xs text-slate-500">Empty</div>}
                                            </div>
                                        );
                                    })()}
                                </div>
                            ))}
                            {/* Then files */}
                            {currentFiles.filter(f => f.type === 'file').map(file => (
                                <div key={file.path} className={`p-2 rounded flex items-center gap-3 ${isMarked(file) ? 'bg-red-900/30 border border-red-700' : 'bg-slate-700/50 hover:bg-slate-700'}`}>
                                    <span>{getFileIcon(file.name)}</span>
                                    <span className="flex-1 font-mono text-sm">{file.name}</span>
                                    <span className="text-xs text-slate-500">{formatBytes(file.size)}</span>
                                    <div className="flex gap-1">
                                        <a href={file.download_url} target="_blank" className="p-1 hover:bg-slate-600 rounded" title="View">
                                            <Icons.Eye />
                                        </a>
                                        <button onClick={() => downloadFile(file)} className="p-1 hover:bg-slate-600 rounded" title="Download">
                                            <Icons.Download />
                                        </button>
                                        <button onClick={() => toggleMarkForDeletion(file)} 
                                            className={`p-1 rounded ${isMarked(file) ? 'bg-red-600 text-white' : 'hover:bg-red-900/50 text-slate-400 hover:text-red-400'}`}
                                            title={isMarked(file) ? 'Unmark' : 'Mark for deletion'}>
                                            <Icons.Trash />
                                        </button>
                                    </div>
                                </div>
                            ))}
                        </div>
                    )}
                    
                    {!isLoading && selectedRepo && currentFiles.length === 0 && (
                        <div className="text-center py-8 text-slate-400">No files found</div>
                    )}
                </div>
                
                {/* Marked for Deletion Panel */}
                {markedForDeletion.length > 0 && (
                    <div className="bg-red-900/20 border border-red-700 rounded-xl p-4">
                        <div className="flex items-center justify-between mb-3">
                            <h3 className="font-semibold text-red-400 flex items-center gap-2">
                                <Icons.Trash /> Marked for Deletion ({markedForDeletion.length})
                            </h3>
                            <div className="flex gap-2">
                                <button onClick={() => setMarkedForDeletion([])} className="px-3 py-1 bg-slate-700 rounded text-sm">
                                    Clear All
                                </button>
                                <button onClick={onDeleteMarked} className="px-3 py-1 bg-red-600 rounded text-sm flex items-center gap-1">
                                    <Icons.Trash /> Delete All
                                </button>
                            </div>
                        </div>
                        <div className="space-y-1">
                            {markedForDeletion.map((item, i) => (
                                <div key={i} className="text-sm flex items-center gap-2 text-slate-300">
                                    <Icons.File /> <span className="text-slate-500">{item.repo.split('/')[1]}/</span>{item.path}
                                </div>
                            ))}
                        </div>
                    </div>
                )}
            </div>
        );
    }

    // =========================================================================
    // PORTFOLIO VIEW - Cross-app metrics, maturity, velocity, cost tracking
    // =========================================================================
    
    function PortfolioView({ apps, config, globalWorkItems, globalSessions, deployments, showAlert }) {
        const [timeRange, setTimeRange] = React.useState('30d'); // 7d, 30d, 90d, all
        
        const configuredApps = React.useMemo(() => 
            Object.entries(apps).filter(([_, a]) => a.testRepo || a.prodRepo).map(([id, a]) => ({ id, ...a })),
            [apps]
        );
        
        // Time filter helper
        const getTimeFilter = React.useCallback(() => {
            if (timeRange === 'all') return 0;
            const days = parseInt(timeRange);
            return Date.now() - (days * 24 * 60 * 60 * 1000);
        }, [timeRange]);
        
        // === MATURITY DISTRIBUTION ===
        const maturityData = React.useMemo(() => {
            const dist = { seed: 0, prototype: 0, alpha: 0, beta: 0, production: 0, unset: 0 };
            configuredApps.forEach(app => {
                const m = app.lifecycle?.currentMaturity;
                if (m && dist.hasOwnProperty(m)) dist[m]++;
                else dist.unset++;
            });
            return dist;
        }, [configuredApps]);
        
        // === BACKLOG HEALTH ===
        const backlogHealth = React.useMemo(() => {
            const items = globalWorkItems || [];
            const byStatus = { idea: 0, ready: 0, 'in-progress': 0, review: 0, done: 0, deferred: 0 };
            const byType = { feature: 0, bugfix: 0, enhancement: 0, chore: 0, research: 0 };
            const byApp = {};
            let aging = 0; // items in-progress or review > 7 days
            
            items.forEach(wi => {
                if (byStatus.hasOwnProperty(wi.status)) byStatus[wi.status]++;
                else if (wi.status) byStatus[wi.status] = (byStatus[wi.status] || 0) + 1;
                if (byType.hasOwnProperty(wi.type)) byType[wi.type]++;
                if (!byApp[wi.appId]) byApp[wi.appId] = 0;
                if (wi.status !== 'done' && wi.status !== 'deferred') byApp[wi.appId]++;
                if (WorkItemService.isStale(wi)) aging++;
            });
            
            return { byStatus, byType, byApp, aging, total: items.length };
        }, [globalWorkItems]);
        
        // === SESSION VELOCITY ===
        const sessionMetrics = React.useMemo(() => {
            const sessions = globalSessions || [];
            const cutoff = getTimeFilter();
            const filtered = cutoff ? sessions.filter(s => new Date(s.createdAt).getTime() > cutoff) : sessions;
            
            const byApp = {};
            const byType = {};
            const byWeek = {};
            let totalTokens = 0;
            let totalCost = 0;
            
            filtered.forEach(s => {
                // By app
                if (!byApp[s.appId]) byApp[s.appId] = 0;
                byApp[s.appId]++;
                
                // By type
                if (!byType[s.type]) byType[s.type] = 0;
                byType[s.type]++;
                
                // By week
                const d = new Date(s.createdAt);
                const weekStart = new Date(d);
                weekStart.setDate(d.getDate() - d.getDay());
                const weekKey = weekStart.toISOString().split('T')[0];
                if (!byWeek[weekKey]) byWeek[weekKey] = 0;
                byWeek[weekKey]++;
                
                // Token/cost tracking
                const tokens = s.packageTokens || 0;
                totalTokens += tokens;
                
                // Calculate cost using engine registry
                const engineId = s.engineId || 'claude-sonnet-4.5';
                const engine = EngineRegistryService.ENGINES[engineId];
                if (engine && tokens > 0) {
                    // Estimate: input tokens = package, output ≈ 30% of input
                    const inputCost = (tokens / 1000000) * engine.cost.input;
                    const outputTokens = tokens * 0.3;
                    const outputCost = (outputTokens / 1000000) * engine.cost.output;
                    totalCost += inputCost + outputCost;
                }
            });
            
            // Sessions per week average
            const weekKeys = Object.keys(byWeek).sort();
            const weekCount = weekKeys.length || 1;
            const avgPerWeek = (filtered.length / weekCount).toFixed(1);
            
            return { total: filtered.length, byApp, byType, byWeek, weekKeys, avgPerWeek, totalTokens, totalCost };
        }, [globalSessions, getTimeFilter]);
        
        // === DEPLOY FREQUENCY ===
        const deployMetrics = React.useMemo(() => {
            const deps = deployments || [];
            const cutoff = getTimeFilter();
            const filtered = cutoff ? deps.filter(d => new Date(d.timestamp || d.date).getTime() > cutoff) : deps;
            
            const byApp = {};
            const byTarget = { test: 0, prod: 0 };
            const byWeek = {};
            
            filtered.forEach(d => {
                const appId = d.appId || d.app;
                if (!byApp[appId]) byApp[appId] = 0;
                byApp[appId]++;
                
                if (d.target === 'prod') byTarget.prod++;
                else byTarget.test++;
                
                const dt = new Date(d.timestamp || d.date);
                const weekStart = new Date(dt);
                weekStart.setDate(dt.getDate() - dt.getDay());
                const weekKey = weekStart.toISOString().split('T')[0];
                if (!byWeek[weekKey]) byWeek[weekKey] = 0;
                byWeek[weekKey]++;
            });
            
            const weekCount = Object.keys(byWeek).length || 1;
            const avgPerWeek = (filtered.length / weekCount).toFixed(1);
            
            return { total: filtered.length, byApp, byTarget, byWeek, avgPerWeek };
        }, [deployments, getTimeFilter]);
        
        // === COST BY APP ===
        const costByApp = React.useMemo(() => {
            const sessions = globalSessions || [];
            const cutoff = getTimeFilter();
            const filtered = cutoff ? sessions.filter(s => new Date(s.createdAt).getTime() > cutoff) : sessions;
            
            const costs = {};
            filtered.forEach(s => {
                const tokens = s.packageTokens || 0;
                const engineId = s.engineId || 'claude-sonnet-4.5';
                const engine = EngineRegistryService.ENGINES[engineId];
                if (engine && tokens > 0) {
                    const inputCost = (tokens / 1000000) * engine.cost.input;
                    const outputTokens = tokens * 0.3;
                    const outputCost = (outputTokens / 1000000) * engine.cost.output;
                    const sessionCost = inputCost + outputCost;
                    
                    if (!costs[s.appId]) costs[s.appId] = { sessions: 0, tokens: 0, cost: 0 };
                    costs[s.appId].sessions++;
                    costs[s.appId].tokens += tokens;
                    costs[s.appId].cost += sessionCost;
                }
            });
            
            return costs;
        }, [globalSessions, getTimeFilter]);
        
        // Maturity bar colors
        const maturityColors = {
            seed: '#64748b',
            prototype: '#d97706',
            alpha: '#ea580c',
            beta: '#3b82f6',
            production: '#22c55e',
            unset: '#334155'
        };
        
        // Helper: stat card
        const StatCard = ({ label, value, sub, icon }) => (
            <div className="bg-slate-800 rounded-xl border border-slate-700 p-4">
                <div className="flex items-center gap-2 text-slate-400 text-xs mb-1">{icon} {label}</div>
                <div className="text-2xl font-bold">{value}</div>
                {sub && <div className="text-xs text-slate-500 mt-1">{sub}</div>}
            </div>
        );
        
        // Helper: horizontal bar
        const HBar = ({ items, total }) => {
            if (!total) return <div className="h-6 rounded bg-slate-700 w-full" />;
            return (
                <div className="h-6 rounded overflow-hidden flex w-full">
                    {items.filter(i => i.count > 0).map((item, idx) => (
                        <div key={idx} style={{ width: `${(item.count / total) * 100}%`, backgroundColor: item.color }}
                            className="h-full flex items-center justify-center text-xs font-medium text-white/90 min-w-[20px]"
                            title={`${item.label}: ${item.count}`}>
                            {item.count > 0 && (item.count / total) > 0.08 ? item.count : ''}
                        </div>
                    ))}
                </div>
            );
        };
        
        return (
            <div className="max-w-6xl mx-auto">
                <div className="flex items-center justify-between mb-6">
                    <div className="flex items-center gap-3">
                        <span className="text-2xl">📊</span>
                        <div>
                            <h1 className="text-2xl font-bold">Portfolio</h1>
                            <p className="text-slate-400 text-sm">Maturity, velocity, costs across all apps</p>
                        </div>
                    </div>
                    <div className="flex items-center gap-1 bg-slate-800 rounded-lg p-1 border border-slate-700">
                        {['7d', '30d', '90d', 'all'].map(r => (
                            <button key={r} onClick={() => setTimeRange(r)}
                                className={`px-3 py-1 text-xs rounded ${timeRange === r ? 'bg-indigo-600 text-white' : 'text-slate-400 hover:text-white'}`}>
                                {r === 'all' ? 'All Time' : r}
                            </button>
                        ))}
                    </div>
                </div>
                
                {/* Top Stats Row (Phase 4.1: Product-focused) */}
                <div className="grid grid-cols-2 md:grid-cols-5 gap-4 mb-6">
                    <StatCard icon="✅" label="Shipped" value={(() => {
                        const cutoff = getTimeFilter();
                        return (globalWorkItems || []).filter(wi => {
                            if (wi.status !== 'done') return false;
                            const t = new Date(wi.completedAt || wi.updatedAt || 0).getTime();
                            return cutoff ? t > cutoff : true;
                        }).length;
                    })()} sub="features completed" />
                    <StatCard icon="📦" label="Apps" value={configuredApps.length} sub={`${maturityData.production} in production`} />
                    <StatCard icon="🧠" label="Sessions" value={sessionMetrics.total} sub={`${sessionMetrics.avgPerWeek}/week avg`} />
                    <StatCard icon="🚀" label="Deploys" value={deployMetrics.total} sub={`${deployMetrics.avgPerWeek}/week avg`} />
                    <StatCard icon="💰" label="Est. Cost" value={`$${sessionMetrics.totalCost.toFixed(2)}`} sub={`${(sessionMetrics.totalTokens / 1000000).toFixed(1)}M tokens`} />
                </div>
                
                {/* Maturity Distribution */}
                <div className="bg-slate-800 rounded-xl border border-slate-700 p-5 mb-6">
                    <h3 className="font-semibold mb-4 flex items-center gap-2">🎯 App Maturity Distribution</h3>
                    <HBar total={configuredApps.length} items={[
                        { label: 'Seed', count: maturityData.seed, color: maturityColors.seed },
                        { label: 'Prototype', count: maturityData.prototype, color: maturityColors.prototype },
                        { label: 'Alpha', count: maturityData.alpha, color: maturityColors.alpha },
                        { label: 'Beta', count: maturityData.beta, color: maturityColors.beta },
                        { label: 'Production', count: maturityData.production, color: maturityColors.production },
                        { label: 'Unset', count: maturityData.unset, color: maturityColors.unset },
                    ]} />
                    <div className="flex flex-wrap gap-4 mt-3 text-xs">
                        {Object.entries(maturityData).filter(([_, v]) => v > 0).map(([stage, count]) => (
                            <div key={stage} className="flex items-center gap-1.5">
                                <div className="w-3 h-3 rounded" style={{ backgroundColor: maturityColors[stage] }} />
                                <span className="text-slate-300 capitalize">{stage}</span>
                                <span className="text-slate-500">{count}</span>
                            </div>
                        ))}
                    </div>
                </div>
                
                {/* Two Column: Backlog Health + Session Types */}
                <div className="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
                    {/* Backlog Health */}
                    <div className="bg-slate-800 rounded-xl border border-slate-700 p-5">
                        <h3 className="font-semibold mb-4 flex items-center gap-2">📋 Backlog Health</h3>
                        <div className="space-y-3">
                            <div>
                                <div className="text-xs text-slate-400 mb-1.5">By Status ({backlogHealth.total} total)</div>
                                <HBar total={backlogHealth.total} items={[
                                    { label: 'Idea', count: backlogHealth.byStatus.idea, color: '#64748b' },
                                    { label: 'Ready', count: backlogHealth.byStatus.ready, color: '#3b82f6' },
                                    { label: 'In Progress', count: backlogHealth.byStatus['in-progress'], color: '#f59e0b' },
                                    { label: 'Done', count: backlogHealth.byStatus.done, color: '#22c55e' },
                                    { label: 'Deferred', count: backlogHealth.byStatus.deferred, color: '#6b7280' },
                                ]} />
                                <div className="flex flex-wrap gap-3 mt-2 text-xs">
                                    {Object.entries(backlogHealth.byStatus).filter(([_, v]) => v > 0).map(([status, count]) => (
                                        <span key={status} className="text-slate-400">{status}: <span className="text-slate-200">{count}</span></span>
                                    ))}
                                </div>
                            </div>
                            {backlogHealth.aging > 0 && (
                                <div className="flex items-center gap-2 text-xs text-amber-400 bg-amber-900/20 rounded-lg px-3 py-2">
                                    ⚠️ {backlogHealth.aging} item{backlogHealth.aging !== 1 ? 's' : ''} in-progress for 7+ days
                                </div>
                            )}
                            {/* Top apps by open items */}
                            <div>
                                <div className="text-xs text-slate-400 mb-1.5">Open Items by App</div>
                                <div className="space-y-1">
                                    {Object.entries(backlogHealth.byApp)
                                        .filter(([_, count]) => count > 0)
                                        .sort((a, b) => b[1] - a[1])
                                        .slice(0, 8)
                                        .map(([appId, count]) => {
                                            const app = apps[appId];
                                            return (
                                                <div key={appId} className="flex items-center gap-2 text-xs">
                                                    <AppIcon icon={app?.icon} size={14} />
                                                    <span className="text-slate-300 flex-1">{app?.name || appId}</span>
                                                    <span className="text-slate-400">{count}</span>
                                                    <div className="w-20 h-2 bg-slate-700 rounded overflow-hidden">
                                                        <div className="h-full bg-indigo-500 rounded" style={{ width: `${Math.min(100, (count / Math.max(...Object.values(backlogHealth.byApp))) * 100)}%` }} />
                                                    </div>
                                                </div>
                                            );
                                        })}
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    {/* Session Types */}
                    <div className="bg-slate-800 rounded-xl border border-slate-700 p-5">
                        <h3 className="font-semibold mb-4 flex items-center gap-2">🧠 Session Mix</h3>
                        {sessionMetrics.total === 0 ? (
                            <div className="text-slate-500 text-sm py-8 text-center">No sessions recorded yet. Use Claude Prep to start tracking.</div>
                        ) : (
                            <div className="space-y-3">
                                <HBar total={sessionMetrics.total} items={[
                                    { label: 'Build', count: sessionMetrics.byType.build || 0, color: '#3b82f6' },
                                    { label: 'Fix', count: sessionMetrics.byType.fix || 0, color: '#ef4444' },
                                    { label: 'Design', count: sessionMetrics.byType.design || 0, color: '#8b5cf6' },
                                    { label: 'Test', count: sessionMetrics.byType.test || 0, color: '#22c55e' },
                                    { label: 'Research', count: sessionMetrics.byType.research || 0, color: '#f59e0b' },
                                    { label: 'Other', count: (sessionMetrics.byType.review || 0) + (sessionMetrics.byType.polish || 0) + (sessionMetrics.byType.document || 0), color: '#64748b' },
                                ]} />
                                <div className="flex flex-wrap gap-3 text-xs">
                                    {Object.entries(sessionMetrics.byType).filter(([_, v]) => v > 0).sort((a, b) => b[1] - a[1]).map(([type, count]) => (
                                        <span key={type} className="text-slate-400 capitalize">{type}: <span className="text-slate-200">{count}</span></span>
                                    ))}
                                </div>
                                {/* Sessions by app */}
                                <div>
                                    <div className="text-xs text-slate-400 mb-1.5 mt-2">Sessions by App</div>
                                    <div className="space-y-1">
                                        {Object.entries(sessionMetrics.byApp)
                                            .sort((a, b) => b[1] - a[1])
                                            .slice(0, 8)
                                            .map(([appId, count]) => {
                                                const app = apps[appId];
                                                const appCost = costByApp[appId];
                                                return (
                                                    <div key={appId} className="flex items-center gap-2 text-xs">
                                                        <AppIcon icon={app?.icon} size={14} />
                                                        <span className="text-slate-300 flex-1">{app?.name || appId}</span>
                                                        <span className="text-slate-400">{count} sess</span>
                                                        {appCost && <span className="text-green-400/70">${appCost.cost.toFixed(2)}</span>}
                                                    </div>
                                                );
                                            })}
                                    </div>
                                </div>
                            </div>
                        )}
                    </div>
                </div>
                
                {/* Deploy Frequency */}
                <div className="bg-slate-800 rounded-xl border border-slate-700 p-5 mb-6">
                    <h3 className="font-semibold mb-4 flex items-center gap-2">🚀 Deploy Activity</h3>
                    {deployMetrics.total === 0 ? (
                        <div className="text-slate-500 text-sm py-4 text-center">No deploys in this time range.</div>
                    ) : (
                        <div className="space-y-4">
                            <div className="flex gap-6 text-sm">
                                <div><span className="text-blue-400 font-semibold">{deployMetrics.byTarget.test}</span> <span className="text-slate-400">to test</span></div>
                                <div><span className="text-green-400 font-semibold">{deployMetrics.byTarget.prod}</span> <span className="text-slate-400">to prod</span></div>
                                <div className="text-slate-500">|</div>
                                <div><span className="text-slate-200 font-semibold">{deployMetrics.avgPerWeek}</span> <span className="text-slate-400">per week</span></div>
                            </div>
                            {/* Weekly sparkline */}
                            {Object.keys(deployMetrics.byWeek).length > 1 && (() => {
                                const weeks = Object.entries(deployMetrics.byWeek).sort((a, b) => a[0].localeCompare(b[0]));
                                const maxWeek = Math.max(...weeks.map(w => w[1]));
                                return (
                                    <div>
                                        <div className="text-xs text-slate-400 mb-2">Weekly Deploy Volume</div>
                                        <div className="flex items-end gap-1 h-16">
                                            {weeks.map(([week, count]) => (
                                                <div key={week} className="flex-1 flex flex-col items-center gap-1">
                                                    <div className="w-full bg-indigo-500/70 rounded-t min-h-[2px]"
                                                        style={{ height: `${(count / maxWeek) * 100}%` }}
                                                        title={`Week of ${week}: ${count} deploys`} />
                                                </div>
                                            ))}
                                        </div>
                                        <div className="flex gap-1 mt-1">
                                            {weeks.map(([week]) => (
                                                <div key={week} className="flex-1 text-center text-[9px] text-slate-600">
                                                    {week.slice(5)}
                                                </div>
                                            ))}
                                        </div>
                                    </div>
                                );
                            })()}
                            {/* Top deployed apps */}
                            <div>
                                <div className="text-xs text-slate-400 mb-1.5">Deploys by App</div>
                                <div className="grid grid-cols-2 md:grid-cols-3 gap-2">
                                    {Object.entries(deployMetrics.byApp)
                                        .sort((a, b) => b[1] - a[1])
                                        .slice(0, 9)
                                        .map(([appId, count]) => {
                                            const app = apps[appId];
                                            return (
                                                <div key={appId} className="flex items-center gap-2 text-xs bg-slate-700/50 rounded-lg px-3 py-2">
                                                    <AppIcon icon={app?.icon} size={14} />
                                                    <span className="text-slate-300 flex-1 truncate">{app?.name || appId}</span>
                                                    <span className="text-slate-400 font-medium">{count}</span>
                                                </div>
                                            );
                                        })}
                                </div>
                            </div>
                        </div>
                    )}
                </div>
                
                {/* Cost Breakdown Table */}
                {Object.keys(costByApp).length > 0 && (
                    <div className="bg-slate-800 rounded-xl border border-slate-700 p-5 mb-6">
                        <h3 className="font-semibold mb-4 flex items-center gap-2">💰 Cost Breakdown by App</h3>
                        <div className="overflow-x-auto">
                            <table className="w-full text-sm">
                                <thead>
                                    <tr className="text-left text-xs text-slate-400 border-b border-slate-700">
                                        <th className="pb-2 pl-2">App</th>
                                        <th className="pb-2 text-right">Sessions</th>
                                        <th className="pb-2 text-right">Tokens</th>
                                        <th className="pb-2 text-right">Est. Cost</th>
                                        <th className="pb-2 text-right pr-2">$/Session</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    {Object.entries(costByApp)
                                        .sort((a, b) => b[1].cost - a[1].cost)
                                        .map(([appId, data]) => {
                                            const app = apps[appId];
                                            return (
                                                <tr key={appId} className="border-b border-slate-700/50 hover:bg-slate-700/30">
                                                    <td className="py-2 pl-2 flex items-center gap-2">
                                                        <AppIcon icon={app?.icon} size={16} />
                                                        <span>{app?.name || appId}</span>
                                                        {app?.lifecycle?.currentMaturity && (
                                                            <span className="text-[10px] text-slate-500 capitalize">{app.lifecycle.currentMaturity}</span>
                                                        )}
                                                    </td>
                                                    <td className="py-2 text-right text-slate-300">{data.sessions}</td>
                                                    <td className="py-2 text-right text-slate-400">{(data.tokens / 1000).toFixed(0)}K</td>
                                                    <td className="py-2 text-right text-green-400">${data.cost.toFixed(2)}</td>
                                                    <td className="py-2 text-right pr-2 text-slate-400">${(data.cost / data.sessions).toFixed(2)}</td>
                                                </tr>
                                            );
                                        })}
                                    <tr className="font-medium">
                                        <td className="py-2 pl-2 text-slate-300">Total</td>
                                        <td className="py-2 text-right text-slate-200">{sessionMetrics.total}</td>
                                        <td className="py-2 text-right text-slate-300">{(sessionMetrics.totalTokens / 1000).toFixed(0)}K</td>
                                        <td className="py-2 text-right text-green-300">${sessionMetrics.totalCost.toFixed(2)}</td>
                                        <td className="py-2 text-right pr-2 text-slate-300">${sessionMetrics.total ? (sessionMetrics.totalCost / sessionMetrics.total).toFixed(2) : '0.00'}</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <div className="mt-3 text-xs text-slate-500">
                            💡 Cost estimates based on package token counts × engine pricing. Actual costs depend on conversation length and output volume.
                        </div>
                    </div>
                )}
                
                {/* App Maturity Detail Table */}
                <div className="bg-slate-800 rounded-xl border border-slate-700 p-5">
                    <h3 className="font-semibold mb-4 flex items-center gap-2">🎯 App Status Overview</h3>
                    <div className="overflow-x-auto">
                        <table className="w-full text-sm">
                            <thead>
                                <tr className="text-left text-xs text-slate-400 border-b border-slate-700">
                                    <th className="pb-2 pl-2">App</th>
                                    <th className="pb-2">Maturity</th>
                                    <th className="pb-2">Target</th>
                                    <th className="pb-2 text-right">Open WI</th>
                                    <th className="pb-2 text-right">Sessions</th>
                                    <th className="pb-2 text-right">Deploys</th>
                                    <th className="pb-2 text-right pr-2">Prod Ver.</th>
                                </tr>
                            </thead>
                            <tbody>
                                {configuredApps
                                    .sort((a, b) => (a.name || a.id).localeCompare(b.name || b.id))
                                    .map(app => {
                                        const m = app.lifecycle?.currentMaturity;
                                        const mt = app.lifecycle?.maturityTarget;
                                        const openWI = (globalWorkItems || []).filter(wi => wi.appId === app.id && !['done', 'deferred'].includes(wi.status)).length;
                                        const sessCount = sessionMetrics.byApp[app.id] || 0;
                                        const depCount = deployMetrics.byApp[app.id] || 0;
                                        const maturityBg = {
                                            seed: 'bg-slate-700 text-slate-300',
                                            prototype: 'bg-amber-900/50 text-amber-300',
                                            alpha: 'bg-orange-900/50 text-orange-300',
                                            beta: 'bg-blue-900/50 text-blue-300',
                                            production: 'bg-green-900/50 text-green-300'
                                        };
                                        
                                        return (
                                            <tr key={app.id} className="border-b border-slate-700/50 hover:bg-slate-700/30">
                                                <td className="py-2 pl-2 flex items-center gap-2">
                                                    <AppIcon icon={app.icon} size={16} />
                                                    <span>{app.name}</span>
                                                </td>
                                                <td className="py-2">
                                                    {m ? (
                                                        <span className={`px-1.5 py-0.5 rounded text-xs capitalize ${maturityBg[m] || ''}`}>{m}</span>
                                                    ) : (
                                                        <span className="text-slate-600 text-xs">—</span>
                                                    )}
                                                </td>
                                                <td className="py-2">
                                                    {mt ? (
                                                        <span className="text-xs text-slate-400 capitalize">{mt}</span>
                                                    ) : (
                                                        <span className="text-slate-600 text-xs">—</span>
                                                    )}
                                                </td>
                                                <td className="py-2 text-right">{openWI > 0 ? <span className="text-indigo-300">{openWI}</span> : <span className="text-slate-600">0</span>}</td>
                                                <td className="py-2 text-right">{sessCount > 0 ? sessCount : <span className="text-slate-600">0</span>}</td>
                                                <td className="py-2 text-right">{depCount > 0 ? depCount : <span className="text-slate-600">0</span>}</td>
                                                <td className="py-2 text-right pr-2 text-xs font-mono">{app.currentProdVersion || <span className="text-slate-600">—</span>}</td>
                                            </tr>
                                        );
                                    })}
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        );
    }

    // =========================================================================
    // ENVIRONMENT OPTIMIZATION VIEW - Claude Project setup guides
    // Phase 4.2: Per-app optimization, token savings, platform recommendations
    // =========================================================================
    
    function EnvironmentOptimizationView({ apps, config, globalSessions, showAlert }) {
        const [selectedAppId, setSelectedAppId] = React.useState(null);
        const [copiedSection, setCopiedSection] = React.useState(null);
        
        const configuredApps = React.useMemo(() => 
            Object.entries(apps).filter(([_, a]) => a.testRepo || a.prodRepo).map(([id, a]) => ({ id, ...a })),
            [apps]
        );
        
        // Sort apps by session count (most active first)
        const sortedApps = React.useMemo(() => {
            const sessions = globalSessions || [];
            const sessionCounts = {};
            sessions.forEach(s => { sessionCounts[s.appId] = (sessionCounts[s.appId] || 0) + 1; });
            return [...configuredApps].sort((a, b) => (sessionCounts[b.id] || 0) - (sessionCounts[a.id] || 0));
        }, [configuredApps, globalSessions]);
        
        const selectedApp = selectedAppId ? { id: selectedAppId, ...apps[selectedAppId] } : null;
        
        // === DOC CLASSIFICATION ===
        // Persistent docs: rarely change, belong in Claude Project Knowledge
        const PERSISTENT_DOCS = [
            { name: 'CONTEXT.md', desc: 'Architecture, conventions, schemas', changeFreq: 'Low — updated every few sessions' },
            { name: 'CLAUDE_INSTRUCTIONS.md', desc: 'AI development instructions, standards profile', changeFreq: 'Very low — set during scoping' },
            { name: 'ARCHITECTURE.md', desc: 'Detailed component/data flow reference', changeFreq: 'Low — updated on major changes' },
            { name: 'CLAUDE-PREP-STANDARD.md', desc: 'Session start/end conventions', changeFreq: 'Very low — ecosystem-wide standard' },
        ];
        
        // Session docs: change often, upload each time
        const SESSION_DOCS = [
            { name: 'SESSION_BRIEF.md', desc: 'Auto-generated session context with current state', changeFreq: 'Every session — auto-generated' },
            { name: 'CHANGELOG.md', desc: 'Full version history', changeFreq: 'Every deploy — new entries added' },
            { name: 'RELEASE_NOTES.txt', desc: 'Human-readable release notes', changeFreq: 'Every deploy — new entries added' },
            { name: 'PROJECT_PLAN.md', desc: 'Roadmap and planned features', changeFreq: 'Moderate — updated as scope evolves' },
            { name: 'Source file(s)', desc: 'index.html, sw.js, etc.', changeFreq: 'Every session — actively modified' },
        ];
        
        // === TOKEN SAVINGS CALCULATION ===
        const getTokenSavings = React.useCallback((app) => {
            // Estimate tokens for persistent docs based on typical sizes
            const persistentTokenEstimates = {
                'CONTEXT.md': 12000,       // ~35KB typical
                'CLAUDE_INSTRUCTIONS.md': 4000,  // ~12KB typical
                'ARCHITECTURE.md': 6000,    // ~18KB typical
                'CLAUDE-PREP-STANDARD.md': 3500,  // ~10KB typical
            };
            
            // Check if app has these docs (approximate — we can't scan repo here)
            const hasInstructions = app.lifecycle?.scope; // If scoped, likely has CLAUDE_INSTRUCTIONS.md
            const hasArchitecture = app.lifecycle?.complexity === 'large' || app.lifecycle?.complexity === 'medium';
            
            let persistentTokens = persistentTokenEstimates['CONTEXT.md'] + persistentTokenEstimates['CLAUDE-PREP-STANDARD.md'];
            if (hasInstructions) persistentTokens += persistentTokenEstimates['CLAUDE_INSTRUCTIONS.md'];
            if (hasArchitecture) persistentTokens += persistentTokenEstimates['ARCHITECTURE.md'];
            
            // Project Knowledge docs are included for free (don't count against context)
            // But they save the time/tokens of uploading them each session
            const sessionsPerMonth = 4; // Conservative estimate
            const sessions = (globalSessions || []).filter(s => s.appId === app.id);
            const actualSessionsPerMonth = sessions.length > 0 
                ? Math.max(1, Math.round(sessions.length / Math.max(1, (Date.now() - new Date(sessions[0]?.createdAt || Date.now()).getTime()) / (30 * 24 * 60 * 60 * 1000))))
                : sessionsPerMonth;
            
            const monthlySavings = persistentTokens * actualSessionsPerMonth;
            
            // Cost savings
            const engine = EngineRegistryService.ENGINES[EngineRegistryService.getDefault()];
            const costPerToken = engine ? engine.cost.input / 1000000 : 0.003;
            const monthlyCostSavings = monthlySavings * costPerToken;
            
            return {
                persistentTokens,
                sessionsPerMonth: actualSessionsPerMonth,
                monthlySavings,
                monthlyCostSavings,
                hasCLAUDE_INSTRUCTIONS: hasInstructions,
                hasArchitecture
            };
        }, [globalSessions]);
        
        // === SKILLS RECOMMENDATIONS ===
        const getSkillRecommendations = React.useCallback((app) => {
            const category = app.lifecycle?.scope?.category || app.appType;
            const scope = app.lifecycle?.scope || {};
            const skills = [];
            
            // Project-aware: recommend skills based on project ecosystem
            const project = config?.projects?.[app.project];
            if (project) {
                // If project has a custom skill config, use it; otherwise derive from category
                if (project.skills && Array.isArray(project.skills)) {
                    project.skills.forEach(s => skills.push({ ...s, reason: `${project.name} ecosystem` }));
                } else if (app.project === 'gameshelf') {
                    // Game Shelf specific (backward compat — will be configurable per project later)
                    skills.push({ name: 'gs-active', desc: 'Archive structure and deployment conventions', relevance: 'high', reason: `${project.name} ecosystem` });
                }
            }
            
            // Category-driven (universal — not ecosystem-specific)
            if (category === 'game') {
                if (!skills.find(s => s.name === 'game-rules')) {
                    skills.push({ name: 'game-rules', desc: 'Game mechanics and rules reference', relevance: 'high', reason: 'Game app category' });
                }
                skills.push({ name: 'firebase-patterns', desc: 'Firebase RTDB structure for game data', relevance: 'high', reason: 'Game data persistence' });
                skills.push({ name: 'ui-components', desc: 'Dark mode styling, modals, buttons', relevance: 'medium', reason: 'Consistent game UI' });
            }
            
            if (category === 'tool' || category === 'admin' || category === 'dashboard') {
                skills.push({ name: 'ui-components', desc: 'Dark mode styling, modals, buttons', relevance: 'high', reason: 'Tool UI patterns' });
            }
            
            // If has Firebase
            if (scope.categoryAnswers?.multiplayer || scope.categoryAnswers?.dataPersistence === 'Firebase' || scope.categoryAnswers?.authRequired) {
                if (!skills.find(s => s.name === 'firebase-patterns')) {
                    skills.push({ name: 'firebase-patterns', desc: 'Firebase RTDB structure', relevance: 'high', reason: 'Firebase integration' });
                }
            }
            
            // Logo skill for ecosystem branding (only for GS)
            if (app.project === 'gameshelf') {
                skills.push({ name: 'gs-logos', desc: 'Game Shelf logo assets and usage', relevance: 'low', reason: 'Ecosystem branding' });
            }
            
            // Session continuity for complex apps
            if (app.lifecycle?.complexity === 'large' || app.lifecycle?.complexity === 'medium') {
                skills.push({ name: 'session-continuity', desc: 'Recovery protocol after session compaction', relevance: 'medium', reason: 'Complex app — long sessions likely' });
            }
            
            return skills;
        }, [config]);
        
        // === PLATFORM FEATURE RECOMMENDATIONS ===
        const getPlatformRecommendations = React.useCallback((app) => {
            const engine = EngineRegistryService.ENGINES[EngineRegistryService.getDefault()];
            const features = engine?.features || {};
            const recs = [];
            
            if (features.projects) {
                recs.push({
                    feature: 'Claude Project',
                    icon: '📂',
                    status: 'recommended',
                    reason: 'Move persistent docs to Project Knowledge to save tokens every session',
                    setup: 'Create a project per app → add CONTEXT.md, CLAUDE_INSTRUCTIONS.md, ARCHITECTURE.md, CLAUDE-PREP-STANDARD.md as Project Knowledge'
                });
            }
            
            if (features.skills) {
                recs.push({
                    feature: 'Custom Skills',
                    icon: '🛠️',
                    status: 'recommended',
                    reason: 'Upload ecosystem-specific skills for consistent conventions across sessions',
                    setup: 'Upload skill .md files to the project\'s Custom Instructions or Skills section'
                });
            }
            
            if (features.artifacts) {
                recs.push({
                    feature: 'Artifacts',
                    icon: '✨',
                    status: 'enabled',
                    reason: 'Enables inline preview of HTML, React, and markdown outputs during build sessions',
                    setup: 'Enabled by default — useful for UI work and documentation'
                });
            }
            
            if (features.memory) {
                recs.push({
                    feature: 'Memory',
                    icon: '🧠',
                    status: 'optional',
                    reason: 'Remembers preferences across sessions, but Project Knowledge is more reliable for structured context',
                    setup: 'Enable in settings — useful for general preferences, not project-specific data'
                });
            }
            
            if (features.extendedThinking) {
                recs.push({
                    feature: 'Extended Thinking',
                    icon: '💭',
                    status: 'for design sessions',
                    reason: 'Improves architecture and design reasoning — enable for Design session types',
                    setup: 'Enable when doing architecture design or complex problem solving'
                });
            }
            
            if (features.computerUse) {
                recs.push({
                    feature: 'Computer Use',
                    icon: '🖥️',
                    status: 'for build sessions',
                    reason: 'File creation and code execution for generating deploy packages',
                    setup: 'Enable when you need Claude to produce files or run tests'
                });
            }
            
            if (features.webSearch) {
                recs.push({
                    feature: 'Web Search',
                    icon: '🌐',
                    status: 'for research sessions',
                    reason: 'Useful for research sessions to find API docs, patterns, and best practices',
                    setup: 'Enable for Research session types, disable for Build sessions to keep focus'
                });
            }
            
            return recs;
        }, []);
        
        // === SESSION TYPE ADVICE ===
        const getSessionTypeAdvice = React.useCallback(() => {
            const types = Object.entries(SESSION_TYPES);
            return types.map(([id, t]) => {
                const engine = EngineRegistryService.recommendForSessionType(id);
                return {
                    id,
                    ...t,
                    recommendedEngine: engine,
                    platformTips: id === 'build' 
                        ? 'Enable Computer Use + Artifacts. Disable Web Search. Use Sonnet for speed/quality balance.'
                        : id === 'design'
                        ? 'Enable Extended Thinking. Disable Computer Use. Use Opus for complex architecture.'
                        : id === 'fix'
                        ? 'Enable Computer Use. Include issue details in brief. Use Sonnet. Minimize context — skip CHANGELOG.'
                        : id === 'research'
                        ? 'Enable Web Search. Disable Computer Use. Use Haiku for cost efficiency. Skip source files.'
                        : id === 'review'
                        ? 'Enable Extended Thinking. Include full source. Use Sonnet. Focus on quality findings.'
                        : id === 'test'
                        ? 'Enable Computer Use for test execution. Include ARCHITECTURE.md. Use Sonnet.'
                        : id === 'polish'
                        ? 'Enable Artifacts for UI preview. Use Haiku for cost efficiency. Focus on specific areas.'
                        : 'Enable Computer Use. Use Haiku for routine documentation updates.'
                };
            });
        }, []);
        
        // === GENERATE PROJECT INSTRUCTIONS ===
        const generateProjectInstructions = React.useCallback((app) => {
            const scope = app.lifecycle?.scope || {};
            const maturity = app.lifecycle?.currentMaturity || 'unknown';
            const category = scope.category || app.appType || 'tool';
            
            let instructions = `# ${app.name} — Claude Project Instructions\n\n`;
            instructions += `## Project Overview\n`;
            instructions += `- **App ID:** ${app.id}\n`;
            instructions += `- **Category:** ${category}\n`;
            instructions += `- **Maturity:** ${maturity}\n`;
            if (scope.description) instructions += `- **Description:** ${scope.description}\n`;
            instructions += `\n`;
            
            instructions += `## Session Protocol\n`;
            instructions += `When starting a session for ${app.name}:\n`;
            instructions += `1. Read the SESSION_BRIEF.md (uploaded each session) for current state\n`;
            instructions += `2. Review any work items or issues being targeted\n`;
            instructions += `3. Confirm the session type (Build/Fix/Design/etc.) and scope\n`;
            instructions += `4. Before finishing, always:\n`;
            instructions += `   - Increment the version number in ALL locations\n`;
            instructions += `   - Update RELEASE_NOTES.txt with what changed\n`;
            instructions += `   - Update CHANGELOG.md with structured entries\n`;
            if (app.hasServiceWorker) {
                instructions += `   - Update sw.js CACHE_VERSION to match the new version\n`;
                instructions += `   - Create a FULL deploy package (index.html + sw.js + manifest.json + icons/)\n`;
            } else {
                instructions += `   - Produce the updated index.html file\n`;
            }
            instructions += `\n`;
            
            instructions += `## Architecture Constraints\n`;
            instructions += `- Single HTML file — all CSS, JS inline (no external files except CDN)\n`;
            instructions += `- React via CDN (no build step)\n`;
            instructions += `- Runs from file:// and GitHub Pages\n`;
            if (app.hasServiceWorker) {
                instructions += `- PWA with service worker — CACHE_VERSION must match app version\n`;
            }
            instructions += `- Dark mode default with CSS variables\n`;
            instructions += `- Mobile-first responsive design\n`;
            instructions += `\n`;
            
            instructions += `## Version Format\n`;
            instructions += `MAJOR.MINOR.PATCH — Patch for fixes, Minor for features, Major for breaking changes.\n`;
            instructions += `Version appears in: <meta name="version">, const APP_VERSION, UI display, sw.js CACHE_VERSION.\n`;
            instructions += `\n`;
            
            if (scope.startingStandards && scope.startingStandards.length > 0) {
                instructions += `## Starting Standards\n`;
                scope.startingStandards.forEach(std => {
                    const stdDesc = STANDARD_DESCRIPTIONS?.[std] || std;
                    instructions += `- ${stdDesc}\n`;
                });
                instructions += `\n`;
            }
            
            instructions += `## What NOT to Do\n`;
            instructions += `- Do not use native alert(), confirm(), or prompt() — use toast notifications\n`;
            instructions += `- Do not hardcode colors — use CSS variables\n`;
            instructions += `- Do not forget to update ALL version locations\n`;
            if (app.hasServiceWorker) {
                instructions += `- Do not output just index.html for PWA — always include sw.js, manifest, icons\n`;
            }
            instructions += `- Do not refactor code outside the scope of the current session\n`;
            
            return instructions;
        }, []);
        
        // === COPY HELPER ===
        const copyToClipboard = React.useCallback((text, section) => {
            navigator.clipboard.writeText(text).then(() => {
                setCopiedSection(section);
                setTimeout(() => setCopiedSection(null), 2000);
            }).catch(() => showAlert('Failed to copy to clipboard', 'error'));
        }, [showAlert]);
        
        // Helper: colored badge
        const RelevanceBadge = ({ level }) => {
            const colors = { high: 'bg-green-600/20 text-green-400 border-green-600/30', medium: 'bg-blue-600/20 text-blue-400 border-blue-600/30', low: 'bg-slate-600/20 text-slate-400 border-slate-600/30' };
            return <span className={`text-xs px-2 py-0.5 rounded border ${colors[level] || colors.low}`}>{level}</span>;
        };
        
        const StatusBadge = ({ status }) => {
            const colors = { 
                recommended: 'bg-green-600/20 text-green-400', 
                enabled: 'bg-blue-600/20 text-blue-400', 
                optional: 'bg-slate-600/20 text-slate-400',
                'for design sessions': 'bg-purple-600/20 text-purple-400',
                'for build sessions': 'bg-amber-600/20 text-amber-400',
                'for research sessions': 'bg-cyan-600/20 text-cyan-400'
            };
            return <span className={`text-xs px-2 py-0.5 rounded ${colors[status] || colors.optional}`}>{status}</span>;
        };
        
        // Copy button helper
        const CopyBtn = ({ text, section, label }) => (
            <button 
                onClick={() => copyToClipboard(text, section)}
                className={`text-xs px-3 py-1 rounded transition-colors ${copiedSection === section ? 'bg-green-600 text-white' : 'bg-slate-700 text-slate-300 hover:bg-slate-600'}`}
            >
                {copiedSection === section ? '✓ Copied' : (label || '📋 Copy')}
            </button>
        );
        
        return (
            <div className="max-w-6xl mx-auto">
                <div className="flex items-center justify-between mb-6">
                    <div className="flex items-center gap-3">
                        <span className="text-2xl">🎯</span>
                        <div>
                            <h1 className="text-2xl font-bold">Setup Guide</h1>
                            <p className="text-slate-400 text-sm">Configure Claude Projects, skills, and platform features for maximum efficiency</p>
                        </div>
                    </div>
                </div>
                
                {/* App Selector */}
                <div className="bg-slate-800 rounded-xl border border-slate-700 p-5 mb-6">
                    <h3 className="font-semibold mb-3 flex items-center gap-2">📦 Select an App</h3>
                    <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-2">
                        {sortedApps.map(app => {
                            const sessions = (globalSessions || []).filter(s => s.appId === app.id);
                            const maturity = app.lifecycle?.currentMaturity;
                            const matColors = { seed: 'border-slate-600', prototype: 'border-amber-600', alpha: 'border-orange-600', beta: 'border-blue-600', production: 'border-green-600' };
                            return (
                                <button key={app.id}
                                    onClick={() => setSelectedAppId(app.id === selectedAppId ? null : app.id)}
                                    className={`p-3 rounded-lg border text-left transition-all ${
                                        app.id === selectedAppId 
                                            ? 'bg-indigo-600/20 border-indigo-500 ring-1 ring-indigo-500/50' 
                                            : `bg-slate-900/50 ${matColors[maturity] || 'border-slate-700'} hover:bg-slate-700/50`
                                    }`}
                                >
                                    <div className="flex items-center gap-2 mb-1">
                                        <AppIcon icon={app.icon} size={18} />
                                        <span className="font-medium text-sm truncate">{app.name}</span>
                                    </div>
                                    <div className="text-xs text-slate-500">{sessions.length} session{sessions.length !== 1 ? 's' : ''}{maturity ? ` · ${maturity}` : ''}</div>
                                </button>
                            );
                        })}
                    </div>
                </div>
                
                {/* No app selected — show overview */}
                {!selectedApp && (
                    <div className="space-y-6">
                        {/* Session Type Quick Reference */}
                        <div className="bg-slate-800 rounded-xl border border-slate-700 p-5">
                            <h3 className="font-semibold mb-4 flex items-center gap-2">⚡ Session Type Quick Reference</h3>
                            <div className="overflow-x-auto">
                                <table className="w-full text-sm">
                                    <thead>
                                        <tr className="border-b border-slate-700 text-left">
                                            <th className="py-2 px-3 text-slate-400 font-medium">Type</th>
                                            <th className="py-2 px-3 text-slate-400 font-medium">Engine</th>
                                            <th className="py-2 px-3 text-slate-400 font-medium">Platform Tips</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        {getSessionTypeAdvice().map(t => (
                                            <tr key={t.id} className="border-b border-slate-700/50 hover:bg-slate-700/30">
                                                <td className="py-2.5 px-3">
                                                    <span className="font-medium">{t.icon} {t.label}</span>
                                                    <div className="text-xs text-slate-500 mt-0.5">{t.description}</div>
                                                </td>
                                                <td className="py-2.5 px-3 text-slate-300">{t.recommendedEngine?.name || 'Sonnet'}</td>
                                                <td className="py-2.5 px-3 text-slate-400 text-xs">{t.platformTips}</td>
                                            </tr>
                                        ))}
                                    </tbody>
                                </table>
                            </div>
                        </div>
                        
                        {/* General Platform Recommendations */}
                        <div className="bg-slate-800 rounded-xl border border-slate-700 p-5">
                            <h3 className="font-semibold mb-4 flex items-center gap-2">🛠️ Platform Feature Guide</h3>
                            <div className="space-y-3">
                                {getPlatformRecommendations({ lifecycle: {} }).map((rec, idx) => (
                                    <div key={idx} className="flex items-start gap-3 p-3 bg-slate-900/50 rounded-lg">
                                        <span className="text-xl mt-0.5">{rec.icon}</span>
                                        <div className="flex-1">
                                            <div className="flex items-center gap-2 mb-1">
                                                <span className="font-medium text-sm">{rec.feature}</span>
                                                <StatusBadge status={rec.status} />
                                            </div>
                                            <p className="text-xs text-slate-400 mb-1">{rec.reason}</p>
                                            <p className="text-xs text-slate-500">{rec.setup}</p>
                                        </div>
                                    </div>
                                ))}
                            </div>
                        </div>
                        
                        <div className="text-center text-slate-500 text-sm py-4">
                            👆 Select an app above for a detailed per-app optimization guide
                        </div>
                    </div>
                )}
                
                {/* Per-App Optimization Guide */}
                {selectedApp && (() => {
                    const savings = getTokenSavings(selectedApp);
                    const skills = getSkillRecommendations(selectedApp);
                    const platformRecs = getPlatformRecommendations(selectedApp);
                    const projectInstructions = generateProjectInstructions(selectedApp);
                    
                    return (
                        <div className="space-y-6">
                            {/* Token Savings Summary */}
                            <div className="bg-gradient-to-r from-indigo-900/30 to-purple-900/30 rounded-xl border border-indigo-700/30 p-5">
                                <h3 className="font-semibold mb-3 flex items-center gap-2">💰 Token Savings with Claude Project</h3>
                                <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
                                    <div className="bg-slate-800/60 rounded-lg p-3">
                                        <div className="text-xs text-slate-400 mb-1">Persistent Docs</div>
                                        <div className="text-xl font-bold text-green-400">{TokenRegistryService.formatTokens(savings.persistentTokens)}</div>
                                        <div className="text-xs text-slate-500">tokens saved per session</div>
                                    </div>
                                    <div className="bg-slate-800/60 rounded-lg p-3">
                                        <div className="text-xs text-slate-400 mb-1">Sessions/Month</div>
                                        <div className="text-xl font-bold">{savings.sessionsPerMonth}</div>
                                        <div className="text-xs text-slate-500">estimated average</div>
                                    </div>
                                    <div className="bg-slate-800/60 rounded-lg p-3">
                                        <div className="text-xs text-slate-400 mb-1">Monthly Savings</div>
                                        <div className="text-xl font-bold text-green-400">{TokenRegistryService.formatTokens(savings.monthlySavings)}</div>
                                        <div className="text-xs text-slate-500">tokens/month</div>
                                    </div>
                                    <div className="bg-slate-800/60 rounded-lg p-3">
                                        <div className="text-xs text-slate-400 mb-1">Cost Savings</div>
                                        <div className="text-xl font-bold text-green-400">${savings.monthlyCostSavings.toFixed(2)}</div>
                                        <div className="text-xs text-slate-500">est. per month</div>
                                    </div>
                                </div>
                            </div>
                            
                            {/* Doc Classification */}
                            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                                {/* Persistent Docs → Project Knowledge */}
                                <div className="bg-slate-800 rounded-xl border border-green-700/30 p-5">
                                    <h3 className="font-semibold mb-3 flex items-center gap-2 text-green-400">
                                        📌 Project Knowledge <span className="text-xs font-normal text-slate-500">(add once, rarely update)</span>
                                    </h3>
                                    <p className="text-xs text-slate-400 mb-3">
                                        These docs rarely change and should be added to your Claude Project's Knowledge section. 
                                        They'll be available automatically in every conversation — no upload needed.
                                    </p>
                                    <div className="space-y-2">
                                        {PERSISTENT_DOCS.map(doc => (
                                            <div key={doc.name} className="flex items-center gap-3 p-2.5 bg-slate-900/50 rounded-lg">
                                                <span className="text-green-500">📄</span>
                                                <div className="flex-1">
                                                    <div className="font-mono text-sm text-green-300">{doc.name}</div>
                                                    <div className="text-xs text-slate-500">{doc.desc}</div>
                                                </div>
                                                <div className="text-xs text-slate-600 text-right whitespace-nowrap">{doc.changeFreq}</div>
                                            </div>
                                        ))}
                                    </div>
                                </div>
                                
                                {/* Session Docs → Upload Each Time */}
                                <div className="bg-slate-800 rounded-xl border border-amber-700/30 p-5">
                                    <h3 className="font-semibold mb-3 flex items-center gap-2 text-amber-400">
                                        📤 Upload Each Session <span className="text-xs font-normal text-slate-500">(changes frequently)</span>
                                    </h3>
                                    <p className="text-xs text-slate-400 mb-3">
                                        These docs change frequently and should be uploaded from your Claude Prep package at the start of each session.
                                        The Session Wizard bundles these automatically.
                                    </p>
                                    <div className="space-y-2">
                                        {SESSION_DOCS.map(doc => (
                                            <div key={doc.name} className="flex items-center gap-3 p-2.5 bg-slate-900/50 rounded-lg">
                                                <span className="text-amber-500">📄</span>
                                                <div className="flex-1">
                                                    <div className="font-mono text-sm text-amber-300">{doc.name}</div>
                                                    <div className="text-xs text-slate-500">{doc.desc}</div>
                                                </div>
                                                <div className="text-xs text-slate-600 text-right whitespace-nowrap">{doc.changeFreq}</div>
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            </div>
                            
                            {/* Recommended Skills */}
                            <div className="bg-slate-800 rounded-xl border border-slate-700 p-5">
                                <h3 className="font-semibold mb-3 flex items-center gap-2">🛠️ Recommended Skills</h3>
                                <p className="text-xs text-slate-400 mb-3">
                                    Skills are reusable instruction sets that help Claude follow ecosystem conventions. 
                                    Upload these to your Claude Project for consistent behavior across sessions.
                                </p>
                                <div className="space-y-2">
                                    {skills.map((skill, idx) => (
                                        <div key={idx} className="flex items-center gap-3 p-2.5 bg-slate-900/50 rounded-lg">
                                            <span>📦</span>
                                            <div className="flex-1">
                                                <div className="flex items-center gap-2">
                                                    <span className="font-mono text-sm text-slate-200">{skill.name}</span>
                                                    <RelevanceBadge level={skill.relevance} />
                                                </div>
                                                <div className="text-xs text-slate-500">{skill.desc}</div>
                                            </div>
                                            <div className="text-xs text-slate-600 text-right">{skill.reason}</div>
                                        </div>
                                    ))}
                                </div>
                            </div>
                            
                            {/* Platform Features */}
                            <div className="bg-slate-800 rounded-xl border border-slate-700 p-5">
                                <h3 className="font-semibold mb-3 flex items-center gap-2">⚡ Platform Features for {selectedApp.name}</h3>
                                <div className="space-y-2">
                                    {platformRecs.map((rec, idx) => (
                                        <div key={idx} className="flex items-start gap-3 p-3 bg-slate-900/50 rounded-lg">
                                            <span className="text-xl mt-0.5">{rec.icon}</span>
                                            <div className="flex-1">
                                                <div className="flex items-center gap-2 mb-1">
                                                    <span className="font-medium text-sm">{rec.feature}</span>
                                                    <StatusBadge status={rec.status} />
                                                </div>
                                                <p className="text-xs text-slate-400 mb-1">{rec.reason}</p>
                                                <p className="text-xs text-slate-500">{rec.setup}</p>
                                            </div>
                                        </div>
                                    ))}
                                </div>
                            </div>
                            
                            {/* Generated Project Instructions */}
                            <div className="bg-slate-800 rounded-xl border border-slate-700 p-5">
                                <div className="flex items-center justify-between mb-3">
                                    <h3 className="font-semibold flex items-center gap-2">📝 Recommended Project Instructions</h3>
                                    <CopyBtn text={projectInstructions} section="instructions" label="📋 Copy Instructions" />
                                </div>
                                <p className="text-xs text-slate-400 mb-3">
                                    Paste these into your Claude Project's Custom Instructions field. 
                                    This ensures Claude follows your conventions without including it in the session package.
                                </p>
                                <div className="bg-slate-900 rounded-lg border border-slate-700 p-4 max-h-80 overflow-y-auto">
                                    <pre className="text-xs text-slate-300 whitespace-pre-wrap font-mono leading-relaxed">{projectInstructions}</pre>
                                </div>
                            </div>
                            
                            {/* Setup Checklist */}
                            <div className="bg-slate-800 rounded-xl border border-slate-700 p-5">
                                <h3 className="font-semibold mb-3 flex items-center gap-2">✅ Setup Checklist for {selectedApp.name}</h3>
                                <div className="space-y-2">
                                    {[
                                        { step: `Create a Claude Project named "${selectedApp.name}"`, detail: 'One project per app keeps context focused and organized' },
                                        { step: 'Paste Project Instructions (above) into Custom Instructions', detail: 'Establishes session protocol, architecture constraints, versioning rules' },
                                        { step: 'Upload persistent docs as Project Knowledge', detail: `Add: ${PERSISTENT_DOCS.map(d => d.name).join(', ')}` },
                                        { step: 'Upload recommended skills as Project Knowledge', detail: `Add: ${skills.filter(s => s.relevance === 'high').map(s => s.name + '.md').join(', ')}` },
                                        { step: 'Use Claude Prep Session Wizard for each session', detail: 'Generates SESSION_BRIEF.md and bundles session docs automatically' },
                                        { step: 'Upload session docs at the start of each conversation', detail: `Upload the generated zip — includes: ${SESSION_DOCS.map(d => d.name).join(', ')}` },
                                    ].map((item, idx) => (
                                        <div key={idx} className="flex items-start gap-3 p-3 bg-slate-900/50 rounded-lg">
                                            <div className="w-6 h-6 rounded-full bg-indigo-600/30 border border-indigo-500/30 flex items-center justify-center flex-shrink-0 mt-0.5">
                                                <span className="text-xs text-indigo-300 font-bold">{idx + 1}</span>
                                            </div>
                                            <div>
                                                <div className="text-sm font-medium">{item.step}</div>
                                                <div className="text-xs text-slate-500 mt-0.5">{item.detail}</div>
                                            </div>
                                        </div>
                                    ))}
                                </div>
                            </div>
                        </div>
                    );
                })()}
            </div>
        );
    }

    // =========================================================================
    // USERS VIEW - User statistics dashboard
    // =========================================================================
    
    function UsersView({ showAlert }) {
        const [userStats, setUserStats] = React.useState(null);
        const [loading, setLoading] = React.useState(false);
        const [error, setError] = React.useState(null);
        
        const loadUserStats = async () => {
            if (!firebaseAuth?.currentUser) {
                setError('Sign in required');
                return;
            }
            setLoading(true);
            setError(null);
            try {
                const getUserStats = firebase.functions().httpsCallable('getUserStats');
                const result = await getUserStats();
                setUserStats({
                    ...result.data,
                    lastUpdated: new Date().toISOString()
                });
            } catch (e) {
                console.error('Failed to load user stats:', e);
                setError(e.message || 'Failed to load stats');
            }
            setLoading(false);
        };
        
        // Auto-load on mount
        React.useEffect(() => {
            loadUserStats();
        }, []);
        
        return (
            <div className="space-y-6">
                <div className="flex items-center justify-between">
                    <h2 className="text-xl font-bold flex items-center gap-2">
                        👥 User Statistics
                    </h2>
                    <button
                        onClick={loadUserStats}
                        disabled={loading}
                        className="px-4 py-2 bg-indigo-600 hover:bg-indigo-500 rounded-lg text-sm font-medium transition-colors disabled:opacity-50"
                    >
                        {loading ? '⏳ Loading...' : '🔄 Refresh'}
                    </button>
                </div>
                
                {error && (
                    <div className="bg-red-900/30 border border-red-700 rounded-lg p-4 text-red-400">
                        ⚠️ {error}
                    </div>
                )}
                
                {!userStats && !error && !loading && (
                    <div className="bg-slate-800 rounded-xl p-8 text-center text-slate-500">
                        Click Refresh to load user statistics
                    </div>
                )}
                
                {loading && !userStats && (
                    <div className="bg-slate-800 rounded-xl p-8 text-center text-slate-400">
                        <div className="animate-pulse">Loading user statistics...</div>
                    </div>
                )}
                
                {userStats && (
                    <div className="space-y-6">
                        {/* Main Stats */}
                        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
                            <div className="bg-gradient-to-br from-indigo-900/50 to-purple-900/50 rounded-xl p-6 border border-indigo-700">
                                <div className="text-4xl font-bold text-indigo-400">{userStats.total?.toLocaleString() || 0}</div>
                                <div className="text-sm text-slate-400 mt-1">Total Registered Users</div>
                            </div>
                            <div className="bg-slate-800 rounded-xl p-6 border border-slate-700">
                                <div className="text-4xl font-bold text-green-400">{userStats.activeMonth || 0}</div>
                                <div className="text-sm text-slate-400 mt-1">Active (30 days)</div>
                            </div>
                            <div className="bg-slate-800 rounded-xl p-6 border border-slate-700">
                                <div className="text-4xl font-bold text-blue-400">{userStats.activeWeek || 0}</div>
                                <div className="text-sm text-slate-400 mt-1">Active (7 days)</div>
                            </div>
                            <div className="bg-slate-800 rounded-xl p-6 border border-slate-700">
                                <div className="text-4xl font-bold text-amber-400">{userStats.activeToday || 0}</div>
                                <div className="text-sm text-slate-400 mt-1">Active Today</div>
                            </div>
                        </div>
                        
                        {/* Growth Stats */}
                        <div className="bg-slate-800 rounded-xl p-6 border border-slate-700">
                            <h3 className="font-semibold mb-4">📈 Growth</h3>
                            <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
                                <div className="text-center p-4 bg-slate-900 rounded-lg">
                                    <div className="text-2xl font-bold text-emerald-400">+{userStats.newToday || 0}</div>
                                    <div className="text-xs text-slate-500">New Today</div>
                                </div>
                                <div className="text-center p-4 bg-slate-900 rounded-lg">
                                    <div className="text-2xl font-bold text-teal-400">+{userStats.newWeek || 0}</div>
                                    <div className="text-xs text-slate-500">New This Week</div>
                                </div>
                                <div className="text-center p-4 bg-slate-900 rounded-lg">
                                    <div className="text-2xl font-bold text-cyan-400">
                                        {userStats.total > 0 ? Math.round((userStats.activeMonth / userStats.total) * 100) : 0}%
                                    </div>
                                    <div className="text-xs text-slate-500">30-Day Retention</div>
                                </div>
                                <div className="text-center p-4 bg-slate-900 rounded-lg">
                                    <div className="text-2xl font-bold text-violet-400">
                                        {userStats.total > 0 ? Math.round((userStats.activeWeek / userStats.total) * 100) : 0}%
                                    </div>
                                    <div className="text-xs text-slate-500">7-Day Retention</div>
                                </div>
                            </div>
                        </div>
                        
                        {/* Last Updated */}
                        {userStats.lastUpdated && (
                            <div className="text-xs text-slate-500 text-right">
                                Last updated: {new Date(userStats.lastUpdated).toLocaleString()}
                            </div>
                        )}
                    </div>
                )}
            </div>
        );
    }

    // =========================================================================
    // BETA ANALYTICS VIEW (v8.7.0) - Onboarding responses, survey ratings, user details
    // =========================================================================
    
    function BetaAnalyticsView({ showAlert }) {
        const [betaUsers, setBetaUsers] = React.useState([]);
        const [loading, setLoading] = React.useState(false);
        const [error, setError] = React.useState(null);
        const [activeTab, setActiveTab] = React.useState('overview');
        const [expandedUser, setExpandedUser] = React.useState(null);
        const [surveyFilter, setSurveyFilter] = React.useState('all');
        
        const loadBetaData = async () => {
            if (!firebaseAuth?.currentUser) {
                setError('Sign in required');
                return;
            }
            setLoading(true);
            setError(null);
            try {
                const getBetaAnalytics = firebase.functions().httpsCallable('getBetaAnalytics');
                const result = await getBetaAnalytics();
                setBetaUsers(result.data.betaUsers || []);
            } catch (e) {
                console.error('Failed to load beta data:', e);
                setError(e.message || 'Failed to load beta data');
            }
            setLoading(false);
        };
        
        React.useEffect(() => { loadBetaData(); }, []);
        
        // Aggregate onboarding stats
        const onboardingStats = React.useMemo(() => {
            const stats = {
                total: betaUsers.length,
                completedOnboarding: 0,
                sources: {},
                experience: {},
                games: {},
                frequency: {},
                devices: {},
                sharing: {},
                shareWhere: {},
                hints: {},
                compete: {},
                frustrations: {},
                dailyUseResponses: [],
                otherTexts: { source: [], games: [], shareWhere: [], frustration: [] }
            };
            
            betaUsers.forEach(u => {
                const ob = u.earlyAccess?.onboarding;
                if (!ob || !ob.completedAt) return;
                stats.completedOnboarding++;
                
                // Count each field
                if (ob.source) stats.sources[ob.source] = (stats.sources[ob.source] || 0) + 1;
                if (ob.sourceOther) stats.otherTexts.source.push({ user: u.displayName, text: ob.sourceOther });
                
                if (ob.experience) stats.experience[ob.experience] = (stats.experience[ob.experience] || 0) + 1;
                
                if (Array.isArray(ob.games)) {
                    ob.games.forEach(g => { stats.games[g] = (stats.games[g] || 0) + 1; });
                }
                if (ob.gamesOther) stats.otherTexts.games.push({ user: u.displayName, text: ob.gamesOther });
                
                if (ob.frequency) stats.frequency[ob.frequency] = (stats.frequency[ob.frequency] || 0) + 1;
                if (ob.device) stats.devices[ob.device] = (stats.devices[ob.device] || 0) + 1;
                if (ob.sharing) stats.sharing[ob.sharing] = (stats.sharing[ob.sharing] || 0) + 1;
                
                if (Array.isArray(ob.shareWhere)) {
                    ob.shareWhere.forEach(s => { stats.shareWhere[s] = (stats.shareWhere[s] || 0) + 1; });
                }
                if (ob.shareWhereOther) stats.otherTexts.shareWhere.push({ user: u.displayName, text: ob.shareWhereOther });
                
                if (ob.hints) stats.hints[ob.hints] = (stats.hints[ob.hints] || 0) + 1;
                if (ob.compete) stats.compete[ob.compete] = (stats.compete[ob.compete] || 0) + 1;
                if (ob.frustration) stats.frustrations[ob.frustration] = (stats.frustrations[ob.frustration] || 0) + 1;
                if (ob.frustrationOther) stats.otherTexts.frustration.push({ user: u.displayName, text: ob.frustrationOther });
                
                if (ob.dailyUse) stats.dailyUseResponses.push({ user: u.displayName, text: ob.dailyUse });
            });
            
            return stats;
        }, [betaUsers]);
        
        // Aggregate survey stats
        const surveyStats = React.useMemo(() => {
            const allRatings = [];
            const byDate = {};
            const byUser = {};
            
            betaUsers.forEach(u => {
                const surveys = u.earlyAccess?.surveys;
                if (!surveys) return;
                byUser[u.displayName] = [];
                
                Object.entries(surveys).forEach(([date, data]) => {
                    const entry = { user: u.displayName, date, rating: data.rating, feedback: data.feedback || '' };
                    allRatings.push(entry);
                    if (!byDate[date]) byDate[date] = [];
                    byDate[date].push(entry);
                    byUser[u.displayName].push(entry);
                });
            });
            
            allRatings.sort((a, b) => b.date.localeCompare(a.date));
            
            const avg = allRatings.length > 0 
                ? (allRatings.reduce((sum, r) => sum + r.rating, 0) / allRatings.length).toFixed(1) 
                : '—';
            
            const distribution = [0, 0, 0, 0, 0];
            allRatings.forEach(r => { if (r.rating >= 1 && r.rating <= 5) distribution[r.rating - 1]++; });
            
            const withFeedback = allRatings.filter(r => r.feedback);
            
            return { allRatings, byDate, byUser, avg, distribution, withFeedback, total: allRatings.length };
        }, [betaUsers]);
        
        // Helper: render a bar chart for key-value data
        const renderBarChart = (data, labelMap = null) => {
            const entries = Object.entries(data).sort((a, b) => b[1] - a[1]);
            const max = entries.length > 0 ? entries[0][1] : 1;
            return entries.map(([key, count]) => (
                <div key={key} className="flex items-center gap-2 mb-1.5">
                    <div className="text-xs text-slate-400 w-28 truncate text-right" title={labelMap?.[key] || key}>
                        {labelMap?.[key] || key}
                    </div>
                    <div className="flex-1 h-5 bg-slate-900 rounded overflow-hidden">
                        <div 
                            className="h-full bg-indigo-600 rounded flex items-center justify-end pr-1.5"
                            style={{ width: `${Math.max((count / max) * 100, 12)}%` }}
                        >
                            <span className="text-[10px] text-white font-bold">{count}</span>
                        </div>
                    </div>
                </div>
            ));
        };
        
        // Helper: format timestamp
        const fmtDate = (ts) => {
            if (!ts) return '—';
            return new Date(ts).toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
        };
        
        const fmtDaysAgo = (ts) => {
            if (!ts) return '';
            const days = Math.floor((Date.now() - ts) / (1000 * 60 * 60 * 24));
            if (days === 0) return 'today';
            if (days === 1) return '1 day ago';
            return `${days} days ago`;
        };
        
        const tabs = [
            { id: 'overview', label: '📊 Overview' },
            { id: 'onboarding', label: '📝 Onboarding' },
            { id: 'surveys', label: '⭐ Surveys' },
            { id: 'users', label: '👤 Users' },
            { id: 'goldq', label: '💡 Gold Question' }
        ];
        
        return (
            <div className="space-y-6">
                <div className="flex items-center justify-between">
                    <h2 className="text-xl font-bold flex items-center gap-2">🧪 Beta Program Analytics</h2>
                    <button onClick={loadBetaData} disabled={loading}
                        className="px-4 py-2 bg-indigo-600 hover:bg-indigo-500 rounded-lg text-sm font-medium transition-colors disabled:opacity-50">
                        {loading ? '⏳ Loading...' : '🔄 Refresh'}
                    </button>
                </div>
                
                {error && <div className="bg-red-900/30 border border-red-700 rounded-lg p-4 text-red-400">⚠️ {error}</div>}
                
                {loading && !betaUsers.length && (
                    <div className="bg-slate-800 rounded-xl p-8 text-center text-slate-400 animate-pulse">Loading beta data...</div>
                )}
                
                {/* Tabs */}
                {betaUsers.length > 0 && (
                    <div className="space-y-6">
                        <div className="flex gap-1 bg-slate-800/50 p-1 rounded-lg">
                            {tabs.map(t => (
                                <button key={t.id} onClick={() => setActiveTab(t.id)}
                                    className={`px-3 py-1.5 rounded text-sm font-medium transition-colors ${
                                        activeTab === t.id ? 'bg-indigo-600 text-white' : 'text-slate-400 hover:text-white'
                                    }`}>{t.label}</button>
                            ))}
                        </div>
                        
                        {/* ---- OVERVIEW TAB ---- */}
                        {activeTab === 'overview' && (
                            <div className="space-y-6">
                                {/* Key Metrics */}
                                <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
                                    <div className="bg-gradient-to-br from-indigo-900/50 to-purple-900/50 rounded-xl p-5 border border-indigo-700 text-center">
                                        <div className="text-3xl font-bold text-indigo-400">{onboardingStats.total}</div>
                                        <div className="text-xs text-slate-400 mt-1">Beta Users</div>
                                    </div>
                                    <div className="bg-slate-800 rounded-xl p-5 border border-slate-700 text-center">
                                        <div className="text-3xl font-bold text-green-400">{onboardingStats.completedOnboarding}</div>
                                        <div className="text-xs text-slate-400 mt-1">Completed Onboarding</div>
                                    </div>
                                    <div className="bg-slate-800 rounded-xl p-5 border border-slate-700 text-center">
                                        <div className="text-3xl font-bold text-amber-400">{surveyStats.total}</div>
                                        <div className="text-xs text-slate-400 mt-1">Survey Responses</div>
                                    </div>
                                    <div className="bg-slate-800 rounded-xl p-5 border border-slate-700 text-center">
                                        <div className="text-3xl font-bold text-cyan-400">{surveyStats.avg}</div>
                                        <div className="text-xs text-slate-400 mt-1">Avg Rating (1-5)</div>
                                    </div>
                                </div>
                                
                                {/* Rating Distribution */}
                                {surveyStats.total > 0 && (
                                    <div className="bg-slate-800 rounded-xl p-6 border border-slate-700">
                                        <h3 className="font-semibold mb-4">⭐ Rating Distribution</h3>
                                        <div className="flex items-end gap-3 justify-center h-32">
                                            {surveyStats.distribution.map((count, i) => {
                                                const maxCount = Math.max(...surveyStats.distribution, 1);
                                                const height = (count / maxCount) * 100;
                                                const colors = ['bg-red-500', 'bg-orange-500', 'bg-yellow-500', 'bg-lime-500', 'bg-green-500'];
                                                return (
                                                    <div key={i} className="flex flex-col items-center gap-1 flex-1 max-w-16">
                                                        <span className="text-xs text-slate-400 font-bold">{count}</span>
                                                        <div className={`w-full ${colors[i]} rounded-t`}
                                                            style={{ height: `${Math.max(height, 4)}%`, minHeight: '4px' }}></div>
                                                        <span className="text-xs text-slate-500">{i + 1}★</span>
                                                    </div>
                                                );
                                            })}
                                        </div>
                                    </div>
                                )}
                                
                                {/* Recent Feedback */}
                                {surveyStats.withFeedback.length > 0 && (
                                    <div className="bg-slate-800 rounded-xl p-6 border border-slate-700">
                                        <h3 className="font-semibold mb-4">💬 Recent Feedback ({surveyStats.withFeedback.length})</h3>
                                        <div className="space-y-3 max-h-64 overflow-y-auto">
                                            {surveyStats.withFeedback.slice(0, 10).map((r, i) => (
                                                <div key={i} className="bg-slate-900 rounded-lg p-3">
                                                    <div className="flex items-center justify-between mb-1">
                                                        <span className="text-sm font-medium text-slate-300">{r.user}</span>
                                                        <span className="text-xs text-slate-500">{r.date} · {'⭐'.repeat(r.rating)}</span>
                                                    </div>
                                                    <div className="text-sm text-slate-400">{r.feedback}</div>
                                                </div>
                                            ))}
                                        </div>
                                    </div>
                                )}
                            </div>
                        )}
                        
                        {/* ---- ONBOARDING TAB ---- */}
                        {activeTab === 'onboarding' && (
                            <div className="space-y-6">
                                <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                                    {/* How did you find GS? */}
                                    <div className="bg-slate-800 rounded-xl p-5 border border-slate-700">
                                        <h3 className="font-semibold mb-3 text-sm">🔍 How did you find Game Shelf?</h3>
                                        {renderBarChart(onboardingStats.sources, {
                                            'friend': 'Friend', 'dave': 'Dave told me', 'social': 'Social Media',
                                            'search': 'Search', 'app-store': 'App Store', 'other': 'Other'
                                        })}
                                        {onboardingStats.otherTexts.source.length > 0 && (
                                            <div className="mt-2 text-xs text-slate-500">
                                                Other: {onboardingStats.otherTexts.source.map(o => `"${o.text}" (${o.user})`).join(', ')}
                                            </div>
                                        )}
                                    </div>
                                    
                                    {/* Experience */}
                                    <div className="bg-slate-800 rounded-xl p-5 border border-slate-700">
                                        <h3 className="font-semibold mb-3 text-sm">⏳ How long playing daily puzzles?</h3>
                                        {renderBarChart(onboardingStats.experience, {
                                            'new': 'Brand new', 'months': 'A few months', 'year': 'About a year', 'years': '2+ years'
                                        })}
                                    </div>
                                    
                                    {/* Games played */}
                                    <div className="bg-slate-800 rounded-xl p-5 border border-slate-700">
                                        <h3 className="font-semibold mb-3 text-sm">🎮 What puzzles do you play?</h3>
                                        {renderBarChart(onboardingStats.games)}
                                        {onboardingStats.otherTexts.games.length > 0 && (
                                            <div className="mt-2 text-xs text-slate-500">
                                                Other: {onboardingStats.otherTexts.games.map(o => `"${o.text}" (${o.user})`).join(', ')}
                                            </div>
                                        )}
                                    </div>
                                    
                                    {/* Frequency */}
                                    <div className="bg-slate-800 rounded-xl p-5 border border-slate-700">
                                        <h3 className="font-semibold mb-3 text-sm">📊 How many puzzles per day?</h3>
                                        {renderBarChart(onboardingStats.frequency, {
                                            '1': 'Just 1', '2-3': '2-3 games', '4-5': '4-5 games', '6+': '6+ games'
                                        })}
                                    </div>
                                    
                                    {/* Device */}
                                    <div className="bg-slate-800 rounded-xl p-5 border border-slate-700">
                                        <h3 className="font-semibold mb-3 text-sm">📱 Primary device?</h3>
                                        {renderBarChart(onboardingStats.devices, {
                                            'iphone': 'iPhone', 'android': 'Android', 'ipad': 'iPad', 
                                            'desktop': 'Desktop', 'multiple': 'Multiple'
                                        })}
                                    </div>
                                    
                                    {/* Sharing */}
                                    <div className="bg-slate-800 rounded-xl p-5 border border-slate-700">
                                        <h3 className="font-semibold mb-3 text-sm">📤 Do you share results?</h3>
                                        {renderBarChart(onboardingStats.sharing, {
                                            'daily': 'Daily', 'sometimes': 'Sometimes', 'rarely': 'Rarely', 'never': 'Never'
                                        })}
                                    </div>
                                    
                                    {/* Where share */}
                                    <div className="bg-slate-800 rounded-xl p-5 border border-slate-700">
                                        <h3 className="font-semibold mb-3 text-sm">💬 Where do you share?</h3>
                                        {renderBarChart(onboardingStats.shareWhere, {
                                            'imessage': 'iMessage', 'twitter': 'Twitter/X', 'discord': 'Discord',
                                            'facebook': 'Facebook', 'slack': 'Slack', 'whatsapp': 'WhatsApp', 'other': 'Other'
                                        })}
                                    </div>
                                    
                                    {/* Hints */}
                                    <div className="bg-slate-800 rounded-xl p-5 border border-slate-700">
                                        <h3 className="font-semibold mb-3 text-sm">💡 Do you look up hints?</h3>
                                        {renderBarChart(onboardingStats.hints, {
                                            'never': 'Never', 'rarely': 'Rarely', 'sometimes': 'Sometimes', 'often': 'Often'
                                        })}
                                    </div>
                                    
                                    {/* Compete */}
                                    <div className="bg-slate-800 rounded-xl p-5 border border-slate-700">
                                        <h3 className="font-semibold mb-3 text-sm">🏆 Do you compete with others?</h3>
                                        {renderBarChart(onboardingStats.compete, {
                                            'yes-regular': 'Yes, regularly', 'yes-casual': 'Casually', 
                                            'want-to': 'Want to', 'no': 'No'
                                        })}
                                    </div>
                                    
                                    {/* Frustrations */}
                                    <div className="bg-slate-800 rounded-xl p-5 border border-slate-700">
                                        <h3 className="font-semibold mb-3 text-sm">😤 Biggest frustration?</h3>
                                        {renderBarChart(onboardingStats.frustrations, {
                                            'no-tracking': 'No tracking across games', 'scattered': 'Games scattered everywhere',
                                            'no-compare': "Can't compare with friends", 'no-hints': 'No good hints',
                                            'manual-share': 'Manual sharing is tedious', 'other': 'Other'
                                        })}
                                        {onboardingStats.otherTexts.frustration.length > 0 && (
                                            <div className="mt-2 text-xs text-slate-500">
                                                Other: {onboardingStats.otherTexts.frustration.map(o => `"${o.text}" (${o.user})`).join(', ')}
                                            </div>
                                        )}
                                    </div>
                                </div>
                            </div>
                        )}
                        
                        {/* ---- SURVEYS TAB ---- */}
                        {activeTab === 'surveys' && (
                            <div className="space-y-6">
                                <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
                                    <div className="bg-slate-800 rounded-xl p-4 border border-slate-700 text-center">
                                        <div className="text-2xl font-bold text-amber-400">{surveyStats.total}</div>
                                        <div className="text-xs text-slate-400">Total Responses</div>
                                    </div>
                                    <div className="bg-slate-800 rounded-xl p-4 border border-slate-700 text-center">
                                        <div className="text-2xl font-bold text-cyan-400">{surveyStats.avg}</div>
                                        <div className="text-xs text-slate-400">Avg Rating</div>
                                    </div>
                                    <div className="bg-slate-800 rounded-xl p-4 border border-slate-700 text-center">
                                        <div className="text-2xl font-bold text-green-400">{surveyStats.withFeedback.length}</div>
                                        <div className="text-xs text-slate-400">With Comments</div>
                                    </div>
                                    <div className="bg-slate-800 rounded-xl p-4 border border-slate-700 text-center">
                                        <div className="text-2xl font-bold text-purple-400">{Object.keys(surveyStats.byUser).length}</div>
                                        <div className="text-xs text-slate-400">Unique Respondents</div>
                                    </div>
                                </div>
                                
                                {/* Filter */}
                                <div className="flex gap-2">
                                    {['all', 'with-feedback', 'low-rating'].map(f => (
                                        <button key={f} onClick={() => setSurveyFilter(f)}
                                            className={`px-3 py-1 rounded text-xs font-medium transition-colors ${
                                                surveyFilter === f ? 'bg-indigo-600 text-white' : 'bg-slate-800 text-slate-400 hover:text-white'
                                            }`}>
                                            {f === 'all' ? 'All' : f === 'with-feedback' ? 'With Comments' : 'Low Ratings (1-2)'}
                                        </button>
                                    ))}
                                </div>
                                
                                {/* Survey entries */}
                                <div className="bg-slate-800 rounded-xl border border-slate-700 overflow-hidden">
                                    <div className="max-h-96 overflow-y-auto divide-y divide-slate-700">
                                        {surveyStats.allRatings
                                            .filter(r => {
                                                if (surveyFilter === 'with-feedback') return r.feedback;
                                                if (surveyFilter === 'low-rating') return r.rating <= 2;
                                                return true;
                                            })
                                            .map((r, i) => (
                                            <div key={i} className="px-4 py-3 flex items-start gap-3">
                                                <div className={`text-lg font-bold min-w-[2rem] text-center ${
                                                    r.rating >= 4 ? 'text-green-400' : r.rating >= 3 ? 'text-yellow-400' : 'text-red-400'
                                                }`}>{r.rating}★</div>
                                                <div className="flex-1 min-w-0">
                                                    <div className="flex items-center gap-2">
                                                        <span className="text-sm font-medium text-slate-300">{r.user}</span>
                                                        <span className="text-xs text-slate-500">{r.date}</span>
                                                    </div>
                                                    {r.feedback && <div className="text-sm text-slate-400 mt-0.5">{r.feedback}</div>}
                                                </div>
                                            </div>
                                        ))}
                                        {surveyStats.total === 0 && (
                                            <div className="px-4 py-8 text-center text-slate-500">No survey responses yet</div>
                                        )}
                                    </div>
                                </div>
                            </div>
                        )}
                        
                        {/* ---- USERS TAB ---- */}
                        {activeTab === 'users' && (
                            <div className="space-y-4">
                                <div className="bg-slate-800 rounded-xl border border-slate-700 overflow-hidden">
                                    <div className="max-h-[600px] overflow-y-auto divide-y divide-slate-700">
                                        {betaUsers.map(u => {
                                            const ob = u.earlyAccess?.onboarding;
                                            const surveys = u.earlyAccess?.surveys;
                                            const surveyCount = surveys ? Object.keys(surveys).length : 0;
                                            const isExpanded = expandedUser === u.uid;
                                            
                                            return (
                                                <div key={u.uid}>
                                                    <button onClick={() => setExpandedUser(isExpanded ? null : u.uid)}
                                                        className="w-full px-4 py-3 flex items-center gap-3 hover:bg-slate-700/50 transition-colors text-left">
                                                        {u.photoURL ? (
                                                            <img src={u.photoURL} className="w-8 h-8 rounded-full" alt="" />
                                                        ) : (
                                                            <div className="w-8 h-8 rounded-full bg-slate-600 flex items-center justify-center text-xs">
                                                                {u.displayName.charAt(0)}
                                                            </div>
                                                        )}
                                                        <div className="flex-1 min-w-0">
                                                            <div className="text-sm font-medium text-slate-200 truncate">{u.displayName}</div>
                                                            <div className="text-xs text-slate-500">
                                                                Joined {fmtDate(u.earlyAccess.joinedAt)}
                                                                {u.lastVisit ? ` · Last active ${fmtDaysAgo(u.lastVisit)}` : ''}
                                                            </div>
                                                        </div>
                                                        <div className="flex items-center gap-2">
                                                            {ob?.completedAt && <span className="px-2 py-0.5 bg-green-900/30 text-green-400 rounded text-[10px]">Onboarded</span>}
                                                            {surveyCount > 0 && <span className="px-2 py-0.5 bg-amber-900/30 text-amber-400 rounded text-[10px]">{surveyCount} survey{surveyCount > 1 ? 's' : ''}</span>}
                                                            <span className={`text-xs transition-transform ${isExpanded ? 'rotate-90' : ''}`}>▶</span>
                                                        </div>
                                                    </button>
                                                    
                                                    {isExpanded && (
                                                        <div className="px-4 pb-4 bg-slate-900/50">
                                                            <div className="grid grid-cols-1 md:grid-cols-2 gap-4 pt-2">
                                                                {/* Onboarding responses */}
                                                                <div className="bg-slate-800 rounded-lg p-4">
                                                                    <h4 className="text-xs font-semibold text-slate-400 mb-2 uppercase">Onboarding</h4>
                                                                    {ob?.completedAt ? (
                                                                        <div className="space-y-1.5 text-sm">
                                                                            {ob.source && <div><span className="text-slate-500">Source:</span> <span className="text-slate-300">{ob.source}{ob.sourceOther ? ` (${ob.sourceOther})` : ''}</span></div>}
                                                                            {ob.experience && <div><span className="text-slate-500">Experience:</span> <span className="text-slate-300">{ob.experience}</span></div>}
                                                                            {ob.games && <div><span className="text-slate-500">Games:</span> <span className="text-slate-300">{Array.isArray(ob.games) ? ob.games.join(', ') : ob.games}{ob.gamesOther ? ` + ${ob.gamesOther}` : ''}</span></div>}
                                                                            {ob.frequency && <div><span className="text-slate-500">Per day:</span> <span className="text-slate-300">{ob.frequency}</span></div>}
                                                                            {ob.device && <div><span className="text-slate-500">Device:</span> <span className="text-slate-300">{ob.device}</span></div>}
                                                                            {ob.sharing && <div><span className="text-slate-500">Sharing:</span> <span className="text-slate-300">{ob.sharing}{ob.shareWhere ? ` via ${Array.isArray(ob.shareWhere) ? ob.shareWhere.join(', ') : ob.shareWhere}` : ''}</span></div>}
                                                                            {ob.hints && <div><span className="text-slate-500">Hints:</span> <span className="text-slate-300">{ob.hints}</span></div>}
                                                                            {ob.compete && <div><span className="text-slate-500">Compete:</span> <span className="text-slate-300">{ob.compete}</span></div>}
                                                                            {ob.frustration && <div><span className="text-slate-500">Frustration:</span> <span className="text-slate-300">{ob.frustration}{ob.frustrationOther ? ` (${ob.frustrationOther})` : ''}</span></div>}
                                                                            {ob.dailyUse && <div className="mt-2 p-2 bg-amber-900/20 border border-amber-800/30 rounded"><span className="text-amber-400 text-xs font-semibold">💡 Daily use:</span> <span className="text-slate-300 text-xs">{ob.dailyUse}</span></div>}
                                                                        </div>
                                                                    ) : (
                                                                        <div className="text-sm text-slate-500">Not completed</div>
                                                                    )}
                                                                </div>
                                                                
                                                                {/* Survey history */}
                                                                <div className="bg-slate-800 rounded-lg p-4">
                                                                    <h4 className="text-xs font-semibold text-slate-400 mb-2 uppercase">Survey History</h4>
                                                                    {surveyCount > 0 ? (
                                                                        <div className="space-y-2 max-h-48 overflow-y-auto">
                                                                            {Object.entries(surveys).sort((a, b) => b[0].localeCompare(a[0])).map(([date, data]) => (
                                                                                <div key={date} className="text-sm flex items-start gap-2">
                                                                                    <span className={`font-bold ${data.rating >= 4 ? 'text-green-400' : data.rating >= 3 ? 'text-yellow-400' : 'text-red-400'}`}>
                                                                                        {data.rating}★
                                                                                    </span>
                                                                                    <div>
                                                                                        <span className="text-slate-500 text-xs">{date}</span>
                                                                                        {data.feedback && <div className="text-slate-400 text-xs mt-0.5">{data.feedback}</div>}
                                                                                    </div>
                                                                                </div>
                                                                            ))}
                                                                        </div>
                                                                    ) : (
                                                                        <div className="text-sm text-slate-500">No surveys yet</div>
                                                                    )}
                                                                </div>
                                                            </div>
                                                        </div>
                                                    )}
                                                </div>
                                            );
                                        })}
                                    </div>
                                </div>
                            </div>
                        )}
                        
                        {/* ---- GOLD QUESTION TAB ---- */}
                        {activeTab === 'goldq' && (
                            <div className="space-y-6">
                                <div className="bg-gradient-to-br from-amber-900/30 to-yellow-900/20 rounded-xl p-6 border border-amber-700/50">
                                    <h3 className="font-semibold text-amber-400 mb-1">💡 "What would make you use Game Shelf every day?"</h3>
                                    <p className="text-sm text-slate-400">The most valuable onboarding question — raw user intent and desires.</p>
                                </div>
                                
                                <div className="space-y-3">
                                    {onboardingStats.dailyUseResponses.length > 0 ? (
                                        onboardingStats.dailyUseResponses.map((r, i) => (
                                            <div key={i} className="bg-slate-800 rounded-xl p-5 border border-slate-700">
                                                <div className="flex items-center gap-2 mb-2">
                                                    <span className="text-sm font-medium text-slate-300">{r.user}</span>
                                                </div>
                                                <div className="text-slate-300 text-sm leading-relaxed">"{r.text}"</div>
                                            </div>
                                        ))
                                    ) : (
                                        <div className="bg-slate-800 rounded-xl p-8 text-center text-slate-500">
                                            No responses to the daily use question yet
                                        </div>
                                    )}
                                </div>
                            </div>
                        )}
                    </div>
                )}
            </div>
        );
    }

    // =========================================================================
    // INTEGRATIONS VIEW (v7.4.0) - Manage Firebase Functions, Claude API, Stripe, Goody
    // =========================================================================
    
    function IntegrationsView({ showAlert, showConfirm, showPrompt }) {
        const [activeTab, setActiveTab] = React.useState('overview');
        const [integrationStatus, setIntegrationStatus] = React.useState({
            firebase: { status: 'unknown', lastCheck: null },
            claude: { status: 'unknown', lastCheck: null },
            stripe: { status: 'unknown', lastCheck: null },
            goody: { status: 'unknown', lastCheck: null }
        });
        const [functionLogs, setFunctionLogs] = React.useState([]);
        const [hintAnalytics, setHintAnalytics] = React.useState(null);
        const [hintUsage, setHintUsage] = React.useState(null);
        const [purchases, setPurchases] = React.useState(null);
        const [loading, setLoading] = React.useState({});
        const [testResults, setTestResults] = React.useState({});
        
        // Firebase Functions endpoint
        const FUNCTIONS_BASE = 'https://us-central1-word-boxing.cloudfunctions.net';
        
        // Integration definitions
        const integrations = {
            firebase: {
                id: 'firebase',
                name: 'Firebase',
                icon: '🔥',
                description: 'Realtime Database, Auth, Cloud Functions',
                functions: ['getHint', 'getHintUsage', 'createCoinCheckout', 'stripeWebhook', 'getGiftOptions', 'redeemGift', 'getGiftHistory'],
                configRequired: ['apiKey', 'projectId', 'databaseURL'],
                docsUrl: 'https://console.firebase.google.com/project/word-boxing'
            },
            claude: {
                id: 'claude',
                name: 'Claude API',
                icon: '🤖',
                description: 'Anthropic AI for hint generation',
                functions: ['getHint'],
                configRequired: ['ANTHROPIC_API_KEY'],
                docsUrl: 'https://console.anthropic.com/'
            },
            stripe: {
                id: 'stripe',
                name: 'Stripe',
                icon: '💳',
                description: 'Payment processing for coins',
                functions: ['createCoinCheckout', 'stripeWebhook'],
                configRequired: ['STRIPE_SECRET_KEY', 'STRIPE_WEBHOOK_SECRET'],
                docsUrl: 'https://dashboard.stripe.com/'
            },
            goody: {
                id: 'goody',
                name: 'Goody',
                icon: '🎁',
                description: 'Gift card redemption (coming soon)',
                functions: ['getGiftOptions', 'redeemGift', 'getGiftHistory'],
                configRequired: ['GOODY_API_KEY'],
                docsUrl: 'https://www.ongoody.com/',
                comingSoon: true
            }
        };
        
        // Check Firebase connection
        const checkFirebase = async () => {
            setLoading(prev => ({ ...prev, firebase: true }));
            try {
                if (!firebaseDb) throw new Error('Firebase not initialized');
                
                // Test read from a public path
                const testRef = firebaseDb.ref('gameshelf-public');
                await testRef.once('value');
                
                setIntegrationStatus(prev => ({
                    ...prev,
                    firebase: { status: 'connected', lastCheck: new Date().toISOString() }
                }));
                setTestResults(prev => ({ ...prev, firebase: { success: true, message: 'Connected to Firebase Realtime Database' } }));
            } catch (e) {
                setIntegrationStatus(prev => ({
                    ...prev,
                    firebase: { status: 'error', lastCheck: new Date().toISOString(), error: e.message }
                }));
                setTestResults(prev => ({ ...prev, firebase: { success: false, message: e.message } }));
            }
            setLoading(prev => ({ ...prev, firebase: false }));
        };
        
        // Check Claude API (via Firebase Function)
        const checkClaude = async () => {
            setLoading(prev => ({ ...prev, claude: true }));
            try {
                // We can't directly test Claude API, but we can check if the function exists
                // by calling getHintUsage which doesn't require auth
                const response = await fetch(`${FUNCTIONS_BASE}/getHintUsage`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ data: { userId: 'test-connection' } })
                });
                
                if (response.ok) {
                    setIntegrationStatus(prev => ({
                        ...prev,
                        claude: { status: 'connected', lastCheck: new Date().toISOString() }
                    }));
                    setTestResults(prev => ({ ...prev, claude: { success: true, message: 'Firebase Functions responding (Claude API configured)' } }));
                } else {
                    throw new Error(`Function returned ${response.status}`);
                }
            } catch (e) {
                setIntegrationStatus(prev => ({
                    ...prev,
                    claude: { status: 'error', lastCheck: new Date().toISOString(), error: e.message }
                }));
                setTestResults(prev => ({ ...prev, claude: { success: false, message: e.message } }));
            }
            setLoading(prev => ({ ...prev, claude: false }));
        };
        
        // Check Stripe (via createCoinCheckout health)
        const checkStripe = async () => {
            setLoading(prev => ({ ...prev, stripe: true }));
            try {
                // Check if we have any purchase records in Firebase
                if (firebaseDb) {
                    const purchasesRef = firebaseDb.ref('purchases');
                    const snapshot = await purchasesRef.limitToLast(5).once('value');
                    const data = snapshot.val();
                    if (data) {
                        setPurchases(data);
                        setIntegrationStatus(prev => ({
                            ...prev,
                            stripe: { status: 'connected', lastCheck: new Date().toISOString() }
                        }));
                        setTestResults(prev => ({ ...prev, stripe: { success: true, message: 'Stripe integration active (purchases found)' } }));
                    } else {
                        setIntegrationStatus(prev => ({
                            ...prev,
                            stripe: { status: 'connected', lastCheck: new Date().toISOString() }
                        }));
                        setTestResults(prev => ({ ...prev, stripe: { success: true, message: 'Stripe configured (no purchases yet)' } }));
                    }
                }
            } catch (e) {
                setIntegrationStatus(prev => ({
                    ...prev,
                    stripe: { status: 'error', lastCheck: new Date().toISOString(), error: e.message }
                }));
                setTestResults(prev => ({ ...prev, stripe: { success: false, message: e.message } }));
            }
            setLoading(prev => ({ ...prev, stripe: false }));
        };
        
        // Load hint analytics
        const loadHintAnalytics = async () => {
            if (!firebaseDb) return;
            setLoading(prev => ({ ...prev, analytics: true }));
            try {
                const analyticsRef = firebaseDb.ref('hint-analytics');
                const snapshot = await analyticsRef.limitToLast(50).once('value');
                setHintAnalytics(snapshot.val());
                
                const usageRef = firebaseDb.ref('hint-usage');
                const usageSnapshot = await usageRef.limitToLast(20).once('value');
                setHintUsage(usageSnapshot.val());
            } catch (e) {
                console.error('Failed to load hint analytics:', e);
            }
            setLoading(prev => ({ ...prev, analytics: false }));
        };
        
        // Test all integrations
        const testAllIntegrations = async () => {
            await checkFirebase();
            await checkClaude();
            await checkStripe();
            await loadHintAnalytics();
        };
        
        // Initial load
        React.useEffect(() => {
            testAllIntegrations();
        }, []);
        
        // Status indicator component
        const StatusIndicator = ({ status }) => {
            const colors = {
                connected: 'bg-green-500',
                error: 'bg-red-500',
                unknown: 'bg-slate-500',
                loading: 'bg-yellow-500 animate-pulse'
            };
            return (
                <div className={`w-3 h-3 rounded-full ${colors[status] || colors.unknown}`} />
            );
        };
        
        // Integration card component
        const IntegrationCard = ({ integration }) => {
            const status = integrationStatus[integration.id];
            const isLoading = loading[integration.id];
            const result = testResults[integration.id];
            
            return (
                <div className={`bg-slate-800 rounded-xl p-5 border ${
                    status?.status === 'connected' ? 'border-green-700' : 
                    status?.status === 'error' ? 'border-red-700' : 'border-slate-700'
                }`}>
                    <div className="flex items-start justify-between mb-3">
                        <div className="flex items-center gap-3">
                            <span className="text-2xl">{integration.icon}</span>
                            <div>
                                <h3 className="font-semibold">{integration.name}</h3>
                                <p className="text-xs text-slate-400">{integration.description}</p>
                            </div>
                        </div>
                        <StatusIndicator status={isLoading ? 'loading' : status?.status} />
                    </div>
                    
                    {integration.comingSoon ? (
                        <div className="text-sm text-amber-400 bg-amber-900/30 rounded px-3 py-2">
                            🚧 Coming Soon
                        </div>
                    ) : (
                        <>
                            {result && (
                                <div className={`text-xs mb-3 p-2 rounded ${
                                    result.success ? 'bg-green-900/30 text-green-400' : 'bg-red-900/30 text-red-400'
                                }`}>
                                    {result.success ? '✓' : '✗'} {result.message}
                                </div>
                            )}
                            
                            <div className="text-xs text-slate-500 mb-3">
                                Functions: {integration.functions.join(', ')}
                            </div>
                            
                            <div className="flex gap-2">
                                <a 
                                    href={integration.docsUrl} 
                                    target="_blank" 
                                    rel="noopener noreferrer"
                                    className="text-xs px-3 py-1.5 bg-slate-700 hover:bg-slate-600 rounded transition-colors"
                                >
                                    📄 Console
                                </a>
                                <button
                                    onClick={() => {
                                        if (integration.id === 'firebase') checkFirebase();
                                        else if (integration.id === 'claude') checkClaude();
                                        else if (integration.id === 'stripe') checkStripe();
                                    }}
                                    disabled={isLoading}
                                    className="text-xs px-3 py-1.5 bg-indigo-600 hover:bg-indigo-500 rounded transition-colors disabled:opacity-50"
                                >
                                    {isLoading ? '...' : '🔄 Test'}
                                </button>
                            </div>
                        </>
                    )}
                    
                    {status?.lastCheck && (
                        <div className="text-xs text-slate-500 mt-3">
                            Last checked: {new Date(status.lastCheck).toLocaleTimeString()}
                        </div>
                    )}
                </div>
            );
        };
        
        // Logs panel
        const LogsPanel = () => {
            const allLogs = [];
            
            // Convert hint analytics to log entries
            if (hintAnalytics) {
                Object.entries(hintAnalytics).forEach(([key, value]) => {
                    if (typeof value === 'object' && value.timestamp) {
                        allLogs.push({
                            id: key,
                            type: 'hint',
                            timestamp: value.timestamp,
                            data: value
                        });
                    }
                });
            }
            
            // Sort by timestamp descending
            allLogs.sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0));
            
            return (
                <div className="bg-slate-800 rounded-xl p-5 border border-slate-700">
                    <div className="flex items-center justify-between mb-4">
                        <h3 className="font-semibold">📊 Recent Activity</h3>
                        <button
                            onClick={loadHintAnalytics}
                            disabled={loading.analytics}
                            className="text-xs px-3 py-1.5 bg-slate-700 hover:bg-slate-600 rounded"
                        >
                            {loading.analytics ? '...' : '🔄 Refresh'}
                        </button>
                    </div>
                    
                    {allLogs.length === 0 ? (
                        <div className="text-sm text-slate-500 text-center py-8">
                            No recent activity logs
                        </div>
                    ) : (
                        <div className="space-y-2 max-h-96 overflow-y-auto">
                            {allLogs.slice(0, 20).map(log => (
                                <div key={log.id} className="text-xs p-2 bg-slate-900 rounded">
                                    <div className="flex items-center justify-between mb-1">
                                        <span className={`font-medium ${
                                            log.type === 'hint' ? 'text-purple-400' :
                                            log.type === 'purchase' ? 'text-green-400' : 'text-slate-400'
                                        }`}>
                                            {log.type === 'hint' ? '🤖 Hint Request' : 
                                             log.type === 'purchase' ? '💳 Purchase' : '📝 Log'}
                                        </span>
                                        <span className="text-slate-500">
                                            {log.timestamp ? new Date(log.timestamp).toLocaleString() : 'N/A'}
                                        </span>
                                    </div>
                                    {log.data && (
                                        <div className="text-slate-400 truncate">
                                            {log.data.game && `Game: ${log.data.game}`}
                                            {log.data.level && ` | Level: ${log.data.level}`}
                                            {log.data.userId && ` | User: ${log.data.userId.substring(0, 8)}...`}
                                        </div>
                                    )}
                                </div>
                            ))}
                        </div>
                    )}
                </div>
            );
        };
        
        // Usage stats panel
        const UsageStatsPanel = () => {
            const userCount = hintUsage ? Object.keys(hintUsage).length : 0;
            let totalRequests = 0;
            let todayRequests = 0;
            const today = new Date().toDateString();
            
            if (hintUsage) {
                Object.values(hintUsage).forEach(user => {
                    if (user.requests && Array.isArray(user.requests)) {
                        totalRequests += user.requests.length;
                        user.requests.forEach(ts => {
                            if (new Date(ts).toDateString() === today) {
                                todayRequests++;
                            }
                        });
                    }
                });
            }
            
            return (
                <div className="bg-slate-800 rounded-xl p-5 border border-slate-700">
                    <h3 className="font-semibold mb-4">📈 Hint Usage Stats</h3>
                    
                    <div className="grid grid-cols-3 gap-4">
                        <div className="text-center p-3 bg-slate-900 rounded-lg">
                            <div className="text-2xl font-bold text-indigo-400">{userCount}</div>
                            <div className="text-xs text-slate-500">Total Users</div>
                        </div>
                        <div className="text-center p-3 bg-slate-900 rounded-lg">
                            <div className="text-2xl font-bold text-green-400">{totalRequests}</div>
                            <div className="text-xs text-slate-500">Total Hints</div>
                        </div>
                        <div className="text-center p-3 bg-slate-900 rounded-lg">
                            <div className="text-2xl font-bold text-amber-400">{todayRequests}</div>
                            <div className="text-xs text-slate-500">Today</div>
                        </div>
                    </div>
                </div>
            );
        };
        
        // Environment variables panel
        const EnvVarsPanel = () => {
            const envVars = [
                { name: 'ANTHROPIC_API_KEY', service: 'Claude', required: true, hint: 'sk-ant-...' },
                { name: 'STRIPE_SECRET_KEY', service: 'Stripe', required: true, hint: 'sk_live_... or sk_test_...' },
                { name: 'STRIPE_WEBHOOK_SECRET', service: 'Stripe', required: true, hint: 'whsec_...' },
                { name: 'GOODY_API_KEY', service: 'Goody', required: false, hint: 'Optional' }
            ];
            
            return (
                <div className="bg-slate-800 rounded-xl p-5 border border-slate-700">
                    <h3 className="font-semibold mb-4">🔐 Environment Variables</h3>
                    <p className="text-xs text-slate-400 mb-4">
                        Set in Firebase Functions: <code className="bg-slate-900 px-1 rounded">~/Documents/.../Games/firebase-functions/functions/.env</code>
                    </p>
                    
                    <div className="space-y-2">
                        {envVars.map(v => (
                            <div key={v.name} className="flex items-center justify-between p-2 bg-slate-900 rounded text-sm">
                                <div>
                                    <code className="text-indigo-400">{v.name}</code>
                                    <span className="text-xs text-slate-500 ml-2">({v.service})</span>
                                </div>
                                <span className={`text-xs px-2 py-0.5 rounded ${
                                    v.required ? 'bg-red-900/50 text-red-400' : 'bg-slate-700 text-slate-400'
                                }`}>
                                    {v.required ? 'Required' : 'Optional'}
                                </span>
                            </div>
                        ))}
                    </div>
                    
                    <div className="mt-4 p-3 bg-slate-900 rounded">
                        <div className="text-xs text-slate-400 mb-2">Deploy functions after updating .env:</div>
                        <code className="text-xs text-green-400 break-all">
                            cd ~/Documents/.../Games/firebase-functions && firebase deploy --only functions
                        </code>
                    </div>
                </div>
            );
        };
        
        return (
            <div className="space-y-6">
                <div className="flex items-center justify-between">
                    <h2 className="text-xl font-bold flex items-center gap-2">
                        <Icons.Zap /> Integrations
                    </h2>
                    <button
                        onClick={testAllIntegrations}
                        className="px-4 py-2 bg-indigo-600 hover:bg-indigo-500 rounded-lg text-sm font-medium transition-colors"
                    >
                        🔄 Test All
                    </button>
                </div>
                
                {/* Tab Navigation */}
                <div className="flex gap-2 border-b border-slate-700 pb-2">
                    {[
                        { id: 'overview', label: '📊 Overview' },
                        { id: 'logs', label: '📝 Logs' },
                        { id: 'config', label: '⚙️ Configuration' }
                    ].map(tab => (
                        <button
                            key={tab.id}
                            onClick={() => setActiveTab(tab.id)}
                            className={`px-4 py-2 rounded-t-lg font-medium transition-colors ${
                                activeTab === tab.id 
                                    ? 'bg-slate-700 text-white' 
                                    : 'text-slate-400 hover:text-white hover:bg-slate-800'
                            }`}
                        >
                            {tab.label}
                        </button>
                    ))}
                </div>
                
                {/* Overview Tab */}
                {activeTab === 'overview' && (
                    <div className="space-y-6">
                        {/* Integration Cards */}
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                            {Object.values(integrations).map(integration => (
                                <IntegrationCard key={integration.id} integration={integration} />
                            ))}
                        </div>
                        
                        {/* Hint Usage Stats */}
                        <UsageStatsPanel />
                    </div>
                )}
                
                {/* Logs Tab */}
                {activeTab === 'logs' && (
                    <div className="space-y-6">
                        <LogsPanel />
                        
                        {/* Hint Usage by User */}
                        {hintUsage && (
                            <div className="bg-slate-800 rounded-xl p-5 border border-slate-700">
                                <h3 className="font-semibold mb-4">👥 Hint Usage by User</h3>
                                <div className="space-y-2 max-h-64 overflow-y-auto">
                                    {Object.entries(hintUsage).map(([userId, data]) => (
                                        <div key={userId} className="flex items-center justify-between p-2 bg-slate-900 rounded text-sm">
                                            <code className="text-xs text-slate-400">{userId.substring(0, 12)}...</code>
                                            <span className="text-indigo-400">
                                                {data.requests?.length || 0} hints
                                            </span>
                                        </div>
                                    ))}
                                </div>
                            </div>
                        )}
                        
                        {/* Recent Purchases */}
                        {purchases && (
                            <div className="bg-slate-800 rounded-xl p-5 border border-slate-700">
                                <h3 className="font-semibold mb-4">💳 Recent Purchases</h3>
                                <div className="space-y-2 max-h-64 overflow-y-auto">
                                    {Object.entries(purchases).slice(0, 10).map(([userId, userPurchases]) => (
                                        <div key={userId} className="p-2 bg-slate-900 rounded">
                                            <code className="text-xs text-slate-400">{userId.substring(0, 12)}...</code>
                                            {Object.entries(userPurchases).map(([purchaseId, purchase]) => (
                                                <div key={purchaseId} className="mt-1 text-xs text-green-400">
                                                    {purchase.coinAmount} coins - ${(purchase.priceCents / 100).toFixed(2)}
                                                </div>
                                            ))}
                                        </div>
                                    ))}
                                </div>
                            </div>
                        )}
                    </div>
                )}
                
                {/* Configuration Tab */}
                {activeTab === 'config' && (
                    <div className="space-y-6">
                        <EnvVarsPanel />
                        
                        {/* Firebase Functions List */}
                        <div className="bg-slate-800 rounded-xl p-5 border border-slate-700">
                            <h3 className="font-semibold mb-4">☁️ Firebase Cloud Functions</h3>
                            <p className="text-xs text-slate-400 mb-4">
                                Project: <code className="bg-slate-900 px-1 rounded">word-boxing</code> | 
                                Region: <code className="bg-slate-900 px-1 rounded">us-central1</code>
                            </p>
                            
                            <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
                                {[
                                    { name: 'getHint', desc: 'AI hint generation via Claude', type: 'callable' },
                                    { name: 'getHintUsage', desc: 'Check user hint limits', type: 'callable' },
                                    { name: 'createCoinCheckout', desc: 'Stripe checkout session', type: 'callable' },
                                    { name: 'stripeWebhook', desc: 'Handle Stripe events', type: 'http' },
                                    { name: 'getGiftOptions', desc: 'Goody gift tiers', type: 'callable' },
                                    { name: 'redeemGift', desc: 'Redeem coins for gift', type: 'callable' },
                                    { name: 'getGiftHistory', desc: 'Gift redemption history', type: 'callable' }
                                ].map(fn => (
                                    <div key={fn.name} className="p-3 bg-slate-900 rounded">
                                        <div className="flex items-center justify-between">
                                            <code className="text-sm text-indigo-400">{fn.name}</code>
                                            <span className={`text-xs px-2 py-0.5 rounded ${
                                                fn.type === 'http' ? 'bg-amber-900/50 text-amber-400' : 'bg-slate-700 text-slate-400'
                                            }`}>
                                                {fn.type}
                                            </span>
                                        </div>
                                        <div className="text-xs text-slate-500 mt-1">{fn.desc}</div>
                                    </div>
                                ))}
                            </div>
                        </div>
                        
                        {/* Quick Actions */}
                        <div className="bg-slate-800 rounded-xl p-5 border border-slate-700">
                            <h3 className="font-semibold mb-4">🚀 Quick Actions</h3>
                            <div className="flex flex-wrap gap-3">
                                <a 
                                    href="https://console.firebase.google.com/project/word-boxing/functions"
                                    target="_blank"
                                    rel="noopener noreferrer"
                                    className="px-4 py-2 bg-amber-600 hover:bg-amber-500 rounded-lg text-sm font-medium transition-colors"
                                >
                                    🔥 Firebase Console
                                </a>
                                <a 
                                    href="https://console.firebase.google.com/project/word-boxing/functions/logs"
                                    target="_blank"
                                    rel="noopener noreferrer"
                                    className="px-4 py-2 bg-slate-700 hover:bg-slate-600 rounded-lg text-sm font-medium transition-colors"
                                >
                                    📋 Function Logs
                                </a>
                                <a 
                                    href="https://dashboard.stripe.com/test/webhooks"
                                    target="_blank"
                                    rel="noopener noreferrer"
                                    className="px-4 py-2 bg-purple-600 hover:bg-purple-500 rounded-lg text-sm font-medium transition-colors"
                                >
                                    💳 Stripe Webhooks
                                </a>
                                <a 
                                    href="https://console.anthropic.com/"
                                    target="_blank"
                                    rel="noopener noreferrer"
                                    className="px-4 py-2 bg-indigo-600 hover:bg-indigo-500 rounded-lg text-sm font-medium transition-colors"
                                >
                                    🤖 Anthropic Console
                                </a>
                            </div>
                        </div>
                        
                        {/* Deployment Instructions */}
                        <div className="bg-slate-800 rounded-xl p-5 border border-slate-700">
                            <h3 className="font-semibold mb-4">📦 Deploy Functions</h3>
                            <div className="bg-slate-900 rounded p-4 font-mono text-sm">
                                <div className="text-slate-500"># Navigate to functions directory</div>
                                <div className="text-green-400">cd ~/Documents/Documents\ -\ David\'s\ MacBook\ Air/Games/firebase-functions</div>
                                <div className="text-slate-500 mt-2"># Set project</div>
                                <div className="text-green-400">firebase use word-boxing</div>
                                <div className="text-slate-500 mt-2"># Deploy all functions</div>
                                <div className="text-green-400">firebase deploy --only functions</div>
                                <div className="text-slate-500 mt-2"># Or deploy specific function</div>
                                <div className="text-green-400">firebase deploy --only functions:getHint</div>
                            </div>
                        </div>
                    </div>
                )}
            </div>
        );
    }

    // =========================================================================
    // CLEANUP VIEW (v7.4.3) - Repo and File Cleanup Management with Rollback
    // =========================================================================
    
    function RepoResetPanel({ apps, github, showAlert, showConfirm }) {
        const [scanning, setScanning] = React.useState(false);
        const [scanProgress, setScanProgress] = React.useState('');
        const [results, setResults] = React.useState(null); // [{ appId, appName, appIcon, repo, target, expectedFiles, unexpectedFiles }]
        const [selected, setSelected] = React.useState(new Set()); // "repo:path" keys
        const [deleting, setDeleting] = React.useState(false);
        const [deleteLog, setDeleteLog] = React.useState([]);
        
        const scanAll = async () => {
            if (!github) return;
            setScanning(true);
            setResults(null);
            setSelected(new Set());
            setDeleteLog([]);
            
            const allResults = [];
            
            // Get recently deployed apps (last 30 days)
            let recentApps = new Set();
            try {
                const history = DeployService.load();
                const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);
                recentApps = new Set(
                    history.filter(d => d.status === 'success' && new Date(d.completedAt || d.startedAt) > thirtyDaysAgo).map(d => d.appId)
                );
            } catch {}
            
            // Fall back to all apps with repos if no recent deploys
            const appsToScan = Object.entries(apps).filter(([id, app]) => {
                if (recentApps.size > 0 && !recentApps.has(id)) return false;
                return (app.testRepo || app.repos?.test || app.prodRepo || app.repos?.prod);
            });
            
            for (let i = 0; i < appsToScan.length; i++) {
                const [appId, app] = appsToScan[i];
                const repos = [];
                const testRepo = app.testRepo || app.repos?.test;
                const prodRepo = app.prodRepo || app.repos?.prod;
                if (testRepo) repos.push({ repo: testRepo, target: 'test' });
                if (prodRepo) repos.push({ repo: prodRepo, target: 'prod' });
                
                for (const { repo, target } of repos) {
                    setScanProgress(`Scanning ${app.name} (${target})... ${i + 1}/${appsToScan.length}`);
                    
                    try {
                        const subPath = app.subPath || '';
                        const expected = new Set();
                        const addExp = (f) => expected.add(subPath ? `${subPath}/${f}` : f);
                        
                        addExp(app.targetPath || 'index.html');
                        if (app.hasServiceWorker) {
                            addExp(app.swPath || 'sw.js');
                            addExp('manifest.json');
                        }
                        
                        // Doc files for prod repos
                        if (target === 'prod') {
                            const docPath = subPath ? `${subPath}/docs` : '';
                            ['CONTEXT.md', 'PROJECT_PLAN.md', 'CHANGELOG.md', 'RELEASE_NOTES.txt', 'ARCHITECTURE.md', 'CLAUDE-PREP-STANDARD.md', 'DATA_MODEL.md'].forEach(doc => {
                                expected.add(docPath ? `${docPath}/${doc}` : doc);
                            });
                        }
                        
                        // Standard files
                        ['README.md', 'LICENSE', '.gitignore', 'CNAME'].forEach(f => expected.add(f));
                        // Expected directories
                        const iconsPrefix = subPath ? `${subPath}/icons` : 'icons';
                        expected.add(iconsPrefix);
                        expected.add('.github');
                        
                        // Fetch root contents only (lightweight)
                        const rootContents = await github.listRepoContents(repo, subPath || '');
                        
                        const expectedFiles = [];
                        const unexpectedFiles = [];
                        
                        for (const item of rootContents) {
                            const fullPath = subPath ? `${subPath}/${item.name}` : item.name;
                            const isExpected = expected.has(fullPath) || expected.has(item.name) ||
                                item.name.startsWith('.github') ||
                                (item.type === 'dir' && (item.name === 'icons' || item.name === '.github'));
                            
                            if (isExpected) {
                                expectedFiles.push({ path: fullPath, name: item.name, type: item.type, sha: item.sha, size: item.size });
                            } else {
                                unexpectedFiles.push({ path: fullPath, name: item.name, type: item.type, sha: item.sha, size: item.size });
                            }
                        }
                        
                        if (unexpectedFiles.length > 0) {
                            allResults.push({
                                appId, appName: app.name, appIcon: app.icon,
                                repo, target, expectedFiles, unexpectedFiles
                            });
                        }
                    } catch (e) {
                        // Skip repos we can't access
                        console.warn(`[RepoReset] Could not scan ${repo}:`, e.message);
                    }
                }
            }
            
            setResults(allResults);
            setScanProgress('');
            setScanning(false);
        };
        
        const deleteSelected = async () => {
            if (selected.size === 0 || !github) return;
            
            const confirmed = await showConfirm(
                `Delete ${selected.size} file${selected.size > 1 ? 's' : ''} across repos? This cannot be undone.`,
                '⚠️ Confirm Deletion'
            );
            if (!confirmed) return;
            
            setDeleting(true);
            setDeleteLog([]);
            
            // Group by repo for efficient deletion
            const byRepo = {};
            for (const key of selected) {
                const [repo, ...pathParts] = key.split('::');
                const path = pathParts.join('::');
                if (!byRepo[repo]) byRepo[repo] = [];
                byRepo[repo].push(path);
            }
            
            for (const [repo, paths] of Object.entries(byRepo)) {
                for (const path of paths) {
                    try {
                        const file = await github.getFile(repo, path);
                        if (file) {
                            // For directories, need to delete all files inside recursively
                            if (!file.content && !file.sha && Array.isArray(file)) {
                                // It's a directory listing
                                for (const item of file) {
                                    if (item.type === 'file') {
                                        await github.deleteFile(repo, item.path, `Cleanup: remove ${item.path} via CC Repo Reset`, item.sha);
                                        setDeleteLog(prev => [...prev, { msg: `✅ ${repo}: ${item.path}`, type: 'success' }]);
                                    }
                                }
                            } else {
                                await github.deleteFile(repo, path, `Cleanup: remove ${path} via CC Repo Reset`, file.sha);
                                setDeleteLog(prev => [...prev, { msg: `✅ ${repo}: ${path}`, type: 'success' }]);
                            }
                        }
                    } catch (e) {
                        // If it's a directory, try listing and deleting contents
                        try {
                            const contents = await github.listRepoContents(repo, path);
                            if (Array.isArray(contents)) {
                                for (const item of contents) {
                                    const itemPath = `${path}/${item.name}`;
                                    try {
                                        if (item.type === 'file') {
                                            await github.deleteFile(repo, itemPath, `Cleanup: remove ${itemPath} via CC Repo Reset`, item.sha);
                                            setDeleteLog(prev => [...prev, { msg: `✅ ${repo}: ${itemPath}`, type: 'success' }]);
                                        } else if (item.type === 'dir') {
                                            // Recurse one level deeper
                                            const subContents = await github.listRepoContents(repo, itemPath);
                                            for (const sub of subContents) {
                                                if (sub.type === 'file') {
                                                    await github.deleteFile(repo, `${itemPath}/${sub.name}`, `Cleanup: remove ${itemPath}/${sub.name} via CC Repo Reset`, sub.sha);
                                                    setDeleteLog(prev => [...prev, { msg: `✅ ${repo}: ${itemPath}/${sub.name}`, type: 'success' }]);
                                                }
                                            }
                                        }
                                    } catch (e2) {
                                        setDeleteLog(prev => [...prev, { msg: `❌ ${repo}: ${itemPath} — ${e2.message}`, type: 'error' }]);
                                    }
                                }
                            }
                        } catch (e2) {
                            setDeleteLog(prev => [...prev, { msg: `❌ ${repo}: ${path} — ${e.message}`, type: 'error' }]);
                        }
                    }
                }
            }
            
            setDeleteLog(prev => [...prev, { msg: `🎉 Done!`, type: 'success' }]);
            setDeleting(false);
            
            // Re-scan after cleanup
            setTimeout(() => scanAll(), 1500);
        };
        
        const totalUnexpected = results ? results.reduce((sum, r) => sum + r.unexpectedFiles.length, 0) : 0;
        
        const selectAll = () => {
            if (!results) return;
            const allKeys = new Set();
            results.forEach(r => r.unexpectedFiles.forEach(f => allKeys.add(`${r.repo}::${f.path}`)));
            setSelected(allKeys);
        };
        
        return (
            <div className="space-y-4">
                <div className="flex items-center justify-between">
                    <p className="text-sm text-slate-400">
                        Scans recently deployed app repos for unexpected files and directories.
                    </p>
                    <button onClick={scanAll} disabled={scanning || !github}
                        className="px-4 py-2 bg-indigo-600 hover:bg-indigo-500 disabled:bg-slate-700 disabled:text-slate-500 rounded text-sm font-medium whitespace-nowrap">
                        {scanning ? `⏳ ${scanProgress || 'Scanning...'}` : '🔍 Scan All Repos'}
                    </button>
                </div>
                
                {results && (
                    <div className="space-y-4">
                        {/* Summary */}
                        <div className="grid grid-cols-3 gap-3">
                            <div className="bg-slate-900 rounded-lg p-3 border border-slate-700">
                                <div className="text-2xl font-bold text-indigo-400">{results.length}</div>
                                <div className="text-xs text-slate-500">Repos with issues</div>
                            </div>
                            <div className="bg-slate-900 rounded-lg p-3 border border-slate-700">
                                <div className={`text-2xl font-bold ${totalUnexpected > 0 ? 'text-amber-400' : 'text-green-400'}`}>
                                    {totalUnexpected}
                                </div>
                                <div className="text-xs text-slate-500">Unexpected items</div>
                            </div>
                            <div className="bg-slate-900 rounded-lg p-3 border border-slate-700">
                                <div className="text-2xl font-bold text-slate-400">{selected.size}</div>
                                <div className="text-xs text-slate-500">Selected for deletion</div>
                            </div>
                        </div>
                        
                        {totalUnexpected === 0 ? (
                            <div className="bg-green-900/20 border border-green-700/50 rounded-lg p-4 text-center">
                                <div className="text-green-400 font-medium">✅ All repos are clean</div>
                            </div>
                        ) : (
                            <>
                                {/* Bulk actions */}
                                <div className="flex gap-2">
                                    <button onClick={selectAll}
                                        className="px-3 py-1.5 text-xs bg-slate-700 hover:bg-slate-600 rounded font-medium">
                                        Select All ({totalUnexpected})
                                    </button>
                                    <button onClick={() => setSelected(new Set())}
                                        className="px-3 py-1.5 text-xs bg-slate-700 hover:bg-slate-600 rounded font-medium">
                                        Deselect All
                                    </button>
                                    {selected.size > 0 && (
                                        <button onClick={deleteSelected} disabled={deleting}
                                            className="px-4 py-1.5 text-xs bg-red-600 hover:bg-red-500 disabled:bg-slate-700 rounded font-medium ml-auto">
                                            {deleting ? '⏳ Deleting...' : `🗑️ Delete ${selected.size} item${selected.size > 1 ? 's' : ''}`}
                                        </button>
                                    )}
                                </div>
                                
                                {/* Per-repo results */}
                                {results.map((result, ri) => (
                                    <div key={ri} className="bg-slate-900/50 rounded-lg border border-slate-700">
                                        <div className="flex items-center justify-between p-3 border-b border-slate-700">
                                            <div className="flex items-center gap-2 text-sm font-medium">
                                                <span>{result.appIcon === 'gs-logo' ? '🎮' : result.appIcon}</span>
                                                <span>{result.appName}</span>
                                                <span className={`px-1.5 py-0.5 text-xs rounded ${result.target === 'test' ? 'bg-yellow-900/50 text-yellow-400' : 'bg-green-900/50 text-green-400'}`}>
                                                    {result.target.toUpperCase()}
                                                </span>
                                                <span className="text-xs text-slate-500 font-normal">{result.repo}</span>
                                            </div>
                                            <span className="text-xs text-amber-400">{result.unexpectedFiles.length} unexpected</span>
                                        </div>
                                        <div className="p-2 space-y-1">
                                            {result.unexpectedFiles.map(f => {
                                                const key = `${result.repo}::${f.path}`;
                                                return (
                                                    <label key={f.path} className={`flex items-center gap-2 px-2 py-1.5 rounded cursor-pointer hover:bg-slate-800/50 ${
                                                        selected.has(key) ? 'bg-red-900/20' : ''
                                                    }`}>
                                                        <input type="checkbox" 
                                                            checked={selected.has(key)}
                                                            onChange={() => setSelected(prev => {
                                                                const next = new Set(prev);
                                                                next.has(key) ? next.delete(key) : next.add(key);
                                                                return next;
                                                            })}
                                                        />
                                                        <span className={`text-xs font-mono flex-1 ${f.type === 'dir' ? 'text-amber-400' : 'text-amber-400/70'}`}>
                                                            {f.type === 'dir' ? '📁 ' : ''}{f.path}
                                                        </span>
                                                        <span className="text-xs text-slate-500">
                                                            {f.type === 'dir' ? 'dir' : f.size ? `${(f.size / 1024).toFixed(1)}KB` : ''}
                                                        </span>
                                                    </label>
                                                );
                                            })}
                                        </div>
                                    </div>
                                ))}
                            </>
                        )}
                        
                        {/* Delete log */}
                        {deleteLog.length > 0 && (
                            <div className="bg-slate-900 rounded-lg p-3 space-y-1 font-mono text-xs max-h-48 overflow-y-auto border border-slate-700">
                                {deleteLog.map((entry, i) => (
                                    <div key={i} className={entry.type === 'success' ? 'text-green-400' : 'text-red-400'}>{entry.msg}</div>
                                ))}
                            </div>
                        )}
                    </div>
                )}
            </div>
        );
    }
    
    function CleanupView({ github, config, apps, availableRepos, showAlert, showConfirm, initialTab, onTabConsumed }) {
        const [activeTab, setActiveTab] = React.useState(initialTab || 'files');
        
        // Handle initialTab from parent (e.g. health check alert)
        React.useEffect(() => {
            if (initialTab) {
                setActiveTab(initialTab);
                if (onTabConsumed) onTabConsumed();
            }
        }, [initialTab]);
        const [scanning, setScanning] = React.useState(false);
        const [scanResults, setScanResults] = React.useState(null);
        const [selectedFiles, setSelectedFiles] = React.useState(new Set());
        const [selectedRepos, setSelectedRepos] = React.useState(new Set());
        const [deleting, setDeleting] = React.useState(false);
        const [deleteProgress, setDeleteProgress] = React.useState({ current: 0, total: 0 });
        const [restoring, setRestoring] = React.useState(false);
        const [fileFilter, setFileFilter] = React.useState('');
        
        // Deletion history - persisted to localStorage
        const [deletionHistory, setDeletionHistory] = React.useState(() => {
            try {
                return JSON.parse(localStorage.getItem('cc_deletion_history') || '[]');
            } catch { return []; }
        });
        
        // Save deletion history to localStorage + Firebase
        const saveDeletionHistory = (history) => {
            setDeletionHistory(history);
            try {
                localStorage.setItem('cc_deletion_history', JSON.stringify(history));
                // Firebase dual-write
                if (FirebaseConfigSync.initialized) {
                    FirebaseConfigSync.pushDeletionHistory(history).catch(() => {});
                }
            } catch (e) {
                console.error('Failed to save deletion history:', e);
            }
        };
        
        // Add to deletion history
        const addToDeletionHistory = (items) => {
            const newHistory = [
                ...items.map(item => ({
                    ...item,
                    deletedAt: new Date().toISOString(),
                    id: `${item.repo}:${item.path}:${Date.now()}`
                })),
                ...deletionHistory
            ].slice(0, 100); // Keep last 100 deletions
            saveDeletionHistory(newHistory);
        };
        
        // Remove from deletion history
        const removeFromHistory = (id) => {
            const newHistory = deletionHistory.filter(h => h.id !== id);
            saveDeletionHistory(newHistory);
        };
        
        // Clear all history
        const clearHistory = async () => {
            const confirmed = await showConfirm('Clear all deletion history? This only removes the history log, not the actual files.', 'Clear History');
            if (confirmed) {
                saveDeletionHistory([]);
            }
        };
        
        // Define base package files for each app type
        // Files/folders that should NEVER be flagged as stale in ANY repo
        const GLOBALLY_PROTECTED_PATHS = [
            '.github',           // GitHub Actions workflows, issue templates, etc.
            '.gitignore',
            'LICENSE',
            'README.md',
            'package.json',
            'package-lock.json',
            'node_modules',
            'firebase.json',
            '.firebaserc',
            '.env',
            '.env.example',
        ];

        const BASE_PACKAGES = {
            pwa: {
                required: ['index.html', 'sw.js', 'manifest.json'],
                optional: ['RELEASE_NOTES.txt', 'CNAME'],
                folders: ['icons']
            },
            gameshelf: {
                // v8.5.0: PWA now in /app/, landing at root
                required: ['index.html', 'sw.js', 'manifest.json', 'manifest-test.json'],
                optional: ['RELEASE_NOTES.txt', 'CNAME'],
                folders: ['icons', 'icons-test', 'quotle', 'slate', 'rungs', 'wordboxing', 'beta']
            },
            simple: {
                required: ['index.html'],
                optional: ['RELEASE_NOTES.txt', 'README.md', 'CNAME'],
                folders: []
            },
            'firebase-functions': {
                required: ['package.json'],
                optional: ['package-lock.json', 'firebase.json', '.firebaserc', '.env', '.env.example', 'README.md', '.gitignore'],
                folders: ['functions', '.github', 'node_modules']
            }
        };
        
        // Define which repos are consolidated (should contain subfolders)
        const CONSOLIDATED_REPOS = {
            // v8.5.0: Added 'app' for PWA location
            'gameshelf': ['app', 'quotle', 'slate', 'rungs', 'wordboxing', 'beta'],
            'gameshelftest': ['app', 'quotle', 'slate', 'rungs', 'wordboxing']
        };
        
        // Define legacy repos that may no longer be needed
        const LEGACY_REPO_PATTERNS = [
            // Individual game repos (now consolidated)
            /^quotle$/i, /^quotletest$/i,
            /^slate$/i, /^slatetest$/i,
            /^rungs$/i, /^rungstest$/i,
            /^wordboxing$/i, /^wordboxingtest$/i,
            /^word-boxing$/i,
            // Landing page repos (now at gameshelf root) - v8.5.0
            /^game-shelf-landing$/i, /^game-shelf-landing-test$/i,
            // Old naming patterns
            /^gameshelf-dev$/i, /^gameshelf-beta$/i,
            // Typos or experiments
            /test$/i
        ];
        
        // Get app type for a repo
        const getAppType = (repoName) => {
            const lower = repoName.toLowerCase();
            if (lower === 'gameshelf' || lower === 'gameshelftest') return 'gameshelf';
            if (lower.includes('command-center') || lower.includes('command') || lower.includes('testplan')) return 'simple';
            if (lower.includes('firebase-functions') || lower.includes('gameshelf-functions')) return 'firebase-functions';
            return 'pwa';
        };
        
        // Check if a file is part of the base package
        const isBaseFile = (filePath, appType) => {
            const pkg = BASE_PACKAGES[appType] || BASE_PACKAGES.pwa;
            const fileName = filePath.split('/').pop();
            const topLevel = filePath.split('/')[0];
            
            // Globally protected — never flag as stale in any repo
            if (GLOBALLY_PROTECTED_PATHS.includes(fileName) || GLOBALLY_PROTECTED_PATHS.includes(topLevel)) return true;
            
            // Check required files
            if (pkg.required.includes(fileName) && !filePath.includes('/')) return true;
            
            // Check optional files
            if (pkg.optional.includes(fileName) && !filePath.includes('/')) return true;
            
            // Check folders
            if (pkg.folders.some(f => topLevel === f || filePath.startsWith(f + '/'))) return true;
            
            // For consolidated repos, check subfolder structure
            if (appType === 'gameshelf') {
                const parts = filePath.split('/');
                if (parts.length >= 2) {
                    const subApp = parts[0];
                    if (['quotle', 'slate', 'rungs', 'wordboxing'].includes(subApp)) {
                        // Check if it's a valid file within the sub-app
                        const subPath = parts.slice(1).join('/');
                        return isBaseFile(subPath, 'pwa');
                    }
                }
            }
            
            return false;
        };
        
        // Check if a repo might be legacy/unused
        const isLegacyRepo = (repoName) => {
            // Check against legacy patterns
            for (const pattern of LEGACY_REPO_PATTERNS) {
                if (pattern.test(repoName)) {
                    // But exclude if it's an active configured repo
                    const isConfigured = Object.values(config.apps || {}).some(app => 
                        Object.values(app.repos || {}).some(r => r && r.includes(repoName))
                    );
                    if (!isConfigured) return true;
                }
            }
            return false;
        };
        
        // Scan all repos for stale files
        const scanForStaleFiles = async () => {
            if (!github) {
                await showAlert('GitHub token required', 'Error');
                return;
            }
            
            setScanning(true);
            setScanResults(null);
            setSelectedFiles(new Set());
            setSelectedRepos(new Set());
            
            const results = {
                staleFiles: [],
                legacyRepos: [],
                scannedRepos: 0,
                totalFiles: 0
            };
            
            try {
                // Get all repos
                const repos = availableRepos || [];
                
                for (const repo of repos) {
                    const repoName = repo.name;
                    const repoFullName = repo.fullName || `${repo.owner}/${repoName}`;
                    
                    // Check if this is a legacy repo
                    if (isLegacyRepo(repoName)) {
                        results.legacyRepos.push({
                            name: repoName,
                            fullName: repoFullName,
                            reason: 'Matches legacy pattern - may be obsolete after consolidation',
                            url: `https://github.com/${repoFullName}`
                        });
                    }
                    
                    // Scan repo files
                    try {
                        const files = await github.getRepoFiles(repoFullName);
                        const appType = getAppType(repoName);
                        
                        results.scannedRepos++;
                        results.totalFiles += files.length;
                        
                        for (const file of files) {
                            if (file.type === 'file' && !isBaseFile(file.path, appType)) {
                                results.staleFiles.push({
                                    repo: repoFullName,
                                    repoName: repoName,
                                    path: file.path,
                                    sha: file.sha,
                                    size: file.size,
                                    reason: 'Not part of standard package'
                                });
                            }
                        }
                    } catch (e) {
                        console.log(`Could not scan ${repoName}:`, e.message);
                    }
                }
                
                setScanResults(results);
            } catch (e) {
                await showAlert(`Scan failed: ${e.message}`, 'Error');
            }
            
            setScanning(false);
        };
        
        // Toggle file selection
        const toggleFileSelection = (fileKey) => {
            setSelectedFiles(prev => {
                const newSet = new Set(prev);
                if (newSet.has(fileKey)) {
                    newSet.delete(fileKey);
                } else {
                    newSet.add(fileKey);
                }
                return newSet;
            });
        };
        
        // Toggle repo selection
        const toggleRepoSelection = (repoName) => {
            setSelectedRepos(prev => {
                const newSet = new Set(prev);
                if (newSet.has(repoName)) {
                    newSet.delete(repoName);
                } else {
                    newSet.add(repoName);
                }
                return newSet;
            });
        };
        
        // Select all files
        const selectAllFiles = () => {
            if (!scanResults) return;
            const allKeys = scanResults.staleFiles.map(f => `${f.repo}:${f.path}`);
            setSelectedFiles(new Set(allKeys));
        };
        
        // Clear file selection
        const clearFileSelection = () => {
            setSelectedFiles(new Set());
        };
        
        // Select all repos
        const selectAllRepos = () => {
            if (!scanResults) return;
            const allRepos = scanResults.legacyRepos.map(r => r.fullName);
            setSelectedRepos(new Set(allRepos));
        };
        
        // Clear repo selection
        const clearRepoSelection = () => {
            setSelectedRepos(new Set());
        };
        
        // Delete selected files
        const deleteSelectedFiles = async () => {
            if (selectedFiles.size === 0) return;
            
            // Check for critical files that could break deployments
            const criticalPatterns = ['.github/', 'deploy.yml', 'package.json', 'firebase.json', '.firebaserc'];
            const criticalFiles = [...selectedFiles].filter(fileKey => {
                const path = fileKey.split(':').slice(1).join(':');
                return criticalPatterns.some(p => path.includes(p));
            });
            
            if (criticalFiles.length > 0) {
                const criticalNames = criticalFiles.map(f => f.split(':').slice(1).join(':')).join('\n  • ');
                const criticalConfirmed = await showConfirm(
                    `⚠️ CRITICAL FILES DETECTED ⚠️\n\nThe following files are essential for CI/CD, builds, or deployments:\n  • ${criticalNames}\n\nDeleting these will break automated deployments. Are you SURE you want to proceed?`,
                    '🚨 Critical File Warning'
                );
                if (!criticalConfirmed) return;
            }
            
            const confirmed = await showConfirm(
                `Delete ${selectedFiles.size} file(s)?\n\nFiles can be restored from the History tab.`,
                'Confirm Deletion'
            );
            
            if (!confirmed) return;
            
            setDeleting(true);
            setDeleteProgress({ current: 0, total: selectedFiles.size });
            
            let deleted = 0;
            let failed = 0;
            const deletedItems = [];
            
            for (const fileKey of selectedFiles) {
                const [repo, ...pathParts] = fileKey.split(':');
                const path = pathParts.join(':');
                const file = scanResults.staleFiles.find(f => f.repo === repo && f.path === path);
                
                if (file) {
                    try {
                        // Get the commit SHA before deletion for restoration
                        const [owner, repoName] = repo.split('/');
                        let parentCommitSha = null;
                        try {
                            const commits = await github.request(`/repos/${owner}/${repoName}/commits?path=${encodeURIComponent(path)}&per_page=1`);
                            if (commits && commits.length > 0) {
                                parentCommitSha = commits[0].sha;
                            }
                        } catch (e) {
                            console.log('Could not get commit sha:', e);
                        }
                        
                        await github.deleteFile(repo, path, `Cleanup: Remove stale file ${path}`, file.sha);
                        
                        // Track successful deletion
                        deletedItems.push({
                            repo,
                            repoName: file.repoName,
                            path,
                            sha: file.sha,
                            size: file.size,
                            parentCommitSha,
                            reason: file.reason
                        });
                        
                        deleted++;
                    } catch (e) {
                        console.error(`Failed to delete ${path}:`, e);
                        failed++;
                    }
                }
                
                setDeleteProgress({ current: deleted + failed, total: selectedFiles.size });
            }
            
            // Save to deletion history
            if (deletedItems.length > 0) {
                addToDeletionHistory(deletedItems);
            }
            
            setDeleting(false);
            setSelectedFiles(new Set());
            
            await showAlert(
                `Deleted ${deleted} file(s)${failed > 0 ? `, ${failed} failed` : ''}\n\nFiles saved to History tab for potential restoration.`,
                'Deletion Complete'
            );
            
            // Re-scan to update results
            scanForStaleFiles();
        };
        
        // Restore a deleted file from git history
        const restoreFile = async (historyItem) => {
            if (!github) return;
            
            const confirmed = await showConfirm(
                `Restore "${historyItem.path}" to ${historyItem.repoName}?`,
                'Confirm Restore'
            );
            
            if (!confirmed) return;
            
            setRestoring(true);
            
            try {
                const [owner, repoName] = historyItem.repo.split('/');
                
                // Try to get the file content from the commit before deletion
                let content = null;
                
                if (historyItem.parentCommitSha) {
                    try {
                        // Get file content at the parent commit
                        const fileData = await github.request(
                            `/repos/${owner}/${repoName}/contents/${encodeURIComponent(historyItem.path)}?ref=${historyItem.parentCommitSha}`
                        );
                        if (fileData && fileData.content) {
                            content = fileData.content; // Already base64 encoded
                        }
                    } catch (e) {
                        console.log('Could not get file from parent commit:', e);
                    }
                }
                
                // Fallback: try to get from any commit in history
                if (!content) {
                    try {
                        const commits = await github.request(
                            `/repos/${owner}/${repoName}/commits?path=${encodeURIComponent(historyItem.path)}&per_page=5`
                        );
                        for (const commit of commits) {
                            try {
                                const fileData = await github.request(
                                    `/repos/${owner}/${repoName}/contents/${encodeURIComponent(historyItem.path)}?ref=${commit.sha}`
                                );
                                if (fileData && fileData.content) {
                                    content = fileData.content;
                                    break;
                                }
                            } catch (e) {
                                continue;
                            }
                        }
                    } catch (e) {
                        console.log('Could not search commit history:', e);
                    }
                }
                
                if (!content) {
                    throw new Error('Could not find file content in git history');
                }
                
                // Restore the file
                await github.request(`/repos/${owner}/${repoName}/contents/${historyItem.path}`, {
                    method: 'PUT',
                    body: JSON.stringify({
                        message: `Restore: ${historyItem.path}`,
                        content: content.replace(/\n/g, ''), // Remove any newlines in base64
                        committer: { name: 'Command Center', email: 'deploy@gameshelf.app' }
                    })
                });
                
                // Remove from history
                removeFromHistory(historyItem.id);
                
                await showAlert(`Successfully restored "${historyItem.path}"`, 'Restore Complete');
                
            } catch (e) {
                console.error('Restore failed:', e);
                await showAlert(`Failed to restore file: ${e.message}`, 'Restore Failed');
            }
            
            setRestoring(false);
        };
        
        // Delete selected repos
        const deleteSelectedRepos = async () => {
            if (selectedRepos.size === 0) return;
            
            const repoList = Array.from(selectedRepos).join('\n• ');
            const confirmed = await showConfirm(
                `⚠️ DELETE ${selectedRepos.size} REPOSITORY(S)?\n\n• ${repoList}\n\nThis will PERMANENTLY delete these repositories and all their contents!\n\nThis action CANNOT be undone.`,
                '🚨 Confirm Repository Deletion'
            );
            
            if (!confirmed) return;
            
            // Double confirm for repos
            const doubleConfirmed = await showConfirm(
                `Are you ABSOLUTELY SURE?\n\nType the number of repos to delete: ${selectedRepos.size}`,
                'Final Confirmation'
            );
            
            if (!doubleConfirmed) return;
            
            setDeleting(true);
            setDeleteProgress({ current: 0, total: selectedRepos.size });
            
            let deleted = 0;
            let failed = 0;
            
            for (const repoFullName of selectedRepos) {
                try {
                    await github.deleteRepo(repoFullName);
                    deleted++;
                } catch (e) {
                    console.error(`Failed to delete repo ${repoFullName}:`, e);
                    failed++;
                }
                
                setDeleteProgress({ current: deleted + failed, total: selectedRepos.size });
            }
            
            setDeleting(false);
            setSelectedRepos(new Set());
            
            await showAlert(
                `Deleted ${deleted} repo(s)${failed > 0 ? `, ${failed} failed` : ''}`,
                'Deletion Complete'
            );
            
            // Re-scan
            scanForStaleFiles();
        };
        
        // Format file size
        const formatSize = (bytes) => {
            if (bytes < 1024) return `${bytes} B`;
            if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
            return `${(bytes / 1024 / 1024).toFixed(1)} MB`;
        };
        
        return (
            <div className="space-y-6">
                <div className="flex items-center justify-between">
                    <h2 className="text-xl font-bold flex items-center gap-2">
                        <Icons.Trash /> Repository Cleanup
                    </h2>
                    {activeTab !== 'reset' && (
                        <button
                            onClick={scanForStaleFiles}
                            disabled={scanning || !github}
                            className="px-4 py-2 bg-indigo-600 hover:bg-indigo-500 rounded-lg text-sm font-medium transition-colors disabled:opacity-50 flex items-center gap-2"
                        >
                            {scanning ? (
                                <><Icons.Refresh className="animate-spin" /> Scanning...</>
                            ) : (
                                <><Icons.Search /> Scan Repositories</>
                            )}
                        </button>
                    )}
                </div>
                
                {!github && (
                    <div className="p-4 bg-amber-900/50 border border-amber-700 rounded-lg">
                        ⚠️ GitHub token required for cleanup operations
                    </div>
                )}
                
                {/* Tab Navigation */}
                <div className="flex gap-2 border-b border-slate-700 pb-2">
                    {[
                        { id: 'files', label: `📄 Stale Files ${scanResults ? `(${scanResults.staleFiles.length})` : ''}` },
                        { id: 'repos', label: `📦 Legacy Repos ${scanResults ? `(${scanResults.legacyRepos.length})` : ''}` },
                        { id: 'reset', label: '🔄 Repo Reset' },
                        { id: 'history', label: `⏪ History ${deletionHistory.length > 0 ? `(${deletionHistory.length})` : ''}` }
                    ].map(tab => (
                        <button
                            key={tab.id}
                            onClick={() => setActiveTab(tab.id)}
                            className={`px-4 py-2 rounded-t-lg font-medium transition-colors ${
                                activeTab === tab.id 
                                    ? 'bg-slate-700 text-white' 
                                    : 'text-slate-400 hover:text-white hover:bg-slate-800'
                            }`}
                        >
                            {tab.label}
                        </button>
                    ))}
                </div>
                
                {/* Scan Results Summary */}
                {scanResults && (
                    <div className="grid grid-cols-4 gap-4">
                        <div className="bg-slate-800 rounded-lg p-4 text-center">
                            <div className="text-2xl font-bold text-indigo-400">{scanResults.scannedRepos}</div>
                            <div className="text-xs text-slate-500">Repos Scanned</div>
                        </div>
                        <div className="bg-slate-800 rounded-lg p-4 text-center">
                            <div className="text-2xl font-bold text-slate-400">{scanResults.totalFiles}</div>
                            <div className="text-xs text-slate-500">Total Files</div>
                        </div>
                        <div className="bg-slate-800 rounded-lg p-4 text-center">
                            <div className="text-2xl font-bold text-amber-400">{scanResults.staleFiles.length}</div>
                            <div className="text-xs text-slate-500">Stale Files</div>
                        </div>
                        <div className="bg-slate-800 rounded-lg p-4 text-center">
                            <div className="text-2xl font-bold text-red-400">{scanResults.legacyRepos.length}</div>
                            <div className="text-xs text-slate-500">Legacy Repos</div>
                        </div>
                    </div>
                )}
                
                {/* Stale Files Tab */}
                {activeTab === 'files' && (
                    <div className="space-y-4">
                        {scanResults && scanResults.staleFiles.length > 0 && (
                            <>
                                {/* Filter Input */}
                                <div className="relative">
                                    <div className="absolute inset-y-0 left-3 flex items-center pointer-events-none text-slate-400">
                                        <Icons.Search />
                                    </div>
                                    <input
                                        type="text"
                                        placeholder="Filter by filename or repo..."
                                        value={fileFilter}
                                        onChange={(e) => setFileFilter(e.target.value)}
                                        className="w-full bg-slate-800 border border-slate-700 rounded-lg pl-10 pr-10 py-2 text-sm focus:outline-none focus:border-indigo-500"
                                    />
                                    {fileFilter && (
                                        <button
                                            onClick={() => setFileFilter('')}
                                            className="absolute inset-y-0 right-3 flex items-center text-slate-400 hover:text-white"
                                        >
                                            <Icons.X />
                                        </button>
                                    )}
                                </div>
                                
                                {/* Selection Controls */}
                                {(() => {
                                    const staleFiles = scanResults.staleFiles;
                                    const filter = fileFilter.toLowerCase().trim();
                                    const filteredFiles = filter 
                                        ? staleFiles.filter(f => 
                                            f.path.toLowerCase().includes(filter) || 
                                            f.repoName.toLowerCase().includes(filter))
                                        : staleFiles;
                                    
                                    return (
                                        <>
                                            <div className="flex items-center justify-between bg-slate-800 rounded-lg p-3">
                                                <div className="flex items-center gap-4">
                                                    <span className="text-sm text-slate-400">
                                                        {selectedFiles.size} selected • {filteredFiles.length} of {staleFiles.length} shown
                                                    </span>
                                                    <button
                                                        onClick={() => {
                                                            const newSelected = new Set(selectedFiles);
                                                            filteredFiles.forEach(f => newSelected.add(`${f.repo}:${f.path}`));
                                                            setSelectedFiles(newSelected);
                                                        }}
                                                        className="text-xs px-2 py-1 bg-slate-700 hover:bg-slate-600 rounded"
                                                    >
                                                        {filter ? 'Select Filtered' : 'Select All'}
                                                    </button>
                                                    <button
                                                        onClick={clearFileSelection}
                                                        className="text-xs px-2 py-1 bg-slate-700 hover:bg-slate-600 rounded"
                                                    >
                                                        Clear
                                                    </button>
                                                </div>
                                                <button
                                                    onClick={deleteSelectedFiles}
                                                    disabled={selectedFiles.size === 0 || deleting}
                                                    className="px-4 py-2 bg-red-600 hover:bg-red-500 rounded-lg text-sm font-medium transition-colors disabled:opacity-50 flex items-center gap-2"
                                                >
                                                    {deleting ? (
                                                        <><Icons.Refresh className="animate-spin" /> Deleting {deleteProgress.current}/{deleteProgress.total}</>
                                                    ) : (
                                                        <><Icons.Trash /> Delete Selected</>
                                                    )}
                                                </button>
                                            </div>
                                            
                                            {/* File List */}
                                            <div className="bg-slate-800 rounded-xl border border-slate-700 overflow-hidden">
                                                <div className="max-h-96 overflow-y-auto">
                                                    {filteredFiles.length === 0 ? (
                                                        <div className="text-center py-8 text-slate-500">
                                                            No files match "{fileFilter}"
                                                        </div>
                                                    ) : (
                                                        filteredFiles.map((file, idx) => {
                                                            const fileKey = `${file.repo}:${file.path}`;
                                                            const isSelected = selectedFiles.has(fileKey);
                                                            return (
                                                                <div
                                                                    key={fileKey}
                                                                    className={`flex items-center gap-3 p-3 border-b border-slate-700 last:border-0 hover:bg-slate-700/50 cursor-pointer ${
                                                                        isSelected ? 'bg-indigo-900/30' : ''
                                                                    }`}
                                                                    onClick={() => toggleFileSelection(fileKey)}
                                                                >
                                                                    <input
                                                                        type="checkbox"
                                                                        checked={isSelected}
                                                                        onChange={() => {}}
                                                                        className="w-4 h-4 rounded"
                                                                    />
                                                                    <Icons.File />
                                                                    <div className="flex-1 min-w-0">
                                                                        <div className="text-sm font-medium truncate">{file.path}</div>
                                                                        <div className="text-xs text-slate-500">
                                                                            {file.repoName} • {formatSize(file.size || 0)}
                                                                        </div>
                                                                    </div>
                                                                    <span className="text-xs text-amber-400 bg-amber-900/30 px-2 py-1 rounded">
                                                                        {file.reason}
                                                                    </span>
                                                                </div>
                                                            );
                                                        })
                                                    )}
                                                </div>
                                            </div>
                                        </>
                                    );
                                })()}
                            </>
                        )}
                        
                        {scanResults && scanResults.staleFiles.length === 0 && (
                            <div className="text-center py-12 text-slate-500">
                                <div className="text-4xl mb-4">✨</div>
                                <div>No stale files found - repositories are clean!</div>
                            </div>
                        )}
                        
                        {!scanResults && !scanning && (
                            <div className="text-center py-12 text-slate-500">
                                <div className="text-4xl mb-4">🔍</div>
                                <div>Click "Scan Repositories" to find stale files</div>
                            </div>
                        )}
                    </div>
                )}
                
                {/* Legacy Repos Tab */}
                {activeTab === 'repos' && (
                    <div className="space-y-4">
                        {scanResults && scanResults.legacyRepos.length > 0 && (
                            <>
                                {/* Selection Controls */}
                                <div className="flex items-center justify-between bg-slate-800 rounded-lg p-3">
                                    <div className="flex items-center gap-4">
                                        <span className="text-sm text-slate-400">
                                            {selectedRepos.size} of {scanResults.legacyRepos.length} selected
                                        </span>
                                        <button
                                            onClick={selectAllRepos}
                                            className="text-xs px-2 py-1 bg-slate-700 hover:bg-slate-600 rounded"
                                        >
                                            Select All
                                        </button>
                                        <button
                                            onClick={clearRepoSelection}
                                            className="text-xs px-2 py-1 bg-slate-700 hover:bg-slate-600 rounded"
                                        >
                                            Clear
                                        </button>
                                    </div>
                                    <button
                                        onClick={deleteSelectedRepos}
                                        disabled={selectedRepos.size === 0 || deleting}
                                        className="px-4 py-2 bg-red-600 hover:bg-red-500 rounded-lg text-sm font-medium transition-colors disabled:opacity-50 flex items-center gap-2"
                                    >
                                        {deleting ? (
                                            <><Icons.Refresh className="animate-spin" /> Deleting {deleteProgress.current}/{deleteProgress.total}</>
                                        ) : (
                                            <><Icons.Trash /> Delete Selected Repos</>
                                        )}
                                    </button>
                                </div>
                                
                                {/* Warning */}
                                <div className="p-4 bg-red-900/30 border border-red-700 rounded-lg text-sm">
                                    <strong>⚠️ Warning:</strong> Deleting repositories is permanent and cannot be undone. 
                                    Make sure you have backups of any important data before proceeding.
                                </div>
                                
                                {/* Repo List */}
                                <div className="bg-slate-800 rounded-xl border border-slate-700 overflow-hidden">
                                    <div className="max-h-96 overflow-y-auto">
                                        {scanResults.legacyRepos.map((repo) => {
                                            const isSelected = selectedRepos.has(repo.fullName);
                                            return (
                                                <div
                                                    key={repo.fullName}
                                                    className={`flex items-center gap-3 p-4 border-b border-slate-700 last:border-0 hover:bg-slate-700/50 cursor-pointer ${
                                                        isSelected ? 'bg-red-900/20' : ''
                                                    }`}
                                                    onClick={() => toggleRepoSelection(repo.fullName)}
                                                >
                                                    <input
                                                        type="checkbox"
                                                        checked={isSelected}
                                                        onChange={() => {}}
                                                        className="w-4 h-4 rounded"
                                                    />
                                                    <Icons.Folder />
                                                    <div className="flex-1 min-w-0">
                                                        <div className="text-sm font-medium">{repo.name}</div>
                                                        <div className="text-xs text-slate-500">{repo.fullName}</div>
                                                    </div>
                                                    <span className="text-xs text-red-400 bg-red-900/30 px-2 py-1 rounded max-w-xs truncate">
                                                        {repo.reason}
                                                    </span>
                                                    <a
                                                        href={repo.url}
                                                        target="_blank"
                                                        rel="noopener noreferrer"
                                                        onClick={(e) => e.stopPropagation()}
                                                        className="text-xs px-2 py-1 bg-slate-700 hover:bg-slate-600 rounded"
                                                    >
                                                        View
                                                    </a>
                                                </div>
                                            );
                                        })}
                                    </div>
                                </div>
                            </>
                        )}
                        
                        {scanResults && scanResults.legacyRepos.length === 0 && (
                            <div className="text-center py-12 text-slate-500">
                                <div className="text-4xl mb-4">✨</div>
                                <div>No legacy repositories found</div>
                            </div>
                        )}
                        
                        {!scanResults && !scanning && (
                            <div className="text-center py-12 text-slate-500">
                                <div className="text-4xl mb-4">🔍</div>
                                <div>Click "Scan Repositories" to identify legacy repos</div>
                            </div>
                        )}
                    </div>
                )}
                
                {/* Repo Reset Tab */}
                {activeTab === 'reset' && (
                    <RepoResetPanel apps={apps} github={github} showAlert={showAlert} showConfirm={showConfirm} />
                )}
                    
                
                {/* History Tab - Restore deleted files */}
                {activeTab === 'history' && (
                    <div className="space-y-4">
                        {deletionHistory.length > 0 && (
                            <>
                                {/* History Controls */}
                                <div className="flex items-center justify-between bg-slate-800 rounded-lg p-3">
                                    <span className="text-sm text-slate-400">
                                        {deletionHistory.length} deleted file(s) in history
                                    </span>
                                    <button
                                        onClick={clearHistory}
                                        className="text-xs px-3 py-1.5 bg-slate-700 hover:bg-slate-600 rounded"
                                    >
                                        Clear History
                                    </button>
                                </div>
                                
                                {/* Info banner */}
                                <div className="p-4 bg-blue-900/30 border border-blue-700 rounded-lg text-sm">
                                    <strong>💡 Restore Files:</strong> Files can be restored from Git history. 
                                    Click "Restore" to recover a deleted file to its original location.
                                </div>
                                
                                {/* Deletion History List */}
                                <div className="bg-slate-800 rounded-xl border border-slate-700 overflow-hidden">
                                    <div className="max-h-96 overflow-y-auto">
                                        {deletionHistory.map((item) => (
                                            <div
                                                key={item.id}
                                                className="flex items-center gap-3 p-3 border-b border-slate-700 last:border-0 hover:bg-slate-700/50"
                                            >
                                                <Icons.File />
                                                <div className="flex-1 min-w-0">
                                                    <div className="text-sm font-medium truncate">{item.path}</div>
                                                    <div className="text-xs text-slate-500">
                                                        {item.repoName} • Deleted {new Date(item.deletedAt).toLocaleString()}
                                                    </div>
                                                </div>
                                                <div className="flex gap-2">
                                                    <button
                                                        onClick={() => restoreFile(item)}
                                                        disabled={restoring}
                                                        className="text-xs px-3 py-1.5 bg-green-600 hover:bg-green-500 rounded transition-colors disabled:opacity-50"
                                                    >
                                                        {restoring ? '...' : '⏪ Restore'}
                                                    </button>
                                                    <button
                                                        onClick={() => removeFromHistory(item.id)}
                                                        className="text-xs px-2 py-1.5 bg-slate-700 hover:bg-slate-600 rounded transition-colors"
                                                        title="Remove from history (does not restore)"
                                                    >
                                                        ✕
                                                    </button>
                                                </div>
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            </>
                        )}
                        
                        {deletionHistory.length === 0 && (
                            <div className="text-center py-12 text-slate-500">
                                <div className="text-4xl mb-4">📭</div>
                                <div>No deletion history</div>
                                <div className="text-xs mt-2">Deleted files will appear here for restoration</div>
                            </div>
                        )}
                    </div>
                )}
                
                {/* Base Package Reference */}
                <div className="bg-slate-800 rounded-xl p-5 border border-slate-700">
                    <h3 className="font-semibold mb-4">📋 Base Package Reference</h3>
                    <p className="text-xs text-slate-400 mb-4">
                        Files outside these patterns are flagged as potentially stale:
                    </p>
                    <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                        <div className="p-3 bg-slate-900 rounded">
                            <div className="font-medium text-sm mb-2">PWA Apps</div>
                            <div className="text-xs text-slate-400 space-y-1">
                                <div>• index.html, sw.js, manifest.json</div>
                                <div>• icons/ folder</div>
                                <div>• RELEASE_NOTES.txt (optional)</div>
                            </div>
                        </div>
                        <div className="p-3 bg-slate-900 rounded">
                            <div className="font-medium text-sm mb-2">Game Shelf (Consolidated)</div>
                            <div className="text-xs text-slate-400 space-y-1">
                                <div>• Root PWA files + manifest-test.json</div>
                                <div>• icons/, icons-test/ folders</div>
                                <div>• quotle/, slate/, rungs/, wordboxing/</div>
                            </div>
                        </div>
                        <div className="p-3 bg-slate-900 rounded">
                            <div className="font-medium text-sm mb-2">Simple Apps</div>
                            <div className="text-xs text-slate-400 space-y-1">
                                <div>• index.html only</div>
                                <div>• README.md (optional)</div>
                                <div>• Command Center, Test Plan</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        );
    }

    // =========================================================================
    // FIREBASE VIEW
    // =========================================================================
    
    function FirebaseView({ showAlert, showConfirm, showPrompt }) {
        const [activeTab, setActiveTab] = React.useState('data');
        
        const tabs = [
            { id: 'data', label: '🗄️ Data Browser' },
            { id: 'rules', label: '🔒 Rules' },
            { id: 'functions', label: '⚡ Functions' },
            { id: 'logs', label: '📋 Logs' },
        ];
        
        return (
            <div className="space-y-6">
                {/* Tab Navigation */}
                <div className="flex gap-1 bg-slate-800 rounded-xl p-1 border border-slate-700">
                    {tabs.map(tab => (
                        <button 
                            key={tab.id}
                            onClick={() => setActiveTab(tab.id)}
                            className={`flex-1 px-4 py-2.5 rounded-lg text-sm font-medium transition-all ${
                                activeTab === tab.id 
                                    ? 'bg-indigo-600 text-white shadow-lg' 
                                    : 'text-slate-400 hover:text-white hover:bg-slate-700'
                            }`}
                        >
                            {tab.label}
                        </button>
                    ))}
                </div>
                
                {activeTab === 'data' && (
                    <FirebaseDataBrowser showAlert={showAlert} showConfirm={showConfirm} showPrompt={showPrompt} />
                )}
                
                {activeTab === 'rules' && (
                    <FirebaseRulesManager showAlert={showAlert} showConfirm={showConfirm} />
                )}
                
                {activeTab === 'functions' && (
                    <FirebaseFunctionsDashboard showAlert={showAlert} />
                )}
                
                {activeTab === 'logs' && (
                    <FirebaseLogViewer showAlert={showAlert} />
                )}
            </div>
        );
    }
    
    // =========================================================================
    // FIREBASE DATA BROWSER (was the original FirebaseView content)
    // =========================================================================
    
    function FirebaseDataBrowser({ showAlert, showConfirm, showPrompt }) {
        const [user, setUser] = React.useState(null);
        const [authLoading, setAuthLoading] = React.useState(true);
        const [dbPath, setDbPath] = React.useState('');
        const [dbData, setDbData] = React.useState(null);
        const [dbLoading, setDbLoading] = React.useState(false);
        const [dbError, setDbError] = React.useState(null);
        const [expandedPaths, setExpandedPaths] = React.useState(new Set());
        const [editingPath, setEditingPath] = React.useState(null);
        const [editValue, setEditValue] = React.useState('');
        const [realtimeEnabled, setRealtimeEnabled] = React.useState(false);
        const [realtimeUnsubscribe, setRealtimeUnsubscribe] = React.useState(null);
        const [manualUid, setManualUid] = React.useState(() => {
            try { return localStorage.getItem('cc_firebase_uid') || ''; } catch { return ''; }
        });
        const [showManualAuth, setShowManualAuth] = React.useState(false);
        
        // Detect if running from file:// protocol
        const isFileProtocol = window.location.protocol === 'file:';
        
        // Quick paths for common data
        const quickPaths = [
            { label: 'Users', path: 'users' },
            { label: 'Battles', path: 'battles' },
            { label: 'Friends', path: 'friends' },
            { label: 'Gameshelf Public', path: 'gameshelf-public' },
            { label: 'Reported Issues', path: 'reported-issues' },
            { label: 'Game Suggestions', path: 'game-suggestions' },
            { label: 'Test Results', path: 'test-results' },
            { label: 'Root', path: '' },
        ];
        
        // Listen for auth state changes
        React.useEffect(() => {
            if (!firebaseAuth) {
                setAuthLoading(false);
                return;
            }
            
            const unsubscribe = firebaseAuth.onAuthStateChanged((u) => {
                setUser(u);
                setAuthLoading(false);
                if (u) {
                    console.log('Firebase auth state:', u.email, 'UID:', u.uid);
                    // Save UID for manual auth fallback
                    try { localStorage.setItem('cc_firebase_uid', u.uid); } catch {}
                    setManualUid(u.uid);
                } else {
                    console.log('Firebase auth state: signed out');
                }
            });
            
            return () => unsubscribe();
        }, []);
        
        // Cleanup realtime listener on unmount
        React.useEffect(() => {
            return () => {
                if (realtimeUnsubscribe) {
                    realtimeUnsubscribe();
                }
            };
        }, [realtimeUnsubscribe]);
        
        const signInWithGoogle = async () => {
            if (isFileProtocol) {
                showAlert('Google Sign-in requires HTTPS. Please open this app from GitHub Pages or a web server.\n\nOr use the "Manual UID" option below for read-only access to public data.', 'HTTPS Required');
                return;
            }
            
            try {
                const provider = new firebase.auth.GoogleAuthProvider();
                await firebaseAuth.signInWithPopup(provider);
            } catch (e) {
                console.error('Sign in error:', e);
                if (e.code === 'auth/operation-not-supported-in-this-environment') {
                    showAlert('Google Sign-in not supported here. Please:\n\n1. Open from GitHub Pages URL, or\n2. Use "Manual UID" for limited access', 'Sign-in Not Supported');
                } else {
                    showAlert('Sign in failed: ' + e.message, 'Sign-in Error');
                }
            }
        };
        
        const signOut = async () => {
            try {
                await firebaseAuth.signOut();
                setDbData(null);
            } catch (e) {
                console.error('Sign out error:', e);
            }
        };
        
        const fetchData = async (path = dbPath) => {
            if (!firebaseDb) return;
            
            // Stop any existing realtime listener
            if (realtimeUnsubscribe) {
                realtimeUnsubscribe();
                setRealtimeUnsubscribe(null);
            }
            
            setDbLoading(true);
            setDbError(null);
            
            try {
                const ref = firebaseDb.ref(path || '/');
                const snapshot = await ref.once('value');
                setDbData(snapshot.val());
                setDbPath(path);
                console.log('Fetched data at', path || '/', snapshot.val());
            } catch (e) {
                console.error('Fetch error:', e);
                setDbError(e.message);
            }
            
            setDbLoading(false);
        };
        
        const enableRealtime = () => {
            if (!firebaseDb || !dbPath) return;
            
            // Stop existing listener
            if (realtimeUnsubscribe) {
                realtimeUnsubscribe();
            }
            
            const ref = firebaseDb.ref(dbPath || '/');
            const callback = ref.on('value', (snapshot) => {
                setDbData(snapshot.val());
                console.log('Realtime update at', dbPath || '/');
            }, (error) => {
                setDbError(error.message);
            });
            
            setRealtimeUnsubscribe(() => () => ref.off('value', callback));
            setRealtimeEnabled(true);
        };
        
        const disableRealtime = () => {
            if (realtimeUnsubscribe) {
                realtimeUnsubscribe();
                setRealtimeUnsubscribe(null);
            }
            setRealtimeEnabled(false);
        };
        
        const updateValue = async (path, value) => {
            if (!firebaseDb) return;
            
            try {
                // Try to parse as JSON, otherwise use as string
                let parsedValue;
                try {
                    parsedValue = JSON.parse(value);
                } catch {
                    parsedValue = value;
                }
                
                await firebaseDb.ref(path).set(parsedValue);
                setEditingPath(null);
                fetchData(dbPath);
            } catch (e) {
                showAlert('Update failed: ' + e.message, 'Update Error');
            }
        };
        
        const deleteValue = async (path) => {
            if (!firebaseDb) return;
            const confirmed = await showConfirm(`Delete data at "${path}"?`, 'Confirm Delete');
            if (!confirmed) return;
            
            try {
                await firebaseDb.ref(path).remove();
                fetchData(dbPath);
            } catch (e) {
                showAlert('Delete failed: ' + e.message, 'Delete Error');
            }
        };
        
        const copyToClipboard = (data) => {
            navigator.clipboard.writeText(JSON.stringify(data, null, 2));
        };
        
        const toggleExpand = (path) => {
            setExpandedPaths(prev => {
                const newSet = new Set(prev);
                if (newSet.has(path)) {
                    newSet.delete(path);
                } else {
                    newSet.add(path);
                }
                return newSet;
            });
        };
        
        // Render a data node recursively
        const renderData = (data, path = '') => {
            if (data === null || data === undefined) {
                return <span className="text-slate-500 italic">null</span>;
            }
            
            if (typeof data !== 'object') {
                // Primitive value
                const isEditing = editingPath === path;
                
                return (
                    <div className="flex items-center gap-2">
                        {isEditing ? (
                            <>
                                <input 
                                    type="text" 
                                    value={editValue}
                                    onChange={e => setEditValue(e.target.value)}
                                    className="flex-1 bg-slate-900 border border-indigo-500 rounded px-2 py-1 text-sm font-mono"
                                    autoFocus
                                />
                                <button onClick={() => updateValue(path, editValue)} className="px-2 py-1 bg-green-600 rounded text-xs">Save</button>
                                <button onClick={() => setEditingPath(null)} className="px-2 py-1 bg-slate-600 rounded text-xs">Cancel</button>
                            </>
                        ) : (
                            <>
                                <span className={`font-mono ${
                                    typeof data === 'string' ? 'text-green-400' :
                                    typeof data === 'number' ? 'text-blue-400' :
                                    typeof data === 'boolean' ? 'text-amber-400' : 'text-white'
                                }`}>
                                    {typeof data === 'string' ? `"${data}"` : String(data)}
                                </span>
                                <button onClick={() => { setEditingPath(path); setEditValue(typeof data === 'string' ? data : JSON.stringify(data)); }} 
                                    className="p-1 hover:bg-slate-600 rounded opacity-50 hover:opacity-100">
                                    <Icons.Edit />
                                </button>
                            </>
                        )}
                    </div>
                );
            }
            
            // Object or array
            const entries = Object.entries(data);
            const isArray = Array.isArray(data);
            const isExpanded = expandedPaths.has(path) || path === '';
            
            return (
                <div className="ml-4 border-l border-slate-700 pl-3">
                    {entries.length === 0 ? (
                        <span className="text-slate-500 italic">{isArray ? '[]' : '{}'}</span>
                    ) : (
                        entries.slice(0, isExpanded ? undefined : 5).map(([key, value]) => {
                            const childPath = path ? `${path}/${key}` : key;
                            const isObject = value && typeof value === 'object';
                            const childCount = isObject ? Object.keys(value).length : 0;
                            
                            return (
                                <div key={key} className="my-1">
                                    <div className="flex items-center gap-2">
                                        {isObject && (
                                            <button onClick={() => toggleExpand(childPath)} className="text-slate-400 hover:text-white">
                                                {expandedPaths.has(childPath) ? '▼' : '▶'}
                                            </button>
                                        )}
                                        <span className={`${isArray ? 'text-slate-500' : 'text-indigo-400'} font-mono text-sm`}>
                                            {isArray ? `[${key}]` : key}:
                                        </span>
                                        {isObject ? (
                                            <span className="text-slate-500 text-xs">
                                                {Array.isArray(value) ? `Array(${childCount})` : `Object(${childCount})`}
                                            </span>
                                        ) : null}
                                        <button onClick={() => copyToClipboard(value)} className="p-1 hover:bg-slate-600 rounded opacity-50 hover:opacity-100" title="Copy">
                                            <Icons.Copy />
                                        </button>
                                        <button onClick={() => deleteValue(childPath)} className="p-1 hover:bg-red-900/50 rounded opacity-50 hover:opacity-100 text-red-400" title="Delete">
                                            <Icons.Trash />
                                        </button>
                                    </div>
                                    {(!isObject || expandedPaths.has(childPath)) && (
                                        <div className="ml-4">
                                            {renderData(value, childPath)}
                                        </div>
                                    )}
                                </div>
                            );
                        })
                    )}
                    {!isExpanded && entries.length > 5 && (
                        <button onClick={() => toggleExpand(path)} className="text-indigo-400 text-sm hover:underline">
                            ... {entries.length - 5} more items
                        </button>
                    )}
                </div>
            );
        };
        
        return (
            <div className="space-y-6">
                {/* Protocol Warning */}
                {isFileProtocol && (
                    <div className="bg-amber-900/30 border border-amber-700 rounded-xl p-4">
                        <div className="flex items-start gap-3">
                            <span className="text-2xl">⚠️</span>
                            <div>
                                <div className="font-semibold text-amber-400">Running from local file</div>
                                <p className="text-sm text-slate-300 mt-1">
                                    Google Sign-in requires HTTPS. For full functionality:
                                </p>
                                <ol className="text-sm text-slate-400 mt-2 list-decimal list-inside space-y-1">
                                    <li>Deploy this file to your <strong>command-center-test</strong> repo</li>
                                    <li>Open from GitHub Pages URL</li>
                                    <li>Sign in with Google there</li>
                                </ol>
                                <p className="text-sm text-slate-400 mt-2">
                                    Or use <strong>Manual UID</strong> below for read-only access to public data.
                                </p>
                            </div>
                        </div>
                    </div>
                )}
                
                {/* Auth Section */}
                <div className="bg-slate-800 rounded-xl border border-slate-700 p-6">
                    <h2 className="text-lg font-semibold mb-4 flex items-center gap-2">
                        <Icons.Database /> Firebase Realtime Database
                    </h2>
                    
                    <div className="flex items-center gap-4 mb-4">
                        <div className="flex-1">
                            <div className="text-xs text-slate-400 mb-1">Project</div>
                            <div className="font-mono text-sm">{FIREBASE_CONFIG.projectId}</div>
                        </div>
                        
                        {authLoading ? (
                            <div className="text-slate-400">Loading auth...</div>
                        ) : user ? (
                            <div className="flex items-center gap-3">
                                <div className="text-right">
                                    <div className="text-sm font-medium">{user.displayName || user.email}</div>
                                    <div className="text-xs text-slate-400">{user.email}</div>
                                    <div className="text-xs text-slate-500 font-mono">UID: {user.uid}</div>
                                </div>
                                {user.photoURL && <img src={user.photoURL} className="w-8 h-8 rounded-full" />}
                                <button onClick={signOut} className="px-3 py-1.5 bg-slate-700 rounded text-sm">Sign Out</button>
                            </div>
                        ) : (
                            <div className="flex items-center gap-2">
                                <button onClick={signInWithGoogle} 
                                    className={`px-4 py-2 rounded flex items-center gap-2 ${isFileProtocol ? 'bg-slate-600 text-slate-400' : 'bg-indigo-600'}`}>
                                    <Icons.User /> Sign in with Google
                                </button>
                                <button onClick={() => setShowManualAuth(!showManualAuth)} 
                                    className="px-3 py-2 bg-slate-700 rounded text-sm">
                                    {showManualAuth ? 'Hide' : 'Manual UID'}
                                </button>
                            </div>
                        )}
                    </div>
                    
                    {/* Manual UID Input (for file:// or debugging) */}
                    {!user && showManualAuth && (
                        <div className="mt-4 p-4 bg-slate-900 rounded-lg border border-slate-600">
                            <div className="text-sm text-slate-400 mb-2">
                                <strong>Manual UID Access</strong> - Enter a UID to access public data (read-only without auth)
                            </div>
                            <div className="flex gap-2">
                                <input 
                                    type="text"
                                    value={manualUid}
                                    onChange={e => setManualUid(e.target.value)}
                                    placeholder="Firebase UID (e.g., abc123xyz...)"
                                    className="flex-1 bg-slate-800 border border-slate-600 rounded px-3 py-2 font-mono text-sm"
                                />
                                <button onClick={() => {
                                    try { localStorage.setItem('cc_firebase_uid', manualUid); } catch {}
                                    showAlert('UID saved. You can now query public data paths.', 'UID Saved');
                                }} className="px-4 py-2 bg-indigo-600 rounded">
                                    Save
                                </button>
                            </div>
                            <div className="text-xs text-slate-500 mt-2">
                                Tip: Sign in from GitHub Pages once to get your UID, then use it here.
                            </div>
                        </div>
                    )}
                    
                    {!user && !showManualAuth && (
                        <div className="text-slate-400 text-sm">
                            Sign in to access protected data, or click "Manual UID" for limited access.
                        </div>
                    )}
                </div>
                
                {/* Query Section */}
                <div className="bg-slate-800 rounded-xl border border-slate-700 p-6">
                    <h3 className="font-semibold mb-4">Query Data</h3>
                    
                    <div className="flex gap-2 mb-4 flex-wrap">
                        {quickPaths.map(qp => (
                            <button key={qp.path} onClick={() => { setDbPath(qp.path); fetchData(qp.path); }}
                                className={`px-3 py-1.5 rounded text-sm ${dbPath === qp.path ? 'bg-indigo-600' : 'bg-slate-700 hover:bg-slate-600'}`}>
                                {qp.label}
                            </button>
                        ))}
                    </div>
                    
                    <div className="flex gap-2 mb-4">
                        <input 
                            type="text" 
                            value={dbPath}
                            onChange={e => setDbPath(e.target.value)}
                            onKeyDown={e => e.key === 'Enter' && fetchData()}
                            placeholder="Path (e.g., users/abc123)"
                            className="flex-1 bg-slate-900 border border-slate-600 rounded px-3 py-2 font-mono text-sm"
                        />
                        <button onClick={() => fetchData()} disabled={dbLoading} className="px-4 py-2 bg-indigo-600 rounded">
                            {dbLoading ? '...' : 'Fetch'}
                        </button>
                        <button 
                            onClick={() => realtimeEnabled ? disableRealtime() : enableRealtime()} 
                            className={`px-4 py-2 rounded flex items-center gap-2 ${realtimeEnabled ? 'bg-green-600' : 'bg-slate-700'}`}
                            title={realtimeEnabled ? 'Disable realtime updates' : 'Enable realtime updates'}
                        >
                            {realtimeEnabled ? '🔴 Live' : '⚪ Live'}
                        </button>
                    </div>
                    
                    {dbError && (
                        <div className="mb-4 p-3 bg-red-900/30 border border-red-700 rounded text-red-400 text-sm">
                            Error: {dbError}
                        </div>
                    )}
                </div>
                
                {/* Data Display */}
                {dbData !== null && (
                    <div className="bg-slate-800 rounded-xl border border-slate-700 p-6">
                        <div className="flex items-center justify-between mb-4">
                            <h3 className="font-semibold">
                                Data at <span className="font-mono text-indigo-400">/{dbPath || ''}</span>
                                {realtimeEnabled && <span className="ml-2 text-green-400 text-sm">● Live</span>}
                            </h3>
                            <div className="flex gap-2">
                                <button onClick={() => copyToClipboard(dbData)} className="px-3 py-1 bg-slate-700 rounded text-sm flex items-center gap-1">
                                    <Icons.Copy /> Copy All
                                </button>
                                <button onClick={() => setExpandedPaths(new Set())} className="px-3 py-1 bg-slate-700 rounded text-sm">
                                    Collapse All
                                </button>
                            </div>
                        </div>
                        
                        <div className="bg-slate-900 rounded p-4 max-h-[600px] overflow-auto">
                            {renderData(dbData, dbPath)}
                        </div>
                    </div>
                )}
            </div>
        );
    }

    // =========================================================================
    // FIREBASE RULES MANAGER (v8.10.0 — Phase 2)
    // =========================================================================
    
    function FirebaseRulesManager({ showAlert, showConfirm }) {
        const [rules, setRules] = React.useState(null);
        const [editedRules, setEditedRules] = React.useState('');
        const [loading, setLoading] = React.useState(false);
        const [deploying, setDeploying] = React.useState(false);
        const [error, setError] = React.useState(null);
        const [isEditing, setIsEditing] = React.useState(false);
        const [parseError, setParseError] = React.useState(null);
        const [history, setHistory] = React.useState(() => {
            try {
                return JSON.parse(localStorage.getItem('cc_rulesHistory') || '[]');
            } catch { return []; }
        });
        const [showHistory, setShowHistory] = React.useState(false);
        const [selectedSnapshot, setSelectedSnapshot] = React.useState(null);
        const [diffView, setDiffView] = React.useState(false);
        const [hasChanges, setHasChanges] = React.useState(false);
        
        const configured = firebaseAdmin.isConfigured();
        
        // Fetch current rules
        const fetchRules = async () => {
            if (!configured) return;
            setLoading(true);
            setError(null);
            try {
                const result = await firebaseAdmin.getRules();
                setRules(result);
                const formatted = JSON.stringify(result, null, 2);
                setEditedRules(formatted);
                setIsEditing(false);
                setHasChanges(false);
                setParseError(null);
            } catch (e) {
                setError(e.message);
            }
            setLoading(false);
        };
        
        // Validate JSON on edit
        const handleEditChange = (value) => {
            setEditedRules(value);
            setParseError(null);
            try {
                const parsed = JSON.parse(value);
                if (!parsed.rules) {
                    setParseError('Rules JSON must have a top-level "rules" key');
                }
            } catch (e) {
                setParseError(e.message);
            }
            // Check if different from fetched rules
            try {
                const currentStr = JSON.stringify(rules, null, 2);
                setHasChanges(value.trim() !== currentStr.trim());
            } catch {
                setHasChanges(true);
            }
        };
        
        // Save snapshot to history
        const saveSnapshot = (rulesObj, label = 'Before deploy') => {
            const snapshot = {
                id: Date.now(),
                timestamp: new Date().toISOString(),
                label,
                rules: rulesObj,
                size: JSON.stringify(rulesObj).length
            };
            const updated = [snapshot, ...history].slice(0, 20); // Keep last 20
            setHistory(updated);
            try {
                localStorage.setItem('cc_rulesHistory', JSON.stringify(updated));
                // Firebase dual-write
                if (FirebaseConfigSync.initialized) {
                    FirebaseConfigSync.pushRulesHistory(updated).catch(() => {});
                }
            } catch (e) {
                console.warn('Failed to save rules history:', e);
            }
            return snapshot;
        };
        
        // Deploy rules
        const handleDeploy = async () => {
            if (parseError) {
                showAlert('Cannot deploy — there are JSON errors:\n\n' + parseError, 'Validation Error');
                return;
            }
            
            let parsed;
            try {
                parsed = JSON.parse(editedRules);
            } catch (e) {
                showAlert('Invalid JSON: ' + e.message, 'Validation Error');
                return;
            }
            
            if (!parsed.rules) {
                showAlert('Rules JSON must have a top-level "rules" key.\n\nExample:\n{\n  "rules": {\n    ".read": false,\n    ".write": false\n  }\n}', 'Invalid Rules Structure');
                return;
            }
            
            // Count paths for context
            const countPaths = (obj, depth = 0) => {
                if (!obj || typeof obj !== 'object') return 0;
                return Object.keys(obj).reduce((sum, key) => sum + 1 + countPaths(obj[key], depth + 1), 0);
            };
            const pathCount = countPaths(parsed.rules);
            
            const confirmed = await showConfirm(
                `Deploy security rules to ${FIREBASE_CONFIG.projectId}?\n\nThis will OVERWRITE all existing rules (${pathCount} paths/properties).\n\nA snapshot of the current rules will be saved to history before deploying.`,
                'Deploy Rules'
            );
            if (!confirmed) return;
            
            setDeploying(true);
            setError(null);
            
            try {
                // Snapshot current rules before overwriting
                if (rules) {
                    saveSnapshot(rules, 'Before deploy');
                }
                
                const result = await firebaseAdmin.putRules(parsed);
                setRules(result);
                const formatted = JSON.stringify(result, null, 2);
                setEditedRules(formatted);
                setIsEditing(false);
                setHasChanges(false);
                showAlert('Rules deployed successfully!', 'Deploy Complete');
            } catch (e) {
                setError('Deploy failed: ' + e.message);
            }
            
            setDeploying(false);
        };
        
        // Restore from snapshot
        const handleRestore = async (snapshot) => {
            const confirmed = await showConfirm(
                `Restore rules from ${new Date(snapshot.timestamp).toLocaleString()}?\n\nThis will replace the editor content. You still need to click "Deploy" to push to Firebase.`,
                'Restore Snapshot'
            );
            if (!confirmed) return;
            
            const formatted = JSON.stringify(snapshot.rules, null, 2);
            setEditedRules(formatted);
            setIsEditing(true);
            setHasChanges(true);
            setParseError(null);
            setShowHistory(false);
            setSelectedSnapshot(null);
        };
        
        // Delete a snapshot
        const handleDeleteSnapshot = (snapshotId) => {
            const updated = history.filter(h => h.id !== snapshotId);
            setHistory(updated);
            try {
                localStorage.setItem('cc_rulesHistory', JSON.stringify(updated));
                // Firebase dual-write
                if (FirebaseConfigSync.initialized) {
                    FirebaseConfigSync.pushRulesHistory(updated).catch(() => {});
                }
            } catch {}
            if (selectedSnapshot?.id === snapshotId) {
                setSelectedSnapshot(null);
            }
        };
        
        // Compute simple line-by-line diff
        const computeDiff = (oldText, newText) => {
            const oldLines = oldText.split('\n');
            const newLines = newText.split('\n');
            const maxLen = Math.max(oldLines.length, newLines.length);
            const result = [];
            for (let i = 0; i < maxLen; i++) {
                const oldLine = oldLines[i];
                const newLine = newLines[i];
                if (oldLine === newLine) {
                    result.push({ type: 'same', line: oldLine, num: i + 1 });
                } else {
                    if (oldLine !== undefined) result.push({ type: 'removed', line: oldLine, num: i + 1 });
                    if (newLine !== undefined) result.push({ type: 'added', line: newLine, num: i + 1 });
                }
            }
            return result;
        };
        
        // Not configured state
        if (!configured) {
            return (
                <div className="bg-slate-800 rounded-xl border border-slate-700 p-6">
                    <h2 className="text-lg font-semibold mb-4 flex items-center gap-2">
                        🔒 Security Rules Manager
                    </h2>
                    <div className="p-4 bg-amber-900/20 border border-amber-700 rounded-lg">
                        <p className="text-amber-400 font-medium">Service account required</p>
                        <p className="text-sm text-slate-400 mt-2">
                            To manage Firebase security rules, configure a service account key in 
                            <strong className="text-white"> Configure → Settings → Firebase Admin</strong>.
                        </p>
                    </div>
                </div>
            );
        }
        
        return (
            <div className="space-y-6">
                {/* Header & Actions */}
                <div className="bg-slate-800 rounded-xl border border-slate-700 p-6">
                    <div className="flex items-center justify-between mb-4">
                        <h2 className="text-lg font-semibold flex items-center gap-2">
                            🔒 Security Rules — <span className="font-mono text-indigo-400">{FIREBASE_CONFIG.projectId}</span>
                        </h2>
                        <div className="flex items-center gap-2">
                            <button 
                                onClick={() => setShowHistory(!showHistory)}
                                className={`px-3 py-1.5 rounded text-sm flex items-center gap-1.5 ${
                                    showHistory ? 'bg-indigo-600' : 'bg-slate-700 hover:bg-slate-600'
                                }`}
                            >
                                📜 History ({history.length})
                            </button>
                            <button 
                                onClick={fetchRules} 
                                disabled={loading}
                                className="px-4 py-1.5 bg-slate-700 hover:bg-slate-600 rounded text-sm flex items-center gap-1.5"
                            >
                                {loading ? '⏳' : '🔄'} {loading ? 'Loading...' : 'Fetch Rules'}
                            </button>
                        </div>
                    </div>
                    
                    {/* Admin info */}
                    {(() => {
                        const info = firebaseAdmin.getInfo();
                        return info ? (
                            <div className="text-xs text-slate-500 flex items-center gap-4">
                                <span>SA: {info.email}</span>
                                <span>Token: {info.tokenValid ? '🟢 Active' : info.tokenCached ? '🟡 Expired' : '⚪ Not requested'}</span>
                            </div>
                        ) : null;
                    })()}
                    
                    {error && (
                        <div className="mt-4 p-3 bg-red-900/30 border border-red-700 rounded text-red-400 text-sm">
                            {error}
                        </div>
                    )}
                </div>
                
                {/* History Panel */}
                {showHistory && (
                    <div className="bg-slate-800 rounded-xl border border-slate-700 p-6">
                        <h3 className="font-semibold mb-4 flex items-center gap-2">
                            📜 Rules History
                            <span className="text-xs text-slate-500 font-normal">({history.length} snapshots, stored in localStorage)</span>
                        </h3>
                        
                        {history.length === 0 ? (
                            <p className="text-slate-500 text-sm">No snapshots yet. A snapshot is saved automatically before each deploy.</p>
                        ) : (
                            <div className="space-y-2">
                                {history.map((snap) => (
                                    <div key={snap.id} className={`flex items-center justify-between p-3 rounded-lg border transition-colors ${
                                        selectedSnapshot?.id === snap.id 
                                            ? 'bg-indigo-900/30 border-indigo-600' 
                                            : 'bg-slate-900 border-slate-700 hover:border-slate-600'
                                    }`}>
                                        <div className="flex-1 min-w-0">
                                            <div className="flex items-center gap-2">
                                                <span className="text-sm font-medium">{snap.label}</span>
                                                <span className="text-xs text-slate-500">
                                                    {(snap.size / 1024).toFixed(1)} KB
                                                </span>
                                            </div>
                                            <div className="text-xs text-slate-500 mt-0.5">
                                                {new Date(snap.timestamp).toLocaleString()}
                                            </div>
                                        </div>
                                        <div className="flex items-center gap-2 ml-4">
                                            <button 
                                                onClick={() => setSelectedSnapshot(selectedSnapshot?.id === snap.id ? null : snap)}
                                                className="px-2 py-1 bg-slate-700 hover:bg-slate-600 rounded text-xs"
                                            >
                                                {selectedSnapshot?.id === snap.id ? 'Hide' : 'View'}
                                            </button>
                                            <button 
                                                onClick={() => handleRestore(snap)}
                                                className="px-2 py-1 bg-indigo-600 hover:bg-indigo-500 rounded text-xs"
                                            >
                                                Restore
                                            </button>
                                            <button 
                                                onClick={() => handleDeleteSnapshot(snap.id)}
                                                className="px-2 py-1 hover:bg-red-900/50 rounded text-xs text-red-400"
                                                title="Delete snapshot"
                                            >
                                                ✕
                                            </button>
                                        </div>
                                    </div>
                                ))}
                            </div>
                        )}
                        
                        {/* Snapshot preview */}
                        {selectedSnapshot && (
                            <div className="mt-4">
                                <div className="flex items-center justify-between mb-2">
                                    <h4 className="text-sm font-medium text-slate-300">
                                        Snapshot: {new Date(selectedSnapshot.timestamp).toLocaleString()}
                                    </h4>
                                    {rules && (
                                        <button 
                                            onClick={() => setDiffView(!diffView)}
                                            className={`px-2 py-1 rounded text-xs ${diffView ? 'bg-amber-600' : 'bg-slate-700 hover:bg-slate-600'}`}
                                        >
                                            {diffView ? 'Raw View' : 'Diff vs Current'}
                                        </button>
                                    )}
                                </div>
                                {diffView && rules ? (
                                    <div className="bg-slate-900 rounded p-4 max-h-[400px] overflow-auto font-mono text-xs">
                                        {computeDiff(
                                            JSON.stringify(selectedSnapshot.rules, null, 2),
                                            JSON.stringify(rules, null, 2)
                                        ).map((line, i) => (
                                            <div key={i} className={`${
                                                line.type === 'removed' ? 'bg-red-900/30 text-red-400' :
                                                line.type === 'added' ? 'bg-green-900/30 text-green-400' :
                                                'text-slate-500'
                                            }`}>
                                                <span className="inline-block w-8 text-right mr-3 text-slate-600 select-none">{line.num}</span>
                                                <span>{line.type === 'removed' ? '- ' : line.type === 'added' ? '+ ' : '  '}</span>
                                                {line.line}
                                            </div>
                                        ))}
                                    </div>
                                ) : (
                                    <pre className="bg-slate-900 rounded p-4 max-h-[400px] overflow-auto font-mono text-xs text-slate-300 whitespace-pre-wrap">
                                        {JSON.stringify(selectedSnapshot.rules, null, 2)}
                                    </pre>
                                )}
                            </div>
                        )}
                    </div>
                )}
                
                {/* Rules Editor */}
                {rules !== null && (
                    <div className="bg-slate-800 rounded-xl border border-slate-700 p-6">
                        <div className="flex items-center justify-between mb-4">
                            <h3 className="font-semibold flex items-center gap-2">
                                {isEditing ? '✏️ Editing Rules' : '📄 Current Rules'}
                                {hasChanges && (
                                    <span className="px-2 py-0.5 bg-amber-600/30 text-amber-400 text-xs rounded-full">
                                        Unsaved changes
                                    </span>
                                )}
                            </h3>
                            <div className="flex items-center gap-2">
                                {!isEditing ? (
                                    <>
                                        <button 
                                            onClick={() => {
                                                navigator.clipboard.writeText(editedRules);
                                                showAlert('Rules copied to clipboard', 'Copied');
                                            }}
                                            className="px-3 py-1.5 bg-slate-700 hover:bg-slate-600 rounded text-sm"
                                        >
                                            📋 Copy
                                        </button>
                                        <button 
                                            onClick={() => {
                                                saveSnapshot(rules, 'Manual snapshot');
                                                showAlert('Snapshot saved to history', 'Snapshot Saved');
                                            }}
                                            className="px-3 py-1.5 bg-slate-700 hover:bg-slate-600 rounded text-sm"
                                        >
                                            📸 Snapshot
                                        </button>
                                        <button 
                                            onClick={() => setIsEditing(true)}
                                            className="px-3 py-1.5 bg-indigo-600 hover:bg-indigo-500 rounded text-sm"
                                        >
                                            ✏️ Edit
                                        </button>
                                    </>
                                ) : (
                                    <>
                                        <button 
                                            onClick={() => {
                                                setEditedRules(JSON.stringify(rules, null, 2));
                                                setIsEditing(false);
                                                setHasChanges(false);
                                                setParseError(null);
                                            }}
                                            className="px-3 py-1.5 bg-slate-700 hover:bg-slate-600 rounded text-sm"
                                        >
                                            Cancel
                                        </button>
                                        <button 
                                            onClick={() => {
                                                // Format / prettify
                                                try {
                                                    const parsed = JSON.parse(editedRules);
                                                    setEditedRules(JSON.stringify(parsed, null, 2));
                                                    setParseError(null);
                                                } catch (e) {
                                                    setParseError(e.message);
                                                }
                                            }}
                                            className="px-3 py-1.5 bg-slate-700 hover:bg-slate-600 rounded text-sm"
                                        >
                                            🧹 Format
                                        </button>
                                        <button 
                                            onClick={handleDeploy}
                                            disabled={deploying || !!parseError || !hasChanges}
                                            className={`px-4 py-1.5 rounded text-sm font-medium flex items-center gap-1.5 ${
                                                deploying || !!parseError || !hasChanges
                                                    ? 'bg-slate-600 text-slate-400 cursor-not-allowed'
                                                    : 'bg-green-600 hover:bg-green-500 text-white'
                                            }`}
                                        >
                                            {deploying ? '⏳ Deploying...' : '🚀 Deploy Rules'}
                                        </button>
                                    </>
                                )}
                            </div>
                        </div>
                        
                        {/* Parse error banner */}
                        {parseError && (
                            <div className="mb-4 p-3 bg-red-900/30 border border-red-700 rounded text-sm">
                                <span className="text-red-400 font-medium">JSON Error: </span>
                                <span className="text-red-300 font-mono">{parseError}</span>
                            </div>
                        )}
                        
                        {/* Editor area */}
                        {isEditing ? (
                            <textarea
                                value={editedRules}
                                onChange={e => handleEditChange(e.target.value)}
                                className={`w-full bg-slate-900 border rounded p-4 font-mono text-sm text-slate-300 leading-relaxed resize-y ${
                                    parseError ? 'border-red-600' : 'border-slate-600 focus:border-indigo-500'
                                } focus:outline-none`}
                                style={{ minHeight: '400px', maxHeight: '700px', tabSize: 2 }}
                                spellCheck={false}
                                onKeyDown={e => {
                                    // Tab support in textarea
                                    if (e.key === 'Tab') {
                                        e.preventDefault();
                                        const start = e.target.selectionStart;
                                        const end = e.target.selectionEnd;
                                        const val = e.target.value;
                                        const newVal = val.substring(0, start) + '  ' + val.substring(end);
                                        handleEditChange(newVal);
                                        // Set cursor position after React re-renders
                                        requestAnimationFrame(() => {
                                            e.target.selectionStart = e.target.selectionEnd = start + 2;
                                        });
                                    }
                                }}
                            />
                        ) : (
                            <div className="relative">
                                <pre className="bg-slate-900 border border-slate-700 rounded p-4 font-mono text-sm text-slate-300 leading-relaxed overflow-auto max-h-[600px] whitespace-pre-wrap">
                                    {editedRules}
                                </pre>
                                <div className="absolute top-3 right-3 text-xs text-slate-600">
                                    {(editedRules.length / 1024).toFixed(1)} KB · {editedRules.split('\n').length} lines
                                </div>
                            </div>
                        )}
                        
                        {/* Editor stats */}
                        {isEditing && (
                            <div className="mt-2 flex items-center justify-between text-xs text-slate-500">
                                <div className="flex items-center gap-3">
                                    <span>{editedRules.split('\n').length} lines</span>
                                    <span>{(editedRules.length / 1024).toFixed(1)} KB</span>
                                    {!parseError && <span className="text-green-500">✓ Valid JSON</span>}
                                </div>
                                <div>Tab inserts spaces · Ctrl+Z to undo</div>
                            </div>
                        )}
                    </div>
                )}
                
                {/* Empty state — no rules loaded yet */}
                {rules === null && !loading && !error && (
                    <div className="bg-slate-800 rounded-xl border border-slate-700 p-8 text-center">
                        <div className="text-4xl mb-3">🔒</div>
                        <p className="text-slate-400 mb-4">Click <strong>Fetch Rules</strong> to load the current security rules from Firebase.</p>
                        <button 
                            onClick={fetchRules}
                            className="px-6 py-2.5 bg-indigo-600 hover:bg-indigo-500 rounded-lg font-medium"
                        >
                            Fetch Rules
                        </button>
                    </div>
                )}
            </div>
        );
    }

    // =========================================================================
    // FIREBASE FUNCTIONS DASHBOARD (v8.11.0 — Phase 3)
    // =========================================================================
    
    function FirebaseFunctionsDashboard({ showAlert }) {
        const [functions, setFunctions] = React.useState(null);
        const [loading, setLoading] = React.useState(false);
        const [error, setError] = React.useState(null);
        const [pinging, setPinging] = React.useState({});
        const [pingResults, setPingResults] = React.useState({});
        const [errorCounts, setErrorCounts] = React.useState({});
        const [loadingErrors, setLoadingErrors] = React.useState(false);
        const [lastRefresh, setLastRefresh] = React.useState(null);
        
        const configured = firebaseAdmin.isConfigured();
        const FUNCTIONS_BASE = 'https://us-central1-word-boxing.cloudfunctions.net';
        
        // Fetch functions list
        const fetchFunctions = async () => {
            if (!configured) return;
            setLoading(true);
            setError(null);
            try {
                const fns = await firebaseAdmin.listFunctions();
                setFunctions(fns);
                setLastRefresh(new Date());
            } catch (e) {
                setError(e.message);
            }
            setLoading(false);
        };
        
        // Fetch error counts per function (last 24h)
        const fetchErrorCounts = async () => {
            if (!configured) return;
            setLoadingErrors(true);
            try {
                const oneDayAgo = new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString();
                const logs = await firebaseAdmin.getLogs({
                    filter: `resource.type="cloud_function" AND severity>=ERROR AND timestamp>="${oneDayAgo}"`,
                    pageSize: 200
                });
                
                // Group by function name
                const counts = {};
                logs.forEach(entry => {
                    const fnName = entry.resource?.labels?.function_name || 'unknown';
                    counts[fnName] = (counts[fnName] || 0) + 1;
                });
                setErrorCounts(counts);
            } catch (e) {
                console.warn('Failed to fetch error counts:', e);
            }
            setLoadingErrors(false);
        };
        
        // Ping a function's HTTPS endpoint
        const pingFunction = async (fn) => {
            const entryPoint = fn.entryPoint || fn.name.split('/').pop();
            setPinging(prev => ({ ...prev, [entryPoint]: true }));
            
            const start = Date.now();
            try {
                // Use a simple POST with empty data — most callable functions will respond with an auth error
                // but that still proves the function is alive and responsive
                const response = await fetch(`${FUNCTIONS_BASE}/${entryPoint}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ data: {} })
                });
                
                const elapsed = Date.now() - start;
                const isHealthy = response.status < 500; // 4xx = auth error but function is alive, 5xx = broken
                
                setPingResults(prev => ({
                    ...prev,
                    [entryPoint]: {
                        status: response.status,
                        elapsed,
                        healthy: isHealthy,
                        message: isHealthy 
                            ? `${response.status} in ${elapsed}ms` 
                            : `${response.status} error in ${elapsed}ms`,
                        timestamp: new Date()
                    }
                }));
            } catch (e) {
                const elapsed = Date.now() - start;
                setPingResults(prev => ({
                    ...prev,
                    [entryPoint]: {
                        status: 0,
                        elapsed,
                        healthy: false,
                        message: `Failed: ${e.message}`,
                        timestamp: new Date()
                    }
                }));
            }
            setPinging(prev => ({ ...prev, [entryPoint]: false }));
        };
        
        // Ping all functions
        const pingAll = async () => {
            if (!functions) return;
            for (const fn of functions) {
                await pingFunction(fn);
            }
        };
        
        // Load on mount
        React.useEffect(() => {
            if (configured) {
                fetchFunctions().then(() => fetchErrorCounts());
            }
        }, []);
        
        // Helper: extract short name from full function path
        const getShortName = (fn) => fn.entryPoint || fn.name.split('/').pop();
        
        // Helper: format time ago
        const timeAgo = (dateStr) => {
            if (!dateStr) return 'unknown';
            const diff = Date.now() - new Date(dateStr).getTime();
            const minutes = Math.floor(diff / 60000);
            const hours = Math.floor(minutes / 60);
            const days = Math.floor(hours / 24);
            if (days > 0) return `${days}d ago`;
            if (hours > 0) return `${hours}h ago`;
            if (minutes > 0) return `${minutes}m ago`;
            return 'just now';
        };
        
        // Not configured
        if (!configured) {
            return (
                <div className="bg-slate-800 rounded-xl border border-slate-700 p-6">
                    <h2 className="text-lg font-semibold mb-4">⚡ Functions Dashboard</h2>
                    <div className="p-4 bg-amber-900/20 border border-amber-700 rounded-lg">
                        <p className="text-amber-400 font-medium">Service account required</p>
                        <p className="text-sm text-slate-400 mt-2">
                            Configure a service account key in <strong className="text-white">Configure → Settings → Firebase Admin</strong> to view Cloud Functions.
                        </p>
                    </div>
                </div>
            );
        }
        
        // Compute summary stats
        const activeFunctions = functions ? functions.filter(f => f.status === 'ACTIVE').length : 0;
        const totalFunctions = functions ? functions.length : 0;
        const totalErrors24h = Object.values(errorCounts).reduce((sum, c) => sum + c, 0);
        const latestDeploy = functions ? functions.reduce((latest, fn) => {
            if (!fn.updateTime) return latest;
            return !latest || new Date(fn.updateTime) > new Date(latest) ? fn.updateTime : latest;
        }, null) : null;
        
        return (
            <div className="space-y-6">
                {/* Summary Cards */}
                <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
                    <div className="bg-slate-800 rounded-xl border border-slate-700 p-4 text-center">
                        <div className={`text-3xl font-bold ${activeFunctions === totalFunctions ? 'text-green-400' : 'text-amber-400'}`}>
                            {loading ? '...' : activeFunctions}
                        </div>
                        <div className="text-xs text-slate-500 mt-1">
                            Active / {totalFunctions} Functions
                        </div>
                    </div>
                    <div className="bg-slate-800 rounded-xl border border-slate-700 p-4 text-center">
                        <div className={`text-3xl font-bold ${totalErrors24h === 0 ? 'text-green-400' : 'text-red-400'}`}>
                            {loadingErrors ? '...' : totalErrors24h}
                        </div>
                        <div className="text-xs text-slate-500 mt-1">Errors (24h)</div>
                    </div>
                    <div className="bg-slate-800 rounded-xl border border-slate-700 p-4 text-center">
                        <div className="text-3xl font-bold text-indigo-400">
                            {latestDeploy ? timeAgo(latestDeploy) : '—'}
                        </div>
                        <div className="text-xs text-slate-500 mt-1">Last Deploy</div>
                    </div>
                    <div className="bg-slate-800 rounded-xl border border-slate-700 p-4 text-center">
                        <div className="text-3xl font-bold text-slate-400">
                            {lastRefresh ? lastRefresh.toLocaleTimeString() : '—'}
                        </div>
                        <div className="text-xs text-slate-500 mt-1">Last Refresh</div>
                    </div>
                </div>
                
                {/* Actions */}
                <div className="flex items-center justify-between">
                    <h2 className="text-lg font-semibold flex items-center gap-2">
                        ⚡ Cloud Functions — <span className="font-mono text-indigo-400">{FIREBASE_CONFIG.projectId}</span>
                    </h2>
                    <div className="flex gap-2">
                        <button 
                            onClick={pingAll}
                            disabled={!functions || Object.values(pinging).some(Boolean)}
                            className="px-3 py-1.5 bg-amber-600 hover:bg-amber-500 rounded text-sm disabled:opacity-50"
                        >
                            🏓 Ping All
                        </button>
                        <button 
                            onClick={() => { fetchFunctions(); fetchErrorCounts(); }}
                            disabled={loading}
                            className="px-3 py-1.5 bg-slate-700 hover:bg-slate-600 rounded text-sm"
                        >
                            {loading ? '⏳' : '🔄'} Refresh
                        </button>
                    </div>
                </div>
                
                {error && (
                    <div className="p-3 bg-red-900/30 border border-red-700 rounded text-red-400 text-sm">
                        {error}
                    </div>
                )}
                
                {/* Functions Table */}
                {functions && (
                    <div className="bg-slate-800 rounded-xl border border-slate-700 overflow-hidden">
                        <table className="w-full text-sm">
                            <thead>
                                <tr className="border-b border-slate-700 text-left">
                                    <th className="px-4 py-3 text-xs text-slate-400 uppercase tracking-wide">Function</th>
                                    <th className="px-4 py-3 text-xs text-slate-400 uppercase tracking-wide">Status</th>
                                    <th className="px-4 py-3 text-xs text-slate-400 uppercase tracking-wide">Runtime</th>
                                    <th className="px-4 py-3 text-xs text-slate-400 uppercase tracking-wide">Memory</th>
                                    <th className="px-4 py-3 text-xs text-slate-400 uppercase tracking-wide">Errors 24h</th>
                                    <th className="px-4 py-3 text-xs text-slate-400 uppercase tracking-wide">Last Deploy</th>
                                    <th className="px-4 py-3 text-xs text-slate-400 uppercase tracking-wide">Health</th>
                                </tr>
                            </thead>
                            <tbody>
                                {functions.map(fn => {
                                    const name = getShortName(fn);
                                    const ping = pingResults[name];
                                    const errors = errorCounts[name] || 0;
                                    const isPinging = pinging[name];
                                    
                                    return (
                                        <tr key={fn.name} className="border-b border-slate-700/50 hover:bg-slate-700/30">
                                            <td className="px-4 py-3">
                                                <div className="font-mono text-indigo-400">{name}</div>
                                                {fn.httpsTrigger?.url && (
                                                    <div className="text-xs text-slate-600 truncate max-w-[250px]" title={fn.httpsTrigger.url}>
                                                        {fn.httpsTrigger.url}
                                                    </div>
                                                )}
                                            </td>
                                            <td className="px-4 py-3">
                                                <span className={`inline-flex items-center gap-1.5 px-2 py-0.5 rounded-full text-xs font-medium ${
                                                    fn.status === 'ACTIVE' 
                                                        ? 'bg-green-900/40 text-green-400' 
                                                        : fn.status === 'DEPLOY_IN_PROGRESS'
                                                        ? 'bg-amber-900/40 text-amber-400'
                                                        : 'bg-red-900/40 text-red-400'
                                                }`}>
                                                    <span className={`w-1.5 h-1.5 rounded-full ${
                                                        fn.status === 'ACTIVE' ? 'bg-green-400' :
                                                        fn.status === 'DEPLOY_IN_PROGRESS' ? 'bg-amber-400' : 'bg-red-400'
                                                    }`}></span>
                                                    {fn.status}
                                                </span>
                                            </td>
                                            <td className="px-4 py-3 text-xs text-slate-400">{fn.runtime || '—'}</td>
                                            <td className="px-4 py-3 text-xs text-slate-400">{fn.availableMemoryMb ? `${fn.availableMemoryMb}MB` : '—'}</td>
                                            <td className="px-4 py-3">
                                                <span className={`text-xs font-medium ${errors > 0 ? 'text-red-400' : 'text-green-400'}`}>
                                                    {loadingErrors ? '...' : errors}
                                                </span>
                                            </td>
                                            <td className="px-4 py-3 text-xs text-slate-400">
                                                {fn.updateTime ? timeAgo(fn.updateTime) : '—'}
                                            </td>
                                            <td className="px-4 py-3">
                                                {isPinging ? (
                                                    <span className="text-xs text-amber-400 animate-pulse">pinging...</span>
                                                ) : ping ? (
                                                    <div className="flex items-center gap-1.5">
                                                        <span className={`w-2 h-2 rounded-full ${ping.healthy ? 'bg-green-400' : 'bg-red-400'}`}></span>
                                                        <span className={`text-xs ${ping.healthy ? 'text-green-400' : 'text-red-400'}`}>
                                                            {ping.message}
                                                        </span>
                                                    </div>
                                                ) : (
                                                    <button 
                                                        onClick={() => pingFunction(fn)}
                                                        className="text-xs px-2 py-1 bg-slate-700 hover:bg-slate-600 rounded"
                                                    >
                                                        🏓 Ping
                                                    </button>
                                                )}
                                            </td>
                                        </tr>
                                    );
                                })}
                            </tbody>
                        </table>
                    </div>
                )}
                
                {/* Empty state */}
                {!functions && !loading && !error && (
                    <div className="bg-slate-800 rounded-xl border border-slate-700 p-8 text-center">
                        <div className="text-4xl mb-3">⚡</div>
                        <p className="text-slate-400 mb-4">Click <strong>Refresh</strong> to load Cloud Functions from Firebase.</p>
                        <button onClick={fetchFunctions} className="px-6 py-2.5 bg-indigo-600 hover:bg-indigo-500 rounded-lg font-medium">
                            Load Functions
                        </button>
                    </div>
                )}
            </div>
        );
    }
    
    // =========================================================================
    // FIREBASE LOG VIEWER (v8.11.0 — Phase 3)
    // =========================================================================
    
    function FirebaseLogViewer({ showAlert }) {
        const [logs, setLogs] = React.useState([]);
        const [loading, setLoading] = React.useState(false);
        const [error, setError] = React.useState(null);
        const [severityFilter, setSeverityFilter] = React.useState('ALL');
        const [functionFilter, setFunctionFilter] = React.useState('ALL');
        const [searchText, setSearchText] = React.useState('');
        const [pageSize, setPageSize] = React.useState(50);
        const [autoRefresh, setAutoRefresh] = React.useState(false);
        const [lastRefresh, setLastRefresh] = React.useState(null);
        const autoRefreshRef = React.useRef(null);
        
        const configured = firebaseAdmin.isConfigured();
        
        const severityLevels = [
            { id: 'ALL', label: 'All', color: 'text-slate-400' },
            { id: 'DEBUG', label: 'Debug', color: 'text-slate-500' },
            { id: 'INFO', label: 'Info', color: 'text-blue-400' },
            { id: 'WARNING', label: 'Warning', color: 'text-amber-400' },
            { id: 'ERROR', label: 'Error', color: 'text-red-400' },
            { id: 'CRITICAL', label: 'Critical', color: 'text-red-500 font-bold' }
        ];
        
        // Build filter string
        const buildFilter = () => {
            const parts = ['resource.type="cloud_function"'];
            if (severityFilter !== 'ALL') {
                if (severityFilter === 'ERROR') {
                    parts.push('severity>=ERROR');
                } else {
                    parts.push(`severity="${severityFilter}"`);
                }
            }
            if (functionFilter !== 'ALL') {
                parts.push(`resource.labels.function_name="${functionFilter}"`);
            }
            if (searchText.trim()) {
                parts.push(`textPayload:"${searchText.trim()}"`);
            }
            return parts.join(' AND ');
        };
        
        // Fetch logs
        const fetchLogs = async () => {
            if (!configured) return;
            setLoading(true);
            setError(null);
            try {
                const entries = await firebaseAdmin.getLogs({
                    filter: buildFilter(),
                    orderBy: 'timestamp desc',
                    pageSize
                });
                setLogs(entries);
                setLastRefresh(new Date());
            } catch (e) {
                setError(e.message);
            }
            setLoading(false);
        };
        
        // Auto-refresh
        React.useEffect(() => {
            if (autoRefresh) {
                autoRefreshRef.current = setInterval(fetchLogs, 30000); // 30s
            }
            return () => {
                if (autoRefreshRef.current) clearInterval(autoRefreshRef.current);
            };
        }, [autoRefresh, severityFilter, functionFilter, searchText, pageSize]);
        
        // Load on mount
        React.useEffect(() => {
            if (configured) fetchLogs();
        }, []);
        
        // Get unique function names from logs
        const functionNames = React.useMemo(() => {
            const names = new Set();
            logs.forEach(entry => {
                const name = entry.resource?.labels?.function_name;
                if (name) names.add(name);
            });
            return Array.from(names).sort();
        }, [logs]);
        
        // Severity badge
        const SeverityBadge = ({ severity }) => {
            const styles = {
                DEBUG: 'bg-slate-700 text-slate-400',
                DEFAULT: 'bg-slate-700 text-slate-400',
                INFO: 'bg-blue-900/40 text-blue-400',
                NOTICE: 'bg-blue-900/40 text-blue-300',
                WARNING: 'bg-amber-900/40 text-amber-400',
                ERROR: 'bg-red-900/40 text-red-400',
                CRITICAL: 'bg-red-900/60 text-red-300 font-bold',
                ALERT: 'bg-red-900/60 text-red-300 font-bold',
                EMERGENCY: 'bg-red-800 text-white font-bold'
            };
            return (
                <span className={`inline-block px-2 py-0.5 rounded text-xs font-mono ${styles[severity] || styles.DEFAULT}`}>
                    {severity || 'DEFAULT'}
                </span>
            );
        };
        
        // Get log message text
        const getLogText = (entry) => {
            if (entry.textPayload) return entry.textPayload;
            if (entry.jsonPayload) {
                if (entry.jsonPayload.message) return entry.jsonPayload.message;
                return JSON.stringify(entry.jsonPayload, null, 2);
            }
            return '(empty)';
        };
        
        // Not configured
        if (!configured) {
            return (
                <div className="bg-slate-800 rounded-xl border border-slate-700 p-6">
                    <h2 className="text-lg font-semibold mb-4">📋 Log Viewer</h2>
                    <div className="p-4 bg-amber-900/20 border border-amber-700 rounded-lg">
                        <p className="text-amber-400 font-medium">Service account required</p>
                        <p className="text-sm text-slate-400 mt-2">
                            Configure a service account key in <strong className="text-white">Configure → Settings → Firebase Admin</strong> to view logs.
                        </p>
                    </div>
                </div>
            );
        }
        
        // Count by severity
        const severityCounts = React.useMemo(() => {
            const counts = {};
            logs.forEach(entry => {
                const sev = entry.severity || 'DEFAULT';
                counts[sev] = (counts[sev] || 0) + 1;
            });
            return counts;
        }, [logs]);
        
        return (
            <div className="space-y-6">
                {/* Controls */}
                <div className="bg-slate-800 rounded-xl border border-slate-700 p-4">
                    <div className="flex items-center justify-between mb-4">
                        <h2 className="text-lg font-semibold flex items-center gap-2">
                            📋 Cloud Logging — <span className="font-mono text-indigo-400">{FIREBASE_CONFIG.projectId}</span>
                        </h2>
                        <div className="flex items-center gap-2">
                            <button 
                                onClick={() => setAutoRefresh(!autoRefresh)}
                                className={`px-3 py-1.5 rounded text-sm ${autoRefresh ? 'bg-green-600' : 'bg-slate-700 hover:bg-slate-600'}`}
                            >
                                {autoRefresh ? '🔴 Auto (30s)' : '⚪ Auto'}
                            </button>
                            <button 
                                onClick={fetchLogs}
                                disabled={loading}
                                className="px-3 py-1.5 bg-slate-700 hover:bg-slate-600 rounded text-sm"
                            >
                                {loading ? '⏳' : '🔄'} Refresh
                            </button>
                        </div>
                    </div>
                    
                    {/* Filter Row */}
                    <div className="flex flex-wrap gap-3 items-center">
                        {/* Severity Filter */}
                        <div className="flex items-center gap-1.5">
                            <span className="text-xs text-slate-500">Severity:</span>
                            <select 
                                value={severityFilter} 
                                onChange={e => setSeverityFilter(e.target.value)}
                                className="bg-slate-900 border border-slate-600 rounded px-2 py-1 text-sm"
                            >
                                {severityLevels.map(s => (
                                    <option key={s.id} value={s.id}>{s.label}</option>
                                ))}
                            </select>
                        </div>
                        
                        {/* Function Filter */}
                        <div className="flex items-center gap-1.5">
                            <span className="text-xs text-slate-500">Function:</span>
                            <select 
                                value={functionFilter} 
                                onChange={e => setFunctionFilter(e.target.value)}
                                className="bg-slate-900 border border-slate-600 rounded px-2 py-1 text-sm"
                            >
                                <option value="ALL">All</option>
                                {functionNames.map(name => (
                                    <option key={name} value={name}>{name}</option>
                                ))}
                            </select>
                        </div>
                        
                        {/* Text Search */}
                        <div className="flex-1 min-w-[200px]">
                            <input 
                                type="text"
                                value={searchText}
                                onChange={e => setSearchText(e.target.value)}
                                onKeyDown={e => e.key === 'Enter' && fetchLogs()}
                                placeholder="Search log text..."
                                className="w-full bg-slate-900 border border-slate-600 rounded px-3 py-1 text-sm"
                            />
                        </div>
                        
                        {/* Page Size */}
                        <div className="flex items-center gap-1.5">
                            <span className="text-xs text-slate-500">Show:</span>
                            <select 
                                value={pageSize} 
                                onChange={e => setPageSize(Number(e.target.value))}
                                className="bg-slate-900 border border-slate-600 rounded px-2 py-1 text-sm"
                            >
                                <option value={25}>25</option>
                                <option value={50}>50</option>
                                <option value={100}>100</option>
                                <option value={200}>200</option>
                            </select>
                        </div>
                        
                        <button 
                            onClick={fetchLogs}
                            className="px-4 py-1 bg-indigo-600 hover:bg-indigo-500 rounded text-sm"
                        >
                            Apply
                        </button>
                    </div>
                </div>
                
                {error && (
                    <div className="p-3 bg-red-900/30 border border-red-700 rounded text-red-400 text-sm">
                        {error}
                    </div>
                )}
                
                {/* Severity Summary Bar */}
                {logs.length > 0 && (
                    <div className="flex gap-3 items-center text-xs">
                        <span className="text-slate-500">{logs.length} entries</span>
                        {Object.entries(severityCounts).sort().map(([sev, count]) => {
                            const level = severityLevels.find(s => s.id === sev) || { color: 'text-slate-400' };
                            return (
                                <button 
                                    key={sev} 
                                    onClick={() => { setSeverityFilter(sev); fetchLogs(); }}
                                    className={`${level.color} hover:underline`}
                                >
                                    {sev}: {count}
                                </button>
                            );
                        })}
                        {lastRefresh && (
                            <span className="text-slate-600 ml-auto">
                                Updated: {lastRefresh.toLocaleTimeString()}
                            </span>
                        )}
                    </div>
                )}
                
                {/* Log Entries */}
                {logs.length > 0 ? (
                    <div className="bg-slate-800 rounded-xl border border-slate-700 overflow-hidden">
                        <div className="max-h-[600px] overflow-y-auto">
                            {logs.map((entry, i) => {
                                const fnName = entry.resource?.labels?.function_name || '';
                                const text = getLogText(entry);
                                const isError = entry.severity === 'ERROR' || entry.severity === 'CRITICAL';
                                
                                return (
                                    <div 
                                        key={i} 
                                        className={`px-4 py-2.5 border-b border-slate-700/50 text-sm hover:bg-slate-700/30 ${
                                            isError ? 'bg-red-900/10' : ''
                                        }`}
                                    >
                                        <div className="flex items-center gap-3 mb-1">
                                            <span className="text-xs text-slate-600 font-mono w-[150px] flex-shrink-0">
                                                {entry.timestamp ? new Date(entry.timestamp).toLocaleString() : '—'}
                                            </span>
                                            <SeverityBadge severity={entry.severity} />
                                            {fnName && (
                                                <button 
                                                    onClick={() => { setFunctionFilter(fnName); fetchLogs(); }}
                                                    className="text-xs font-mono text-indigo-400 hover:underline"
                                                >
                                                    {fnName}
                                                </button>
                                            )}
                                        </div>
                                        <div className={`font-mono text-xs leading-relaxed whitespace-pre-wrap break-all ${
                                            isError ? 'text-red-300' : 'text-slate-300'
                                        }`}>
                                            {text}
                                        </div>
                                    </div>
                                );
                            })}
                        </div>
                    </div>
                ) : !loading && (
                    <div className="bg-slate-800 rounded-xl border border-slate-700 p-8 text-center">
                        <div className="text-4xl mb-3">📋</div>
                        <p className="text-slate-400 mb-4">
                            {logs.length === 0 && lastRefresh 
                                ? 'No log entries match the current filters.'
                                : 'Click Refresh to load Cloud Logging entries.'
                            }
                        </p>
                        {!lastRefresh && (
                            <button onClick={fetchLogs} className="px-6 py-2.5 bg-indigo-600 hover:bg-indigo-500 rounded-lg font-medium">
                                Load Logs
                            </button>
                        )}
                    </div>
                )}
            </div>
        );
    }

    // =========================================================================
    // APPS VIEW
    // =========================================================================
    
    function AppsView({ apps, repos, onUpdate, github }) {
        const [repoDirectories, setRepoDirectories] = React.useState({});
        const [loadingDirs, setLoadingDirs] = React.useState({});
        
        // Fetch directories for a repo
        const fetchDirectories = async (repoFullName) => {
            if (!github || !repoFullName || repoDirectories[repoFullName]) return;
            
            setLoadingDirs(prev => ({ ...prev, [repoFullName]: true }));
            try {
                const contents = await github.listRepoContents(repoFullName, '');
                const dirs = contents
                    .filter(item => item.type === 'dir')
                    .map(item => item.name)
                    .sort();
                setRepoDirectories(prev => ({ ...prev, [repoFullName]: dirs }));
            } catch (e) {
                console.error('Failed to fetch directories for', repoFullName, e);
                setRepoDirectories(prev => ({ ...prev, [repoFullName]: [] }));
            }
            setLoadingDirs(prev => ({ ...prev, [repoFullName]: false }));
        };
        
        // Fetch directories when prod repo changes
        React.useEffect(() => {
            Object.values(apps).forEach(app => {
                if (app.prodRepo && !repoDirectories[app.prodRepo]) {
                    fetchDirectories(app.prodRepo);
                }
            });
        }, [apps, github]);
        
        // Get directories for a given app's prod repo
        const getDirsForApp = (app) => {
            return repoDirectories[app.prodRepo] || [];
        };
        
        return (
            <div className="space-y-6">
                <h2 className="text-xl font-bold">App Configuration</h2>
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                    {Object.values(apps).map(app => (
                        <div key={app.id} className="bg-slate-800 rounded-xl border border-slate-700 p-4">
                            <div className="flex items-center gap-2 mb-3">
                                <AppIcon icon={app.icon} size={28} />
                                <span className="font-semibold">{app.name}</span>
                            </div>
                            <div className="space-y-2">
                                <div>
                                    <label className="text-xs text-blue-400">🧪 TEST</label>
                                    <select value={app.testRepo || ''} onChange={e => onUpdate(app.id, { testRepo: e.target.value })}
                                        className="w-full p-1.5 bg-slate-700 border border-slate-600 rounded text-sm">
                                        <option value="">Select...</option>
                                        {repos.map(r => <option key={r.fullName} value={r.fullName}>{r.name}</option>)}
                                    </select>
                                </div>
                                <div>
                                    <label className="text-xs text-green-400">🚀 PROD</label>
                                    <select value={app.prodRepo || ''} onChange={e => {
                                        onUpdate(app.id, { prodRepo: e.target.value });
                                        if (e.target.value) fetchDirectories(e.target.value);
                                    }}
                                        className="w-full p-1.5 bg-slate-700 border border-slate-600 rounded text-sm">
                                        <option value="">Select...</option>
                                        {repos.map(r => <option key={r.fullName} value={r.fullName}>{r.name}</option>)}
                                    </select>
                                </div>
                                <div>
                                    <label className="text-xs text-slate-400">Sub Path</label>
                                    <select value={app.subPath || ''} onChange={e => onUpdate(app.id, { subPath: e.target.value })}
                                        className="w-full p-1.5 bg-slate-700 border border-slate-600 rounded text-sm font-mono">
                                        <option value="">(root)</option>
                                        {loadingDirs[app.prodRepo] && <option disabled>Loading...</option>}
                                        {getDirsForApp(app).map(dir => (
                                            <option key={dir} value={dir}>{dir}/</option>
                                        ))}
                                    </select>
                                </div>
                                <div>
                                    <label className="text-xs text-slate-400">Target Path</label>
                                    <input type="text" value={app.targetPath} onChange={e => onUpdate(app.id, { targetPath: e.target.value })}
                                        className="w-full p-1.5 bg-slate-700 border border-slate-600 rounded text-sm font-mono" />
                                </div>
                            </div>
                        </div>
                    ))}
                </div>
            </div>
        );
    }

    // =========================================================================
    // HISTORY VIEW
    // =========================================================================
    
    function HistoryView({ deployments, apps, onRollback, globalWorkItems, globalSessions }) {
        // Helper: find session linked to a deploy
        const findLinkedSession = (deploy) => {
            if (deploy.sessionId) {
                return (globalSessions || []).find(s => s.id === deploy.sessionId);
            }
            // Try to find by deployId match
            return (globalSessions || []).find(s => s.deployId === `deploy-${deploy.id}`);
        };
        
        // Helper: find completed work items for a deploy
        const findCompletedWIs = (deploy) => {
            if (deploy.workItemsCompleted && deploy.workItemsCompleted.length > 0) {
                return (globalWorkItems || []).filter(wi => deploy.workItemsCompleted.includes(wi.id));
            }
            return [];
        };
        
        return (
            <div className="bg-slate-800 rounded-xl border border-slate-700 p-6">
                <h2 className="text-lg font-semibold mb-4 flex items-center gap-2">
                    <Icons.History /> History ({deployments.length})
                </h2>
                {deployments.length === 0 ? (
                    <div className="text-slate-400 text-center py-8">No deployments yet</div>
                ) : (
                    <div className="space-y-2">
                        {deployments.map(d => {
                            const linkedSession = findLinkedSession(d);
                            const completedWIs = findCompletedWIs(d);
                            
                            return (
                            <div key={d.id} className={`p-3 rounded-lg border ${
                                d.status === 'success' ? 'bg-green-900/20 border-green-800' :
                                d.status === 'failed' ? 'bg-red-900/20 border-red-800' : 'border-slate-600'
                            }`}>
                                <div className="flex items-center gap-2">
                                    <AppIcon icon={apps[d.appId]?.icon} size={18} />
                                    <span className="font-medium">{d.appName}</span>
                                    <span className="font-mono text-sm text-slate-400">{formatVersion(d.version)}</span>
                                    {d.fileCount && <span className="text-xs text-slate-500">({d.fileCount} files)</span>}
                                    <span className={`text-xs px-1.5 rounded ${d.target === 'prod' ? 'bg-green-900 text-green-300' : 'bg-blue-900 text-blue-300'}`}>
                                        {d.target?.toUpperCase()}
                                    </span>
                                    {d.isPromotion && <span className="text-xs text-amber-400">↑ promoted</span>}
                                    {d.isRollback && <span className="text-xs text-amber-400">↩ rollback</span>}
                                    <span className="flex-1" />
                                    {d.status === 'success' && d.commitSha && !d.fileCount && (
                                        <button onClick={() => onRollback(d)}
                                            className="px-2 py-1 text-xs bg-slate-700 hover:bg-amber-900/50 rounded flex items-center gap-1">
                                            <Icons.Rewind className="w-3 h-3" /> Rollback
                                        </button>
                                    )}
                                </div>
                                <div className="text-xs text-slate-500 mt-1 flex items-center gap-2 flex-wrap">
                                    {formatDate(d.completedAt || d.startedAt)}
                                    {d.commitSha && <span className="font-mono">• {d.commitSha.substring(0, 7)}</span>}
                                    {d.previousVersion && <span>• was {formatVersion(d.previousVersion)}</span>}
                                    {linkedSession && (
                                        <span className="text-indigo-400">• {linkedSession.type} session</span>
                                    )}
                                </div>
                                {/* Work Items completed in this deploy (v8.27.0) */}
                                {completedWIs.length > 0 && (
                                    <div className="flex flex-wrap gap-1 mt-1.5">
                                        {completedWIs.map(wi => (
                                            <span key={wi.id} className="text-xs px-1.5 py-0.5 bg-green-900/30 text-green-300 rounded border border-green-800/30">
                                                ✓ {wi.id}: {wi.title}
                                            </span>
                                        ))}
                                    </div>
                                )}
                                {d.url && d.status === 'success' && (
                                    <a href={d.url} target="_blank" className="text-xs text-indigo-400 hover:underline">View ↗</a>
                                )}
                            </div>
                            );
                        })}
                    </div>
                )}
            </div>
        );
    }

    // =========================================================================
    // SMART DEPLOY VIEW - Deploy from gs-active archive
    // =========================================================================
    
    // Map gs-active folder names to app IDs
    const GS_ACTIVE_FOLDER_MAP = {
        'gameshelf': 'gameshelf',
        'quotle': 'quotle',
        'slate': 'slate',
        'rungs': 'rungs',
        'wordboxing': 'wordboxing',
        'beta': 'beta',
        'landing': 'landing',
        'command-center': 'command-center',
        'testplan': 'testplan',
        'firebase-functions': 'firebase-functions'
    };
    
    function SmartDeployView({ apps, github, onDeploy, onBatchDeploy, showAlert, showConfirm, activeDeployments, removeActiveDeployment, pendingFile, clearPendingFile }) {
        const [archiveApps, setArchiveApps] = React.useState([]); // Apps found in archive
        const [selectedApps, setSelectedApps] = React.useState(new Set());
        const [loading, setLoading] = React.useState(false);
        const [checkingVersions, setCheckingVersions] = React.useState(false);
        const [archiveName, setArchiveName] = React.useState(null);
        const fileInputRef = React.useRef(null);
        
        // v8.36.1: Smart default target based on repo configuration
        // Two-repo apps → TEST (safe), prod-only → PROD, test-only → TEST
        const getDefaultTarget = (appId) => {
            const appConfig = apps[appId];
            if (!appConfig) return 'test';
            const hasTest = !!(appConfig.testRepo || appConfig.repos?.test || (appConfig.repoPatterns?.test?.length > 0));
            const hasProd = !!(appConfig.prodRepo || appConfig.repos?.prod || (appConfig.repoPatterns?.prod?.length > 0));
            if (hasTest && hasProd) return 'test';   // Two-repo: safe default
            if (hasProd && !hasTest) return 'prod';   // Prod-only
            if (hasTest && !hasProd) return 'test';   // Test-only
            return 'test';
        };
        
        // Auto-load pending file from Dashboard redirect
        React.useEffect(() => {
            if (pendingFile) {
                processArchive(pendingFile);
                clearPendingFile();
            }
        }, [pendingFile]);
        
        // Parse gs-active archive
        const handleFileSelect = async (e) => {
            const file = e.target.files?.[0];
            if (!file) return;
            processArchive(file);
        };
        
        // Process archive file (shared by handleFileSelect and pendingFile)
        const processArchive = async (file) => {
            setLoading(true);
            setArchiveName(file.name);
            
            try {
                const zip = await JSZip.loadAsync(file);
                const foundApps = [];
                
                // Find all folders in gs-active/
                const folders = new Set();
                zip.forEach((path, entry) => {
                    if (entry.dir) {
                        // Extract folder name from paths like "gs-active/gameshelf/" or "gameshelf/"
                        const parts = path.split('/').filter(p => p && p !== 'gs-active');
                        if (parts.length >= 1) {
                            folders.add(parts[0]);
                        }
                    }
                });
                
                // Process each known folder
                for (const folder of folders) {
                    const appId = GS_ACTIVE_FOLDER_MAP[folder];
                    if (!appId) continue;
                    
                    const appConfig = apps[appId];
                    if (!appConfig) continue;
                    
                    // Try to find index.html in this folder
                    const possiblePaths = [
                        `gs-active/${folder}/index.html`,
                        `${folder}/index.html`,
                        `gs-active/${folder}/${appConfig.targetPath || 'index.html'}`,
                        `${folder}/${appConfig.targetPath || 'index.html'}`
                    ];
                    
                    let indexContent = null;
                    let foundPath = null;
                    
                    for (const path of possiblePaths) {
                        const entry = zip.file(path);
                        if (entry) {
                            indexContent = await entry.async('string');
                            foundPath = path;
                            break;
                        }
                    }
                    
                    if (!indexContent) continue;
                    
                    // Extract version
                    const archiveVersion = extractVersionFromHTML(indexContent);
                    
                    // Collect all files for this app
                    const appFiles = [];
                    const basePath = foundPath.substring(0, foundPath.lastIndexOf('/') + 1);
                    
                    zip.forEach((path, entry) => {
                        if (!entry.dir && path.startsWith(basePath)) {
                            const relativePath = path.substring(basePath.length);
                            appFiles.push({ path, relativePath, entry });
                        }
                    });
                    
                    foundApps.push({
                        id: appId,
                        folder,
                        name: appConfig.name,
                        icon: appConfig.icon,
                        archiveVersion,
                        deployedVersion: null, // Will fetch later
                        deployedVersionLoading: false,
                        needsUpdate: null,
                        files: appFiles,
                        indexContent,
                        testRepo: appConfig.testRepo,
                        prodRepo: appConfig.prodRepo,
                        subPath: appConfig.subPath,
                        targetPath: appConfig.targetPath || 'index.html',
                        hasServiceWorker: appConfig.hasServiceWorker,
                        swPath: appConfig.swPath
                    });
                }
                
                // Sort: apps needing update first, then alphabetically
                foundApps.sort((a, b) => a.name.localeCompare(b.name));
                
                setArchiveApps(foundApps);
                
                // Auto-check deployed versions if GitHub is available
                if (github && foundApps.length > 0) {
                    checkDeployedVersions(foundApps);
                }
                
            } catch (err) {
                console.error('Failed to parse archive:', err);
                showAlert('Failed to parse archive: ' + err.message);
            } finally {
                setLoading(false);
            }
        };
        
        // Check deployed versions for all apps
        const checkDeployedVersions = async (appsToCheck) => {
            setCheckingVersions(true);
            
            const updated = [...appsToCheck];
            
            for (let i = 0; i < updated.length; i++) {
                const app = updated[i];
                const target = getDefaultTarget(app.id);
                const repo = target === 'prod' ? app.prodRepo : app.testRepo;
                
                // Store target on app for later use
                updated[i] = { ...app, deployTarget: target };
                
                if (!repo) {
                    updated[i] = { ...updated[i], deployedVersion: 'No repo', needsUpdate: false };
                    continue;
                }
                
                try {
                    // Try to fetch the deployed version from GitHub
                    const targetPath = app.subPath ? `${app.subPath}/${app.targetPath}` : app.targetPath;
                    const fileData = await github.getFileContent(repo, targetPath);
                    
                    if (fileData?.textContent) {
                        const deployedVersion = extractVersionFromHTML(fileData.textContent);
                        const needsUpdate = app.archiveVersion !== deployedVersion;
                        updated[i] = { ...app, deployedVersion, needsUpdate };
                    } else {
                        updated[i] = { ...app, deployedVersion: 'Not found', needsUpdate: true };
                    }
                } catch (err) {
                    console.warn(`Failed to check ${app.name}:`, err.message);
                    updated[i] = { ...app, deployedVersion: 'Error', needsUpdate: null };
                }
                
                // Update state incrementally
                setArchiveApps([...updated]);
            }
            
            // Auto-select apps that need updates
            const needingUpdate = updated.filter(a => a.needsUpdate === true).map(a => a.id);
            setSelectedApps(new Set(needingUpdate));
            
            setCheckingVersions(false);
        };
        
        // Toggle app selection
        const toggleApp = (appId) => {
            setSelectedApps(prev => {
                const next = new Set(prev);
                if (next.has(appId)) next.delete(appId);
                else next.add(appId);
                return next;
            });
        };
        
        // Select all / none
        const selectAll = () => setSelectedApps(new Set(archiveApps.map(a => a.id)));
        const selectNone = () => setSelectedApps(new Set());
        const selectOutdated = () => setSelectedApps(new Set(archiveApps.filter(a => a.needsUpdate === true).map(a => a.id)));
        
        // Deploy selected apps
        const deploySelected = async () => {
            const toDeploy = archiveApps.filter(a => selectedApps.has(a.id));
            if (toDeploy.length === 0) return;
            
            // Group by target for confirmation message
            const testApps = toDeploy.filter(a => a.deployTarget === 'test');
            const prodApps = toDeploy.filter(a => a.deployTarget === 'prod');
            
            let confirmMsg = `Deploy ${toDeploy.length} app(s)?\n\n`;
            if (testApps.length > 0) {
                confirmMsg += `TEST:\n${testApps.map(a => `  • ${a.name} v${a.archiveVersion}`).join('\n')}\n\n`;
            }
            if (prodApps.length > 0) {
                confirmMsg += `PROD:\n${prodApps.map(a => `  • ${a.name} v${a.archiveVersion}`).join('\n')}`;
            }
            
            const confirmed = await showConfirm(confirmMsg, '📦 Smart Deploy');
            
            if (!confirmed) return;
            
            // Deploy each app to its appropriate target
            for (const app of toDeploy) {
                const target = app.deployTarget || getDefaultTarget(app.id);
                
                try {
                    // Build staged files from archive
                    const stagedFiles = [];
                    
                    for (const file of app.files) {
                        const content = await file.entry.async('string');
                        stagedFiles.push({
                            id: `${app.id}-${file.relativePath}`,
                            name: file.relativePath,
                            content,
                            size: content.length,
                            appId: app.id,
                            version: app.archiveVersion
                        });
                    }
                    
                    // Use batch deploy for multiple files
                    if (stagedFiles.length > 1) {
                        await onBatchDeploy(stagedFiles, app.id, target);
                    } else if (stagedFiles.length === 1) {
                        await onDeploy(stagedFiles[0], app.id, target);
                    }
                    
                } catch (err) {
                    console.error(`Failed to deploy ${app.name}:`, err);
                }
            }
        };
        
        return (
            <div className="space-y-6">
                {/* Header */}
                <div className="bg-slate-800 rounded-xl border border-slate-700 p-6">
                    <h2 className="text-lg font-semibold mb-2 flex items-center gap-2">
                        📦 Smart Deploy from gs-active
                    </h2>
                    <p className="text-sm text-slate-400 mb-4">
                        Upload a gs-active archive to compare versions and deploy updates in one click.
                    </p>
                    
                    <div className="flex items-center gap-4">
                        <input
                            ref={fileInputRef}
                            type="file"
                            accept=".zip"
                            onChange={handleFileSelect}
                            className="hidden"
                        />
                        <button
                            onClick={() => fileInputRef.current?.click()}
                            disabled={loading}
                            className="px-4 py-2 bg-indigo-600 hover:bg-indigo-500 disabled:opacity-50 rounded-lg font-medium flex items-center gap-2"
                        >
                            {loading ? (
                                <><div className="w-4 h-4 border-2 border-white border-t-transparent rounded-full animate-spin" /> Parsing...</>
                            ) : (
                                <><Icons.Upload /> Choose gs-active.zip</>
                            )}
                        </button>
                        
                        {archiveName && (
                            <span className="text-sm text-slate-400">
                                📁 {archiveName}
                            </span>
                        )}
                        
                        <div className="ml-auto text-xs text-slate-500">
                            <span className="text-blue-400">Public apps → TEST</span>
                            <span className="mx-2">•</span>
                            <span className="text-green-400">Internal apps → PROD</span>
                        </div>
                    </div>
                </div>
                
                {/* Active Deployments */}
                {activeDeployments && activeDeployments.length > 0 && (
                    <div className="space-y-3">
                        {activeDeployments.map(deployment => (
                            <div key={deployment.id} className={`bg-slate-800 rounded-xl border p-4 fade-in ${
                                deployment.status === 'running' ? 'border-indigo-500' :
                                deployment.status === 'success' ? 'border-green-500' : 'border-red-500'
                            }`}>
                                <div className="flex items-center gap-2 text-sm">
                                    {deployment.status === 'running' ? (
                                        <div className="w-4 h-4 border-2 border-indigo-500 border-t-transparent rounded-full animate-spin" />
                                    ) : deployment.status === 'success' ? (
                                        <span className="text-green-400">✓</span>
                                    ) : (
                                        <span className="text-red-400">✗</span>
                                    )}
                                    <span className="font-medium">{deployment.appName}</span>
                                    <span className="text-slate-400">→</span>
                                    <span className={deployment.status === 'success' ? 'text-green-400' : deployment.status === 'error' ? 'text-red-400' : 'text-indigo-300'}>
                                        {deployment.status === 'running' ? 'Deploying...' : deployment.status === 'success' ? 'Complete!' : 'Failed'}
                                    </span>
                                    <span className="flex-1" />
                                    {deployment.status !== 'running' && (
                                        <button onClick={() => removeActiveDeployment(deployment.id)} className="text-slate-400 hover:text-white text-xs">✕</button>
                                    )}
                                </div>
                                {deployment.steps && deployment.steps.length > 0 && (
                                    <div className="mt-2 space-y-1 text-xs text-slate-400">
                                        {deployment.steps.slice(-2).map((s, i) => (
                                            <div key={i} className="flex items-center gap-1">
                                                <span className={s.status === 'complete' ? 'text-green-400' : s.status === 'error' ? 'text-red-400' : 'text-indigo-400'}>
                                                    {s.status === 'complete' ? '✓' : s.status === 'error' ? '✗' : '•'}
                                                </span>
                                                {s.name} {s.details && <span className="text-slate-500">({s.details})</span>}
                                            </div>
                                        ))}
                                    </div>
                                )}
                            </div>
                        ))}
                    </div>
                )}
                
                {/* Apps Table */}
                {archiveApps.length > 0 && (
                    <div className="bg-slate-800 rounded-xl border border-slate-700 overflow-hidden">
                        {/* Table Header */}
                        <div className="p-4 border-b border-slate-700 flex items-center gap-4">
                            <span className="font-semibold">Apps in Archive ({archiveApps.length})</span>
                            <span className="flex-1" />
                            <button onClick={selectAll} className="text-xs text-indigo-400 hover:underline">Select All</button>
                            <button onClick={selectOutdated} className="text-xs text-amber-400 hover:underline">Select Outdated</button>
                            <button onClick={selectNone} className="text-xs text-slate-400 hover:underline">Select None</button>
                            {checkingVersions && (
                                <span className="text-xs text-slate-400 flex items-center gap-1">
                                    <div className="w-3 h-3 border border-indigo-400 border-t-transparent rounded-full animate-spin" />
                                    Checking versions...
                                </span>
                            )}
                        </div>
                        
                        {/* Table */}
                        <table className="w-full text-sm">
                            <thead>
                                <tr className="border-b border-slate-700 text-slate-400">
                                    <th className="px-4 py-2 text-left w-8"></th>
                                    <th className="px-4 py-2 text-left">App</th>
                                    <th className="px-4 py-2 text-center">Target</th>
                                    <th className="px-4 py-2 text-center">Archive</th>
                                    <th className="px-4 py-2 text-center">Deployed</th>
                                    <th className="px-4 py-2 text-center">Status</th>
                                    <th className="px-4 py-2 text-center">Files</th>
                                </tr>
                            </thead>
                            <tbody>
                                {archiveApps.map(app => {
                                    const isSelected = selectedApps.has(app.id);
                                    const target = app.deployTarget || getDefaultTarget(app.id);
                                    const repo = target === 'prod' ? app.prodRepo : app.testRepo;
                                    
                                    return (
                                        <tr key={app.id} className={`border-b border-slate-700/50 hover:bg-slate-700/30 ${isSelected ? 'bg-indigo-900/20' : ''}`}>
                                            <td className="px-4 py-3">
                                                <input
                                                    type="checkbox"
                                                    checked={isSelected}
                                                    onChange={() => toggleApp(app.id)}
                                                    disabled={!repo}
                                                    className="rounded"
                                                />
                                            </td>
                                            <td className="px-4 py-3">
                                                <div className="flex items-center gap-2">
                                                    <AppIcon icon={app.icon} size={20} />
                                                    <span className="font-medium">{app.name}</span>
                                                    {!repo && <span className="text-xs text-red-400">(no {target} repo)</span>}
                                                </div>
                                            </td>
                                            <td className="px-4 py-3 text-center">
                                                <span className={`px-2 py-0.5 rounded text-xs ${target === 'prod' ? 'bg-green-900/50 text-green-300' : 'bg-blue-900/50 text-blue-300'}`}>
                                                    {target.toUpperCase()}
                                                </span>
                                            </td>
                                            <td className="px-4 py-3 text-center font-mono text-indigo-300">
                                                {app.archiveVersion || '?'}
                                            </td>
                                            <td className="px-4 py-3 text-center font-mono">
                                                {app.deployedVersionLoading ? (
                                                    <div className="w-4 h-4 border border-slate-400 border-t-transparent rounded-full animate-spin mx-auto" />
                                                ) : (
                                                    <span className={app.deployedVersion === app.archiveVersion ? 'text-green-400' : 'text-slate-400'}>
                                                        {app.deployedVersion || '—'}
                                                    </span>
                                                )}
                                            </td>
                                            <td className="px-4 py-3 text-center">
                                                {app.needsUpdate === true && (
                                                    <span className="px-2 py-0.5 rounded bg-amber-900/50 text-amber-300 text-xs">🔄 Needs Update</span>
                                                )}
                                                {app.needsUpdate === false && (
                                                    <span className="px-2 py-0.5 rounded bg-green-900/50 text-green-300 text-xs">✓ Current</span>
                                                )}
                                                {app.needsUpdate === null && app.deployedVersion && (
                                                    <span className="px-2 py-0.5 rounded bg-slate-700 text-slate-400 text-xs">? Unknown</span>
                                                )}
                                            </td>
                                            <td className="px-4 py-3 text-center text-slate-400">
                                                {app.files.length}
                                            </td>
                                        </tr>
                                    );
                                })}
                            </tbody>
                        </table>
                        
                        {/* Deploy Button */}
                        <div className="p-4 border-t border-slate-700 flex items-center gap-4">
                            <button
                                onClick={deploySelected}
                                disabled={selectedApps.size === 0}
                                className="px-6 py-2 bg-green-600 hover:bg-green-500 disabled:opacity-40 disabled:hover:bg-green-600 rounded-lg font-medium flex items-center gap-2"
                            >
                                🚀 Deploy Selected ({selectedApps.size})
                            </button>
                            
                            {selectedApps.size > 0 && (
                                <span className="text-sm text-slate-400">
                                    {archiveApps.filter(a => selectedApps.has(a.id)).map(a => a.name).join(', ')}
                                </span>
                            )}
                            
                            <button
                                onClick={() => checkDeployedVersions(archiveApps)}
                                disabled={checkingVersions}
                                className="ml-auto px-4 py-2 bg-slate-700 hover:bg-slate-600 disabled:opacity-50 rounded-lg text-sm flex items-center gap-2"
                            >
                                <Icons.Refresh className={checkingVersions ? 'animate-spin' : ''} /> Refresh Versions
                            </button>
                        </div>
                    </div>
                )}
                
                {/* Empty State */}
                {!loading && archiveApps.length === 0 && (
                    <div className="bg-slate-800 rounded-xl border border-slate-700 p-12 text-center">
                        <div className="text-4xl mb-4">📦</div>
                        <div className="text-lg font-medium mb-2">No archive loaded</div>
                        <div className="text-sm text-slate-400">
                            Upload a gs-active-*.zip file to compare and deploy apps
                        </div>
                    </div>
                )}
            </div>
        );
    }

    // =========================================================================
    // SESSION LOG VIEW
    // =========================================================================
    
    function SessionLogView({ apps, sessionLog, setSessionLog, deployments, github, onFileDrop, showAlert, globalSessions, globalWorkItems, firebaseUid, config, globalStreams, globalInterfaces, globalDependencies, globalDependencyAlerts }) {
        const [newEntry, setNewEntry] = React.useState('');
        const [firebaseUser, setFirebaseUser] = React.useState(null);
        const [syncStatus, setSyncStatus] = React.useState('local');
        const [quickDeployCode, setQuickDeployCode] = React.useState('');
        const [detectedFile, setDetectedFile] = React.useState(null);
        const [projectFile, setProjectFile] = React.useState(null);
        const [uploading, setUploading] = React.useState(false);
        const [downloading, setDownloading] = React.useState(false);
        const [pendingDeploys, setPendingDeploys] = React.useState([]);
        const [activeSubTab, setActiveSubTab] = React.useState('log');
        const [reviewingSession, setReviewingSession] = React.useState(null); // Phase 3: active review session
        const [apiKey, setApiKey] = React.useState(() => {
            try { return localStorage.getItem('cc_api_key') || ''; } catch { return ''; }
        });
        
        const configuredApps = Object.values(apps).filter(a => a.testRepo || a.prodRepo);
        
        // Listen for Firebase auth
        React.useEffect(() => {
            if (!firebaseAuth) return;
            const unsubscribe = firebaseAuth.onAuthStateChanged((u) => {
                setFirebaseUser(u);
                if (u) {
                    loadProjectFileInfo(u.uid);
                    listenForPendingDeploys(u.uid);
                }
            });
            return () => unsubscribe();
        }, []);
        
        // Listen for pending deploys from Claude
        const listenForPendingDeploys = (uid) => {
            if (!firebaseDb) return;
            
            const ref = firebaseDb.ref(`command-center/${uid}/pending-deploys`);
            ref.orderByChild('status').equalTo('pending').on('value', (snapshot) => {
                const data = snapshot.val();
                if (data) {
                    const deploys = Object.entries(data).map(([id, d]) => ({ id, ...d }));
                    setPendingDeploys(deploys.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt)));
                } else {
                    setPendingDeploys([]);
                }
            });
            
            return () => ref.off();
        };
        
        // Accept pending deploy
        const acceptPendingDeploy = async (deploy) => {
            if (!github) {
                showAlert('Configure GitHub token first', 'Configuration Required');
                return;
            }
            
            // Create file object for existing deploy handler
            const file = {
                id: Date.now(),
                name: 'index.html',
                content: deploy.code,
                version: deploy.version,
                targetPath: 'index.html'
            };
            
            onFileDrop([file]);
            
            // Update status in Firebase
            await firebaseDb.ref(`command-center/${firebaseUser.uid}/pending-deploys/${deploy.id}/status`).set('deployed');
            await logEntry(`Deployed from queue: ${deploy.appName || deploy.appId} v${deploy.version}`, 'deploy');
        };
        
        // Reject pending deploy
        const rejectPendingDeploy = async (deployId) => {
            await firebaseDb.ref(`command-center/${firebaseUser.uid}/pending-deploys/${deployId}/status`).set('rejected');
        };
        
        // Generate API key for Claude
        const generateApiKey = () => {
            const key = 'cc_' + Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
            setApiKey(key);
            localStorage.setItem('cc_api_key', key);
            
            // Store in Firebase for validation
            if (firebaseDb && firebaseUser) {
                firebaseDb.ref(`command-center/${firebaseUser.uid}/apiKey`).set(key);
            }
        };
        
        // Load project file info from Firebase
        const loadProjectFileInfo = async (uid) => {
            if (!firebaseDb || !uid) return;
            try {
                const snapshot = await firebaseDb.ref(`command-center/${uid}/projectFile`).once('value');
                const data = snapshot.val();
                if (data) {
                    setProjectFile(data);
                }
                setSyncStatus('synced');
            } catch (e) {
                console.error('Error loading project file info:', e);
                setSyncStatus('error');
            }
        };
        
        // Upload gs-active.zip to Firebase
        const uploadProjectFile = async (file) => {
            if (!firebaseDb || !firebaseUser) {
                showAlert('Please sign in via the Firebase tab first', 'Sign-in Required');
                return;
            }
            
            setUploading(true);
            try {
                const reader = new FileReader();
                reader.onload = async (e) => {
                    const base64 = e.target.result.split(',')[1];
                    
                    const fileInfo = {
                        name: file.name,
                        size: file.size,
                        lastModified: new Date().toISOString(),
                        data: base64
                    };
                    
                    await firebaseDb.ref(`command-center/${firebaseUser.uid}/projectFile`).set(fileInfo);
                    
                    setProjectFile({
                        name: file.name,
                        size: file.size,
                        lastModified: fileInfo.lastModified
                    });
                    
                    await logEntry(`Uploaded ${file.name} (${(file.size/1024).toFixed(1)}KB)`, 'upload');
                    setUploading(false);
                };
                reader.readAsDataURL(file);
            } catch (e) {
                console.error('Upload error:', e);
                showAlert('Upload failed: ' + e.message, 'Upload Error');
                setUploading(false);
            }
        };
        
        // Download gs-active.zip from Firebase
        const downloadProjectFile = async () => {
            if (!firebaseDb || !firebaseUser) {
                showAlert('Please sign in via the Firebase tab first', 'Sign-in Required');
                return;
            }
            
            setDownloading(true);
            try {
                const snapshot = await firebaseDb.ref(`command-center/${firebaseUser.uid}/projectFile`).once('value');
                const data = snapshot.val();
                
                if (!data || !data.data) {
                    showAlert('No project file found. Upload one first!', 'File Not Found');
                    setDownloading(false);
                    return;
                }
                
                const byteCharacters = atob(data.data);
                const byteNumbers = new Array(byteCharacters.length);
                for (let i = 0; i < byteCharacters.length; i++) {
                    byteNumbers[i] = byteCharacters.charCodeAt(i);
                }
                const byteArray = new Uint8Array(byteNumbers);
                const blob = new Blob([byteArray], { type: 'application/zip' });
                
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = data.name || 'gs-active.zip';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                await logEntry(`Downloaded ${data.name}`, 'download');
                setDownloading(false);
            } catch (e) {
                console.error('Download error:', e);
                showAlert('Download failed: ' + e.message, 'Download Error');
                setDownloading(false);
            }
        };
        
        // Handle file drop for project upload
        const handleProjectFileDrop = (e) => {
            e.preventDefault();
            
            // Capture file BEFORE resetting input
            const file = e.dataTransfer?.files[0] || e.target.files?.[0];
            
            // Reset file input so same file can be selected again
            if (e.target && e.target.value) {
                e.target.value = '';
            }
            
            if (file && (file.name.endsWith('.zip') || file.name === 'gs-active.zip')) {
                uploadProjectFile(file);
            } else if (file) {
                showAlert('Please upload a .zip file (gs-active.zip)', 'Invalid File');
            }
        };
        
        // Log entry to Firebase
        const logEntry = async (text, type = 'note') => {
            if (!firebaseDb || !firebaseUser) return;
            
            const entry = {
                time: new Date().toISOString(),
                type,
                text
            };
            
            const today = new Date().toISOString().split('T')[0];
            await firebaseDb.ref(`command-center/${firebaseUser.uid}/logs/${today}`).push(entry);
        };
        
        // Add manual entry
        const addEntry = async () => {
            if (!newEntry.trim()) return;
            await logEntry(newEntry.trim());
            setNewEntry('');
            
            setSessionLog(prev => ({
                ...prev,
                recentEntries: [...(prev.recentEntries || []), {
                    time: new Date().toISOString(),
                    type: 'note',
                    text: newEntry.trim()
                }].slice(-20)
            }));
        };
        
        // Quick Deploy: Detect file from pasted code
        const handleCodePaste = (code) => {
            setQuickDeployCode(code);
            
            if (!code.trim()) {
                setDetectedFile(null);
                return;
            }
            
            const versionMatch = code.match(/<meta\s+name=["']version["']\s+content=["']([^"']+)["']/i);
            const titleMatch = code.match(/<title>([^<]+)<\/title>/i);
            
            const version = versionMatch?.[1] || 'unknown';
            const title = titleMatch?.[1]?.toLowerCase() || '';
            
            let matchedApp = null;
            for (const app of configuredApps) {
                const name = app.name.toLowerCase();
                if (title.includes(name) || code.toLowerCase().includes(`${name} v`)) {
                    matchedApp = app;
                    break;
                }
            }
            
            setDetectedFile({
                content: code,
                version,
                detectedApp: matchedApp,
                title: titleMatch?.[1] || 'Unknown',
                size: code.length
            });
        };
        
        // Quick Deploy
        const handleQuickDeploy = async (appId, target) => {
            if (!detectedFile || !github) return;
            
            const file = {
                id: Date.now(),
                name: 'index.html',
                content: detectedFile.content,
                version: detectedFile.version,
                targetPath: 'index.html'
            };
            
            onFileDrop([file]);
            await logEntry(`Quick deploy: ${apps[appId]?.name} v${detectedFile.version} → ${target.toUpperCase()}`, 'deploy');
            
            setQuickDeployCode('');
            setDetectedFile(null);
        };
        
        // Generate context for Claude
        const generateContext = () => {
            const lines = [
                `# Session Context - ${new Date().toLocaleString()}`,
                ``,
                `## App Versions`,
                `| App | TEST | PROD |`,
                `|-----|------|------|`,
            ];
            configuredApps.forEach(app => {
                lines.push(`| ${app.name} | ${app.currentTestVersion || '—'} | ${app.currentProdVersion || '—'} |`);
            });
            return lines.join('\n');
        };
        
        const copyContext = async () => {
            await navigator.clipboard.writeText(generateContext());
        };
        
        // Copy Claude deploy instructions
        const copyClaudeInstructions = () => {
            const instructions = `## Deploy to Command Center

To deploy code directly to Command Center, use this Firebase write:

\`\`\`javascript
// Firebase config (already in your context)
const FIREBASE_CONFIG = {
    apiKey: "AIzaSyBUgW3EkJ3P8Zj6Gq2x7X0nR1YQ2LdW8_A",
    authDomain: "word-boxing.firebaseapp.com",
    databaseURL: "https://word-boxing-default-rtdb.firebaseio.com",
    projectId: "word-boxing"
};

// Write pending deploy
await firebase.database().ref('command-center/${firebaseUser?.uid || 'USER_UID'}/pending-deploys').push({
    code: YOUR_HTML_CODE,
    appId: 'gameshelf', // or 'quotle', 'slate', 'rungs', 'wordboxing'
    appName: 'Game Shelf',
    version: '1.0.1',
    target: 'test',
    status: 'pending',
    createdAt: new Date().toISOString()
});
\`\`\`

The deploy will appear in Command Center's Session tab for one-click deployment.`;
            
            navigator.clipboard.writeText(instructions);
        };
        
        return (
            <div className="space-y-6">
                {/* Sub-tab Navigation (v8.27.0) */}
                <div className="flex gap-1 bg-slate-800/50 rounded-lg p-1">
                    {[
                        { id: 'log', label: '📝 Session Log', count: null },
                        { id: 'history', label: '🔄 Session History', count: (globalSessions || []).length || null }
                    ].map(tab => (
                        <button
                            key={tab.id}
                            onClick={() => setActiveSubTab(tab.id)}
                            className={`flex-1 px-4 py-2 rounded-md text-sm font-medium transition-colors ${
                                activeSubTab === tab.id
                                    ? 'bg-indigo-600/40 text-indigo-200 border border-indigo-500/30'
                                    : 'text-slate-400 hover:text-slate-200 hover:bg-slate-700/50'
                            }`}>
                            {tab.label}
                            {tab.count ? <span className="ml-1.5 text-xs opacity-70">({tab.count})</span> : null}
                        </button>
                    ))}
                </div>
                
                {activeSubTab === 'log' && (<React.Fragment>
                {/* Pending Deploys from Claude */}
                {pendingDeploys.length > 0 && (
                    <div className="bg-green-900/30 border border-green-600 rounded-xl p-6 animate-pulse-slow">
                        <h2 className="text-lg font-semibold mb-4 flex items-center gap-2 text-green-300">
                            🚀 Incoming from Claude ({pendingDeploys.length})
                        </h2>
                        <div className="space-y-3">
                            {pendingDeploys.map(deploy => (
                                <div key={deploy.id} className="p-4 bg-slate-800 rounded-lg flex items-center justify-between">
                                    <div>
                                        <div className="font-medium">{deploy.appName || deploy.appId}</div>
                                        <div className="text-sm text-slate-400">
                                            v{deploy.version} → {deploy.target?.toUpperCase()} • 
                                            {(deploy.code?.length / 1024).toFixed(1)}KB •
                                            {new Date(deploy.createdAt).toLocaleTimeString()}
                                        </div>
                                    </div>
                                    <div className="flex gap-2">
                                        <button
                                            onClick={() => rejectPendingDeploy(deploy.id)}
                                            className="px-3 py-1.5 bg-red-600 hover:bg-red-500 rounded text-sm">
                                            ✕ Reject
                                        </button>
                                        <button
                                            onClick={() => acceptPendingDeploy(deploy)}
                                            className="px-3 py-1.5 bg-green-600 hover:bg-green-500 rounded text-sm">
                                            ✓ Deploy
                                        </button>
                                    </div>
                                </div>
                            ))}
                        </div>
                    </div>
                )}
                
                {/* Project File (gs-active.zip) */}
                <div className="bg-indigo-900/30 border border-indigo-700 rounded-xl p-6">
                    <h2 className="text-lg font-semibold mb-4 flex items-center gap-2 text-indigo-300">
                        📦 Project File (gs-active.zip)
                    </h2>
                    
                    {!firebaseUser ? (
                        <div className="text-amber-400 text-sm p-3 bg-amber-900/30 rounded-lg">
                            ⚠️ Sign in via the Firebase tab to sync your project file
                        </div>
                    ) : (
                        <div className="space-y-4">
                            {projectFile ? (
                                <div className="p-4 bg-slate-800 rounded-lg flex items-center justify-between">
                                    <div>
                                        <div className="font-medium">{projectFile.name}</div>
                                        <div className="text-sm text-slate-400">
                                            {(projectFile.size / 1024).toFixed(1)} KB • 
                                            Updated: {new Date(projectFile.lastModified).toLocaleString()}
                                        </div>
                                    </div>
                                    <button
                                        onClick={downloadProjectFile}
                                        disabled={downloading}
                                        className="px-4 py-2 bg-green-600 hover:bg-green-500 rounded-lg flex items-center gap-2 disabled:opacity-50">
                                        {downloading ? '⏳' : '⬇️'} Download
                                    </button>
                                </div>
                            ) : (
                                <div className="p-4 bg-slate-800 rounded-lg text-slate-400 text-center">
                                    No project file uploaded yet
                                </div>
                            )}
                            
                            <div
                                onDrop={handleProjectFileDrop}
                                onDragOver={e => e.preventDefault()}
                                className="border-2 border-dashed border-slate-600 rounded-lg p-4 text-center hover:border-indigo-500 transition-colors">
                                <input
                                    type="file"
                                    accept=".zip"
                                    onChange={handleProjectFileDrop}
                                    className="hidden"
                                    id="project-file-input"
                                />
                                <label htmlFor="project-file-input" className="cursor-pointer">
                                    {uploading ? (
                                        <span className="text-indigo-400">⏳ Uploading...</span>
                                    ) : (
                                        <span className="text-slate-400">
                                            📤 Drop gs-active.zip or <span className="text-indigo-400 underline">browse</span>
                                        </span>
                                    )}
                                </label>
                            </div>
                        </div>
                    )}
                </div>
                
                {/* Claude API Integration */}
                {firebaseUser && (
                    <div className="bg-purple-900/30 border border-purple-700 rounded-xl p-6">
                        <h2 className="text-lg font-semibold mb-4 flex items-center gap-2 text-purple-300">
                            🤖 Claude Direct Deploy
                        </h2>
                        <p className="text-sm text-slate-400 mb-4">
                            If Claude has network access, it can push code directly here for one-click deployment.
                        </p>
                        
                        <div className="space-y-3">
                            <div className="p-3 bg-slate-800 rounded-lg">
                                <div className="text-xs text-slate-500 mb-1">Your Firebase UID (for Claude):</div>
                                <code className="text-sm text-purple-300 break-all">{firebaseUser.uid}</code>
                            </div>
                            
                            <button
                                onClick={copyClaudeInstructions}
                                className="w-full px-4 py-2 bg-purple-600 hover:bg-purple-500 rounded-lg text-sm">
                                📋 Copy Instructions for Claude
                            </button>
                        </div>
                    </div>
                )}
                
                {/* Quick Deploy */}
                <div className="bg-slate-800 rounded-xl border border-slate-700 p-6">
                    <h2 className="text-lg font-semibold mb-4 flex items-center gap-2">
                        ⚡ Quick Deploy (Paste Code)
                    </h2>
                    <textarea
                        value={quickDeployCode}
                        onChange={e => handleCodePaste(e.target.value)}
                        placeholder="Paste HTML code from Claude here..."
                        className="w-full h-24 p-3 bg-slate-900 border border-slate-600 rounded-lg text-sm font-mono mb-3"
                    />
                    
                    {detectedFile && (
                        <div className="p-4 bg-slate-700/50 rounded-lg space-y-3">
                            <div className="flex items-center justify-between">
                                <div>
                                    <div className="font-medium">{detectedFile.title}</div>
                                    <div className="text-sm text-slate-400">
                                        v{detectedFile.version} • {(detectedFile.size / 1024).toFixed(1)}KB
                                    </div>
                                </div>
                                {detectedFile.detectedApp && (
                                    <span className="px-2 py-1 bg-green-900/50 text-green-400 rounded text-sm">
                                        ✓ {detectedFile.detectedApp.name}
                                    </span>
                                )}
                            </div>
                            
                            <div className="flex flex-wrap gap-2">
                                {configuredApps.map(app => (
                                    <button
                                        key={app.id}
                                        onClick={() => handleQuickDeploy(app.id, 'test')}
                                        className={`px-3 py-1.5 rounded text-sm ${
                                            detectedFile.detectedApp?.id === app.id 
                                                ? 'bg-blue-600 hover:bg-blue-500' 
                                                : 'bg-slate-600 hover:bg-slate-500'
                                        }`}>
                                        <AppIcon icon={app.icon} size={16} /> {app.name} → TEST
                                    </button>
                                ))}
                            </div>
                        </div>
                    )}
                </div>
                
                {/* Activity Log */}
                <div className="bg-slate-800 rounded-xl border border-slate-700 p-6">
                    <div className="flex items-center justify-between mb-4">
                        <h2 className="text-lg font-semibold">📋 Activity Log</h2>
                        <button onClick={copyContext} className="px-3 py-1 bg-indigo-600 hover:bg-indigo-500 rounded text-sm">
                            📋 Copy Context
                        </button>
                    </div>
                    
                    <div className="flex gap-2 mb-4">
                        <input
                            value={newEntry}
                            onChange={e => setNewEntry(e.target.value)}
                            onKeyDown={e => e.key === 'Enter' && addEntry()}
                            placeholder="Log a note..."
                            className="flex-1 p-2 bg-slate-900 border border-slate-600 rounded text-sm"
                        />
                        <button onClick={addEntry} className="px-4 bg-indigo-600 hover:bg-indigo-500 rounded">
                            + Log
                        </button>
                    </div>
                    
                    {sessionLog.recentEntries?.length > 0 && (
                        <div className="space-y-1 max-h-32 overflow-y-auto">
                            {[...sessionLog.recentEntries].reverse().map((e, i) => (
                                <div key={i} className="text-sm flex items-center gap-2">
                                    <span className="text-xs text-slate-500 w-16">
                                        {new Date(e.time).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}
                                    </span>
                                    <span className={
                                        e.type === 'deploy' ? 'text-green-400' : 
                                        e.type === 'upload' ? 'text-blue-400' : ''
                                    }>
                                        {e.text}
                                    </span>
                                </div>
                            ))}
                        </div>
                    )}
                </div>
                
                {/* Current Versions */}
                <div className="bg-slate-800 rounded-xl border border-slate-700 p-6">
                    <h2 className="text-lg font-semibold mb-4">📊 Current Versions</h2>
                    <table className="w-full text-sm">
                        <thead>
                            <tr className="border-b border-slate-700">
                                <th className="text-left p-2">App</th>
                                <th className="text-center p-2">TEST</th>
                                <th className="text-center p-2">PROD</th>
                                <th className="text-center p-2">Sync</th>
                            </tr>
                        </thead>
                        <tbody>
                            {configuredApps.map(app => (
                                <tr key={app.id} className="border-b border-slate-700/50">
                                    <td className="p-2"><span className="inline-flex items-center gap-1"><AppIcon icon={app.icon} size={16} /> {app.name}</span></td>
                                    <td className="p-2 text-center font-mono text-blue-400">{app.currentTestVersion || '—'}</td>
                                    <td className="p-2 text-center font-mono text-green-400">{app.currentProdVersion || '—'}</td>
                                    <td className="p-2 text-center">
                                        {app.currentTestVersion === app.currentProdVersion 
                                            ? <span className="text-green-400">✓</span>
                                            : <span className="text-amber-400">⚠️</span>
                                        }
                                    </td>
                                </tr>
                            ))}
                        </tbody>
                    </table>
                </div>
                
                {/* Testing & Issues */}
                <div className="bg-slate-800 rounded-xl border border-slate-700 p-6">
                    <h2 className="text-lg font-semibold mb-4">🧪 Testing & Issues</h2>
                    
                    <div className="grid grid-cols-2 md:grid-cols-4 gap-3 mb-4">
                        <a href="https://stewartdavidp-ship-it.github.io/gameshelf-testplan/" 
                           target="_blank"
                           className="p-3 bg-indigo-900/30 border border-indigo-700 rounded-lg text-center hover:bg-indigo-900/50 transition-colors">
                            <div className="text-2xl mb-1">📋</div>
                            <div className="text-sm">Test Plan</div>
                        </a>
                        <a href="https://stewartdavidp-ship-it.github.io/gameshelf-testplan/issue-tracker.html" 
                           target="_blank"
                           className="p-3 bg-red-900/30 border border-red-700 rounded-lg text-center hover:bg-red-900/50 transition-colors">
                            <div className="text-2xl mb-1">🐛</div>
                            <div className="text-sm">Issue Tracker</div>
                        </a>
                        <a href="https://stewartdavidp-ship-it.github.io/gameshelftest/" 
                           target="_blank"
                           className="p-3 bg-blue-900/30 border border-blue-700 rounded-lg text-center hover:bg-blue-900/50 transition-colors">
                            <div className="text-2xl mb-1">🧪</div>
                            <div className="text-sm">TEST Site</div>
                        </a>
                        <a href="https://stewartdavidp-ship-it.github.io/gameshelf/" 
                           target="_blank"
                           className="p-3 bg-green-900/30 border border-green-700 rounded-lg text-center hover:bg-green-900/50 transition-colors">
                            <div className="text-2xl mb-1">🚀</div>
                            <div className="text-sm">PROD Site</div>
                        </a>
                    </div>
                    
                    <div className="text-xs text-slate-500 bg-slate-900/50 rounded-lg p-3">
                        <div className="font-medium text-slate-400 mb-2">Test → Fix Workflow:</div>
                        <ol className="list-decimal list-inside space-y-1">
                            <li>Run tests in Test Plan → Issues logged to tracker</li>
                            <li>Click issue → Copy details for Claude</li>
                            <li>Claude fixes → Quick Deploy to TEST</li>
                            <li>Re-test → Promote to PROD when passing</li>
                        </ol>
                    </div>
                </div>
                </React.Fragment>)}
                
                {/* === Session History Sub-Tab (v8.27.0 / Phase 2.3) === */}
                {activeSubTab === 'history' && (
                    <SessionHistoryPanel 
                        sessions={globalSessions || []}
                        workItems={globalWorkItems || []}
                        apps={apps}
                        deployments={deployments}
                        firebaseUid={firebaseUid}
                        config={config}
                        showAlert={showAlert}
                        onStartReview={(session) => setReviewingSession(session)}
                    />
                )}
                
                {/* Phase 3: Post-Session Review Modal */}
                {reviewingSession && (
                    <PostSessionReviewModal
                        session={reviewingSession}
                        workItems={globalWorkItems || []}
                        app={apps[reviewingSession.appId]}
                        onClose={() => setReviewingSession(null)}
                        onDeploy={() => { setReviewingSession(null); setActiveSubTab('log'); }}
                        showAlert={showAlert}
                        firebaseUid={firebaseUid}
                        config={config}
                        streams={globalStreams || []}
                        interfaces={globalInterfaces || []}
                        dependencies={globalDependencies || []}
                        dependencyAlerts={globalDependencyAlerts || []}
                    />
                )}
            </div>
        );
    }
    
    // === Session History Panel Component (v8.27.0 / Phase 2.3) ===
    // =========================================================================
    // POST-SESSION REVIEW FLOW — Phase 3.1
    // Inline guided flow: Review deliverables → Check criteria → Deploy decision → Close items
    // =========================================================================
    
    function PostSessionReviewModal({ session, workItems, app, onClose, onDeploy, showAlert, firebaseUid, config, streams, interfaces, dependencies, dependencyAlerts }) {
        const [step, setStep] = React.useState(1); // 1: Overview, 2: Criteria Review, 3: Deploy Decision, 4: Close Items
        const [deliverableNotes, setDeliverableNotes] = React.useState(session?.deliverables?.summary || '');
        const [criteriaResults, setCriteriaResults] = React.useState([]);
        const [reviewNotes, setReviewNotes] = React.useState('');
        const [closingItems, setClosingItems] = React.useState(new Set());
        const [saving, setSaving] = React.useState(false);
        
        // Phase 5.4: Interface change detection state
        const [interfaceChanges, setInterfaceChanges] = React.useState([]); // [{interfaceId, changed: bool, description: '', notes: ''}]
        const [alertsTriggered, setAlertsTriggered] = React.useState(false);
        const [triggerResults, setTriggerResults] = React.useState([]); // Results from triggerAlerts
        const [triggeringAlerts, setTriggeringAlerts] = React.useState(false);
        
        // Gather acceptance criteria from linked work items
        const sessionWorkItemIds = React.useMemo(() => {
            if (!session?.workItemId) return [];
            return typeof session.workItemId === 'string' ? session.workItemId.split(',').map(s => s.trim()) : [session.workItemId];
        }, [session]);
        
        const sessionWorkItems = React.useMemo(() => {
            return (workItems || []).filter(wi => sessionWorkItemIds.includes(wi.id));
        }, [workItems, sessionWorkItemIds]);
        
        // Initialize criteria results from work items
        React.useEffect(() => {
            const allCriteria = [];
            sessionWorkItems.forEach(wi => {
                (wi.criteria || []).forEach((text, idx) => {
                    allCriteria.push({
                        id: `${wi.id}-c${idx}`,
                        itemId: wi.id,
                        itemTitle: wi.title,
                        text,
                        met: false
                    });
                });
            });
            setCriteriaResults(allCriteria);
            setClosingItems(new Set(sessionWorkItems.map(wi => wi.id)));
        }, [sessionWorkItems]);
        
        // Phase 5.4: Detect which interfaces this session's stream provides
        const sessionStreamId = React.useMemo(() => {
            const streamIds = [...new Set(sessionWorkItems.filter(wi => wi.streamId).map(wi => wi.streamId))];
            return streamIds.length === 1 ? streamIds[0] : null;
        }, [sessionWorkItems]);
        
        const providedInterfaces = React.useMemo(() => {
            if (!sessionStreamId || !interfaces) return [];
            return (interfaces || []).filter(i => i.streamId === sessionStreamId);
        }, [sessionStreamId, interfaces]);
        
        // Interfaces that actually have dependents (other streams consume them)
        const interfacesWithDependents = React.useMemo(() => {
            if (!providedInterfaces.length || !dependencies) return [];
            return providedInterfaces.filter(iface => 
                (dependencies || []).some(d => d.interfaceId === iface.id)
            );
        }, [providedInterfaces, dependencies]);
        
        // Initialize interface change tracking
        React.useEffect(() => {
            if (interfacesWithDependents.length > 0 && interfaceChanges.length === 0) {
                setInterfaceChanges(interfacesWithDependents.map(iface => ({
                    interfaceId: iface.id,
                    description: iface.description,
                    changed: false,
                    changeDescription: '',
                    changeNotes: ''
                })));
            }
        }, [interfacesWithDependents]);
        
        const hasInterfaceChanges = interfaceChanges.some(ic => ic.changed);
        
        const toggleInterfaceChange = (interfaceId) => {
            setInterfaceChanges(prev => prev.map(ic => 
                ic.interfaceId === interfaceId ? { ...ic, changed: !ic.changed } : ic
            ));
        };
        
        const updateInterfaceChange = (interfaceId, field, value) => {
            setInterfaceChanges(prev => prev.map(ic => 
                ic.interfaceId === interfaceId ? { ...ic, [field]: value } : ic
            ));
        };
        
        // Trigger dependency alerts for changed interfaces
        const handleTriggerAlerts = async () => {
            if (!firebaseUid || alertsTriggered) return;
            setTriggeringAlerts(true);
            const actor = config?.ownerName || 'Owner';
            const allResults = [];
            
            try {
                for (const ic of interfaceChanges.filter(c => c.changed && c.changeDescription.trim())) {
                    const results = await DependencyAlertService.triggerAlerts(firebaseUid, {
                        interfaceId: ic.interfaceId,
                        changeDescription: ic.changeDescription,
                        changeNotes: ic.changeNotes || deliverableNotes,
                        sessionId: session?.id,
                        workItemId: sessionWorkItemIds[0] || null,
                        actor,
                        interfaces: interfaces || [],
                        dependencies: dependencies || [],
                        streams: streams || [],
                        workItems: workItems || [],
                        alerts: dependencyAlerts || []
                    });
                    allResults.push(...results);
                }
                
                // Update the interface lastUpdated timestamps
                for (const ic of interfaceChanges.filter(c => c.changed)) {
                    await StreamInterfaceService.update(firebaseUid, ic.interfaceId, {
                        lastUpdatedBy: actor,
                        lastChangeDescription: ic.changeDescription
                    });
                }
                
                setTriggerResults(allResults);
                setAlertsTriggered(true);
                
                if (allResults.length > 0) {
                    showAlert(`🔔 ${allResults.length} dependency alert${allResults.length !== 1 ? 's' : ''} triggered — work items created in dependent streams.`, 'success');
                }
            } catch (e) {
                console.error('[DependencyAlert] Failed to trigger alerts:', e);
                showAlert(`Error triggering alerts: ${e.message}`, 'error');
            } finally {
                setTriggeringAlerts(false);
            }
        };
        
        const toggleCriteria = (criteriaId) => {
            setCriteriaResults(prev => prev.map(c => c.id === criteriaId ? { ...c, met: !c.met } : c));
        };
        
        const toggleCloseItem = (itemId) => {
            setClosingItems(prev => {
                const next = new Set(prev);
                if (next.has(itemId)) next.delete(itemId); else next.add(itemId);
                return next;
            });
        };
        
        const metCount = criteriaResults.filter(c => c.met).length;
        const totalCriteria = criteriaResults.length;
        const allMet = totalCriteria > 0 && metCount === totalCriteria;
        
        // Step 1: Save deliverable notes and move session to review
        const handleStep1Complete = async () => {
            if (firebaseUid && session) {
                await SessionService.startReview(firebaseUid, session.id, {
                    files: session.packageFiles || [],
                    summary: deliverableNotes
                });
                
                // === Phase 3.3: In-Progress → Review auto-transition ===
                // When review starts, transition linked work items to review status
                const actor = config?.ownerName || 'Owner';
                for (const wi of sessionWorkItems) {
                    if (wi.status === 'in-progress') {
                        try {
                            await WorkItemService.updateStatus(firebaseUid, wi.id, 'review');
                            ActivityLogService.logItemTransition(firebaseUid, actor, app?.name || session.appId, wi.id, wi.title, 'in-progress', 'review').catch(() => {});
                        } catch (e) {
                            console.warn(`[Review] Could not transition ${wi.id} to review:`, e);
                        }
                    }
                }
            }
            setStep(totalCriteria > 0 ? 2 : 3);
        };
        
        // Step 2: Save criteria review
        const handleStep2Complete = async () => {
            if (firebaseUid && session) {
                const actor = config?.ownerName || 'Owner';
                await SessionService.completeReview(firebaseUid, session.id, {
                    criteriaResults,
                    reviewedBy: actor,
                    notes: reviewNotes
                });
                ActivityLogService.logReview(firebaseUid, actor, app?.name || session.appId, session.id, metCount, totalCriteria).catch(() => {});
            }
            setStep(3);
        };
        
        // Step 3: Deploy decision — user clicks "Deploy Now" (triggers external deploy) or "Skip Deploy"
        const handleDeploy = () => {
            if (onDeploy) onDeploy(session);
            onClose();
        };
        
        // Step 4: Close work items
        const handleCloseItems = async () => {
            if (!firebaseUid) return;
            setSaving(true);
            const actor = config?.ownerName || 'Owner';
            try {
                for (const itemId of closingItems) {
                    const wi = sessionWorkItems.find(w => w.id === itemId);
                    const fromStatus = wi?.status || 'review';
                    await WorkItemService.updateStatus(firebaseUid, itemId, 'done');
                    ActivityLogService.logItemTransition(firebaseUid, actor, app?.name || session.appId, itemId, wi?.title || itemId, fromStatus, 'done').catch(() => {});
                }
                if (closingItems.size > 0) {
                    ActivityLogService.logSessionComplete(firebaseUid, actor, app?.name || session.appId, session.id, closingItems.size).catch(() => {});
                }
                showAlert(`✅ Completed ${closingItems.size} work item${closingItems.size !== 1 ? 's' : ''}`, 'success');
                onClose();
            } catch (e) {
                showAlert(`Error closing items: ${e.message}`, 'error');
            } finally {
                setSaving(false);
            }
        };
        
        const stepLabels = ['Overview', totalCriteria > 0 ? 'Verify' : null, 'Deploy', 'Close Items'].filter(Boolean);
        const adjustedStep = totalCriteria === 0 && step >= 2 ? step : step;
        
        const StepIndicator = () => (
            <div className="flex items-center gap-2 mb-6">
                {stepLabels.map((label, i) => {
                    const stepNum = i + 1;
                    const isActive = step === (totalCriteria === 0 && stepNum >= 2 ? stepNum + 1 : stepNum);
                    const isDone = (totalCriteria === 0 && stepNum >= 2 ? stepNum + 1 : stepNum) < step;
                    return (
                        <React.Fragment key={i}>
                            {i > 0 && <div className={`flex-1 h-0.5 ${isDone ? 'bg-green-500' : 'bg-slate-600'}`} />}
                            <div className={`flex items-center gap-1.5 px-2.5 py-1 rounded-full text-xs font-medium ${
                                isActive ? 'bg-indigo-600 text-white' : isDone ? 'bg-green-900/40 text-green-300' : 'bg-slate-700 text-slate-400'
                            }`}>
                                {isDone ? '✓' : stepNum}
                                <span>{label}</span>
                            </div>
                        </React.Fragment>
                    );
                })}
            </div>
        );
        
        return (
            <div className="fixed inset-0 bg-black/60 flex items-center justify-center z-50 p-4" onClick={onClose}>
                <div className="bg-slate-800 rounded-xl border border-slate-600 w-full max-w-2xl max-h-[85vh] overflow-y-auto shadow-2xl" onClick={e => e.stopPropagation()}>
                    {/* Header */}
                    <div className="sticky top-0 bg-slate-800 border-b border-slate-700 px-6 py-4 flex items-center justify-between rounded-t-xl z-10">
                        <div>
                            <div className="text-lg font-semibold text-white">Post-Session Review</div>
                            <div className="text-sm text-slate-400 mt-0.5">
                                {app?.icon || '📦'} {app?.name || session?.appId} — {session?.type || 'build'} session
                            </div>
                        </div>
                        <button onClick={onClose} className="text-slate-400 hover:text-white text-xl">✕</button>
                    </div>
                    
                    <div className="px-6 py-5">
                        <StepIndicator />
                        
                        {/* Step 1: Overview — What did this session produce? */}
                        {step === 1 && (
                            <div className="space-y-4">
                                <div>
                                    <div className="text-sm font-medium text-slate-300 mb-1">What was built in this session?</div>
                                    <div className="text-xs text-slate-500 mb-2">Summarize what Claude delivered. This becomes the session record.</div>
                                    <textarea
                                        value={deliverableNotes}
                                        onChange={e => setDeliverableNotes(e.target.value)}
                                        placeholder="e.g. Added share button, fixed mobile layout, updated scoring display..."
                                        className="w-full px-3 py-2 bg-slate-900 border border-slate-600 rounded-lg text-sm text-white placeholder-slate-500 focus:border-indigo-500 outline-none resize-none"
                                        rows={3}
                                    />
                                </div>
                                
                                {sessionWorkItems.length > 0 && (
                                    <div>
                                        <div className="text-sm font-medium text-slate-300 mb-2">Work items in this session</div>
                                        <div className="space-y-2">
                                            {sessionWorkItems.map(wi => (
                                                <div key={wi.id} className="flex items-center gap-2 px-3 py-2 bg-slate-900/60 border border-slate-700 rounded-lg text-sm">
                                                    <span className="text-indigo-400 font-mono text-xs">{wi.id}</span>
                                                    <span className="text-slate-200">{wi.title}</span>
                                                    <span className={`ml-auto text-xs px-1.5 py-0.5 rounded ${
                                                        wi.status === 'in-progress' ? 'bg-blue-900/40 text-blue-300' : 'bg-slate-700 text-slate-400'
                                                    }`}>{wi.status}</span>
                                                </div>
                                            ))}
                                        </div>
                                    </div>
                                )}
                                
                                {/* Phase 5.4: Interface change detection */}
                                {interfacesWithDependents.length > 0 && (
                                    <div className="border-t border-slate-700 pt-4">
                                        <div className="text-sm font-medium text-slate-300 mb-1">🔗 Did any provided interfaces change?</div>
                                        <div className="text-xs text-slate-500 mb-3">
                                            This stream provides interfaces other streams depend on. If any changed, dependent streams will be notified with a work item.
                                        </div>
                                        
                                        <div className="space-y-2">
                                            {interfaceChanges.map(ic => {
                                                const depCount = (dependencies || []).filter(d => d.interfaceId === ic.interfaceId).length;
                                                return (
                                                    <div key={ic.interfaceId} className={`rounded-lg border transition-colors ${
                                                        ic.changed ? 'bg-amber-900/20 border-amber-700/50' : 'bg-slate-900/60 border-slate-700'
                                                    }`}>
                                                        <div className="flex items-center gap-3 px-3 py-2.5 cursor-pointer" onClick={() => toggleInterfaceChange(ic.interfaceId)}>
                                                            <div className={`w-5 h-5 rounded flex items-center justify-center flex-shrink-0 ${
                                                                ic.changed ? 'bg-amber-600 text-white' : 'border-2 border-slate-500'
                                                            }`}>
                                                                {ic.changed && <span className="text-xs">✓</span>}
                                                            </div>
                                                            <div className="flex-1">
                                                                <div className={`text-sm ${ic.changed ? 'text-amber-200' : 'text-slate-200'}`}>{ic.description}</div>
                                                                <div className="text-xs text-slate-500">{depCount} dependent stream{depCount !== 1 ? 's' : ''}</div>
                                                            </div>
                                                        </div>
                                                        
                                                        {ic.changed && (
                                                            <div className="px-3 pb-3 space-y-2">
                                                                <input
                                                                    type="text"
                                                                    value={ic.changeDescription}
                                                                    onChange={e => updateInterfaceChange(ic.interfaceId, 'changeDescription', e.target.value)}
                                                                    placeholder="What changed? e.g. 'Score format now includes difficulty badge'"
                                                                    className="w-full px-2.5 py-1.5 bg-slate-800 border border-slate-600 rounded text-sm text-white placeholder-slate-500 focus:border-amber-500 outline-none"
                                                                    onClick={e => e.stopPropagation()}
                                                                />
                                                                <textarea
                                                                    value={ic.changeNotes}
                                                                    onChange={e => updateInterfaceChange(ic.interfaceId, 'changeNotes', e.target.value)}
                                                                    placeholder="Additional context for the dependent stream's Claude session (optional)"
                                                                    className="w-full px-2.5 py-1.5 bg-slate-800 border border-slate-600 rounded text-sm text-white placeholder-slate-500 focus:border-amber-500 outline-none resize-none"
                                                                    rows={2}
                                                                    onClick={e => e.stopPropagation()}
                                                                />
                                                            </div>
                                                        )}
                                                    </div>
                                                );
                                            })}
                                        </div>
                                        
                                        {/* Trigger alerts button */}
                                        {hasInterfaceChanges && !alertsTriggered && (
                                            <div className="mt-3">
                                                <button 
                                                    onClick={handleTriggerAlerts}
                                                    disabled={triggeringAlerts || interfaceChanges.filter(c => c.changed && !c.changeDescription.trim()).length > 0}
                                                    className={`px-4 py-2 rounded-lg text-sm font-medium w-full ${
                                                        triggeringAlerts ? 'bg-slate-700 text-slate-400 cursor-wait' :
                                                        interfaceChanges.filter(c => c.changed && !c.changeDescription.trim()).length > 0 
                                                            ? 'bg-slate-700 text-slate-500 cursor-not-allowed' 
                                                            : 'bg-amber-600 hover:bg-amber-500 text-white'
                                                    }`}>
                                                    {triggeringAlerts ? '⏳ Creating dependency alerts...' : 
                                                     `🔔 Notify ${interfaceChanges.filter(c => c.changed).length} changed interface${interfaceChanges.filter(c => c.changed).length !== 1 ? 's' : ''}`}
                                                </button>
                                                {interfaceChanges.filter(c => c.changed && !c.changeDescription.trim()).length > 0 && (
                                                    <div className="text-xs text-amber-400/70 mt-1">Describe what changed for each checked interface</div>
                                                )}
                                            </div>
                                        )}
                                        
                                        {/* Alert results */}
                                        {alertsTriggered && triggerResults.length > 0 && (
                                            <div className="mt-3 bg-green-900/20 border border-green-700/50 rounded-lg px-3 py-2.5">
                                                <div className="text-sm text-green-300 font-medium mb-1">
                                                    ✅ {triggerResults.length} dependency alert{triggerResults.length !== 1 ? 's' : ''} triggered
                                                </div>
                                                <div className="space-y-1">
                                                    {triggerResults.map((r, i) => (
                                                        <div key={i} className="text-xs text-green-200/70">
                                                            📋 {r.workItem?.id}: "{r.workItem?.title}" → {r.dependentStream?.name}
                                                        </div>
                                                    ))}
                                                </div>
                                                <div className="text-xs text-green-200/50 mt-1.5">
                                                    Work items created in dependent streams with change context for prompt chaining.
                                                </div>
                                            </div>
                                        )}
                                        
                                        {alertsTriggered && triggerResults.length === 0 && (
                                            <div className="mt-3 text-xs text-slate-500">No alerts needed — no dependent streams found.</div>
                                        )}
                                    </div>
                                )}
                                
                                <div className="flex justify-end pt-2">
                                    <button onClick={handleStep1Complete} className="px-4 py-2 bg-indigo-600 hover:bg-indigo-500 text-white rounded-lg text-sm font-medium">
                                        {totalCriteria > 0 ? 'Next: Verify Criteria →' : 'Next: Deploy Decision →'}
                                    </button>
                                </div>
                            </div>
                        )}
                        
                        {/* Step 2: Criteria Review — Check acceptance criteria */}
                        {step === 2 && totalCriteria > 0 && (
                            <div className="space-y-4">
                                <div>
                                    <div className="text-sm font-medium text-slate-300 mb-1">
                                        Acceptance criteria check — {metCount}/{totalCriteria} met
                                    </div>
                                    <div className="text-xs text-slate-500 mb-3">
                                        Verify each criterion was met in the deliverables. Unmet criteria can become new work items.
                                    </div>
                                    
                                    <div className="w-full bg-slate-700 rounded-full h-1.5 mb-4">
                                        <div className={`h-1.5 rounded-full transition-all ${allMet ? 'bg-green-500' : 'bg-indigo-500'}`} 
                                             style={{ width: `${totalCriteria > 0 ? (metCount / totalCriteria * 100) : 0}%` }} />
                                    </div>
                                    
                                    <div className="space-y-2 max-h-60 overflow-y-auto">
                                        {criteriaResults.map(c => (
                                            <div key={c.id} 
                                                 className={`flex items-start gap-3 px-3 py-2.5 rounded-lg border cursor-pointer transition-colors ${
                                                     c.met ? 'bg-green-900/20 border-green-700/50' : 'bg-slate-900/60 border-slate-700 hover:border-slate-600'
                                                 }`}
                                                 onClick={() => toggleCriteria(c.id)}>
                                                <div className={`w-5 h-5 rounded flex items-center justify-center flex-shrink-0 mt-0.5 ${
                                                    c.met ? 'bg-green-600 text-white' : 'border-2 border-slate-500'
                                                }`}>
                                                    {c.met && <span className="text-xs">✓</span>}
                                                </div>
                                                <div>
                                                    <div className={`text-sm ${c.met ? 'text-green-200' : 'text-slate-200'}`}>{c.text}</div>
                                                    <div className="text-xs text-slate-500 mt-0.5">{c.itemTitle}</div>
                                                </div>
                                            </div>
                                        ))}
                                    </div>
                                </div>
                                
                                <div>
                                    <div className="text-sm font-medium text-slate-300 mb-1">Review notes (optional)</div>
                                    <textarea
                                        value={reviewNotes}
                                        onChange={e => setReviewNotes(e.target.value)}
                                        placeholder="Any issues noticed, edge cases to retest, follow-up items..."
                                        className="w-full px-3 py-2 bg-slate-900 border border-slate-600 rounded-lg text-sm text-white placeholder-slate-500 focus:border-indigo-500 outline-none resize-none"
                                        rows={2}
                                    />
                                </div>
                                
                                {!allMet && (
                                    <div className="bg-amber-900/20 border border-amber-700/50 rounded-lg px-3 py-2 text-sm text-amber-200">
                                        ⚠️ {totalCriteria - metCount} criterion{totalCriteria - metCount !== 1 ? ' are' : ' is'} not yet met. 
                                        You can still proceed — unmet items will be noted in the session record.
                                    </div>
                                )}
                                
                                <div className="flex justify-between pt-2">
                                    <button onClick={() => setStep(1)} className="px-4 py-2 text-slate-400 hover:text-white text-sm">← Back</button>
                                    <button onClick={handleStep2Complete} className="px-4 py-2 bg-indigo-600 hover:bg-indigo-500 text-white rounded-lg text-sm font-medium">
                                        Next: Deploy Decision →
                                    </button>
                                </div>
                            </div>
                        )}
                        
                        {/* Step 3: Deploy Decision */}
                        {step === 3 && (
                            <div className="space-y-4">
                                <div className="text-sm font-medium text-slate-300 mb-1">Ready to deploy?</div>
                                
                                {/* Review summary */}
                                {totalCriteria > 0 && (
                                    <div className={`rounded-lg border px-4 py-3 ${allMet ? 'bg-green-900/20 border-green-700/50' : 'bg-amber-900/20 border-amber-700/50'}`}>
                                        <div className={`text-sm font-medium ${allMet ? 'text-green-200' : 'text-amber-200'}`}>
                                            {allMet ? '✅ All criteria met' : `⚠️ ${metCount}/${totalCriteria} criteria met`}
                                        </div>
                                        {reviewNotes && <div className="text-xs text-slate-400 mt-1">Notes: {reviewNotes}</div>}
                                    </div>
                                )}
                                
                                {deliverableNotes && (
                                    <div className="bg-slate-900/60 border border-slate-700 rounded-lg px-4 py-3">
                                        <div className="text-xs text-slate-400 mb-1">Session summary</div>
                                        <div className="text-sm text-slate-200">{deliverableNotes}</div>
                                    </div>
                                )}
                                
                                <div className="grid grid-cols-2 gap-3 pt-2">
                                    <button onClick={handleDeploy}
                                        className="px-4 py-3 bg-green-600 hover:bg-green-500 text-white rounded-lg text-sm font-medium flex items-center justify-center gap-2">
                                        🚀 Deploy Now
                                    </button>
                                    <button onClick={() => setStep(4)}
                                        className="px-4 py-3 bg-slate-700 hover:bg-slate-600 text-slate-200 rounded-lg text-sm font-medium flex items-center justify-center gap-2">
                                        Skip Deploy →
                                    </button>
                                </div>
                                
                                <div className="flex justify-start pt-1">
                                    <button onClick={() => setStep(totalCriteria > 0 ? 2 : 1)} className="px-4 py-2 text-slate-400 hover:text-white text-sm">← Back</button>
                                </div>
                            </div>
                        )}
                        
                        {/* Step 4: Close Work Items */}
                        {step === 4 && (
                            <div className="space-y-4">
                                <div>
                                    <div className="text-sm font-medium text-slate-300 mb-1">Mark work items as done?</div>
                                    <div className="text-xs text-slate-500 mb-3">Select which items were completed in this session.</div>
                                </div>
                                
                                {sessionWorkItems.length > 0 ? (
                                    <div className="space-y-2">
                                        {sessionWorkItems.map(wi => (
                                            <div key={wi.id} 
                                                 className={`flex items-center gap-3 px-3 py-2.5 rounded-lg border cursor-pointer transition-colors ${
                                                     closingItems.has(wi.id) ? 'bg-green-900/20 border-green-700/50' : 'bg-slate-900/60 border-slate-700 hover:border-slate-600'
                                                 }`}
                                                 onClick={() => toggleCloseItem(wi.id)}>
                                                <div className={`w-5 h-5 rounded flex items-center justify-center flex-shrink-0 ${
                                                    closingItems.has(wi.id) ? 'bg-green-600 text-white' : 'border-2 border-slate-500'
                                                }`}>
                                                    {closingItems.has(wi.id) && <span className="text-xs">✓</span>}
                                                </div>
                                                <div className="flex-1">
                                                    <span className="text-indigo-400 font-mono text-xs mr-2">{wi.id}</span>
                                                    <span className="text-sm text-slate-200">{wi.title}</span>
                                                </div>
                                            </div>
                                        ))}
                                    </div>
                                ) : (
                                    <div className="text-sm text-slate-500 text-center py-4">No work items linked to this session.</div>
                                )}
                                
                                <div className="flex justify-between pt-2">
                                    <button onClick={() => setStep(3)} className="px-4 py-2 text-slate-400 hover:text-white text-sm">← Back</button>
                                    <div className="flex gap-2">
                                        <button onClick={onClose} className="px-4 py-2 text-slate-400 hover:text-white text-sm">Skip</button>
                                        <button onClick={handleCloseItems} disabled={saving || closingItems.size === 0}
                                            className={`px-4 py-2 rounded-lg text-sm font-medium ${
                                                closingItems.size > 0 ? 'bg-green-600 hover:bg-green-500 text-white' : 'bg-slate-700 text-slate-500 cursor-not-allowed'
                                            }`}>
                                            {saving ? 'Saving...' : `✅ Complete ${closingItems.size} Item${closingItems.size !== 1 ? 's' : ''}`}
                                        </button>
                                    </div>
                                </div>
                            </div>
                        )}
                    </div>
                </div>
            </div>
        );
    }
    
    function SessionHistoryPanel({ sessions, workItems, apps, deployments, firebaseUid, config, showAlert, onStartReview }) {
        const [filterApp, setFilterApp] = React.useState('all');
        const [filterType, setFilterType] = React.useState('all');
        const [expandedSession, setExpandedSession] = React.useState(null);
        
        const SESSION_TYPE_META = {
            build: { icon: '🔨', color: 'blue' },
            design: { icon: '🎨', color: 'purple' },
            fix: { icon: '🔧', color: 'orange' },
            test: { icon: '🧪', color: 'green' },
            research: { icon: '🔍', color: 'cyan' },
            review: { icon: '📋', color: 'yellow' },
            polish: { icon: '✨', color: 'pink' },
            document: { icon: '📝', color: 'slate' }
        };
        
        const filteredSessions = sessions.filter(s => {
            if (filterApp !== 'all' && s.appId !== filterApp) return false;
            if (filterType !== 'all' && s.type !== filterType) return false;
            return true;
        });
        
        const sessionAppIds = [...new Set(sessions.map(s => s.appId))];
        const sessionTypes = [...new Set(sessions.map(s => s.type))];
        
        const findLinkedDeploy = (session) => {
            if (!session.deployId) return null;
            const deployTimestamp = parseInt(session.deployId.replace('deploy-', ''));
            return deployments.find(d => d.id === deployTimestamp);
        };
        
        const findSessionWorkItems = (session) => {
            if (!session.workItemId) return [];
            const ids = Array.isArray(session.workItemId) ? session.workItemId : [session.workItemId];
            return workItems.filter(wi => ids.includes(wi.id));
        };
        
        const totalSessions = sessions.length;
        const completedSessions = sessions.filter(s => s.status === 'completed').length;
        const activeSessions = sessions.filter(s => s.status === 'prep' || s.status === 'active' || s.status === 'review').length;
        const reviewSessions = sessions.filter(s => s.status === 'prep' || s.status === 'review');
        
        const typeColor = (type) => {
            const meta = SESSION_TYPE_META[type] || { color: 'slate' };
            const colors = {
                blue: 'bg-blue-900/30 text-blue-300 border-blue-700',
                purple: 'bg-purple-900/30 text-purple-300 border-purple-700',
                orange: 'bg-orange-900/30 text-orange-300 border-orange-700',
                green: 'bg-green-900/30 text-green-300 border-green-700',
                cyan: 'bg-cyan-900/30 text-cyan-300 border-cyan-700',
                yellow: 'bg-yellow-900/30 text-yellow-300 border-yellow-700',
                pink: 'bg-pink-900/30 text-pink-300 border-pink-700',
                slate: 'bg-slate-800 text-slate-300 border-slate-600'
            };
            return colors[meta.color] || colors.slate;
        };
        
        if (sessions.length === 0) {
            return (
                <div className="bg-slate-800 rounded-xl border border-slate-700 p-8 text-center">
                    <div className="text-4xl mb-3">🔄</div>
                    <div className="text-lg font-medium text-slate-300 mb-2">No Session History Yet</div>
                    <div className="text-sm text-slate-500 max-w-md mx-auto">
                        Sessions are recorded when you generate a Claude Prep package via the wizard.
                        Each session tracks the prep → build → deploy cycle.
                    </div>
                </div>
            );
        }
        
        return (
            <div className="space-y-4">
                {/* Awaiting Review Banner (Phase 3) */}
                {reviewSessions.length > 0 && onStartReview && (
                    <div className="bg-indigo-900/30 border border-indigo-700/50 rounded-xl p-4">
                        <div className="flex items-center justify-between mb-2">
                            <div className="text-sm font-semibold text-indigo-200">
                                📋 {reviewSessions.length} session{reviewSessions.length !== 1 ? 's' : ''} awaiting review
                            </div>
                        </div>
                        <div className="space-y-2">
                            {reviewSessions.slice(0, 3).map(s => {
                                const appName = apps[s.appId]?.name || s.appId;
                                const appIcon = apps[s.appId]?.icon || '📦';
                                return (
                                    <div key={s.id} className="flex items-center justify-between bg-slate-800/60 rounded-lg px-3 py-2">
                                        <div className="flex items-center gap-2 text-sm">
                                            <span>{appIcon}</span>
                                            <span className="text-slate-200">{appName}</span>
                                            <span className={`text-xs px-1.5 py-0.5 rounded ${typeColor(s.type)}`}>{s.type}</span>
                                            <span className="text-xs text-slate-500">{new Date(s.createdAt).toLocaleDateString()}</span>
                                        </div>
                                        <button 
                                            onClick={() => onStartReview(s)}
                                            className="text-xs px-3 py-1.5 bg-indigo-600 hover:bg-indigo-500 text-white rounded-lg font-medium transition-colors">
                                            Review →
                                        </button>
                                    </div>
                                );
                            })}
                        </div>
                    </div>
                )}
                
                {/* Stats Row */}
                <div className="grid grid-cols-3 gap-3">
                    <div className="bg-slate-800 rounded-lg border border-slate-700 p-3 text-center">
                        <div className="text-2xl font-bold text-indigo-300">{totalSessions}</div>
                        <div className="text-xs text-slate-400">Total Sessions</div>
                    </div>
                    <div className="bg-slate-800 rounded-lg border border-slate-700 p-3 text-center">
                        <div className="text-2xl font-bold text-green-300">{completedSessions}</div>
                        <div className="text-xs text-slate-400">Completed (Deployed)</div>
                    </div>
                    <div className="bg-slate-800 rounded-lg border border-slate-700 p-3 text-center">
                        <div className="text-2xl font-bold text-amber-300">{activeSessions}</div>
                        <div className="text-xs text-slate-400">Active / Prep</div>
                    </div>
                </div>
                
                {/* Filters */}
                <div className="flex gap-3">
                    <select
                        value={filterApp}
                        onChange={e => setFilterApp(e.target.value)}
                        className="px-3 py-1.5 bg-slate-800 border border-slate-600 rounded text-sm text-slate-200 focus:border-indigo-500 outline-none">
                        <option value="all">All Apps</option>
                        {sessionAppIds.map(id => (
                            <option key={id} value={id}>{apps[id]?.name || id}</option>
                        ))}
                    </select>
                    <select
                        value={filterType}
                        onChange={e => setFilterType(e.target.value)}
                        className="px-3 py-1.5 bg-slate-800 border border-slate-600 rounded text-sm text-slate-200 focus:border-indigo-500 outline-none">
                        <option value="all">All Types</option>
                        {sessionTypes.map(t => (
                            <option key={t} value={t}>{(SESSION_TYPE_META[t]?.icon || '📋')} {t}</option>
                        ))}
                    </select>
                    <div className="text-sm text-slate-400 ml-auto self-center">
                        {filteredSessions.length} session{filteredSessions.length !== 1 ? 's' : ''}
                    </div>
                </div>
                
                {/* Session Cards */}
                <div className="space-y-3">
                    {filteredSessions.map(session => {
                        const meta = SESSION_TYPE_META[session.type] || { icon: '📋', color: 'slate' };
                        const linkedDeploy = findLinkedDeploy(session);
                        const linkedWIs = findSessionWorkItems(session);
                        const isExpanded = expandedSession === session.id;
                        const appName = apps[session.appId]?.name || session.appId;
                        
                        return (
                            <div key={session.id} 
                                className={`bg-slate-800 rounded-lg border ${session.status === 'completed' ? 'border-green-800/50' : 'border-slate-700'} overflow-hidden`}>
                                {/* Session Header */}
                                <div 
                                    className="p-4 cursor-pointer hover:bg-slate-750 transition-colors"
                                    onClick={() => setExpandedSession(isExpanded ? null : session.id)}>
                                    <div className="flex items-center justify-between">
                                        <div className="flex items-center gap-3">
                                            <span className="text-xl">{meta.icon}</span>
                                            <div>
                                                <div className="font-medium text-slate-200">
                                                    {appName}
                                                    <span className={`ml-2 text-xs px-2 py-0.5 rounded border ${typeColor(session.type)}`}>
                                                        {session.type}
                                                    </span>
                                                </div>
                                                <div className="text-xs text-slate-400 mt-0.5">
                                                    {new Date(session.createdAt).toLocaleDateString()} {new Date(session.createdAt).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}
                                                    {session.engineId && <span className="ml-2 opacity-70">• {session.engineId}</span>}
                                                </div>
                                            </div>
                                        </div>
                                        <div className="flex items-center gap-3">
                                            <span className={`text-xs px-2 py-1 rounded-full ${
                                                session.status === 'completed' 
                                                    ? 'bg-green-900/40 text-green-300' 
                                                    : session.status === 'abandoned'
                                                        ? 'bg-red-900/40 text-red-300'
                                                        : session.status === 'review'
                                                            ? 'bg-purple-900/40 text-purple-300'
                                                            : 'bg-amber-900/40 text-amber-300'
                                            }`}>
                                                {session.status === 'completed' ? '✓ Deployed' 
                                                    : session.status === 'abandoned' ? '✕ Abandoned' 
                                                    : session.status === 'review' ? '📋 In Review'
                                                    : '⏳ ' + (session.status || 'prep')}
                                            </span>
                                            {(session.status === 'prep' || session.status === 'review') && onStartReview && (
                                                <button 
                                                    onClick={(e) => { e.stopPropagation(); onStartReview(session); }}
                                                    className="text-xs px-2.5 py-1 bg-indigo-600 hover:bg-indigo-500 text-white rounded-full font-medium transition-colors">
                                                    {session.status === 'review' ? 'Continue Review' : 'Review Session'}
                                                </button>
                                            )}
                                            <span className={`text-slate-500 transition-transform ${isExpanded ? 'rotate-180' : ''}`}>▾</span>
                                        </div>
                                    </div>
                                    
                                    {!isExpanded && (linkedDeploy || session.status === 'prep' || session.status === 'review') && (
                                        <div className="flex items-center gap-2 mt-2 text-xs text-slate-500">
                                            <span>📦 Prep</span>
                                            <span className="flex-1 border-t border-dashed border-slate-600"></span>
                                            <span>→</span>
                                            {session.review && (
                                                <>
                                                    <span className={session.review.allMet ? 'text-green-400' : 'text-amber-400'}>📋 {session.review.allMet ? '✓' : '⚠'}</span>
                                                    <span>→</span>
                                                </>
                                            )}
                                            <span className="flex-1 border-t border-dashed border-slate-600"></span>
                                            {linkedDeploy 
                                                ? <span>🚀 v{linkedDeploy.version} {linkedDeploy.target?.toUpperCase()}</span>
                                                : <span className="text-slate-600">⏳ Deploy</span>
                                            }
                                        </div>
                                    )}
                                </div>
                                
                                {/* Expanded Details */}
                                {isExpanded && (
                                    <div className="border-t border-slate-700 p-4 bg-slate-900/40 space-y-3">
                                        {/* Session Flow */}
                                        <div className="flex items-center gap-2 text-sm flex-wrap">
                                            <div className="flex items-center gap-1 px-2 py-1 bg-indigo-900/30 rounded border border-indigo-800/40">
                                                <span>📦</span>
                                                <span className="text-indigo-300">Prep</span>
                                            </div>
                                            <span className="text-slate-600">→</span>
                                            <div className={`flex items-center gap-1 px-2 py-1 rounded border ${
                                                session.review 
                                                    ? 'bg-purple-900/30 border-purple-800/40' 
                                                    : session.status === 'review'
                                                        ? 'bg-purple-900/30 border-purple-800/40 border-dashed animate-pulse'
                                                        : 'bg-slate-800 border-slate-700 border-dashed'
                                            }`}>
                                                <span>{session.review ? '📋' : '⏳'}</span>
                                                <span className={session.review ? 'text-purple-300' : 'text-slate-500'}>
                                                    {session.review ? (session.review.allMet ? 'Verified ✓' : 'Reviewed') 
                                                        : session.status === 'review' ? 'Reviewing...'
                                                        : 'Review'}
                                                </span>
                                            </div>
                                            <span className="text-slate-600">→</span>
                                            <div className={`flex items-center gap-1 px-2 py-1 rounded border ${
                                                linkedDeploy 
                                                    ? 'bg-green-900/30 border-green-800/40' 
                                                    : 'bg-slate-800 border-slate-700 border-dashed'
                                            }`}>
                                                <span>{linkedDeploy ? '🚀' : '⏳'}</span>
                                                <span className={linkedDeploy ? 'text-green-300' : 'text-slate-500'}>
                                                    {linkedDeploy 
                                                        ? `v${linkedDeploy.version} → ${linkedDeploy.target?.toUpperCase()}`
                                                        : 'Deploy'}
                                                </span>
                                            </div>
                                        </div>
                                        
                                        {/* Details Grid */}
                                        <div className="grid grid-cols-2 gap-3 text-sm">
                                            <div>
                                                <div className="text-xs text-slate-500 mb-1">Session ID</div>
                                                <div className="text-slate-300 font-mono text-xs">{session.id}</div>
                                            </div>
                                            <div>
                                                <div className="text-xs text-slate-500 mb-1">Token Budget</div>
                                                <div className="text-slate-300">
                                                    {session.packageTokens ? `${(session.packageTokens / 1000).toFixed(1)}K tokens` : '—'}
                                                </div>
                                            </div>
                                            <div>
                                                <div className="text-xs text-slate-500 mb-1">Engine</div>
                                                <div className="text-slate-300">{session.engineId || '—'}</div>
                                            </div>
                                            <div>
                                                <div className="text-xs text-slate-500 mb-1">Duration</div>
                                                <div className="text-slate-300">
                                                    {session.completedAt && session.createdAt 
                                                        ? (() => {
                                                            const mins = Math.round((new Date(session.completedAt) - new Date(session.createdAt)) / 60000);
                                                            return mins < 60 ? `${mins}m` : `${Math.floor(mins/60)}h ${mins%60}m`;
                                                        })()
                                                        : '—'}
                                                </div>
                                            </div>
                                        </div>
                                        
                                        {/* Package Files */}
                                        {session.packageFiles && session.packageFiles.length > 0 && (
                                            <div>
                                                <div className="text-xs text-slate-500 mb-1">Package Files ({session.packageFiles.length})</div>
                                                <div className="flex flex-wrap gap-1">
                                                    {session.packageFiles.slice(0, 8).map((f, i) => (
                                                        <span key={i} className="text-xs px-1.5 py-0.5 bg-slate-700 rounded text-slate-300 font-mono">
                                                            {typeof f === 'string' ? f : f.name || f}
                                                        </span>
                                                    ))}
                                                    {session.packageFiles.length > 8 && (
                                                        <span className="text-xs text-slate-500">+{session.packageFiles.length - 8} more</span>
                                                    )}
                                                </div>
                                            </div>
                                        )}
                                        
                                        {/* Linked Work Items */}
                                        {linkedWIs.length > 0 && (
                                            <div>
                                                <div className="text-xs text-slate-500 mb-1">Work Items</div>
                                                <div className="space-y-1">
                                                    {linkedWIs.map(wi => (
                                                        <div key={wi.id} className="flex items-center gap-2 text-sm">
                                                            <span className={`text-xs px-1.5 py-0.5 rounded ${
                                                                wi.status === 'done' ? 'bg-green-900/40 text-green-300' : 'bg-amber-900/40 text-amber-300'
                                                            }`}>
                                                                {wi.status === 'done' ? '✓' : '•'} {wi.id}
                                                            </span>
                                                            <span className="text-slate-300">{wi.title}</span>
                                                        </div>
                                                    ))}
                                                </div>
                                            </div>
                                        )}
                                        
                                        {/* Notes */}
                                        {session.notes && (
                                            <div>
                                                <div className="text-xs text-slate-500 mb-1">Notes</div>
                                                <div className="text-sm text-slate-300">{session.notes}</div>
                                            </div>
                                        )}
                                        
                                        {/* Phase 3: Deliverables summary */}
                                        {session.deliverables?.summary && (
                                            <div>
                                                <div className="text-xs text-slate-500 mb-1">Deliverables</div>
                                                <div className="text-sm text-slate-300">{session.deliverables.summary}</div>
                                            </div>
                                        )}
                                        
                                        {/* Phase 3: Review Results */}
                                        {session.review && (
                                            <div>
                                                <div className="text-xs text-slate-500 mb-1">Review</div>
                                                <div className={`text-sm px-3 py-2 rounded-lg border ${
                                                    session.review.allMet ? 'bg-green-900/20 border-green-700/50 text-green-200' : 'bg-amber-900/20 border-amber-700/50 text-amber-200'
                                                }`}>
                                                    {session.review.allMet ? '✅ All criteria met' : `⚠️ ${(session.review.criteriaResults || []).filter(c => c.met).length}/${(session.review.criteriaResults || []).length} criteria met`}
                                                    {session.review.reviewedBy && <span className="text-xs ml-2 opacity-60">by {session.review.reviewedBy}</span>}
                                                </div>
                                                {session.review.notes && (
                                                    <div className="text-xs text-slate-400 mt-1">{session.review.notes}</div>
                                                )}
                                            </div>
                                        )}
                                    </div>
                                )}
                            </div>
                        );
                    })}
                </div>
            </div>
        );
    }

    // =========================================================================
    // PROJECT SCOPING — Category-Driven Scoping Flow (v8.23.0 / Phase 1.2)
    // =========================================================================
    
    // Category question definitions — static data, no AI dependency
    // Built-in scope categories (Phase 5.1: extensible — custom categories can override or extend)
    const SCOPE_CATEGORIES = {
        game: { label: 'Game', icon: '🎮', description: 'Puzzle, word game, or interactive game' },
        tool: { label: 'Tool', icon: '🔧', description: 'Utility or productivity tool' },
        dashboard: { label: 'Dashboard', icon: '📊', description: 'Data display or monitoring' },
        content: { label: 'Content', icon: '📄', description: 'Content site or documentation' },
        admin: { label: 'Admin', icon: '🔐', description: 'Administration or management panel' }
    };
    
    // Helper: get all categories (built-in + custom from config)
    function getAllCategories(config) {
        const custom = config?.customCategories || {};
        return { ...SCOPE_CATEGORIES, ...custom };
    }
    
    // v8.38.0: PM-first intent questions (Phase 2.1 + 2.4)
    // Questions capture INTENT. The package engine translates intent into technology.
    // Removed: tool.settingsPersistence (redundant with dataPersistence)
    // Merged: dashboard.autoRefresh + dashboard.realtime → dashboard.dataUpdates
    const CATEGORY_QUESTIONS = {
        game: [
            { id: 'dailyReset', label: 'Does the game reset daily with a new puzzle?', type: 'toggle', default: true, drives: 'Daily reset logic, streak tracking, puzzle number' },
            { id: 'difficultyModes', label: 'How many difficulty levels?', type: 'select', options: ['none', 'easy-hard', 'multiple'], optionLabels: ['None', 'Two modes (e.g. Easy/Hard)', 'Multiple levels'], default: 'easy-hard', drives: 'Mode selector, separate stats per mode' },
            { id: 'scoringSystem', label: 'How are players scored?', type: 'select', options: ['none', 'points', 'tries', 'time'], optionLabels: ['No scoring', 'Points earned', 'Number of attempts', 'Time to complete'], default: 'points', drives: 'Score display, personal best tracking' },
            { id: 'shareResults', label: 'Can players share their results?', type: 'toggle', default: true, drives: 'Share button with clipboard fallback' },
            { id: 'multiplayer', label: 'Will players interact with each other?', type: 'toggle', default: false, drives: 'User accounts, friend system, battles or leaderboard' },
            { id: 'streaks', label: 'Track daily play streaks?', type: 'toggle', default: true, drives: 'Streak counter, daily play detection' },
            { id: 'achievements', label: 'Reward milestones with achievements?', type: 'toggle', default: false, drives: 'Achievement system, unlock notifications' },
            { id: 'soundEffects', label: 'Include sound effects?', type: 'toggle', default: false, drives: 'Audio on key events, mute toggle' },
            { id: 'tutorial', label: 'Guide new players through the game?', type: 'toggle', default: true, drives: 'Welcome walkthrough, replayable from menu' }
        ],
        tool: [
            { id: 'dataPersistence', label: 'Should data save between sessions?', type: 'select', options: ['none', 'localStorage', 'Firebase'], optionLabels: ['No — starts fresh each time', 'Yes — on this device', 'Yes — synced across devices'], default: 'localStorage', drives: 'Storage strategy and data migration' },
            { id: 'primaryDataType', label: 'What does the user work with?', type: 'text', placeholder: 'e.g. label sheets, expense records, recipes', default: '', drives: 'Data model and CRUD scaffolding' },
            { id: 'multiItem', label: 'Work with a list of items or a single item?', type: 'select', options: [true, false], optionLabels: ['A list of items (browse, select, manage)', 'A single item at a time'], default: true, drives: 'List view, item cards, bulk actions' },
            { id: 'searchFilter', label: 'Will users need to search or filter?', type: 'toggle', default: true, drives: 'Search input, filter controls' },
            { id: 'importExport', label: 'Import or export data?', type: 'toggle', default: true, drives: 'File input, download as JSON/CSV' },
            { id: 'printSupport', label: 'Does anything need to be printed?', type: 'toggle', default: false, drives: 'Print-friendly layout, page breaks' },
            { id: 'undoRedo', label: 'Should users be able to undo mistakes?', type: 'toggle', default: false, drives: 'Undo/redo with Ctrl+Z support' },
            { id: 'keyboardShortcuts', label: 'Power-user keyboard shortcuts?', type: 'toggle', default: false, drives: 'Key bindings, shortcut reference' }
        ],
        dashboard: [
            { id: 'dataSources', label: 'Where does the data come from?', type: 'multi-select', options: ['Firebase', 'API', 'localStorage', 'manual'], optionLabels: ['Database', 'External service', 'Browser storage', 'User input'], default: ['Firebase'], drives: 'Data fetching and refresh strategy' },
            { id: 'layout', label: 'How should data be displayed?', type: 'select', options: ['cards', 'table', 'mixed'], optionLabels: ['Visual cards', 'Data table', 'Mix of both'], default: 'cards', drives: 'Layout pattern and component structure' },
            { id: 'dataUpdates', label: 'How should data stay current?', type: 'select', options: ['manual', 'periodic', 'realtime'], optionLabels: ['Manual refresh only', 'Auto-refresh periodically', 'Live — updates instantly'], default: 'periodic', drives: 'Refresh interval or live listeners' },
            { id: 'filtering', label: 'Can users filter what they see?', type: 'toggle', default: true, drives: 'Filter controls, active filter display' },
            { id: 'dateRange', label: 'Filter by date range?', type: 'toggle', default: true, drives: 'Date picker, preset ranges' },
            { id: 'exportData', label: 'Download data as a file?', type: 'toggle', default: false, drives: 'Export to CSV or JSON' }
        ],
        content: [
            { id: 'contentType', label: 'Does the content change?', type: 'select', options: ['static', 'dynamic'], optionLabels: ['Same every time', 'Updates regularly'], default: 'static', drives: 'Static vs runtime content strategy' },
            { id: 'contentSource', label: 'Where does content come from?', type: 'select', options: ['hardcoded', 'Firebase', 'API', 'CMS'], optionLabels: ['Built into the app', 'Database', 'External service', 'Content management system'], default: 'hardcoded', drives: 'Data loading pattern' },
            { id: 'seo', label: 'Should search engines find this?', type: 'toggle', default: false, drives: 'SEO meta tags, Open Graph, semantic HTML' },
            { id: 'mediaTypes', label: 'What types of content?', type: 'multi-select', options: ['text', 'images', 'video', 'audio'], default: ['text'], drives: 'Media handling and optimization' },
            { id: 'navPattern', label: 'How much content?', type: 'select', options: ['single-page', 'multi-section', 'paginated'], optionLabels: ['One page', 'Multiple sections', 'Many pages'], default: 'single-page', drives: 'Navigation structure, scroll behavior' }
        ],
        admin: [
            { id: 'authRequired', label: 'Must users sign in?', type: 'toggle', default: true, drives: 'Login flow, session management' },
            { id: 'roleAccess', label: 'Different permission levels?', type: 'toggle', default: false, drives: 'Role definitions, permission checks' },
            { id: 'crudOps', label: 'Can users create, edit, and delete records?', type: 'toggle', default: true, drives: 'Data tables, edit forms, delete confirmation' },
            { id: 'auditLog', label: 'Track who changed what?', type: 'toggle', default: false, drives: 'Action log with timestamps and attribution' },
            { id: 'bulkOps', label: 'Act on multiple items at once?', type: 'toggle', default: true, drives: 'Multi-select, batch operations' },
            { id: 'dataViz', label: 'Charts or visual summaries?', type: 'toggle', default: false, drives: 'Charts, summary cards, trend indicators' }
        ]
    };
    
    // Universal starting standards (always on by default)
    const UNIVERSAL_STANDARDS = [
        { id: 'css-variables', label: 'CSS variables for all colors — :root and [data-theme="dark"]', group: 'theme' },
        { id: 'dark-light-toggle', label: 'Dark mode default with light mode toggle', group: 'theme' },
        { id: 'theme-persistence', label: 'Theme persistence in localStorage', group: 'theme' },
        { id: 'mobile-first', label: 'Mobile-first responsive design', group: 'layout' },
        { id: 'safe-areas', label: 'Safe area support for notched devices', group: 'layout' },
        { id: 'toast-system', label: 'Toast notification system (replaces native alert/confirm/prompt)', group: 'feedback' },
        { id: 'confirm-dialog', label: 'Custom confirm dialog', group: 'feedback' },
        { id: 'hamburger-menu', label: 'Hamburger menu (☰) with settings panel', group: 'nav' },
        { id: 'meta-tags', label: 'Meta tags: version and gs-app-id', group: 'infra' },
        { id: 'version-display', label: 'Version display in settings/footer', group: 'infra' },
        { id: 'loading-spinner', label: 'Loading spinner for async operations', group: 'feedback' },
        { id: 'empty-states', label: 'Empty state pattern (icon + message + action)', group: 'feedback' }
    ];
    
    // Category-driven standards (selected based on answers)
    const CATEGORY_STANDARDS = {
        'daily-reset': { label: 'Daily reset at midnight UTC', group: 'game', condition: (cat, ans) => cat === 'game' && ans.dailyReset },
        'streak-tracking': { label: 'Streak tracking with localStorage persistence', group: 'game', condition: (cat, ans) => cat === 'game' && ans.streaks },
        'share-results': { label: 'Share results (navigator.share → clipboard fallback)', group: 'game', condition: (cat, ans) => cat === 'game' && ans.shareResults },
        'difficulty-modes': { label: 'Difficulty mode selector in settings', group: 'game', condition: (cat, ans) => cat === 'game' && ans.difficultyModes !== 'none' },
        'stats-tracking': { label: 'Stats tracking object in localStorage', group: 'game', condition: (cat, ans) => cat === 'game' && ans.scoringSystem !== 'none' },
        'celebration-effects': { label: 'Celebration effects on special achievements', group: 'game', condition: (cat, ans) => cat === 'game' && ans.achievements },
        'tutorial-onboarding': { label: 'Tutorial: welcome modal → guided steps → replay from menu', group: 'game', condition: (cat, ans) => cat === 'game' && ans.tutorial },
        'sound-manager': { label: 'Audio manager with mute toggle', group: 'game', condition: (cat, ans) => cat === 'game' && ans.soundEffects },
        'tab-nav': { label: 'Tab navigation pattern', group: 'tool', condition: (cat, ans) => cat === 'tool' && (ans.multiItem === true || ans.multiItem === 'true') },
        'settings-storage': { label: 'Settings persistence (single localStorage key with JSON)', group: 'tool', condition: (cat, ans) => cat === 'tool' && ans.dataPersistence !== 'none' },
        'import-export': { label: 'Import/export functions', group: 'tool', condition: (cat, ans) => cat === 'tool' && ans.importExport },
        'print-css': { label: 'Print-friendly CSS', group: 'tool', condition: (cat, ans) => cat === 'tool' && ans.printSupport },
        'keyboard-shortcuts': { label: 'Keyboard shortcuts with reference panel', group: 'tool', condition: (cat, ans) => cat === 'tool' && ans.keyboardShortcuts },
        'undo-redo': { label: 'Undo/redo with state history', group: 'tool', condition: (cat, ans) => cat === 'tool' && ans.undoRedo },
        'firebase-auth': { label: 'Firebase Auth: Google sign-in flow with auth state listener', group: 'firebase', condition: (cat, ans) => (cat === 'game' && ans.multiplayer) || (cat === 'admin' && ans.authRequired) || (cat === 'dashboard' && ans.dataSources?.includes('Firebase')) },
        'firebase-rtdb': { label: 'Firebase RTDB: read/write helpers at specified paths', group: 'firebase', condition: (cat, ans) => (cat === 'game' && ans.multiplayer) || (cat === 'admin') || (cat === 'dashboard' && ans.dataSources?.includes('Firebase')) || (cat === 'tool' && ans.dataPersistence === 'Firebase') },
        'firebase-connection': { label: 'Connection status indicator', group: 'firebase', condition: (cat, ans) => (cat === 'game' && ans.multiplayer) || (cat === 'dashboard' && ans.dataUpdates === 'realtime') },
        'auto-refresh': { label: 'Auto-refresh with last-updated display', group: 'dashboard', condition: (cat, ans) => cat === 'dashboard' && ans.dataUpdates === 'periodic' },
        'date-range': { label: 'Date range selector for time-scoped queries', group: 'dashboard', condition: (cat, ans) => cat === 'dashboard' && ans.dateRange },
        'data-export': { label: 'CSV/JSON data export', group: 'dashboard', condition: (cat, ans) => cat === 'dashboard' && ans.exportData },
        'realtime-updates': { label: 'Real-time Firebase listeners with live indicators', group: 'dashboard', condition: (cat, ans) => cat === 'dashboard' && ans.dataUpdates === 'realtime' },
        'seo-tags': { label: 'SEO meta tags, semantic HTML, OG tags', group: 'content', condition: (cat, ans) => cat === 'content' && ans.seo },
        'role-access': { label: 'Role-based access control with UI permission gating', group: 'admin', condition: (cat, ans) => cat === 'admin' && ans.roleAccess },
        'audit-logging': { label: 'Audit logging with timestamps', group: 'admin', condition: (cat, ans) => cat === 'admin' && ans.auditLog },
        'bulk-actions': { label: 'Multi-select with batch operations', group: 'admin', condition: (cat, ans) => cat === 'admin' && ans.bulkOps },
        'data-charts': { label: 'Charts and summary cards', group: 'admin', condition: (cat, ans) => cat === 'admin' && ans.dataViz }
    };
    
    // Feature generation from category answers
    function generateFeaturesFromScope(category, answers) {
        const features = [];
        
        if (category === 'game') {
            if (answers.dailyReset) features.push({ title: 'Daily puzzle generation with midnight UTC reset', description: 'New puzzle each day, puzzle number tracking, automatic reset at midnight UTC', priority: 'core', effort: 'session' });
            if (answers.scoringSystem !== 'none') features.push({ title: `${answers.scoringSystem === 'points' ? 'Points-based' : answers.scoringSystem === 'tries' ? 'Attempts-based' : 'Time-based'} scoring with personal best tracking`, description: `Track ${answers.scoringSystem} per game with historical best`, priority: 'core', effort: 'quick' });
            if (answers.shareResults) features.push({ title: 'Share results with emoji grid', description: 'Navigator.share with clipboard fallback, generates share text with emoji representation', priority: 'core', effort: 'session' });
            if (answers.difficultyModes !== 'none') features.push({ title: `${answers.difficultyModes === 'easy-hard' ? 'Easy/Hard' : 'Multiple'} difficulty modes with separate stats`, description: 'Mode selector in menu/settings with independent statistics tracking', priority: 'core', effort: 'session' });
            if (answers.streaks) features.push({ title: 'Streak tracking with daily play detection', description: 'Current streak, max streak, daily check against localStorage', priority: 'core', effort: 'quick' });
            if (answers.tutorial) features.push({ title: 'Tutorial / onboarding flow', description: 'Welcome modal for first visit, guided walkthrough, replayable from menu', priority: 'nice-to-have', effort: 'session' });
            if (answers.achievements) features.push({ title: 'Achievement system', description: 'Achievement definitions, unlock tracking, celebration notification', priority: 'nice-to-have', effort: 'multi-session' });
            if (answers.soundEffects) features.push({ title: 'Sound effects with mute toggle', description: 'Audio manager, sound triggers on key events, mute in settings', priority: 'nice-to-have', effort: 'session' });
            if (answers.multiplayer) features.push({ title: 'Multiplayer / social features', description: 'Firebase auth, friend connections, battles or shared leaderboard', priority: 'nice-to-have', effort: 'multi-session' });
        }
        
        if (category === 'tool') {
            if (answers.multiItem === true || answers.multiItem === 'true') features.push({ title: 'Multi-item list with CRUD', description: 'List view, item cards, create/edit/delete with confirmation', priority: 'core', effort: 'session' });
            if (answers.searchFilter) features.push({ title: 'Search and filter controls', description: 'Text search, filter dropdowns, clear filters action', priority: 'core', effort: 'quick' });
            if (answers.importExport) features.push({ title: 'Import/export functionality', description: 'File input for import, export to JSON/CSV, format validation', priority: 'core', effort: 'session' });
            if (answers.printSupport) features.push({ title: 'Print support with preview', description: 'Print-friendly CSS, print preview, page break handling', priority: 'core', effort: 'session' });
            if (answers.dataPersistence !== 'none') features.push({ title: 'Persistent settings', description: 'Settings object in localStorage, settings UI in menu', priority: 'core', effort: 'quick' });
            if (answers.undoRedo) features.push({ title: 'Undo/redo system', description: 'State history stack, keyboard shortcuts Ctrl+Z/Y', priority: 'nice-to-have', effort: 'session' });
            if (answers.keyboardShortcuts) features.push({ title: 'Keyboard shortcuts', description: 'Key bindings for common actions, shortcut reference panel', priority: 'nice-to-have', effort: 'quick' });
            if (answers.dataPersistence === 'Firebase') features.push({ title: 'Firebase data persistence', description: 'Firebase RTDB storage with auth, sync status indicator', priority: 'core', effort: 'session' });
        }
        
        if (category === 'dashboard') {
            features.push({ title: `${answers.layout === 'cards' ? 'Card grid' : answers.layout === 'table' ? 'Data table' : 'Mixed'} layout`, description: `Primary data display using ${answers.layout} pattern`, priority: 'core', effort: 'session' });
            if (answers.filtering) features.push({ title: 'Filter controls', description: 'Filter dropdowns, active filter display, clear all action', priority: 'core', effort: 'quick' });
            if (answers.dataUpdates === 'periodic') features.push({ title: 'Auto-refresh with interval', description: 'Configurable refresh interval, last-updated timestamp display', priority: 'core', effort: 'quick' });
            if (answers.dataUpdates === 'realtime') features.push({ title: 'Real-time live updates', description: 'Firebase listeners, live update indicators, connection status', priority: 'core', effort: 'session' });
            if (answers.dateRange) features.push({ title: 'Date range selector', description: 'Date picker for time-scoped data queries, preset ranges', priority: 'core', effort: 'session' });
            if (answers.exportData) features.push({ title: 'Data export (CSV/JSON)', description: 'Export current view to CSV or JSON format', priority: 'nice-to-have', effort: 'quick' });
        }
        
        if (category === 'content') {
            features.push({ title: `${answers.contentType === 'static' ? 'Static' : 'Dynamic'} content display`, description: `Content loaded from ${answers.contentSource}`, priority: 'core', effort: 'session' });
            if (answers.navPattern !== 'single-page') features.push({ title: `${answers.navPattern === 'multi-section' ? 'Section-based' : 'Paginated'} navigation`, description: `${answers.navPattern} navigation with smooth transitions`, priority: 'core', effort: 'session' });
            if (answers.seo) features.push({ title: 'SEO optimization', description: 'Meta tags, OG tags, semantic HTML, structured data', priority: 'core', effort: 'quick' });
            if (answers.mediaTypes?.includes('images')) features.push({ title: 'Image handling', description: 'Responsive images, lazy loading, lightbox', priority: 'core', effort: 'session' });
            if (answers.mediaTypes?.includes('video')) features.push({ title: 'Video embedding', description: 'Video player, responsive embeds', priority: 'core', effort: 'quick' });
        }
        
        if (category === 'admin') {
            if (answers.authRequired) features.push({ title: 'Authentication gate', description: 'Firebase auth, login/logout flow, session management', priority: 'core', effort: 'session' });
            if (answers.crudOps) features.push({ title: 'CRUD data management', description: 'Data tables, edit modals, create/update/delete with confirmation', priority: 'core', effort: 'session' });
            if (answers.bulkOps) features.push({ title: 'Bulk operations', description: 'Multi-select, batch status changes, bulk delete with confirmation', priority: 'core', effort: 'session' });
            if (answers.roleAccess) features.push({ title: 'Role-based access control', description: 'Role definitions, permission checks, UI gating by role', priority: 'core', effort: 'multi-session' });
            if (answers.auditLog) features.push({ title: 'Audit logging', description: 'Action log with timestamps, user attribution, log viewer', priority: 'nice-to-have', effort: 'session' });
            if (answers.dataViz) features.push({ title: 'Data visualization', description: 'Charts, summary cards, trend indicators', priority: 'nice-to-have', effort: 'session' });
        }
        
        return features;
    }
    
    // Assemble starting standards from category + answers
    function assembleStartingStandards(category, answers) {
        const standards = UNIVERSAL_STANDARDS.map(s => s.id);
        Object.entries(CATEGORY_STANDARDS).forEach(([id, spec]) => {
            if (spec.condition(category, answers)) {
                standards.push(id);
            }
        });
        return standards;
    }
    
    // =========================================================================
    // CLAUDE_INSTRUCTIONS.md GENERATOR
    // =========================================================================
    
    // Standard descriptions for each standard ID — requirement statements, not code
    const STANDARD_DESCRIPTIONS = {
        // Universal
        'css-variables': 'All colors defined as CSS variables in :root and [data-theme="dark"]. Never hardcode color values anywhere.',
        'dark-light-toggle': 'Dark mode is the default theme. Support light mode toggle using data-theme attribute on <html>.',
        'theme-persistence': 'Persist theme preference in localStorage. Restore on page load.',
        'mobile-first': 'Mobile-first responsive design. Base styles target 375px viewport. Minimum 44px touch targets for all interactive elements.',
        'safe-areas': 'Support safe areas for notched devices using env(safe-area-inset-*) padding.',
        'toast-system': 'Toast notification system for all user messages. No native alert(), confirm(), or prompt(). Toasts positioned bottom-center, auto-dismiss after 3s, support success/error/warning types.',
        'confirm-dialog': 'Custom confirm dialog for destructive actions. Returns a Promise<boolean>. Styled consistently with the app theme.',
        'hamburger-menu': 'Hamburger menu (☰) in top-right corner with slide-out or modal settings panel.',
        'meta-tags': 'Required meta tags in <head>: <meta name="version" content="X.Y.Z"> and <meta name="gs-app-id" content="{appId}">.',
        'version-display': 'Display current version in settings panel or footer.',
        'loading-spinner': 'Loading spinner for all async operations. Prevent interaction during loading.',
        'empty-states': 'Empty state pattern for all list/data views: icon + descriptive message + action button.',
        // Game
        'daily-reset': 'Daily puzzle reset at midnight UTC. Track puzzle number from a fixed epoch date. Detect new day on load and on visibility change.',
        'streak-tracking': 'Track current streak and max streak in localStorage. Daily play detection — a missed day breaks the streak.',
        'share-results': 'Share button using navigator.share() with clipboard.writeText() fallback. Generate share text with emoji grid representation of results.',
        'difficulty-modes': 'Difficulty mode selector accessible from settings. Separate statistics tracking per mode.',
        'stats-tracking': 'Stats tracking object in localStorage: games played, win rate, score distribution, personal bests. Display in a stats modal.',
        'celebration-effects': 'Celebration effects (confetti, animation) on special achievements like perfect scores or streak milestones.',
        'tutorial-onboarding': 'Tutorial flow: welcome modal on first visit → guided walkthrough of key features → replayable from settings menu.',
        'sound-manager': 'Audio manager with sound effects on key game events. Mute toggle in settings, persisted in localStorage.',
        // Tool
        'tab-nav': 'Tab navigation pattern for switching between app sections. Active tab indicator, smooth transitions.',
        'settings-storage': 'Settings persistence using a single localStorage key with JSON object. Settings UI in hamburger menu.',
        'import-export': 'Import function (file input with format validation) and export function (JSON or CSV download).',
        'print-css': 'Print-friendly CSS with @media print rules. Hide navigation and non-essential UI. Proper page breaks.',
        'keyboard-shortcuts': 'Keyboard shortcuts for common actions. Shortcut reference panel accessible from settings or ? key.',
        'undo-redo': 'Undo/redo system with state history stack. Ctrl+Z / Ctrl+Y (Cmd on Mac) keyboard shortcuts.',
        // Firebase
        'firebase-auth': 'Firebase Authentication with Google sign-in. Auth state listener for UI updates. Sign in/out flow in settings.',
        'firebase-rtdb': 'Firebase Realtime Database read/write helpers. Structured paths under the app namespace. Error handling for offline/permission errors.',
        'firebase-connection': 'Firebase connection status indicator. Show online/offline state. Handle reconnection gracefully.',
        // Dashboard
        'auto-refresh': 'Auto-refresh data on a configurable interval. Display last-updated timestamp. Manual refresh button.',
        'date-range': 'Date range selector for time-scoped data queries. Preset ranges (today, last 7 days, last 30 days, custom).',
        'data-export': 'Export current view data to CSV or JSON format via download.',
        'realtime-updates': 'Firebase real-time listeners with live update indicators. Show when data refreshes automatically.',
        // Content
        'seo-tags': 'SEO meta tags (title, description), Open Graph tags, semantic HTML structure.',
        // Admin
        'role-access': 'Role-based access control. Define roles with permissions. Gate UI elements by role. Check permissions on data operations.',
        'audit-logging': 'Audit logging: record user actions with timestamps and user attribution. Audit log viewer in admin interface.',
        'bulk-actions': 'Multi-select with batch operations: select all, select range, batch status changes, bulk delete with confirmation.',
        'data-charts': 'Data visualization with charts (bar, line, pie) and summary cards with trend indicators.'
    };
    
    // Group labels for standard sections
    const STANDARD_GROUP_LABELS = {
        'theme': 'Theme & Display',
        'layout': 'Layout & Responsiveness',
        'feedback': 'User Feedback',
        'nav': 'Navigation',
        'infra': 'Infrastructure',
        'game': 'Game Mechanics',
        'tool': 'Tool Patterns',
        'firebase': 'Firebase Integration',
        'dashboard': 'Dashboard Patterns',
        'content': 'Content Management',
        'admin': 'Admin Patterns'
    };
    
    /**
     * Generate CLAUDE_INSTRUCTIONS.md from app scope data.
     * Produces a structured AI briefing document with requirement statements.
     * 
     * @param {Object} app - App definition from CC
     * @param {Object} scopeData - Scope data (from Firebase appScopes/{appId})
     * @param {Object} config - CC config (for project info)
     * @returns {string} Markdown content for CLAUDE_INSTRUCTIONS.md
     */
    function generateClaudeInstructions(app, scopeData, config) {
        if (!scopeData) return null;
        
        const cat = SCOPE_CATEGORIES[scopeData.category];
        const projectDef = config?.projects?.[app.project] || {};
        
        // === Section: Project Identity ===
        let md = `# ${app.name} — AI Development Instructions\n\n`;
        md += `> Generated by Command Center from project scope. This document travels with every Claude Prep package.\n`;
        md += `> Edit freely — manual changes take precedence over regeneration.\n\n`;
        
        md += `## Project Identity\n\n`;
        md += `${scopeData.description || app.description || app.name + ' is a web application.'}\n\n`;
        md += `- **Category:** ${cat?.icon || '📦'} ${cat?.label || scopeData.category || 'Unknown'}\n`;
        if (projectDef.name) md += `- **Project:** ${projectDef.name}\n`;
        md += `- **App ID:** ${app.id}\n`;
        md += `\n`;
        
        // === Section: Launch Scope ===
        const coreFeatures = (scopeData.v1Features || []).filter(f => f.priority === 'core');
        const niceFeatures = (scopeData.v1Features || []).filter(f => f.priority === 'nice-to-have');
        const outFeatures = (scopeData.v1Features || []).filter(f => f.priority === 'out-of-scope');
        const futureFeatures = scopeData.futureFeatures || [];
        
        md += `## Launch Scope\n\n`;
        
        if (coreFeatures.length > 0) {
            md += `### Must Build (Core)\n`;
            coreFeatures.forEach(f => {
                md += `- **${f.title}**`;
                if (f.description) md += ` — ${f.description}`;
                if (f.effort) md += ` _(${f.effort})_`;
                md += `\n`;
            });
            md += `\n`;
        }
        
        if (niceFeatures.length > 0) {
            md += `### Nice to Have (If Time)\n`;
            niceFeatures.forEach(f => {
                md += `- **${f.title}**`;
                if (f.description) md += ` — ${f.description}`;
                md += `\n`;
            });
            md += `\n`;
        }
        
        if (outFeatures.length > 0 || futureFeatures.length > 0) {
            md += `### Out of Scope (Do NOT Build)\n`;
            outFeatures.forEach(f => {
                md += `- ~~${f.title}~~`;
                if (f.description) md += ` — ${f.description}`;
                md += `\n`;
            });
            futureFeatures.forEach(f => {
                md += `- ~~${f.title}~~`;
                if (f.description) md += ` — ${f.description}`;
                md += ` _(future)_\n`;
            });
            md += `\n`;
        }
        
        // === Section: Starting Standards ===
        const standards = scopeData.startingStandards || [];
        if (standards.length > 0) {
            md += `## Starting Standards\n\n`;
            md += `These are the baseline requirements for the app. Each session should ensure these are implemented.\n\n`;
            
            // Group standards by their group
            const grouped = {};
            standards.forEach(id => {
                // Find in universal or category standards
                const universal = UNIVERSAL_STANDARDS.find(s => s.id === id);
                const catStd = CATEGORY_STANDARDS[id];
                const group = universal?.group || catStd?.group || 'other';
                if (!grouped[group]) grouped[group] = [];
                grouped[group].push(id);
            });
            
            // Render each group
            Object.entries(grouped).forEach(([group, ids]) => {
                const groupLabel = STANDARD_GROUP_LABELS[group] || group.charAt(0).toUpperCase() + group.slice(1);
                md += `### ${groupLabel}\n`;
                ids.forEach(id => {
                    const desc = STANDARD_DESCRIPTIONS[id];
                    if (desc) {
                        md += `- ${desc}\n`;
                    } else {
                        // Fallback to the label from standards data
                        const universal = UNIVERSAL_STANDARDS.find(s => s.id === id);
                        const catStd = CATEGORY_STANDARDS[id];
                        md += `- ${universal?.label || catStd?.label || id}\n`;
                    }
                });
                md += `\n`;
            });
        }
        
        // === Section: Key Decisions ===
        const unresolvedDecisions = (scopeData.keyDecisions || []).filter(d => !d.resolved);
        if (unresolvedDecisions.length > 0) {
            md += `## Key Decisions to Resolve\n\n`;
            md += `These need answers before or during the first build session.\n\n`;
            unresolvedDecisions.forEach(d => {
                md += `- **${d.title}**`;
                if (d.description) md += ` — ${d.description}`;
                md += `\n`;
            });
            md += `\n`;
        }
        
        // === Section: Architecture Constraints ===
        md += `## Architecture Constraints\n\n`;
        md += `- Single-file HTML application — all CSS and JS inline in ${app.targetPath || 'index.html'}\n`;
        md += `- No build step, no bundler, no framework dependency (unless React via CDN)\n`;
        
        // Firebase if selected
        const hasFirebase = standards.some(s => s.startsWith('firebase-'));
        if (hasFirebase) {
            md += `- Firebase integration using the shared Game Shelf project\n`;
            md += `\n`;
            md += `### Firebase Config\n`;
            md += `\`\`\`javascript\n`;
            md += `const firebaseConfig = {\n`;
            md += `    apiKey: "AIzaSyBQVwn8vOrFTzLlm2MYIPBwgZV2xR9AuhM",\n`;
            md += `    authDomain: "word-boxing.firebaseapp.com",\n`;
            md += `    databaseURL: "https://word-boxing-default-rtdb.firebaseio.com",\n`;
            md += `    projectId: "word-boxing"\n`;
            md += `};\n`;
            md += `\`\`\`\n`;
        }
        
        // PWA if applicable
        if (app.hasServiceWorker) {
            md += `- Progressive Web App: include sw.js, manifest.json, and app icons\n`;
        }
        
        md += `\n`;
        
        // === Section: Command Center Integration ===
        md += `## Command Center Integration\n\n`;
        md += `### Required Meta Tags\n`;
        md += `\`\`\`html\n`;
        md += `<meta name="version" content="X.Y.Z">\n`;
        md += `<meta name="gs-app-id" content="${app.id}">\n`;
        md += `\`\`\`\n\n`;
        md += `### Version Management\n`;
        md += `Semver: bump patch for fixes, minor for features, major for breaking changes.\n`;
        md += `Command Center reads the version meta tag to track deployed versions.\n\n`;
        
        // Deploy package
        md += `### Deploy Package\n`;
        if (app.hasServiceWorker) {
            md += `- index.html (main app — single file, all CSS/JS inline)\n`;
            md += `- sw.js (service worker — CACHE_VERSION must match app version)\n`;
            md += `- manifest.json (PWA manifest with app name, icons, theme)\n`;
            md += `- icons/ folder (192px, 512px, maskable, apple-touch-icon)\n`;
        } else {
            md += `- index.html (main app — single file, all CSS/JS inline)\n`;
        }
        md += `- RELEASE_NOTES.txt (append new version notes each session)\n`;
        md += `\n`;
        
        // === Section: Session Protocol ===
        md += `## Session Protocol\n\n`;
        md += `### Starting a Session\n`;
        md += `1. Read SESSION_BRIEF.md for current versions and recent changes\n`;
        md += `2. Read CONTEXT.md for architecture and conventions\n`;
        md += `3. Review this document for scope and standards\n`;
        md += `4. Check RELEASE_NOTES.txt for what changed last\n\n`;
        
        md += `### Ending a Session\n`;
        md += `1. Bump version in all locations (meta tag, footer, sw.js if PWA)\n`;
        md += `2. Update RELEASE_NOTES.txt with changes made\n`;
        md += `3. Update CHANGELOG.md (Added / Changed / Fixed / Removed)\n`;
        md += `4. Produce deploy-ready files\n`;
        md += `5. Note any unfinished work for the next session\n`;
        
        md += `\n---\n`;
        md += `*Generated ${new Date().toLocaleDateString()} by Command Center v${document.querySelector('meta[name="version"]')?.content || '?'}*\n`;
        
        return md;
    }
    
    // =========================================================================
    // CONTEXT.md GENERATOR (Phase 3.2)
    // =========================================================================
    
    function generateContextMd(app, scopeData, config) {
        const cat = SCOPE_CATEGORIES[scopeData?.category];
        const answers = scopeData?.categoryAnswers || {};
        const standards = scopeData?.startingStandards || [];
        const prodRepo = app.repos?.prod || '';
        const testRepo = app.repos?.test || '';
        const ccVersion = document.querySelector('meta[name="version"]')?.content || '?';
        
        let md = `# ${app.name} — CONTEXT.md\n\n`;
        md += `> **Read this first** at the start of every session.\n\n`;
        
        // Current Version
        md += `## Current Version\n\n`;
        md += `**v0.1.0** — Released ${new Date().toLocaleDateString()}\n\n`;
        
        // What It Is
        md += `## What ${app.name} Is\n\n`;
        md += `${scopeData?.description || app.description || app.name + ' is a web application.'}\n\n`;
        
        // Architecture
        md += `## Architecture\n\n`;
        md += `- **Single-file HTML app**: All CSS/JS inline in ${app.targetPath || 'index.html'}\n`;
        
        // Framework from category
        if (scopeData?.category === 'game' || scopeData?.category === 'dashboard') {
            md += `- **Framework**: React via CDN (development recommended, switch to production for deploy)\n`;
        } else {
            md += `- **Framework**: Vanilla JS (or React via CDN if complexity warrants)\n`;
        }
        
        // Data layer from answers
        const hasFirebase = standards.some(s => s.startsWith('firebase-'));
        const usesLocalStorage = (answers.dataPersistence === 'localStorage') || 
            (scopeData?.category === 'game' && !answers.multiplayer);
        if (hasFirebase && usesLocalStorage) {
            md += `- **Data**: Firebase RTDB + localStorage (Firebase for shared/social data, localStorage for local settings/stats)\n`;
        } else if (hasFirebase) {
            md += `- **Data**: Firebase RTDB\n`;
        } else if (usesLocalStorage || scopeData?.category === 'game') {
            md += `- **Data**: localStorage\n`;
        } else {
            md += `- **Data**: localStorage (or Firebase if persistence scope expands)\n`;
        }
        
        // PWA
        md += `- **PWA**: ${app.hasServiceWorker ? 'Yes — sw.js + manifest.json' : 'No'}\n`;
        
        // Deploy target
        if (testRepo) {
            md += `- **Deploy target**: Test: https://${(testRepo).split('/')[0]}.github.io/${(testRepo).split('/')[1]}/ → Prod: https://${(prodRepo).split('/')[0]}.github.io/${(prodRepo).split('/')[1]}/\n`;
        } else if (prodRepo) {
            md += `- **Deploy target**: https://${(prodRepo).split('/')[0]}.github.io/${(prodRepo).split('/')[1]}/\n`;
        }
        md += `\n`;
        
        // Key Technical Details
        md += `## Key Technical Details\n\n`;
        
        // Meta Tags
        md += `### Meta Tags (Required)\n`;
        md += `\`\`\`html\n`;
        md += `<meta name="version" content="X.Y.Z">\n`;
        md += `<meta name="gs-app-id" content="${app.id}">\n`;
        md += `\`\`\`\n\n`;
        
        // Data Schema stubs
        md += `### Data Schema\n\n`;
        if (hasFirebase) {
            md += `Firebase paths (under \`word-boxing-default-rtdb\`):\n`;
            md += `\`\`\`\n`;
            if (standards.includes('firebase-auth')) {
                md += `users/{uid}/\n`;
                md += `  └── profile: { displayName, photoURL, lastLogin }\n`;
            }
            if (scopeData?.category === 'game') {
                md += `${app.id}/\n`;
                md += `  ├── puzzles/ (if server-driven puzzles)\n`;
                if (answers.multiplayer) {
                    md += `  ├── battles/ (matchmaking, results)\n`;
                    md += `  ├── leaderboard/ (rankings)\n`;
                }
                md += `  └── stats/{uid}/ (per-user stats)\n`;
            } else {
                md += `${app.id}/\n`;
                md += `  └── data/{uid}/ (per-user data)\n`;
            }
            md += `\`\`\`\n\n`;
        }
        
        if (usesLocalStorage || scopeData?.category === 'game') {
            md += `localStorage keys:\n`;
            md += `\`\`\`\n`;
            md += `${app.id}-settings    → { theme, ... }\n`;
            if (scopeData?.category === 'game') {
                md += `${app.id}-stats       → { gamesPlayed, gamesWon, streak, maxStreak, ... }\n`;
                md += `${app.id}-gameState   → { puzzleNumber, guesses, status, ... }\n`;
            } else {
                md += `${app.id}-data        → { ... }\n`;
            }
            md += `\`\`\`\n\n`;
        }
        
        // Key Components placeholder
        md += `### Key Components / Functions\n\n`;
        md += `*Update this section as the codebase develops. Map major components and what they do so Claude can navigate the code.*\n\n`;
        
        // Deployment
        md += `## Deployment\n\n`;
        md += `- **Prod Repo:** ${prodRepo || 'TBD'}\n`;
        if (testRepo) md += `- **Test Repo:** ${testRepo}\n`;
        if (app.subPath) md += `- **SubPath:** ${app.subPath}\n`;
        md += `- **Structure:** ${testRepo ? 'Dual (test → prod)' : 'Single repo'}\n`;
        md += `- **Deploy type:** ${app.hasServiceWorker ? 'PWA package (index.html + sw.js + manifest.json + icons/)' : 'Single HTML file'}\n`;
        md += `- **Deploy tool:** Command Center — deploy to test, verify, promote to prod\n\n`;
        
        // Conventions from standards
        md += `## Conventions\n\n`;
        
        // Pull key conventions from the starting standards
        const themeStds = standards.filter(s => ['css-variables', 'dark-light-toggle', 'theme-persistence'].includes(s));
        if (themeStds.length > 0) {
            md += `- **Theming:** CSS variables on \`:root\` and \`[data-theme="dark"]\`. Dark mode default, light mode toggle. Theme persisted in localStorage.\n`;
        }
        
        if (standards.includes('hamburger-menu')) {
            md += `- **Navigation:** Hamburger menu (☰) with settings panel\n`;
        }
        
        if (standards.includes('toast-system')) {
            md += `- **Notifications:** Custom toast system — no native alert/confirm/prompt\n`;
        }
        
        if (standards.includes('mobile-first')) {
            md += `- **Layout:** Mobile-first responsive design\n`;
        }
        
        // Category-specific conventions
        if (scopeData?.category === 'game') {
            md += `- **Game data:** Stats and game state in localStorage with daily reset at midnight UTC\n`;
            if (answers.shareResults) md += `- **Sharing:** navigator.share with clipboard fallback, emoji grid format\n`;
        }
        
        if (scopeData?.category === 'tool') {
            if (answers.primaryDataType) md += `- **Primary data:** ${answers.primaryDataType}\n`;
        }
        
        md += `\n`;
        
        // Recent Changes
        md += `## Recent Changes\n\n`;
        md += `**v0.1.0** — Initial seed generated by Command Center. App shell with placeholder content.\n`;
        
        md += `\n---\n`;
        md += `*Generated ${new Date().toLocaleDateString()} by Command Center v${ccVersion}*\n`;
        
        return md;
    }
    
    // =========================================================================
    // PROJECT_PLAN.md GENERATOR (Phase 3.2)
    // =========================================================================
    
    function generateProjectPlanMd(app, scopeData) {
        const ccVersion = document.querySelector('meta[name="version"]')?.content || '?';
        const coreFeatures = (scopeData?.v1Features || []).filter(f => f.priority === 'core');
        const niceFeatures = (scopeData?.v1Features || []).filter(f => f.priority === 'nice-to-have');
        const futureFeatures = scopeData?.futureFeatures || [];
        const unresolvedDecisions = (scopeData?.keyDecisions || []).filter(d => !d.resolved);
        const resolvedDecisions = (scopeData?.keyDecisions || []).filter(d => d.resolved);
        const answers = scopeData?.categoryAnswers || {};
        const cat = SCOPE_CATEGORIES[scopeData?.category];
        
        let md = `# ${app.name} — Project Plan\n\n`;
        
        // Mission
        md += `## Mission\n\n`;
        md += `${scopeData?.description || app.description || app.name + ' — purpose to be defined.'}\n\n`;
        
        // Completed Features
        md += `## Completed Features\n\n`;
        md += `*Nothing yet — this is a new project.*\n\n`;
        
        // In Progress
        md += `## In Progress\n\n`;
        md += `- [ ] Initial build from seed — implement core features from V1 scope below\n\n`;
        
        // Planned Features
        md += `## Planned Features\n\n`;
        
        if (coreFeatures.length > 0) {
            md += `### Phase 1: Core (Must Build)\n\n`;
            coreFeatures.forEach(f => {
                md += `- [ ] **${f.title}**`;
                if (f.description) md += ` — ${f.description}`;
                if (f.effort) md += ` _(${f.effort})_`;
                md += `\n`;
            });
            md += `\n`;
        }
        
        if (niceFeatures.length > 0) {
            md += `### Phase 2: Nice to Have\n\n`;
            niceFeatures.forEach(f => {
                md += `- [ ] **${f.title}**`;
                if (f.description) md += ` — ${f.description}`;
                md += `\n`;
            });
            md += `\n`;
        }
        
        if (futureFeatures.length > 0) {
            md += `### Future / Ideas\n\n`;
            futureFeatures.forEach(f => {
                md += `- [ ] **${f.title}**`;
                if (f.description) md += ` — ${f.description}`;
                md += `\n`;
            });
            md += `\n`;
        }
        
        // Architecture Decisions
        md += `## Architecture Decisions\n\n`;
        
        // Always-present decisions from the ecosystem
        md += `- **Single-file HTML**: All CSS/JS inline — no build step, no bundler. This is a Game Shelf ecosystem convention.\n`;
        md += `- **Deploy via Command Center**: GitHub Pages repos managed through CC. Test → prod promotion workflow.\n`;
        
        // Category-driven decisions
        if (scopeData?.category === 'game') {
            md += `- **Category: Game**: ${cat?.description || 'Game application'}\n`;
            if (answers.dailyReset) md += `- **Daily reset**: Midnight UTC, puzzle number derived from epoch date\n`;
            if (answers.scoringSystem && answers.scoringSystem !== 'none') md += `- **Scoring**: ${answers.scoringSystem}-based scoring with personal best tracking\n`;
            if (answers.difficultyModes && answers.difficultyModes !== 'none') md += `- **Difficulty**: ${answers.difficultyModes === 'easy-hard' ? 'Easy/Hard' : 'Multiple'} modes with separate statistics\n`;
        } else if (scopeData?.category === 'tool') {
            md += `- **Category: Tool**: ${cat?.description || 'Utility application'}\n`;
            if (answers.dataPersistence) md += `- **Data persistence**: ${answers.dataPersistence}\n`;
        } else if (scopeData?.category === 'dashboard') {
            md += `- **Category: Dashboard**: ${cat?.description || 'Data display application'}\n`;
            if (answers.layout) md += `- **Layout**: ${answers.layout} pattern\n`;
        } else if (scopeData?.category) {
            md += `- **Category: ${cat?.label || scopeData.category}**: ${cat?.description || ''}\n`;
        }
        
        // Resolved decisions from scoping
        if (resolvedDecisions.length > 0) {
            resolvedDecisions.forEach(d => {
                md += `- **${d.title}**`;
                if (d.description) md += ` — ${d.description}`;
                md += ` ✅\n`;
            });
        }
        
        md += `\n`;
        
        // Open Questions
        md += `## Open Questions\n\n`;
        if (unresolvedDecisions.length > 0) {
            unresolvedDecisions.forEach(d => {
                md += `- **${d.title}**`;
                if (d.description) md += ` — ${d.description}`;
                md += `\n`;
            });
        } else {
            md += `*No open questions from scoping. Add questions here as they arise during development.*\n`;
        }
        
        md += `\n---\n`;
        md += `*Generated ${new Date().toLocaleDateString()} by Command Center v${ccVersion}*\n`;
        
        return md;
    }
    
    // ProjectScopeModal — 3-step scoping flow (v8.37.0: removed Step 4 Standards)
    function ProjectScopeModal({ app, apps, onSave, onCancel, showAlert, config }) {
        const [step, setStep] = React.useState(1);
        
        // Step 1: Describe
        const [description, setDescription] = React.useState(app?.lifecycle?.scope?.description || '');
        const [category, setCategory] = React.useState(app?.lifecycle?.scope?.category || '');
        
        // Step 2: Category answers
        const [categoryAnswers, setCategoryAnswers] = React.useState(() => {
            if (app?.lifecycle?.scope?.categoryAnswers) return { ...app.lifecycle.scope.categoryAnswers };
            // Initialize defaults from category questions
            const defaults = {};
            if (category && CATEGORY_QUESTIONS[category]) {
                CATEGORY_QUESTIONS[category].forEach(q => {
                    defaults[q.id] = q.default;
                });
            }
            return defaults;
        });
        
        // Step 3: Features
        const [v1Features, setV1Features] = React.useState(app?.lifecycle?.scope?.v1Features || []);
        const [futureFeatures, setFutureFeatures] = React.useState(app?.lifecycle?.scope?.futureFeatures || []);
        const [keyDecisions, setKeyDecisions] = React.useState(app?.lifecycle?.scope?.keyDecisions || []);
        const [featuresGenerated, setFeaturesGenerated] = React.useState(false);
        
        // Standards (auto-assembled silently — no user step)
        const [startingStandards, setStartingStandards] = React.useState(app?.lifecycle?.scope?.startingStandards || []);
        
        // New feature/decision forms
        const [newFeatureTitle, setNewFeatureTitle] = React.useState('');
        const [newFutureTitle, setNewFutureTitle] = React.useState('');
        const [newDecisionTitle, setNewDecisionTitle] = React.useState('');
        
        // Re-initialize defaults when category changes
        React.useEffect(() => {
            if (category && CATEGORY_QUESTIONS[category]) {
                const existingAnswers = app?.lifecycle?.scope?.categoryAnswers || {};
                const defaults = {};
                CATEGORY_QUESTIONS[category].forEach(q => {
                    defaults[q.id] = existingAnswers[q.id] !== undefined ? existingAnswers[q.id] : q.default;
                });
                // Migrate old dashboard questions: autoRefresh + realtime → dataUpdates
                if (category === 'dashboard' && !existingAnswers.dataUpdates) {
                    if (existingAnswers.realtime) defaults.dataUpdates = 'realtime';
                    else if (existingAnswers.autoRefresh) defaults.dataUpdates = 'periodic';
                    else defaults.dataUpdates = 'manual';
                }
                // Migrate old tool.settingsPersistence → derived from dataPersistence
                setCategoryAnswers(defaults);
            }
        }, [category]);
        
        // Auto-generate features when moving from step 2 → 3
        // Auto-assemble standards when moving from step 2 → 3
        const handleStep2Next = () => {
            if (!featuresGenerated) {
                const generated = generateFeaturesFromScope(category, categoryAnswers);
                if (v1Features.length === 0) {
                    setV1Features(generated);
                }
                setFeaturesGenerated(true);
            }
            setStep(3);
        };
        
        // Add feature
        const addV1Feature = () => {
            if (!newFeatureTitle.trim()) return;
            setV1Features(prev => [...prev, { title: newFeatureTitle.trim(), description: '', priority: 'core', effort: 'session' }]);
            setNewFeatureTitle('');
        };
        
        const addFutureFeature = () => {
            if (!newFutureTitle.trim()) return;
            setFutureFeatures(prev => [...prev, { title: newFutureTitle.trim(), description: '' }]);
            setNewFutureTitle('');
        };
        
        const addKeyDecision = () => {
            if (!newDecisionTitle.trim()) return;
            setKeyDecisions(prev => [...prev, { title: newDecisionTitle.trim(), description: '', resolved: false }]);
            setNewDecisionTitle('');
        };
        
        const removeV1Feature = (idx) => setV1Features(prev => prev.filter((_, i) => i !== idx));
        const removeFutureFeature = (idx) => setFutureFeatures(prev => prev.filter((_, i) => i !== idx));
        const removeKeyDecision = (idx) => setKeyDecisions(prev => prev.filter((_, i) => i !== idx));
        
        const updateV1Feature = (idx, field, value) => {
            setV1Features(prev => prev.map((f, i) => i === idx ? { ...f, [field]: value } : f));
        };
        
        // Final save — standards auto-assembled silently
        const handleSave = () => {
            const autoStandards = assembleStartingStandards(category, categoryAnswers);
            const scope = {
                description,
                category,
                categoryAnswers,
                v1Features,
                futureFeatures,
                keyDecisions,
                startingStandards: autoStandards,
                scopedAt: new Date().toISOString(),
                scopedBy: config?.ownerName || 'Owner',
                source: 'manual'
            };
            onSave(scope);
        };
        
        // Render question input based on type
        const renderQuestion = (q) => {
            const value = categoryAnswers[q.id];
            
            if (q.type === 'toggle') {
                return (
                    <label key={q.id} className="flex items-center justify-between p-3 bg-slate-700/50 rounded-lg hover:bg-slate-700 cursor-pointer">
                        <div className="flex-1 pr-4">
                            <div className="text-sm font-medium flex items-center gap-1.5">
                                {q.label}
                                {q.drives && (
                                    <span className="relative group inline-flex">
                                        <span className="text-slate-500 hover:text-slate-300 cursor-help text-xs">ⓘ</span>
                                        <span className="absolute bottom-full left-1/2 -translate-x-1/2 mb-1.5 px-2.5 py-1.5 bg-slate-900 border border-slate-600 rounded text-[11px] text-slate-300 whitespace-nowrap opacity-0 group-hover:opacity-100 pointer-events-none transition-opacity z-10 shadow-lg">{q.drives}</span>
                                    </span>
                                )}
                            </div>
                        </div>
                        <div className="relative">
                            <input type="checkbox" className="sr-only" checked={!!value}
                                onChange={e => setCategoryAnswers(prev => ({ ...prev, [q.id]: e.target.checked }))} />
                            <div className={`w-11 h-6 rounded-full transition-colors ${value ? 'bg-indigo-600' : 'bg-slate-600'}`}>
                                <div className={`w-5 h-5 bg-white rounded-full shadow transform transition-transform mt-0.5 ${value ? 'translate-x-5.5 ml-[22px]' : 'translate-x-0.5 ml-[2px]'}`} />
                            </div>
                        </div>
                    </label>
                );
            }
            
            if (q.type === 'select') {
                return (
                    <div key={q.id} className="p-3 bg-slate-700/50 rounded-lg">
                        <div className="text-sm font-medium mb-1 flex items-center gap-1.5">
                            {q.label}
                            {q.drives && (
                                <span className="relative group inline-flex">
                                    <span className="text-slate-500 hover:text-slate-300 cursor-help text-xs">ⓘ</span>
                                    <span className="absolute bottom-full left-1/2 -translate-x-1/2 mb-1.5 px-2.5 py-1.5 bg-slate-900 border border-slate-600 rounded text-[11px] text-slate-300 whitespace-nowrap opacity-0 group-hover:opacity-100 pointer-events-none transition-opacity z-10 shadow-lg">{q.drives}</span>
                                </span>
                            )}
                        </div>
                        <select value={value !== undefined ? value : q.default}
                            onChange={e => {
                                let val = e.target.value;
                                // Handle boolean selects (multiItem)
                                if (val === 'true') val = true;
                                if (val === 'false') val = false;
                                setCategoryAnswers(prev => ({ ...prev, [q.id]: val }));
                            }}
                            className="w-full bg-slate-800 border border-slate-600 rounded px-3 py-1.5 text-sm">
                            {q.options.map((opt, oi) => <option key={String(opt)} value={opt}>{q.optionLabels?.[oi] || opt}</option>)}
                        </select>
                    </div>
                );
            }
            
            if (q.type === 'multi-select') {
                const selected = value || q.default || [];
                return (
                    <div key={q.id} className="p-3 bg-slate-700/50 rounded-lg">
                        <div className="text-sm font-medium mb-1 flex items-center gap-1.5">
                            {q.label}
                            {q.drives && (
                                <span className="relative group inline-flex">
                                    <span className="text-slate-500 hover:text-slate-300 cursor-help text-xs">ⓘ</span>
                                    <span className="absolute bottom-full left-1/2 -translate-x-1/2 mb-1.5 px-2.5 py-1.5 bg-slate-900 border border-slate-600 rounded text-[11px] text-slate-300 whitespace-nowrap opacity-0 group-hover:opacity-100 pointer-events-none transition-opacity z-10 shadow-lg">{q.drives}</span>
                                </span>
                            )}
                        </div>
                        <div className="flex flex-wrap gap-2">
                            {q.options.map((opt, oi) => (
                                <button key={opt}
                                    onClick={() => {
                                        const next = selected.includes(opt) ? selected.filter(s => s !== opt) : [...selected, opt];
                                        setCategoryAnswers(prev => ({ ...prev, [q.id]: next }));
                                    }}
                                    className={`px-3 py-1 rounded text-xs font-medium transition-colors ${
                                        selected.includes(opt) ? 'bg-indigo-600 text-white' : 'bg-slate-800 text-slate-400 hover:bg-slate-600'
                                    }`}>
                                    {q.optionLabels?.[oi] || opt}
                                </button>
                            ))}
                        </div>
                    </div>
                );
            }
            
            if (q.type === 'text') {
                return (
                    <div key={q.id} className="p-3 bg-slate-700/50 rounded-lg">
                        <div className="text-sm font-medium mb-1 flex items-center gap-1.5">
                            {q.label}
                            {q.drives && (
                                <span className="relative group inline-flex">
                                    <span className="text-slate-500 hover:text-slate-300 cursor-help text-xs">ⓘ</span>
                                    <span className="absolute bottom-full left-1/2 -translate-x-1/2 mb-1.5 px-2.5 py-1.5 bg-slate-900 border border-slate-600 rounded text-[11px] text-slate-300 whitespace-nowrap opacity-0 group-hover:opacity-100 pointer-events-none transition-opacity z-10 shadow-lg">{q.drives}</span>
                                </span>
                            )}
                        </div>
                        <input value={value || ''}
                            onChange={e => setCategoryAnswers(prev => ({ ...prev, [q.id]: e.target.value }))}
                            placeholder={q.placeholder}
                            className="w-full bg-slate-800 border border-slate-600 rounded px-3 py-1.5 text-sm" />
                    </div>
                );
            }
            
            return null;
        };
        
        return (
            <div className="fixed inset-0 bg-black/70 flex items-start justify-center z-50 overflow-y-auto p-4 pt-8">
                <div className="bg-slate-800 rounded-xl border border-slate-700 w-full max-w-3xl shadow-2xl">
                    {/* Header */}
                    <div className="flex items-center justify-between p-5 border-b border-slate-700">
                        <div>
                            <h2 className="text-lg font-bold flex items-center gap-2">
                                🎯 Project Scoping {app?.name ? `— ${app.icon || ''} ${app.name}` : ''}
                            </h2>
                            <p className="text-xs text-slate-400 mt-1">Define what to build → get a prioritized feature list and work items ready for Claude.</p>
                        </div>
                        <button onClick={onCancel} className="text-slate-400 hover:text-white text-xl">✕</button>
                    </div>
                    
                    {/* Progress Steps */}
                    <div className="flex items-center gap-2 px-5 py-3 bg-slate-900/50">
                        {[
                            { n: 1, label: 'Describe' },
                            { n: 2, label: 'Clarify' },
                            { n: 3, label: 'Features' }
                        ].map((s, i) => (
                            <React.Fragment key={s.n}>
                                <button onClick={() => { if (s.n < step) setStep(s.n); }}
                                    className={`flex items-center gap-1.5 px-3 py-1.5 rounded-lg text-xs font-medium transition-colors ${
                                        step === s.n ? 'bg-indigo-600 text-white' : step > s.n ? 'bg-green-600/20 text-green-400 cursor-pointer hover:bg-green-600/30' : 'bg-slate-800 text-slate-500'
                                    }`}>
                                    {step > s.n ? '✓' : s.n} {s.label}
                                </button>
                                {i < 2 && <div className={`flex-1 h-px ${step > s.n ? 'bg-green-600' : 'bg-slate-700'}`} />}
                            </React.Fragment>
                        ))}
                    </div>
                    
                    {/* Content */}
                    <div className="p-5 max-h-[60vh] overflow-y-auto">
                        
                        {/* Step 1: Describe */}
                        {step === 1 && (
                            <div className="space-y-4">
                                <div>
                                    <label className="block text-sm font-medium mb-2">What does this app do? Who is it for? What problem does it solve?</label>
                                    <textarea value={description} onChange={e => setDescription(e.target.value)}
                                        rows={4} placeholder="A daily word puzzle where players uncover a hidden quote by guessing letters..."
                                        className="w-full bg-slate-900 border border-slate-600 rounded-lg px-4 py-3 text-sm focus:border-indigo-500 focus:outline-none resize-none" />
                                    <p className="text-xs text-slate-500 mt-1">3-5 sentences describing purpose, audience, and core concept</p>
                                </div>
                                
                                <div>
                                    <label className="block text-sm font-medium mb-2">App Category</label>
                                    <div className="grid grid-cols-5 gap-2">
                                        {Object.entries(SCOPE_CATEGORIES).map(([id, cat]) => (
                                            <button key={id}
                                                onClick={() => setCategory(id)}
                                                className={`p-3 rounded-lg border text-center transition-all ${
                                                    category === id 
                                                        ? 'border-indigo-500 bg-indigo-500/15 ring-1 ring-indigo-500/50' 
                                                        : 'border-slate-600 hover:border-slate-500 bg-slate-700/30'
                                                }`}>
                                                <div className="text-2xl mb-1">{cat.icon}</div>
                                                <div className="text-xs font-medium">{cat.label}</div>
                                            </button>
                                        ))}
                                    </div>
                                </div>
                            </div>
                        )}
                        
                        {/* Step 2: Clarify */}
                        {step === 2 && (
                            <div>
                                <div className="flex items-center gap-2 mb-4">
                                    <span className="text-xl">{SCOPE_CATEGORIES[category]?.icon}</span>
                                    <h3 className="font-semibold">{SCOPE_CATEGORIES[category]?.label} Questions</h3>
                                </div>
                                <div className="space-y-2">
                                    {(CATEGORY_QUESTIONS[category] || []).map(q => renderQuestion(q))}
                                </div>
                            </div>
                        )}
                        
                        {/* Step 3: Features */}
                        {step === 3 && (
                            <div className="space-y-6">
                                {/* Launch Features */}
                                <div>
                                    <h3 className="font-semibold text-sm mb-2 flex items-center gap-2">
                                        🎯 Launch Features <span className="text-xs font-normal text-slate-400">must ship</span>
                                        <span className="text-xs px-2 py-0.5 bg-slate-700 rounded-full">{v1Features.length}</span>
                                    </h3>
                                    <div className="space-y-2 mb-3">
                                        {v1Features.map((f, idx) => (
                                            <div key={idx} className="bg-slate-700/50 rounded-lg p-3">
                                                <div className="flex items-start justify-between gap-2">
                                                    <div className="flex-1">
                                                        <input value={f.title} onChange={e => updateV1Feature(idx, 'title', e.target.value)}
                                                            className="w-full bg-transparent text-sm font-medium border-none outline-none" />
                                                        <input value={f.description || ''} onChange={e => updateV1Feature(idx, 'description', e.target.value)}
                                                            placeholder="Brief description..."
                                                            className="w-full bg-transparent text-xs text-slate-400 border-none outline-none mt-1" />
                                                    </div>
                                                    <div className="flex items-center gap-2 shrink-0">
                                                        <select value={f.priority} onChange={e => updateV1Feature(idx, 'priority', e.target.value)}
                                                            className="bg-slate-800 border border-slate-600 rounded px-2 py-1 text-xs">
                                                            <option value="core">Must have</option>
                                                            <option value="nice-to-have">Nice to have</option>
                                                            <option value="out-of-scope">Not now</option>
                                                        </select>
                                                        <select value={f.effort} onChange={e => updateV1Feature(idx, 'effort', e.target.value)}
                                                            className="bg-slate-800 border border-slate-600 rounded px-2 py-1 text-xs">
                                                            <option value="quick">Quick</option>
                                                            <option value="session">Session</option>
                                                            <option value="multi-session">Multi-session</option>
                                                            <option value="epic">Epic</option>
                                                        </select>
                                                        <button onClick={() => removeV1Feature(idx)} className="text-slate-500 hover:text-red-400 text-xs">✕</button>
                                                    </div>
                                                </div>
                                            </div>
                                        ))}
                                    </div>
                                    <div className="flex gap-2">
                                        <input value={newFeatureTitle} onChange={e => setNewFeatureTitle(e.target.value)}
                                            onKeyDown={e => e.key === 'Enter' && addV1Feature()}
                                            placeholder="Add a V1 feature..."
                                            className="flex-1 bg-slate-700 border border-slate-600 rounded px-3 py-1.5 text-sm" />
                                        <button onClick={addV1Feature} disabled={!newFeatureTitle.trim()}
                                            className="px-3 py-1.5 bg-indigo-600 hover:bg-indigo-500 disabled:bg-slate-700 disabled:text-slate-500 rounded text-sm">
                                            Add
                                        </button>
                                    </div>
                                </div>
                                
                                {/* Future Features */}
                                <div>
                                    <h3 className="font-semibold text-sm mb-2 flex items-center gap-2">
                                        🔮 Future Features <span className="text-xs font-normal text-slate-400">V2+ — inform architecture, don't build yet</span>
                                        <span className="text-xs px-2 py-0.5 bg-slate-700 rounded-full">{futureFeatures.length}</span>
                                    </h3>
                                    <div className="space-y-1 mb-3">
                                        {futureFeatures.map((f, idx) => (
                                            <div key={idx} className="flex items-center gap-2 bg-slate-700/30 rounded px-3 py-2">
                                                <span className="flex-1 text-sm text-slate-300">{f.title}</span>
                                                <button onClick={() => removeFutureFeature(idx)} className="text-slate-500 hover:text-red-400 text-xs">✕</button>
                                            </div>
                                        ))}
                                    </div>
                                    <div className="flex gap-2">
                                        <input value={newFutureTitle} onChange={e => setNewFutureTitle(e.target.value)}
                                            onKeyDown={e => e.key === 'Enter' && addFutureFeature()}
                                            placeholder="Add a future feature idea..."
                                            className="flex-1 bg-slate-700 border border-slate-600 rounded px-3 py-1.5 text-sm" />
                                        <button onClick={addFutureFeature} disabled={!newFutureTitle.trim()}
                                            className="px-3 py-1.5 bg-slate-600 hover:bg-slate-500 disabled:bg-slate-700 disabled:text-slate-500 rounded text-sm">
                                            Add
                                        </button>
                                    </div>
                                </div>
                                
                                {/* Key Decisions */}
                                <div>
                                    <h3 className="font-semibold text-sm mb-2 flex items-center gap-2">
                                        🤔 Key Decisions <span className="text-xs font-normal text-slate-400">resolve before or during Session 1</span>
                                        <span className="text-xs px-2 py-0.5 bg-slate-700 rounded-full">{keyDecisions.length}</span>
                                    </h3>
                                    <div className="space-y-1 mb-3">
                                        {keyDecisions.map((d, idx) => (
                                            <div key={idx} className="flex items-center gap-2 bg-amber-900/10 border border-amber-800/30 rounded px-3 py-2">
                                                <span className="text-amber-400 text-xs">❓</span>
                                                <span className="flex-1 text-sm text-slate-300">{d.title}</span>
                                                <button onClick={() => removeKeyDecision(idx)} className="text-slate-500 hover:text-red-400 text-xs">✕</button>
                                            </div>
                                        ))}
                                    </div>
                                    <div className="flex gap-2">
                                        <input value={newDecisionTitle} onChange={e => setNewDecisionTitle(e.target.value)}
                                            onKeyDown={e => e.key === 'Enter' && addKeyDecision()}
                                            placeholder="Add a key decision to resolve..."
                                            className="flex-1 bg-slate-700 border border-slate-600 rounded px-3 py-1.5 text-sm" />
                                        <button onClick={addKeyDecision} disabled={!newDecisionTitle.trim()}
                                            className="px-3 py-1.5 bg-amber-700 hover:bg-amber-600 disabled:bg-slate-700 disabled:text-slate-500 rounded text-sm">
                                            Add
                                        </button>
                                    </div>
                                </div>
                            </div>
                        )}
                    </div>
                    
                    {/* Footer */}
                    <div className="flex items-center justify-between p-5 border-t border-slate-700">
                        <button onClick={() => step > 1 ? setStep(step - 1) : onCancel()}
                            className="px-4 py-2 text-sm text-slate-400 hover:text-white transition-colors">
                            {step > 1 ? '← Back' : 'Cancel'}
                        </button>
                        
                        <div className="flex items-center gap-3">
                            {step === 3 && (
                                <span className="text-xs text-slate-400">
                                    Will generate {v1Features.length + futureFeatures.length + keyDecisions.length} work items
                                </span>
                            )}
                            
                            {step < 3 ? (
                                <button onClick={() => {
                                        if (step === 1) { if (!description.trim() || !category) return; setStep(2); }
                                        else if (step === 2) handleStep2Next();
                                    }}
                                    disabled={step === 1 && (!description.trim() || !category)}
                                    className="px-6 py-2 bg-indigo-600 hover:bg-indigo-500 disabled:bg-slate-700 disabled:text-slate-500 rounded-lg text-sm font-medium transition-colors">
                                    Next →
                                </button>
                            ) : (
                                <button onClick={handleSave}
                                    className="px-6 py-2 bg-green-600 hover:bg-green-500 rounded-lg text-sm font-medium transition-colors flex items-center gap-2">
                                    ✅ Save Scope & Generate Work Items
                                </button>
                            )}
                        </div>
                    </div>
                </div>
            </div>
        );
    }
    
    // =========================================================================
    // BACKLOG VIEW - Work Item Tracking & Project Planning (v8.22.0)
    // =========================================================================
    
    function WorkItemEditModal({ item, apps, isNew, onSave, onCancel, globalStreams }) {
        const configuredApps = Object.values(apps).filter(a => a.testRepo || a.prodRepo);
        
        const [formData, setFormData] = React.useState({
            appId: item?.appId || configuredApps[0]?.id || '',
            streamId: item?.streamId || null,  // Phase 5.3: stream assignment
            title: item?.title || '',
            description: item?.description || '',
            type: item?.type || 'feature',
            priority: item?.priority || 'core',
            status: item?.status || 'idea',
            effort: item?.effort || 'session',
            criteria: item?.criteria || [],
            context: {
                filesAffected: item?.context?.filesAffected || [],
                sections: item?.context?.sections || [],
                dependencies: item?.context?.dependencies || [],
                notes: item?.context?.notes || '',
                relatedItems: item?.context?.relatedItems || []
            },
            tags: item?.tags || [],
            source: item?.source || 'manual'
        });
        
        const [newCriterion, setNewCriterion] = React.useState('');
        const [newTag, setNewTag] = React.useState('');
        const [showContext, setShowContext] = React.useState(false);
        
        const update = (field, value) => setFormData(prev => ({ ...prev, [field]: value }));
        
        const addCriterion = () => {
            if (!newCriterion.trim()) return;
            update('criteria', [...formData.criteria, newCriterion.trim()]);
            setNewCriterion('');
        };
        
        const removeCriterion = (idx) => {
            update('criteria', formData.criteria.filter((_, i) => i !== idx));
        };
        
        const addTag = () => {
            if (!newTag.trim()) return;
            update('tags', [...formData.tags, newTag.trim()]);
            setNewTag('');
        };
        
        const removeTag = (idx) => {
            update('tags', formData.tags.filter((_, i) => i !== idx));
        };
        
        const handleSave = () => {
            if (!formData.title.trim()) return;
            if (!formData.appId) return;
            onSave(formData);
        };
        
        const typeOptions = [
            { value: 'feature', label: '✨ Feature', color: 'bg-indigo-900/50 text-indigo-300' },
            { value: 'bugfix', label: '🐛 Bugfix', color: 'bg-red-900/50 text-red-300' },
            { value: 'enhancement', label: '💎 Enhancement', color: 'bg-purple-900/50 text-purple-300' },
            { value: 'chore', label: '🔧 Chore', color: 'bg-slate-700 text-slate-300' },
            { value: 'research', label: '🔍 Research', color: 'bg-amber-900/50 text-amber-300' }
        ];
        
        const priorityOptions = [
            { value: 'core', label: 'Must Have', color: 'bg-red-900/50 text-red-300' },
            { value: 'nice-to-have', label: 'Nice to Have', color: 'bg-amber-900/50 text-amber-300' }
        ];
        
        const statusOptions = [
            { value: 'idea', label: '💡 Idea' },
            { value: 'ready', label: '📋 Ready' },
            { value: 'in-progress', label: '🔨 In Progress' },
            { value: 'review', label: '📝 In Review' },
            { value: 'done', label: '✅ Done' },
            { value: 'deferred', label: '⏸️ Deferred' }
        ];
        
        const effortOptions = [
            { value: 'quick', label: '⚡ Quick (<30 min)' },
            { value: 'session', label: '🕐 Session (1–2 hrs, one Claude chat)' },
            { value: 'multi-session', label: '📅 Multi-Session' },
            { value: 'epic', label: '🏔️ Epic' }
        ];
        
        return (
            <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50 p-4" onClick={onCancel}>
                <div className="bg-slate-800 rounded-xl border border-slate-700 w-full max-w-2xl max-h-[90vh] overflow-y-auto" onClick={e => e.stopPropagation()}>
                    <div className="p-6">
                        <div className="flex items-center justify-between mb-6">
                            <h2 className="text-xl font-bold">{isNew ? '➕ New Work Item' : `✏️ Edit ${item?.id || ''}`}</h2>
                            <button onClick={onCancel} className="text-slate-400 hover:text-white text-xl">✕</button>
                        </div>
                        
                        {/* App + Title */}
                        <div className="grid grid-cols-[200px_1fr] gap-3 mb-4">
                            <div>
                                <label className="text-xs text-slate-400 block mb-1">App</label>
                                <select value={formData.appId} onChange={e => { update('appId', e.target.value); update('streamId', null); }}
                                    className="w-full bg-slate-700 border border-slate-600 rounded px-3 py-2 text-sm">
                                    {configuredApps.map(a => (
                                        <option key={a.id} value={a.id}>{a.icon} {a.name}</option>
                                    ))}
                                </select>
                            </div>
                            <div>
                                <label className="text-xs text-slate-400 block mb-1">Title *</label>
                                <input value={formData.title} onChange={e => update('title', e.target.value)}
                                    placeholder="What needs to be done?"
                                    className="w-full bg-slate-700 border border-slate-600 rounded px-3 py-2 text-sm"
                                    autoFocus />
                            </div>
                        </div>
                        
                        {/* Stream assignment (Phase 5.3) */}
                        {globalStreams && (() => {
                            const appStreams = (globalStreams || []).filter(s => s.appId === formData.appId);
                            if (appStreams.length === 0) return null;
                            return (
                                <div className="mb-4">
                                    <label className="text-xs text-slate-400 block mb-1">Work Stream</label>
                                    <select value={formData.streamId || ''} onChange={e => update('streamId', e.target.value || null)}
                                        className="w-full bg-slate-700 border border-slate-600 rounded px-3 py-2 text-sm">
                                        <option value="">No stream (unassigned)</option>
                                        {appStreams.map(s => (
                                            <option key={s.id} value={s.id}>🔀 {s.name} ({s.status})</option>
                                        ))}
                                    </select>
                                </div>
                            );
                        })()}
                        
                        {/* Description */}
                        <div className="mb-4">
                            <label className="text-xs text-slate-400 block mb-1">Description</label>
                            <textarea value={formData.description} onChange={e => update('description', e.target.value)}
                                placeholder="Detailed description of the work..."
                                rows={3}
                                className="w-full bg-slate-700 border border-slate-600 rounded px-3 py-2 text-sm resize-y" />
                        </div>
                        
                        {/* Type + Priority + Status + Effort */}
                        <div className="grid grid-cols-2 sm:grid-cols-4 gap-3 mb-4">
                            <div>
                                <label className="text-xs text-slate-400 block mb-1">Type</label>
                                <select value={formData.type} onChange={e => update('type', e.target.value)}
                                    className="w-full bg-slate-700 border border-slate-600 rounded px-3 py-2 text-sm">
                                    {typeOptions.map(o => <option key={o.value} value={o.value}>{o.label}</option>)}
                                </select>
                            </div>
                            <div>
                                <label className="text-xs text-slate-400 block mb-1">Priority</label>
                                <select value={formData.priority} onChange={e => update('priority', e.target.value)}
                                    className="w-full bg-slate-700 border border-slate-600 rounded px-3 py-2 text-sm">
                                    {priorityOptions.map(o => <option key={o.value} value={o.value}>{o.label}</option>)}
                                </select>
                            </div>
                            <div>
                                <label className="text-xs text-slate-400 block mb-1">Status</label>
                                <select value={formData.status} onChange={e => update('status', e.target.value)}
                                    className="w-full bg-slate-700 border border-slate-600 rounded px-3 py-2 text-sm">
                                    {statusOptions.map(o => <option key={o.value} value={o.value}>{o.label}</option>)}
                                </select>
                            </div>
                            <div>
                                <label className="text-xs text-slate-400 block mb-1">Effort</label>
                                <select value={formData.effort} onChange={e => update('effort', e.target.value)}
                                    className="w-full bg-slate-700 border border-slate-600 rounded px-3 py-2 text-sm">
                                    {effortOptions.map(o => <option key={o.value} value={o.value}>{o.label}</option>)}
                                </select>
                            </div>
                        </div>
                        
                        {/* Acceptance Criteria */}
                        <div className="mb-4">
                            <label className="text-xs text-slate-400 block mb-1">Acceptance Criteria <span className="text-slate-600">— describe what a user should experience</span></label>
                            {formData.criteria.length > 0 && (
                                <div className="space-y-1 mb-2">
                                    {formData.criteria.map((c, i) => (
                                        <div key={i} className="flex items-center gap-2 text-sm bg-slate-700/50 rounded px-3 py-1.5">
                                            <span className="text-slate-500">☐</span>
                                            <span className="flex-1">{c}</span>
                                            <button onClick={() => removeCriterion(i)} className="text-slate-500 hover:text-red-400 text-xs">✕</button>
                                        </div>
                                    ))}
                                </div>
                            )}
                            <div className="flex gap-2">
                                <input value={newCriterion} onChange={e => setNewCriterion(e.target.value)}
                                    onKeyDown={e => e.key === 'Enter' && addCriterion()}
                                    placeholder="What should a user see or be able to do? e.g. 'Score updates immediately after each guess, displayed as ★ 450'"
                                    className="flex-1 bg-slate-700 border border-slate-600 rounded px-3 py-1.5 text-sm" />
                                <button onClick={addCriterion} className="px-3 py-1.5 bg-slate-600 hover:bg-slate-500 rounded text-sm">+</button>
                            </div>
                        </div>
                        
                        {/* Tags */}
                        <div className="mb-4">
                            <label className="text-xs text-slate-400 block mb-1">Tags</label>
                            <div className="flex flex-wrap gap-1 mb-2">
                                {formData.tags.map((t, i) => (
                                    <span key={i} className="inline-flex items-center gap-1 px-2 py-0.5 bg-slate-600 rounded text-xs">
                                        {t}
                                        <button onClick={() => removeTag(i)} className="text-slate-400 hover:text-red-400">✕</button>
                                    </span>
                                ))}
                            </div>
                            <div className="flex gap-2">
                                <input value={newTag} onChange={e => setNewTag(e.target.value)}
                                    onKeyDown={e => e.key === 'Enter' && addTag()}
                                    placeholder="Add tag..."
                                    className="flex-1 bg-slate-700 border border-slate-600 rounded px-3 py-1.5 text-sm" />
                                <button onClick={addTag} className="px-3 py-1.5 bg-slate-600 hover:bg-slate-500 rounded text-sm">+</button>
                            </div>
                        </div>
                        
                        {/* Context (collapsible) */}
                        <div className="mb-6">
                            <button onClick={() => setShowContext(!showContext)}
                                className="text-xs text-slate-400 hover:text-white flex items-center gap-1">
                                <span className={`transform transition-transform ${showContext ? 'rotate-90' : ''}`}>▶</span>
                                Context & Dependencies
                            </button>
                            {showContext && (
                                <div className="mt-2 space-y-3 pl-4 border-l border-slate-700">
                                    <div>
                                        <label className="text-xs text-slate-400 block mb-1">Files Affected (comma-separated)</label>
                                        <input value={formData.context.filesAffected.join(', ')}
                                            onChange={e => setFormData(prev => ({
                                                ...prev,
                                                context: { ...prev.context, filesAffected: e.target.value.split(',').map(s => s.trim()).filter(Boolean) }
                                            }))}
                                            placeholder="index.html, sw.js"
                                            className="w-full bg-slate-700 border border-slate-600 rounded px-3 py-1.5 text-sm" />
                                    </div>
                                    <div>
                                        <label className="text-xs text-slate-400 block mb-1">Sections (comma-separated)</label>
                                        <input value={formData.context.sections.join(', ')}
                                            onChange={e => setFormData(prev => ({
                                                ...prev,
                                                context: { ...prev.context, sections: e.target.value.split(',').map(s => s.trim()).filter(Boolean) }
                                            }))}
                                            placeholder="DashboardView, WorkItemService"
                                            className="w-full bg-slate-700 border border-slate-600 rounded px-3 py-1.5 text-sm" />
                                    </div>
                                    <div>
                                        <label className="text-xs text-slate-400 block mb-1">Dependencies (comma-separated)</label>
                                        <input value={formData.context.dependencies.join(', ')}
                                            onChange={e => setFormData(prev => ({
                                                ...prev,
                                                context: { ...prev.context, dependencies: e.target.value.split(',').map(s => s.trim()).filter(Boolean) }
                                            }))}
                                            placeholder="WI-001, WI-003"
                                            className="w-full bg-slate-700 border border-slate-600 rounded px-3 py-1.5 text-sm" />
                                    </div>
                                    <div>
                                        <label className="text-xs text-slate-400 block mb-1">Notes</label>
                                        <textarea value={formData.context.notes}
                                            onChange={e => setFormData(prev => ({
                                                ...prev,
                                                context: { ...prev.context, notes: e.target.value }
                                            }))}
                                            rows={2}
                                            placeholder="Additional context..."
                                            className="w-full bg-slate-700 border border-slate-600 rounded px-3 py-1.5 text-sm resize-y" />
                                    </div>
                                </div>
                            )}
                        </div>
                        
                        {/* Actions */}
                        <div className="flex justify-end gap-3">
                            <button onClick={onCancel} className="px-4 py-2 text-sm text-slate-400 hover:text-white">Cancel</button>
                            <button onClick={handleSave} disabled={!formData.title.trim() || !formData.appId}
                                className="px-6 py-2 bg-indigo-600 hover:bg-indigo-500 disabled:opacity-40 rounded-lg text-sm font-medium">
                                {isNew ? 'Create Work Item' : 'Save Changes'}
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        );
    }
    
    function BacklogView({ apps, showAlert, showConfirm, showPrompt, setView, config, globalStreams }) {
        const [workItems, setWorkItems] = React.useState([]);
        const [firebaseUser, setFirebaseUser] = React.useState(null);
        const [loading, setLoading] = React.useState(true);
        const [showEditModal, setShowEditModal] = React.useState(null); // null | { item, isNew }
        const [showScopeModal, setShowScopeModal] = React.useState(null); // null | { app }
        const [statusFilter, setStatusFilter] = React.useState('active'); // 'all', 'active', 'idea', 'ready', 'in-progress', 'done', 'deferred'
        const [typeFilter, setTypeFilter] = React.useState('all');
        const [appFilter, setAppFilter] = React.useState('all');
        const [searchQuery, setSearchQuery] = React.useState('');
        const [sortBy, setSortBy] = React.useState('priority'); // 'priority', 'status', 'created', 'effort', 'type'
        const [groupBy, setGroupBy] = React.useState('app'); // 'app', 'status', 'type', 'stream', 'none'
        const [selectedItems, setSelectedItems] = React.useState(new Set());
        
        const configuredApps = Object.values(apps).filter(a => a.testRepo || a.prodRepo);
        
        // Firebase listener
        React.useEffect(() => {
            if (!firebaseAuth) return;
            let unsub = () => {};
            const authUnsub = firebaseAuth.onAuthStateChanged((u) => {
                setFirebaseUser(u);
                if (u) {
                    setLoading(true);
                    unsub = WorkItemService.listen(u.uid, (list) => {
                        setWorkItems(list);
                        setLoading(false);
                    });
                }
            });
            return () => { authUnsub(); unsub(); };
        }, []);
        
        // Generate next ID
        const getNextId = () => WorkItemService.getNextId(workItems);
        
        // CRUD operations
        const createItem = async (data) => {
            if (!firebaseUser) return;
            const id = getNextId();
            await WorkItemService.create(firebaseUser.uid, { ...data, id });
            setShowEditModal(null);
            showAlert(`Created ${id}: ${data.title}`, 'success');
        };
        
        const updateItem = async (data) => {
            if (!firebaseUser || !showEditModal?.item?.id) return;
            const id = showEditModal.item.id;
            const originalItem = showEditModal.item;
            
            // === Phase 3.3: Idea → Ready auto-suggest ===
            // When criteria are added to an idea-status item, suggest promoting to ready
            const hadCriteria = originalItem.criteria && originalItem.criteria.length > 0 && originalItem.criteria.some(c => c.trim());
            const hasCriteriaNow = data.criteria && data.criteria.length > 0 && data.criteria.some(c => c.trim());
            const isIdea = originalItem.status === 'idea';
            const statusUnchanged = data.status === 'idea' || data.status === originalItem.status;
            
            if (isIdea && !hadCriteria && hasCriteriaNow && statusUnchanged) {
                await WorkItemService.update(firebaseUser.uid, id, data);
                setShowEditModal(null);
                // Ask about promotion after modal closes
                setTimeout(async () => {
                    const confirmed = await showConfirm(
                        `${id} now has acceptance criteria.\n\nPromote from Idea → Ready?`,
                        '📋 Ready for Work?'
                    );
                    if (confirmed) {
                        await WorkItemService.updateStatus(firebaseUser.uid, id, 'ready');
                        const actor = config?.ownerName || 'Owner';
                        ActivityLogService.logItemTransition(firebaseUser.uid, actor, '', id, data.title, 'idea', 'ready').catch(() => {});
                        showAlert(`${id} promoted to Ready`, 'success');
                    }
                }, 300);
            } else {
                await WorkItemService.update(firebaseUser.uid, id, data);
                setShowEditModal(null);
                showAlert(`Updated ${id}`, 'success');
            }
        };
        
        const deleteItem = async (item) => {
            if (!firebaseUser) return;
            const confirmed = await showConfirm(`Delete ${item.id}: ${item.title}?`);
            if (!confirmed) return;
            await WorkItemService.delete(firebaseUser.uid, item.id);
            showAlert(`Deleted ${item.id}`, 'success');
        };
        
        const transitionStatus = async (item, newStatus) => {
            if (!firebaseUser) return;
            await WorkItemService.updateStatus(firebaseUser.uid, item.id, newStatus);
        };
        
        const bulkUpdateStatus = async (newStatus) => {
            if (!firebaseUser || selectedItems.size === 0) return;
            const confirmed = await showConfirm(`Change ${selectedItems.size} item(s) to "${newStatus}"?`);
            if (!confirmed) return;
            for (const id of selectedItems) {
                await WorkItemService.updateStatus(firebaseUser.uid, id, newStatus);
            }
            setSelectedItems(new Set());
            showAlert(`Updated ${selectedItems.size} items`, 'success');
        };
        
        // Copy for Claude
        const copyForClaude = (item) => {
            const app = configuredApps.find(a => a.id === item.appId);
            const text = `## Work Item ${item.id}: ${item.title}

**App:** ${app?.name || item.appId}
**Type:** ${item.type} | **Priority:** ${item.priority} | **Effort:** ${item.effort}
**Status:** ${item.status}

### Description
${item.description || 'N/A'}

### Acceptance Criteria
${item.criteria?.length > 0 ? item.criteria.map((c, i) => `${i + 1}. ${c}`).join('\n') : 'None specified'}
${item.context?.filesAffected?.length > 0 ? `\n### Files Affected\n${item.context.filesAffected.join(', ')}` : ''}
${item.context?.notes ? `\n### Notes\n${item.context.notes}` : ''}
---
When complete, note: "Completes ${item.id}" in deploy notes.`;
            
            navigator.clipboard.writeText(text);
            showAlert(`Copied ${item.id} for Claude`, 'success');
        };
        
        // Handle scope save — store scope on app and generate work items
        const handleScopeSave = async (scope) => {
            if (!firebaseUser || !showScopeModal?.app) return;
            const appId = showScopeModal.app.id;
            
            try {
                // Store scope data at app.lifecycle.scope in Firebase
                const scopeRef = firebaseDb.ref(`command-center/${firebaseUser.uid}/appScopes/${appId}`);
                await scopeRef.set(scope);
                
                // Generate work items from scope
                const itemsToCreate = [];
                const existingIds = workItems.map(i => parseInt(i.id?.replace('WI-', '') || '0'));
                let nextNum = Math.max(0, ...existingIds) + 1;
                
                // V1 features → work items
                scope.v1Features.forEach(f => {
                    itemsToCreate.push({
                        id: `WI-${String(nextNum++).padStart(3, '0')}`,
                        appId: appId,
                        title: f.title,
                        description: f.description || '',
                        type: 'feature',
                        priority: f.priority || 'core',
                        status: f.priority === 'out-of-scope' ? 'deferred' : 'ready',
                        effort: f.effort || 'session',
                        source: 'scoped',
                        tags: ['scoped', `v1-${f.priority}`]
                    });
                });
                
                // Future features → idea work items
                scope.futureFeatures.forEach(f => {
                    itemsToCreate.push({
                        id: `WI-${String(nextNum++).padStart(3, '0')}`,
                        appId: appId,
                        title: f.title,
                        description: f.description || '',
                        type: 'feature',
                        priority: 'nice-to-have',
                        status: 'idea',
                        effort: 'multi-session',
                        source: 'scoped',
                        tags: ['scoped', 'v2-future']
                    });
                });
                
                // Key decisions → research work items
                scope.keyDecisions.forEach(d => {
                    if (!d.resolved) {
                        itemsToCreate.push({
                            id: `WI-${String(nextNum++).padStart(3, '0')}`,
                            appId: appId,
                            title: `Decision: ${d.title}`,
                            description: d.description || 'Resolve before or during Session 1',
                            type: 'research',
                            priority: 'core',
                            status: 'ready',
                            effort: 'quick',
                            source: 'scoped',
                            tags: ['scoped', 'decision']
                        });
                    }
                });
                
                if (itemsToCreate.length > 0) {
                    await WorkItemService.createBatch(firebaseUser.uid, itemsToCreate);
                }
                
                setShowScopeModal(null);
                showAlert(`Scope saved for ${showScopeModal.app.name} — created ${itemsToCreate.length} work items`, 'success');
            } catch (e) {
                showAlert(`Error saving scope: ${e.message}`, 'error');
            }
        };
        
        // Filtering & sorting
        const priorityOrder = { 'core': 0, 'nice-to-have': 1, 'out-of-scope': 2 };
        const statusOrder = { 'in-progress': 0, 'ready': 1, 'idea': 2, 'deferred': 3, 'done': 4 };
        const effortOrder = { 'quick': 0, 'session': 1, 'multi-session': 2, 'epic': 3 };
        
        const filteredItems = React.useMemo(() => {
            let items = [...workItems];
            
            // Status filter
            if (statusFilter === 'active') {
                items = items.filter(i => ['idea', 'ready', 'in-progress', 'review'].includes(i.status));
            } else if (statusFilter !== 'all') {
                items = items.filter(i => i.status === statusFilter);
            }
            
            // Type filter
            if (typeFilter !== 'all') {
                items = items.filter(i => i.type === typeFilter);
            }
            
            // App filter
            if (appFilter !== 'all') {
                items = items.filter(i => i.appId === appFilter);
            }
            
            // Search
            if (searchQuery.trim()) {
                const q = searchQuery.toLowerCase();
                items = items.filter(i =>
                    i.title?.toLowerCase().includes(q) ||
                    i.description?.toLowerCase().includes(q) ||
                    i.id?.toLowerCase().includes(q) ||
                    i.tags?.some(t => t.toLowerCase().includes(q))
                );
            }
            
            // Sort
            items.sort((a, b) => {
                switch (sortBy) {
                    case 'priority': return (priorityOrder[a.priority] || 9) - (priorityOrder[b.priority] || 9);
                    case 'status': return (statusOrder[a.status] || 9) - (statusOrder[b.status] || 9);
                    case 'effort': return (effortOrder[a.effort] || 9) - (effortOrder[b.effort] || 9);
                    case 'type': return (a.type || '').localeCompare(b.type || '');
                    case 'created': return new Date(b.createdAt || 0) - new Date(a.createdAt || 0);
                    default: return 0;
                }
            });
            
            return items;
        }, [workItems, statusFilter, typeFilter, appFilter, searchQuery, sortBy]);
        
        // Grouping
        const groupedItems = React.useMemo(() => {
            if (groupBy === 'none') return { 'All Items': filteredItems };
            
            const groups = {};
            filteredItems.forEach(item => {
                let key;
                switch (groupBy) {
                    case 'app': {
                        const app = configuredApps.find(a => a.id === item.appId);
                        key = app ? `${app.icon} ${app.name}` : item.appId || 'Unassigned';
                        break;
                    }
                    case 'status': key = item.status || 'unknown'; break;
                    case 'type': key = item.type || 'unknown'; break;
                    case 'stream': {
                        const stream = (globalStreams || []).find(s => s.id === item.streamId);
                        key = stream ? `🔀 ${stream.name}` : '📋 Unassigned';
                        break;
                    }
                    default: key = 'All';
                }
                if (!groups[key]) groups[key] = [];
                groups[key].push(item);
            });
            return groups;
        }, [filteredItems, groupBy, configuredApps, globalStreams]);
        
        // Stats
        const stats = React.useMemo(() => {
            const all = workItems;
            return {
                total: all.length,
                idea: all.filter(i => i.status === 'idea').length,
                ready: all.filter(i => i.status === 'ready').length,
                inProgress: all.filter(i => i.status === 'in-progress').length,
                review: all.filter(i => i.status === 'review').length,
                done: all.filter(i => i.status === 'done').length,
                deferred: all.filter(i => i.status === 'deferred').length,
                stale: all.filter(i => WorkItemService.isStale(i)).length,
            };
        }, [workItems]);
        
        // Toggle selection
        const toggleSelect = (id) => {
            setSelectedItems(prev => {
                const next = new Set(prev);
                if (next.has(id)) next.delete(id); else next.add(id);
                return next;
            });
        };
        
        const selectAll = () => {
            if (selectedItems.size === filteredItems.length) {
                setSelectedItems(new Set());
            } else {
                setSelectedItems(new Set(filteredItems.map(i => i.id)));
            }
        };
        
        // Status badge component
        const StatusBadge = ({ status }) => {
            const styles = {
                'idea': 'bg-slate-600 text-slate-300',
                'ready': 'bg-blue-900/50 text-blue-300',
                'in-progress': 'bg-amber-900/50 text-amber-300',
                'review': 'bg-purple-900/50 text-purple-300',
                'done': 'bg-green-900/50 text-green-300',
                'deferred': 'bg-slate-700 text-slate-400'
            };
            const icons = { 'idea': '💡', 'ready': '📋', 'in-progress': '🔨', 'review': '📝', 'done': '✅', 'deferred': '⏸️' };
            return (
                <span className={`px-2 py-0.5 rounded text-xs ${styles[status] || 'bg-slate-600 text-slate-300'}`}>
                    {icons[status] || ''} {status}
                </span>
            );
        };
        
        const TypeBadge = ({ type }) => {
            const styles = {
                'feature': 'bg-indigo-900/50 text-indigo-300',
                'bugfix': 'bg-red-900/50 text-red-300',
                'enhancement': 'bg-purple-900/50 text-purple-300',
                'chore': 'bg-slate-700 text-slate-300',
                'research': 'bg-amber-900/50 text-amber-300'
            };
            const icons = { 'feature': '✨', 'bugfix': '🐛', 'enhancement': '💎', 'chore': '🔧', 'research': '🔍' };
            return (
                <span className={`px-2 py-0.5 rounded text-xs ${styles[type] || 'bg-slate-600'}`}>
                    {icons[type] || ''} {type}
                </span>
            );
        };
        
        const PriorityBadge = ({ priority }) => {
            const styles = {
                'core': 'bg-red-900/30 text-red-300 border border-red-800/50',
                'nice-to-have': 'bg-amber-900/30 text-amber-300 border border-amber-800/50',
                'out-of-scope': 'bg-slate-700/50 text-slate-400 border border-slate-600'
            };
            const labels = { 'core': 'Must have', 'nice-to-have': 'Nice to have', 'out-of-scope': 'Not now' };
            return <span className={`px-2 py-0.5 rounded text-xs ${styles[priority] || ''}`}>{labels[priority] || priority}</span>;
        };
        
        const EffortBadge = ({ effort }) => {
            const icons = { 'quick': '⚡', 'session': '🕐', 'multi-session': '📅', 'epic': '🏔️' };
            return <span className="text-xs text-slate-500">{icons[effort] || ''} {effort}</span>;
        };
        
        // Quick status transitions
        const getNextStatuses = (current) => {
            const transitions = {
                'idea': ['ready', 'deferred'],
                'ready': ['in-progress', 'deferred'],
                'in-progress': ['review', 'done', 'deferred'],
                'review': ['done', 'in-progress'],
                'done': ['ready'],
                'deferred': ['idea', 'ready']
            };
            return transitions[current] || [];
        };
        
        if (!firebaseUser && !loading) {
            return (
                <div className="text-center py-20">
                    <div className="text-4xl mb-4">🔐</div>
                    <h2 className="text-xl font-bold mb-2">Sign in Required</h2>
                    <p className="text-slate-400 text-sm">Backlog requires Firebase authentication. Sign in via Settings.</p>
                    <button onClick={() => setView('settings')} className="mt-4 px-4 py-2 bg-indigo-600 rounded-lg text-sm">
                        Go to Settings
                    </button>
                </div>
            );
        }
        
        return (
            <div>
                {/* Header */}
                <div className="flex items-center justify-between mb-6">
                    <div>
                        <h1 className="text-2xl font-bold flex items-center gap-2">📋 Backlog</h1>
                        <p className="text-sm text-slate-400 mt-1">
                            {stats.total} items — {stats.inProgress} in progress, {stats.review > 0 ? `${stats.review} in review, ` : ''}{stats.ready} ready, {stats.idea} ideas
                        </p>
                    </div>
                    <div className="flex gap-2">
                        <div className="relative group">
                            <button className="px-4 py-2 bg-slate-700 hover:bg-slate-600 rounded-lg text-sm font-medium flex items-center gap-2">
                                🎯 Scope Work ▾
                            </button>
                            <div className="absolute right-0 top-full mt-1 bg-slate-800 border border-slate-700 rounded-lg shadow-xl opacity-0 invisible group-hover:opacity-100 group-hover:visible transition-all z-50 min-w-[200px]">
                                {configuredApps.map(a => (
                                    <button key={a.id} onClick={() => setShowScopeModal({ app: a })}
                                        className="w-full text-left px-4 py-2 text-sm text-slate-300 hover:bg-slate-700 first:rounded-t-lg last:rounded-b-lg flex items-center gap-2">
                                        <span>{a.icon || '📦'}</span> {a.name}
                                    </button>
                                ))}
                                {configuredApps.length === 0 && (
                                    <div className="px-4 py-2 text-xs text-slate-500">No apps configured</div>
                                )}
                            </div>
                        </div>
                        <button onClick={() => setShowEditModal({ item: null, isNew: true })}
                            className="px-4 py-2 bg-indigo-600 hover:bg-indigo-500 rounded-lg text-sm font-medium flex items-center gap-2">
                            ➕ New Work Item
                        </button>
                    </div>
                </div>
                
                {/* Stats Bar */}
                {stats.total > 0 && (
                    <div className="flex gap-2 mb-4 flex-wrap">
                        {[
                            { label: 'Active', value: stats.idea + stats.ready + stats.inProgress + stats.review, filter: 'active', color: 'bg-indigo-600' },
                            { label: 'Ideas', value: stats.idea, filter: 'idea', color: 'bg-slate-600' },
                            { label: 'Ready', value: stats.ready, filter: 'ready', color: 'bg-blue-600' },
                            { label: 'In Progress', value: stats.inProgress, filter: 'in-progress', color: 'bg-amber-600' },
                            { label: 'In Review', value: stats.review, filter: 'review', color: 'bg-purple-600' },
                            { label: 'Done', value: stats.done, filter: 'done', color: 'bg-green-600' },
                            { label: 'Deferred', value: stats.deferred, filter: 'deferred', color: 'bg-slate-500' },
                        ].map(s => (
                            <button key={s.filter} onClick={() => setStatusFilter(statusFilter === s.filter ? 'all' : s.filter)}
                                className={`px-3 py-1.5 rounded-lg text-xs font-medium flex items-center gap-2 transition-colors ${
                                    statusFilter === s.filter ? `${s.color} text-white` : 'bg-slate-800 text-slate-400 hover:bg-slate-700'
                                }`}>
                                {s.label} <span className="font-bold">{s.value}</span>
                            </button>
                        ))}
                    </div>
                )}
                
                {/* Filters Bar */}
                <div className="flex flex-wrap items-center gap-3 mb-4 bg-slate-800/50 rounded-lg p-3">
                    <div className="flex-1 min-w-[200px]">
                        <input value={searchQuery} onChange={e => setSearchQuery(e.target.value)}
                            placeholder="🔍 Search items..."
                            className="w-full bg-slate-700 border border-slate-600 rounded px-3 py-1.5 text-sm" />
                    </div>
                    <select value={appFilter} onChange={e => setAppFilter(e.target.value)}
                        className="bg-slate-700 border border-slate-600 rounded px-3 py-1.5 text-sm">
                        <option value="all">All Apps</option>
                        {configuredApps.map(a => <option key={a.id} value={a.id}>{a.icon} {a.name}</option>)}
                    </select>
                    <select value={typeFilter} onChange={e => setTypeFilter(e.target.value)}
                        className="bg-slate-700 border border-slate-600 rounded px-3 py-1.5 text-sm">
                        <option value="all">All Types</option>
                        <option value="feature">✨ Feature</option>
                        <option value="bugfix">🐛 Bugfix</option>
                        <option value="enhancement">💎 Enhancement</option>
                        <option value="chore">🔧 Chore</option>
                        <option value="research">🔍 Research</option>
                    </select>
                    <select value={sortBy} onChange={e => setSortBy(e.target.value)}
                        className="bg-slate-700 border border-slate-600 rounded px-3 py-1.5 text-sm">
                        <option value="priority">Sort: Priority</option>
                        <option value="status">Sort: Status</option>
                        <option value="effort">Sort: Effort</option>
                        <option value="type">Sort: Type</option>
                        <option value="created">Sort: Newest</option>
                    </select>
                    <select value={groupBy} onChange={e => setGroupBy(e.target.value)}
                        className="bg-slate-700 border border-slate-600 rounded px-3 py-1.5 text-sm">
                        <option value="app">Group: App</option>
                        <option value="stream">Group: Stream</option>
                        <option value="status">Group: Status</option>
                        <option value="type">Group: Type</option>
                        <option value="none">No Grouping</option>
                    </select>
                </div>
                
                {/* Bulk Actions */}
                {selectedItems.size > 0 && (
                    <div className="flex items-center gap-3 mb-4 bg-indigo-900/20 border border-indigo-700/50 rounded-lg p-3">
                        <span className="text-sm font-medium">{selectedItems.size} selected</span>
                        <div className="flex gap-2">
                            <button onClick={() => bulkUpdateStatus('ready')} className="px-3 py-1 bg-blue-600 rounded text-xs">→ Ready</button>
                            <button onClick={() => bulkUpdateStatus('in-progress')} className="px-3 py-1 bg-amber-600 rounded text-xs">→ In Progress</button>
                            <button onClick={() => bulkUpdateStatus('done')} className="px-3 py-1 bg-green-600 rounded text-xs">→ Done</button>
                            <button onClick={() => bulkUpdateStatus('deferred')} className="px-3 py-1 bg-slate-600 rounded text-xs">→ Deferred</button>
                        </div>
                        <button onClick={() => setSelectedItems(new Set())} className="text-xs text-slate-400 hover:text-white ml-auto">Clear</button>
                    </div>
                )}
                
                {/* Content */}
                {loading ? (
                    <div className="text-center py-20">
                        <div className="w-8 h-8 border-2 border-indigo-500 border-t-transparent rounded-full animate-spin mx-auto mb-4" />
                        <p className="text-slate-400">Loading backlog...</p>
                    </div>
                ) : filteredItems.length === 0 ? (
                    <div className="text-center py-20">
                        <div className="text-4xl mb-4">{workItems.length === 0 ? '📋' : '🔍'}</div>
                        <h2 className="text-lg font-bold mb-2">{workItems.length === 0 ? 'Backlog is empty' : 'No items match filters'}</h2>
                        <p className="text-slate-400 text-sm mb-4">
                            {workItems.length === 0 ? 'Create your first work item to start tracking.' : 'Try adjusting your filters.'}
                        </p>
                        {workItems.length === 0 && (
                            <button onClick={() => setShowEditModal({ item: null, isNew: true })}
                                className="px-4 py-2 bg-indigo-600 hover:bg-indigo-500 rounded-lg text-sm">
                                ➕ Create First Item
                            </button>
                        )}
                    </div>
                ) : (
                    <div className="space-y-6">
                        {Object.entries(groupedItems).map(([groupName, items]) => (
                            <div key={groupName}>
                                {groupBy !== 'none' && (
                                    <div className="flex items-center gap-2 mb-3">
                                        <h3 className="text-sm font-bold text-slate-300 capitalize">{groupName}</h3>
                                        <span className="text-xs text-slate-500 bg-slate-700 px-2 py-0.5 rounded-full">{items.length}</span>
                                    </div>
                                )}
                                <div className="space-y-2">
                                    {items.map(item => {
                                        const app = configuredApps.find(a => a.id === item.appId);
                                        const isSelected = selectedItems.has(item.id);
                                        const nextStatuses = getNextStatuses(item.status);
                                        
                                        return (
                                            <div key={item.id} className={`bg-slate-800 rounded-lg border transition-colors ${
                                                isSelected ? 'border-indigo-500 bg-indigo-900/10' : 'border-slate-700 hover:border-slate-600'
                                            }`}>
                                                <div className="p-3">
                                                    <div className="flex items-start gap-3">
                                                        {/* Checkbox */}
                                                        <button onClick={() => toggleSelect(item.id)}
                                                            className={`mt-1 w-4 h-4 rounded border flex-shrink-0 flex items-center justify-center text-xs ${
                                                                isSelected ? 'bg-indigo-600 border-indigo-500 text-white' : 'border-slate-500 hover:border-slate-400'
                                                            }`}>
                                                            {isSelected && '✓'}
                                                        </button>
                                                        
                                                        {/* Main content */}
                                                        <div className="flex-1 min-w-0">
                                                            <div className="flex items-center gap-2 mb-1 flex-wrap">
                                                                <span className="text-xs text-slate-500 font-mono">{item.id}</span>
                                                                <TypeBadge type={item.type} />
                                                                <PriorityBadge priority={item.priority} />
                                                                <StatusBadge status={item.status} />
                                                                <EffortBadge effort={item.effort} />
                                                                {WorkItemService.isStale(item) && (
                                                                    <span className="px-1.5 py-0.5 rounded text-xs bg-red-900/40 text-red-400 border border-red-800/50" title={`${WorkItemService.getStaleDays(item)} days in ${item.status}`}>
                                                                        ⚠ {WorkItemService.getStaleDays(item)}d stale
                                                                    </span>
                                                                )}
                                                                {groupBy !== 'app' && app && (
                                                                    <span className="text-xs text-slate-500">{app.icon} {app.name}</span>
                                                                )}
                                                                {groupBy !== 'stream' && item.streamId && (() => {
                                                                    const stream = (globalStreams || []).find(s => s.id === item.streamId);
                                                                    return stream ? <span className="text-xs text-indigo-400/70">🔀 {stream.name}</span> : null;
                                                                })()}
                                                                {item.source && item.source !== 'manual' && (
                                                                    <span className="text-xs text-slate-600 italic">{item.source}</span>
                                                                )}
                                                            </div>
                                                            <h4 className="font-medium text-sm">{item.title}</h4>
                                                            {item.description && (
                                                                <p className="text-xs text-slate-400 mt-1 line-clamp-2">{item.description}</p>
                                                            )}
                                                            {item.criteria?.length > 0 && (
                                                                <div className="text-xs text-slate-500 mt-1">
                                                                    ☐ {item.criteria.length} acceptance criteria
                                                                </div>
                                                            )}
                                                            {item.tags?.length > 0 && (
                                                                <div className="flex gap-1 mt-1">
                                                                    {item.tags.map((t, i) => (
                                                                        <span key={i} className="text-xs px-1.5 py-0.5 bg-slate-700 rounded text-slate-400">{t}</span>
                                                                    ))}
                                                                </div>
                                                            )}
                                                        </div>
                                                        
                                                        {/* Actions */}
                                                        <div className="flex items-center gap-1 flex-shrink-0">
                                                            {/* Quick status transitions */}
                                                            {nextStatuses.map(ns => (
                                                                <button key={ns} onClick={() => transitionStatus(item, ns)}
                                                                    title={`→ ${ns}`}
                                                                    className="p-1.5 rounded hover:bg-slate-700 text-xs text-slate-400 hover:text-white">
                                                                    {ns === 'ready' && '📋'}
                                                                    {ns === 'in-progress' && '🔨'}
                                                                    {ns === 'done' && '✅'}
                                                                    {ns === 'deferred' && '⏸️'}
                                                                    {ns === 'idea' && '💡'}
                                                                </button>
                                                            ))}
                                                            <div className="w-px h-4 bg-slate-700 mx-1" />
                                                            <button onClick={() => copyForClaude(item)} title="Copy for Claude"
                                                                className="p-1.5 rounded hover:bg-slate-700 text-xs text-slate-400 hover:text-white">📋</button>
                                                            <button onClick={() => setShowEditModal({ item, isNew: false })} title="Edit"
                                                                className="p-1.5 rounded hover:bg-slate-700 text-xs text-slate-400 hover:text-white">✏️</button>
                                                            <button onClick={() => deleteItem(item)} title="Delete"
                                                                className="p-1.5 rounded hover:bg-slate-700 text-xs text-slate-400 hover:text-red-400">🗑️</button>
                                                        </div>
                                                    </div>
                                                </div>
                                            </div>
                                        );
                                    })}
                                </div>
                            </div>
                        ))}
                    </div>
                )}
                
                {/* Select all shortcut */}
                {filteredItems.length > 0 && (
                    <div className="mt-4 text-center">
                        <button onClick={selectAll} className="text-xs text-slate-500 hover:text-slate-300">
                            {selectedItems.size === filteredItems.length ? 'Deselect all' : `Select all ${filteredItems.length} items`}
                        </button>
                    </div>
                )}
                
                {/* Edit Modal */}
                {showEditModal && (
                    <WorkItemEditModal
                        item={showEditModal.item}
                        apps={apps}
                        isNew={showEditModal.isNew}
                        onSave={showEditModal.isNew ? createItem : updateItem}
                        onCancel={() => setShowEditModal(null)}
                        globalStreams={globalStreams || []}
                    />
                )}
                
                {/* Scope Modal */}
                {showScopeModal && (
                    <ProjectScopeModal
                        app={showScopeModal.app}
                        apps={apps}
                        onSave={handleScopeSave}
                        onCancel={() => setShowScopeModal(null)}
                        showAlert={showAlert}
                        config={config}
                    />
                )}
            </div>
        );
    }
    
    // =========================================================================
    // RELEASE COORDINATION VIEW — Phase 4.4 + 4.5
    // Answers: "Is this version ready to ship?"
    // Shows completion %, blocked items, go/no-go summary, test checklists
    // =========================================================================
    // WorkStreamsView — Named, owned, parallel tracks of work (Phase 5.2)
    // =========================================================================
    
    function WorkStreamsView({ apps, config, globalWorkItems, globalStreams, globalInterfaces, globalDependencies, globalDependencyAlerts, showAlert, showConfirm, showPrompt, setView }) {
        const [selectedApp, setSelectedApp] = React.useState('all');
        const [editingStream, setEditingStream] = React.useState(null); // null, 'new', or stream object
        const [firebaseUser, setFirebaseUser] = React.useState(null);
        
        React.useEffect(() => {
            if (firebaseAuth) {
                return firebaseAuth.onAuthStateChanged(u => setFirebaseUser(u));
            }
        }, []);
        
        const actor = config?._userName || 'Owner';
        const appList = Object.values(apps).filter(a => a.id !== 'command-center').sort((a, b) => (a.name || '').localeCompare(b.name || ''));
        
        const filteredStreams = selectedApp === 'all' 
            ? globalStreams 
            : WorkStreamService.filterByApp(globalStreams, selectedApp);
        
        // Group streams by app
        const streamsByApp = {};
        filteredStreams.forEach(s => {
            const key = s.appId || 'unassigned';
            if (!streamsByApp[key]) streamsByApp[key] = [];
            streamsByApp[key].push(s);
        });
        
        // Get unassigned items count per app
        const getUnassignedCount = (appId) => {
            return WorkItemService.getUnassigned(globalWorkItems, appId).length;
        };
        
        const handleCreateStream = async (streamData) => {
            if (!firebaseUser) return;
            const id = WorkStreamService.getNextId(globalStreams);
            await WorkStreamService.create(firebaseUser.uid, { ...streamData, id, createdBy: actor });
            ActivityLogService.log(firebaseUser.uid, {
                appId: streamData.appId,
                streamId: id,
                actor,
                action: 'stream_create',
                summary: `${actor} created stream "${streamData.name}" for ${apps[streamData.appId]?.name || streamData.appId}`,
                metadata: { streamId: id }
            }).catch(() => {});
            setEditingStream(null);
        };
        
        const handleUpdateStream = async (streamId, updates) => {
            if (!firebaseUser) return;
            await WorkStreamService.update(firebaseUser.uid, streamId, updates);
        };
        
        const handleDeleteStream = async (stream) => {
            if (!firebaseUser) return;
            const itemCount = WorkItemService.filterByStream(globalWorkItems, stream.id).length;
            const msg = itemCount > 0 
                ? `Delete stream "${stream.name}"? ${itemCount} work item(s) will become unassigned.`
                : `Delete stream "${stream.name}"?`;
            showConfirm(msg, '🗑️ Delete Stream', async () => {
                // Unassign work items from this stream
                if (itemCount > 0) {
                    const items = WorkItemService.filterByStream(globalWorkItems, stream.id);
                    for (const item of items) {
                        await WorkItemService.update(firebaseUser.uid, item.id, { streamId: null });
                    }
                }
                await WorkStreamService.delete(firebaseUser.uid, stream.id);
                ActivityLogService.log(firebaseUser.uid, {
                    appId: stream.appId,
                    actor,
                    action: 'stream_delete',
                    summary: `${actor} deleted stream "${stream.name}"`,
                    metadata: { streamId: stream.id }
                }).catch(() => {});
            });
        };
        
        const handleStatusChange = async (stream, newStatus) => {
            if (!firebaseUser) return;
            await WorkStreamService.updateStatus(firebaseUser.uid, stream.id, newStatus);
            ActivityLogService.log(firebaseUser.uid, {
                appId: stream.appId,
                streamId: stream.id,
                actor,
                action: 'stream_status',
                summary: `${actor} changed "${stream.name}" to ${newStatus}`,
                metadata: { fromStatus: stream.status, toStatus: newStatus }
            }).catch(() => {});
        };
        
        // Assign work items to stream
        const handleAssignItems = async (stream) => {
            if (!firebaseUser) return;
            const unassigned = WorkItemService.getUnassigned(globalWorkItems, stream.appId);
            if (unassigned.length === 0) {
                showAlert('No unassigned work items for this app.', '📋 No Items');
                return;
            }
            // For now, show a confirm with list and assign all unassigned
            const names = unassigned.slice(0, 10).map(i => `• ${i.title}`).join('\n');
            const more = unassigned.length > 10 ? `\n...and ${unassigned.length - 10} more` : '';
            showConfirm(
                `Assign ${unassigned.length} unassigned item(s) to "${stream.name}"?\n\n${names}${more}`,
                `📋 Assign to ${stream.name}`,
                async () => {
                    for (const item of unassigned) {
                        await WorkItemService.update(firebaseUser.uid, item.id, { streamId: stream.id });
                    }
                    showAlert(`${unassigned.length} item(s) assigned to "${stream.name}".`, '✅ Assigned');
                }
            );
        };
        
        // Phase 5.4: Resolve a dependency alert
        const handleResolveAlert = async (alert, resolution) => {
            if (!firebaseUser) return;
            const actor = config?.ownerName || 'Owner';
            try {
                await DependencyAlertService.resolve(firebaseUser.uid, alert.id, resolution, actor);
                
                // If resolved as 'updated', also mark the dependency as 'verified'
                if (resolution === 'updated') {
                    await DependencyService.update(firebaseUser.uid, alert.dependencyId, {
                        status: 'verified',
                        lastVerified: new Date().toISOString(),
                        lastVerifiedBy: actor
                    });
                }
                
                showAlert(`Alert resolved: ${resolution === 'updated' ? 'Updated' : 'No impact'}.`, '✅ Resolved');
            } catch (e) {
                showAlert(`Error: ${e.message}`, 'error');
            }
        };
        
        // Pending alerts count for summary stats
        const totalPendingAlerts = DependencyAlertService.getPending(globalDependencyAlerts || []).length;
        
        const statusColors = {
            active: 'bg-green-900/30 text-green-400 border-green-800/50',
            paused: 'bg-yellow-900/30 text-yellow-400 border-yellow-800/50',
            blocked: 'bg-red-900/30 text-red-400 border-red-800/50',
            complete: 'bg-slate-700/30 text-slate-400 border-slate-600/50'
        };
        
        const statusIcons = { active: '🟢', paused: '⏸️', blocked: '🔴', complete: '✅' };
        
        return (
            <div className="max-w-6xl mx-auto">
                <div className="flex items-center justify-between mb-6">
                    <div>
                        <h2 className="text-xl font-bold flex items-center gap-2">🔀 Work Streams</h2>
                        <p className="text-sm text-slate-400 mt-1">Named, owned, parallel tracks of work. Different people run AI sessions against different streams.</p>
                    </div>
                    <div className="flex items-center gap-3">
                        <select value={selectedApp} onChange={e => setSelectedApp(e.target.value)}
                            className="bg-slate-800 border border-slate-600 rounded px-3 py-1.5 text-sm">
                            <option value="all">All Apps</option>
                            {appList.map(a => (
                                <option key={a.id} value={a.id}>{a.icon === 'gs-logo' ? '🎮' : a.icon} {a.name}</option>
                            ))}
                        </select>
                        <button onClick={() => setEditingStream('new')}
                            className="px-4 py-1.5 bg-indigo-600 hover:bg-indigo-500 rounded text-sm font-medium">
                            + New Stream
                        </button>
                    </div>
                </div>
                
                {/* Summary stats */}
                <div className={`grid gap-4 mb-6 ${totalPendingAlerts > 0 ? 'grid-cols-5' : 'grid-cols-4'}`}>
                    {[
                        { label: 'Active Streams', value: filteredStreams.filter(s => s.status === 'active').length, color: 'text-green-400' },
                        { label: 'Blocked', value: filteredStreams.filter(s => s.status === 'blocked').length, color: 'text-red-400' },
                        { label: 'Complete', value: filteredStreams.filter(s => s.status === 'complete').length, color: 'text-slate-400' },
                        { label: 'Total Items', value: filteredStreams.reduce((sum, s) => sum + WorkItemService.filterByStream(globalWorkItems, s.id).length, 0), color: 'text-blue-400' },
                        ...(totalPendingAlerts > 0 ? [{ label: '🔔 Pending Alerts', value: totalPendingAlerts, color: 'text-amber-400' }] : [])
                    ].map(stat => (
                        <div key={stat.label} className="bg-slate-800 rounded-lg border border-slate-700 p-4 text-center">
                            <div className={`text-2xl font-bold ${stat.color}`}>{stat.value}</div>
                            <div className="text-xs text-slate-500 mt-1">{stat.label}</div>
                        </div>
                    ))}
                </div>
                
                {/* Stream cards by app */}
                {Object.keys(streamsByApp).length === 0 && (
                    <div className="bg-slate-800 rounded-xl border border-slate-700 p-12 text-center">
                        <div className="text-4xl mb-3">🔀</div>
                        <h3 className="text-lg font-semibold mb-2">No work streams yet</h3>
                        <p className="text-slate-400 text-sm mb-4 max-w-lg mx-auto">
                            Work streams organize your backlog into parallel tracks. Each stream has an owner, a goal, and its own set of work items. 
                            Different people can run AI sessions against different streams without stepping on each other.
                        </p>
                        <button onClick={() => setEditingStream('new')}
                            className="px-4 py-2 bg-indigo-600 hover:bg-indigo-500 rounded font-medium">
                            Create Your First Stream
                        </button>
                    </div>
                )}
                
                {Object.entries(streamsByApp).sort((a, b) => (apps[a[0]]?.name || '').localeCompare(apps[b[0]]?.name || '')).map(([appId, streams]) => {
                    const app = apps[appId] || { name: appId, icon: '📦' };
                    const unassignedCount = getUnassignedCount(appId);
                    
                    return (
                        <div key={appId} className="mb-6">
                            <div className="flex items-center gap-2 mb-3">
                                <span>{app.icon === 'gs-logo' ? '🎮' : app.icon}</span>
                                <h3 className="font-semibold">{app.name}</h3>
                                <span className="text-xs text-slate-500">{streams.length} stream{streams.length !== 1 ? 's' : ''}</span>
                                {unassignedCount > 0 && (
                                    <span className="px-2 py-0.5 rounded text-xs bg-amber-900/30 text-amber-400 border border-amber-800/50">
                                        {unassignedCount} unassigned item{unassignedCount !== 1 ? 's' : ''}
                                    </span>
                                )}
                            </div>
                            
                            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                                {streams.map(stream => {
                                    const completion = WorkStreamService.getCompletion(stream, globalWorkItems);
                                    const streamItems = WorkItemService.filterByStream(globalWorkItems, stream.id);
                                    const isBlocked = WorkStreamService.isBlocked(stream, globalStreams);
                                    const interfaces = StreamInterfaceService.getByStream(globalInterfaces, stream.id);
                                    const consumedDeps = DependencyService.getConsumedBy(globalDependencies, stream.id);
                                    const pendingAlerts = DependencyAlertService.getPendingForStream(globalDependencyAlerts || [], globalDependencies, stream.id);
                                    
                                    return (
                                        <div key={stream.id} className={`bg-slate-800 rounded-xl border ${stream.status === 'blocked' ? 'border-red-800/50' : 'border-slate-700'} p-4`}>
                                            {/* Header */}
                                            <div className="flex items-start justify-between mb-3">
                                                <div className="flex-1">
                                                    <div className="flex items-center gap-2">
                                                        <span className={`px-2 py-0.5 rounded text-xs border ${statusColors[stream.status]}`}>
                                                            {statusIcons[stream.status]} {stream.status}
                                                        </span>
                                                        <h4 className="font-semibold">{stream.name}</h4>
                                                    </div>
                                                    {stream.goal && <p className="text-xs text-slate-400 mt-1">{stream.goal}</p>}
                                                    <div className="text-xs text-slate-500 mt-1 flex items-center gap-3">
                                                        <span>👤 {stream.owner}</span>
                                                        {stream.targetRelease && <span>🎯 {stream.targetRelease}</span>}
                                                    </div>
                                                </div>
                                                <div className="flex items-center gap-1">
                                                    <button onClick={() => setEditingStream(stream)} className="p-1 hover:bg-slate-700 rounded text-slate-400 text-xs" title="Edit stream">✏️</button>
                                                    <button onClick={() => handleDeleteStream(stream)} className="p-1 hover:bg-slate-700 rounded text-slate-400 text-xs" title="Delete stream">🗑️</button>
                                                </div>
                                            </div>
                                            
                                            {/* Completion bar */}
                                            {completion.total > 0 && (
                                                <div className="mb-3">
                                                    <div className="flex items-center justify-between text-xs text-slate-400 mb-1">
                                                        <span>{completion.done}/{completion.total} items done</span>
                                                        <span>{completion.pct}%</span>
                                                    </div>
                                                    <div className="h-1.5 bg-slate-700 rounded-full overflow-hidden">
                                                        <div className="h-full bg-green-500 rounded-full transition-all" style={{width: `${completion.pct}%`}}></div>
                                                    </div>
                                                </div>
                                            )}
                                            
                                            {/* Work items summary */}
                                            <div className="space-y-1 mb-3">
                                                {streamItems.filter(i => i.status !== 'done' && i.status !== 'deferred').slice(0, 5).map(item => (
                                                    <div key={item.id} className="flex items-center gap-2 text-xs">
                                                        <span>{item.status === 'in-progress' ? '🔨' : item.status === 'review' ? '👁️' : item.status === 'ready' ? '◉' : '○'}</span>
                                                        <span className="text-slate-300 truncate flex-1">{item.title}</span>
                                                        <span className="text-slate-500 capitalize">{item.status}</span>
                                                    </div>
                                                ))}
                                                {streamItems.filter(i => i.status !== 'done' && i.status !== 'deferred').length > 5 && (
                                                    <div className="text-xs text-slate-500">+{streamItems.filter(i => i.status !== 'done' && i.status !== 'deferred').length - 5} more</div>
                                                )}
                                                {streamItems.length === 0 && (
                                                    <div className="text-xs text-slate-500 py-2">No items assigned yet</div>
                                                )}
                                            </div>
                                            
                                            {/* Interfaces provided */}
                                            {interfaces.length > 0 && (
                                                <div className="mb-3 border-t border-slate-700 pt-2">
                                                    <div className="text-xs text-slate-500 mb-1">Provides:</div>
                                                    {interfaces.map(iface => (
                                                        <div key={iface.id} className="text-xs text-slate-400 flex items-center gap-1">
                                                            <span className="text-indigo-400">•</span> {iface.description}
                                                        </div>
                                                    ))}
                                                </div>
                                            )}
                                            
                                            {/* Dependencies consumed */}
                                            {consumedDeps.length > 0 && (
                                                <div className="mb-3 border-t border-slate-700 pt-2">
                                                    <div className="text-xs text-slate-500 mb-1">Depends on:</div>
                                                    {consumedDeps.map(dep => {
                                                        const iface = globalInterfaces.find(i => i.id === dep.interfaceId);
                                                        const providerStream = globalStreams.find(s => s.id === iface?.streamId);
                                                        return (
                                                            <div key={dep.id} className="text-xs text-slate-400 flex items-center gap-1">
                                                                <span className={dep.status === 'changed' ? 'text-amber-400' : 'text-green-400'}>•</span>
                                                                <span>{iface?.description || dep.interfaceId}</span>
                                                                {providerStream && <span className="text-slate-500">← {providerStream.name}</span>}
                                                                {dep.status === 'changed' && <span className="text-amber-400 ml-1">⚠ changed</span>}
                                                            </div>
                                                        );
                                                    })}
                                                </div>
                                            )}
                                            
                                            {/* Phase 5.4: Pending dependency alerts */}
                                            {pendingAlerts.length > 0 && (
                                                <div className="mb-3 bg-amber-900/20 border border-amber-700/50 rounded-lg px-3 py-2">
                                                    <div className="text-xs font-medium text-amber-300 mb-1">
                                                        🔔 {pendingAlerts.length} dependency update{pendingAlerts.length !== 1 ? 's' : ''} pending
                                                    </div>
                                                    {pendingAlerts.slice(0, 3).map(alert => {
                                                        const iface = globalInterfaces.find(i => i.id === alert.interfaceId);
                                                        return (
                                                            <div key={alert.id} className="text-xs text-amber-200/70 mb-0.5">
                                                                • {iface?.description || 'Interface'}: {alert.changeDescription}
                                                            </div>
                                                        );
                                                    })}
                                                    {pendingAlerts.length > 3 && (
                                                        <div className="text-xs text-amber-200/50">+{pendingAlerts.length - 3} more</div>
                                                    )}
                                                </div>
                                            )}
                                            
                                            {/* Actions */}
                                            <div className="flex items-center gap-2 pt-2 border-t border-slate-700">
                                                <select value={stream.status} onChange={e => handleStatusChange(stream, e.target.value)}
                                                    className="bg-slate-700 border border-slate-600 rounded px-2 py-1 text-xs flex-1">
                                                    <option value="active">🟢 Active</option>
                                                    <option value="paused">⏸️ Paused</option>
                                                    <option value="blocked">🔴 Blocked</option>
                                                    <option value="complete">✅ Complete</option>
                                                </select>
                                                <button onClick={() => handleAssignItems(stream)}
                                                    className="px-2 py-1 bg-slate-700 hover:bg-slate-600 rounded text-xs"
                                                    title="Assign unassigned items">
                                                    📋 Assign Items
                                                </button>
                                                <button onClick={() => { setView('backlog'); }}
                                                    className="px-2 py-1 bg-slate-700 hover:bg-slate-600 rounded text-xs"
                                                    title="View in backlog">
                                                    📋 Backlog
                                                </button>
                                            </div>
                                        </div>
                                    );
                                })}
                            </div>
                        </div>
                    );
                })}
                
                {/* Stream Edit Modal */}
                {editingStream && (
                    <StreamEditModal
                        stream={editingStream === 'new' ? null : editingStream}
                        apps={apps}
                        globalStreams={globalStreams}
                        config={config}
                        onSave={editingStream === 'new' ? handleCreateStream : (data) => handleUpdateStream(editingStream.id, data)}
                        onCancel={() => setEditingStream(null)}
                    />
                )}
            </div>
        );
    }
    
    // StreamEditModal — Create/edit work streams
    function StreamEditModal({ stream, apps, globalStreams, config, onSave, onCancel }) {
        const isNew = !stream;
        const [name, setName] = React.useState(stream?.name || '');
        const [appId, setAppId] = React.useState(stream?.appId || '');
        const [owner, setOwner] = React.useState(stream?.owner || config?._userName || 'Owner');
        const [goal, setGoal] = React.useState(stream?.goal || '');
        const [targetRelease, setTargetRelease] = React.useState(stream?.targetRelease || '');
        const [status, setStatus] = React.useState(stream?.status || 'active');
        const [blockedBy, setBlockedBy] = React.useState(stream?.blockedBy || []);
        
        const appList = Object.values(apps).filter(a => a.id !== 'command-center').sort((a, b) => (a.name || '').localeCompare(b.name || ''));
        const otherStreams = globalStreams.filter(s => s.id !== stream?.id);
        
        const handleSubmit = () => {
            if (!name.trim() || !appId) return;
            onSave({
                name: name.trim(),
                appId,
                owner: owner.trim() || 'Owner',
                goal: goal.trim(),
                targetRelease: targetRelease.trim(),
                status,
                blockedBy
            });
        };
        
        return (
            <div className="fixed inset-0 bg-black/70 z-50 flex items-center justify-center p-4" onClick={onCancel}>
                <div className="bg-slate-800 rounded-xl border border-slate-700 max-w-lg w-full p-6" onClick={e => e.stopPropagation()}>
                    <h3 className="text-lg font-bold mb-4">{isNew ? '🔀 New Work Stream' : `✏️ Edit: ${stream.name}`}</h3>
                    
                    <div className="space-y-4">
                        <div>
                            <label className="block text-sm text-slate-400 mb-1">Stream Name *</label>
                            <input value={name} onChange={e => setName(e.target.value)}
                                className="w-full bg-slate-900 border border-slate-600 rounded px-3 py-2 text-sm"
                                placeholder="Core Gameplay, Help & Onboarding, Marketing..." autoFocus />
                        </div>
                        
                        <div>
                            <label className="block text-sm text-slate-400 mb-1">App *</label>
                            <select value={appId} onChange={e => setAppId(e.target.value)}
                                className="w-full bg-slate-900 border border-slate-600 rounded px-3 py-2 text-sm"
                                disabled={!isNew}>
                                <option value="">Select app...</option>
                                {appList.map(a => (
                                    <option key={a.id} value={a.id}>{a.icon === 'gs-logo' ? '🎮' : a.icon} {a.name}</option>
                                ))}
                            </select>
                        </div>
                        
                        <div className="grid grid-cols-2 gap-4">
                            <div>
                                <label className="block text-sm text-slate-400 mb-1">Owner</label>
                                <input value={owner} onChange={e => setOwner(e.target.value)}
                                    className="w-full bg-slate-900 border border-slate-600 rounded px-3 py-2 text-sm"
                                    placeholder="Dave, Sarah..." />
                            </div>
                            <div>
                                <label className="block text-sm text-slate-400 mb-1">Target Release</label>
                                <input value={targetRelease} onChange={e => setTargetRelease(e.target.value)}
                                    className="w-full bg-slate-900 border border-slate-600 rounded px-3 py-2 text-sm"
                                    placeholder="v1.0, v2.0..." />
                            </div>
                        </div>
                        
                        <div>
                            <label className="block text-sm text-slate-400 mb-1">Goal — what done looks like</label>
                            <textarea value={goal} onChange={e => setGoal(e.target.value)}
                                className="w-full bg-slate-900 border border-slate-600 rounded px-3 py-2 text-sm h-20"
                                placeholder="All core game mechanics working, tested, and deployed to prod..." />
                        </div>
                        
                        <div>
                            <label className="block text-sm text-slate-400 mb-1">Status</label>
                            <select value={status} onChange={e => setStatus(e.target.value)}
                                className="w-full bg-slate-900 border border-slate-600 rounded px-3 py-2 text-sm">
                                <option value="active">🟢 Active</option>
                                <option value="paused">⏸️ Paused</option>
                                <option value="blocked">🔴 Blocked</option>
                                <option value="complete">✅ Complete</option>
                            </select>
                        </div>
                        
                        {otherStreams.length > 0 && (
                            <div>
                                <label className="block text-sm text-slate-400 mb-1">Blocked by (other streams)</label>
                                <div className="space-y-1 max-h-32 overflow-y-auto">
                                    {otherStreams.map(s => (
                                        <label key={s.id} className="flex items-center gap-2 text-sm cursor-pointer hover:bg-slate-700/50 px-2 py-1 rounded">
                                            <input type="checkbox" checked={blockedBy.includes(s.id)}
                                                onChange={e => {
                                                    if (e.target.checked) setBlockedBy([...blockedBy, s.id]);
                                                    else setBlockedBy(blockedBy.filter(id => id !== s.id));
                                                }} />
                                            <span className="text-slate-300">{s.name}</span>
                                            <span className="text-xs text-slate-500">{apps[s.appId]?.name || s.appId}</span>
                                        </label>
                                    ))}
                                </div>
                            </div>
                        )}
                    </div>
                    
                    <div className="flex justify-end gap-3 mt-6 pt-4 border-t border-slate-700">
                        <button onClick={onCancel} className="px-4 py-2 text-sm text-slate-400 hover:text-white">Cancel</button>
                        <button onClick={handleSubmit} disabled={!name.trim() || !appId}
                            className="px-4 py-2 bg-indigo-600 hover:bg-indigo-500 disabled:opacity-50 disabled:cursor-not-allowed rounded text-sm font-medium">
                            {isNew ? 'Create Stream' : 'Save Changes'}
                        </button>
                    </div>
                </div>
            </div>
        );
    }
    
    // =========================================================================
    
    function ReleaseCoordinationView({ apps, config, globalWorkItems, globalSessions, deployments, showAlert, showConfirm, showPrompt, setView }) {
        const [selectedApp, setSelectedApp] = React.useState('all');
        const [showTestChecklist, setShowTestChecklist] = React.useState(null); // appId or null
        const [checklistState, setChecklistState] = React.useState({}); // { itemId: true/false }
        const [expandedMilestones, setExpandedMilestones] = React.useState({});
        
        const configuredApps = Object.values(apps).filter(a => a.testRepo || a.prodRepo);
        const items = globalWorkItems || [];
        const sessions = globalSessions || [];
        const deps = deployments || [];
        
        // === Build release data per app ===
        const releaseData = React.useMemo(() => {
            const data = {};
            
            for (const app of configuredApps) {
                const appItems = items.filter(wi => wi.appId === app.id);
                const appSessions = sessions.filter(s => s.appId === app.id);
                const appDeploys = deps.filter(d => d.appId === app.id);
                
                // Group items by milestone
                const milestones = {};
                appItems.forEach(wi => {
                    const ms = wi.milestone || 'unassigned';
                    if (!milestones[ms]) milestones[ms] = { items: [], done: 0, total: 0, stale: [], blocked: [] };
                    milestones[ms].items.push(wi);
                    milestones[ms].total++;
                    if (wi.status === 'done') milestones[ms].done++;
                    if (WorkItemService.isStale && WorkItemService.isStale(wi)) milestones[ms].stale.push(wi);
                });
                
                // Current versions
                const testVer = app.versions?.test || null;
                const prodVer = app.versions?.prod || null;
                
                // Recent deploys (last 5)
                const recentDeploys = appDeploys
                    .sort((a, b) => new Date(b.timestamp || b.date || 0) - new Date(a.timestamp || a.date || 0))
                    .slice(0, 5);
                
                // Sessions pending review
                const pendingReview = appSessions.filter(s => s.status === 'prep' || s.status === 'active' || s.status === 'review');
                
                // Items with unmet criteria from reviews
                const reviewedSessions = appSessions.filter(s => s.review && !s.review.allMet);
                
                // Pipeline summary
                const pipeline = { idea: 0, ready: 0, 'in-progress': 0, review: 0, done: 0 };
                appItems.forEach(wi => { if (pipeline.hasOwnProperty(wi.status)) pipeline[wi.status]++; });
                
                // Overall readiness assessment
                const activeItems = appItems.filter(wi => wi.status !== 'done' && wi.status !== 'deferred');
                const blockers = [];
                if (pipeline['in-progress'] > 0) blockers.push(`${pipeline['in-progress']} item${pipeline['in-progress'] > 1 ? 's' : ''} still in progress`);
                if (pipeline.review > 0) blockers.push(`${pipeline.review} item${pipeline.review > 1 ? 's' : ''} awaiting review`);
                const staleAll = appItems.filter(wi => WorkItemService.isStale && WorkItemService.isStale(wi));
                if (staleAll.length > 0) blockers.push(`${staleAll.length} stale item${staleAll.length > 1 ? 's' : ''}`);
                if (pendingReview.length > 0) blockers.push(`${pendingReview.length} session${pendingReview.length > 1 ? 's' : ''} not yet completed`);
                
                const totalItems = appItems.length;
                const doneItems = pipeline.done;
                const completionPct = totalItems > 0 ? Math.round((doneItems / totalItems) * 100) : 0;
                
                // Go/No-Go
                let readiness = 'unknown';
                if (totalItems === 0) readiness = 'no-items';
                else if (blockers.length === 0 && completionPct === 100) readiness = 'ready';
                else if (blockers.length === 0 && completionPct >= 80) readiness = 'almost';
                else if (blockers.length > 0) readiness = 'blocked';
                else readiness = 'in-progress';
                
                data[app.id] = {
                    app, milestones, testVer, prodVer, recentDeploys,
                    pendingReview, reviewedSessions, pipeline, activeItems,
                    blockers, totalItems, doneItems, completionPct, readiness, staleAll
                };
            }
            
            return data;
        }, [configuredApps, items, sessions, deps]);
        
        // === Phase 4.5: Generate Test Checklist ===
        const generateTestChecklist = (appId) => {
            const rd = releaseData[appId];
            if (!rd) return [];
            
            const checklist = [];
            let idx = 0;
            
            // Section 1: Recently completed work items
            const doneItems = rd.app ? items.filter(wi => wi.appId === appId && wi.status === 'done') : [];
            const recentDone = doneItems
                .filter(wi => wi.completedAt && (Date.now() - new Date(wi.completedAt).getTime()) < 30 * 24 * 60 * 60 * 1000)
                .sort((a, b) => new Date(b.completedAt) - new Date(a.completedAt));
            
            if (recentDone.length > 0) {
                checklist.push({ id: `hdr-${idx++}`, type: 'header', text: 'Recently Shipped Features' });
                recentDone.forEach(wi => {
                    checklist.push({ 
                        id: `feat-${wi.id}`, type: 'check', 
                        text: `${wi.title}${wi.completedInVersion ? ` (v${wi.completedInVersion})` : ''}`,
                        detail: wi.description || null
                    });
                    // Add acceptance criteria as sub-checks
                    if (wi.criteria && wi.criteria.length > 0) {
                        wi.criteria.filter(c => c.trim()).forEach((c, ci) => {
                            checklist.push({ 
                                id: `crit-${wi.id}-${ci}`, type: 'subcheck',
                                text: c
                            });
                        });
                    }
                });
            }
            
            // Section 2: Items currently in review
            const inReview = items.filter(wi => wi.appId === appId && wi.status === 'review');
            if (inReview.length > 0) {
                checklist.push({ id: `hdr-${idx++}`, type: 'header', text: 'Pending Review — Verify Before Deploy' });
                inReview.forEach(wi => {
                    checklist.push({ 
                        id: `rev-${wi.id}`, type: 'check',
                        text: `${wi.title} — verify implementation matches spec`
                    });
                    if (wi.criteria && wi.criteria.length > 0) {
                        wi.criteria.filter(c => c.trim()).forEach((c, ci) => {
                            checklist.push({
                                id: `revcrit-${wi.id}-${ci}`, type: 'subcheck',
                                text: c
                            });
                        });
                    }
                });
            }
            
            // Section 3: Standard user journeys
            const appCategory = rd.app?.category || 'tool';
            const journeys = {
                game: [
                    'Load app fresh (no cache) — game loads correctly',
                    'Play a complete round — scoring works as expected',
                    'Share results — share text formats correctly',
                    'Return next day — daily reset works, stats preserved',
                    'Switch between Easy/Hard modes (if applicable)',
                    'Check responsive layout on mobile (375px width)',
                    'Verify PWA install prompt and offline behavior'
                ],
                tool: [
                    'Load app fresh — default state is correct',
                    'Complete primary workflow end-to-end',
                    'Save data — verify persistence after page reload',
                    'Error handling — try invalid input, empty states',
                    'Check responsive layout on mobile (375px width)',
                    'Verify keyboard navigation works'
                ],
                dashboard: [
                    'Load app — data populates correctly',
                    'Verify all data sources are connected',
                    'Check refresh behavior — data updates properly',
                    'Filter/sort controls work as expected',
                    'Check responsive layout on mobile (375px width)',
                    'Verify loading states (slow network)'
                ],
                content: [
                    'Load app — content renders correctly',
                    'Navigate between sections/pages',
                    'Verify external links open correctly',
                    'Check responsive layout on mobile (375px width)',
                    'Verify images/media load properly'
                ],
                admin: [
                    'Create a new record — verify it appears',
                    'Edit an existing record — changes persist',
                    'Delete a record — confirm prompt works',
                    'Verify data validation (required fields, formats)',
                    'Check responsive layout on mobile (375px width)',
                    'Verify access controls (if applicable)'
                ]
            };
            
            const categoryJourneys = journeys[appCategory] || journeys.tool;
            checklist.push({ id: `hdr-${idx++}`, type: 'header', text: 'Standard User Journeys' });
            categoryJourneys.forEach((j, ji) => {
                checklist.push({ id: `journey-${ji}`, type: 'check', text: j });
            });
            
            // Section 4: Regression checks for recently changed areas
            const recentSessions = sessions
                .filter(s => s.appId === appId && s.completedAt)
                .sort((a, b) => new Date(b.completedAt) - new Date(a.completedAt))
                .slice(0, 3);
            
            if (recentSessions.length > 0) {
                checklist.push({ id: `hdr-${idx++}`, type: 'header', text: 'Regression Checks (Recent Sessions)' });
                recentSessions.forEach((s, si) => {
                    const typeLabel = s.type || 'build';
                    const dateStr = new Date(s.completedAt || s.createdAt).toLocaleDateString();
                    checklist.push({
                        id: `regress-${si}`, type: 'check',
                        text: `${typeLabel} session (${dateStr}) — verify no side effects from changes`
                    });
                    if (s.deliverables?.summary) {
                        checklist.push({
                            id: `regress-detail-${si}`, type: 'subcheck',
                            text: `Deliverables: ${s.deliverables.summary}`
                        });
                    }
                });
            }
            
            // Section 5: Deploy verification
            checklist.push({ id: `hdr-${idx++}`, type: 'header', text: 'Deploy Verification' });
            checklist.push({ id: 'deploy-test', type: 'check', text: 'Deploy to test environment — verify live site matches local' });
            checklist.push({ id: 'deploy-version', type: 'check', text: 'Version number displays correctly on deployed site' });
            if (rd.app?.hasServiceWorker) {
                checklist.push({ id: 'deploy-sw', type: 'check', text: 'Service worker updates — hard refresh shows new version' });
                checklist.push({ id: 'deploy-pwa', type: 'check', text: 'PWA install/update works — no stale cache issues' });
            }
            checklist.push({ id: 'deploy-console', type: 'check', text: 'Browser console clean — no errors or warnings' });
            checklist.push({ id: 'deploy-promote', type: 'check', text: 'Promote test → prod (when all checks pass)' });
            
            return checklist;
        };
        
        // Checklist completion stats
        const getChecklistStats = (checklistItems) => {
            const checkable = checklistItems.filter(c => c.type === 'check' || c.type === 'subcheck');
            const checked = checkable.filter(c => checklistState[c.id]);
            return { total: checkable.length, done: checked.length, pct: checkable.length > 0 ? Math.round((checked.length / checkable.length) * 100) : 0 };
        };
        
        const toggleCheck = (id) => {
            setChecklistState(prev => ({ ...prev, [id]: !prev[id] }));
        };
        
        // Readiness badge
        const ReadinessBadge = ({ readiness }) => {
            const styles = {
                'ready': 'bg-green-500/20 text-green-400 border-green-500/30',
                'almost': 'bg-amber-500/20 text-amber-400 border-amber-500/30',
                'blocked': 'bg-red-500/20 text-red-400 border-red-500/30',
                'in-progress': 'bg-blue-500/20 text-blue-400 border-blue-500/30',
                'no-items': 'bg-slate-500/20 text-slate-400 border-slate-500/30',
                'unknown': 'bg-slate-500/20 text-slate-400 border-slate-500/30'
            };
            const labels = {
                'ready': '✅ Ready to Ship',
                'almost': '🟡 Almost Ready',
                'blocked': '🔴 Blocked',
                'in-progress': '🔵 In Progress',
                'no-items': '— No Work Items',
                'unknown': '— Unknown'
            };
            return (
                <span className={`px-2 py-0.5 rounded-full text-xs border ${styles[readiness] || styles.unknown}`}>
                    {labels[readiness] || readiness}
                </span>
            );
        };
        
        // Pipeline bar (mini)
        const MiniPipelineBar = ({ pipeline }) => {
            const total = Object.values(pipeline).reduce((s, v) => s + v, 0);
            if (total === 0) return <span className="text-xs text-slate-500">No items</span>;
            const segments = [
                { key: 'done', color: 'bg-green-500', count: pipeline.done || 0 },
                { key: 'review', color: 'bg-purple-500', count: pipeline.review || 0 },
                { key: 'in-progress', color: 'bg-blue-500', count: pipeline['in-progress'] || 0 },
                { key: 'ready', color: 'bg-amber-500', count: pipeline.ready || 0 },
                { key: 'idea', color: 'bg-slate-500', count: pipeline.idea || 0 }
            ].filter(s => s.count > 0);
            
            return (
                <div className="flex items-center gap-2 w-full">
                    <div className="flex-1 h-2 rounded-full bg-slate-700 overflow-hidden flex">
                        {segments.map(s => (
                            <div key={s.key} className={`${s.color} h-full`} 
                                style={{ width: `${(s.count / total) * 100}%` }}
                                title={`${s.key}: ${s.count}`} />
                        ))}
                    </div>
                    <span className="text-xs text-slate-400 whitespace-nowrap">{pipeline.done || 0}/{total}</span>
                </div>
            );
        };
        
        // Relative time
        const relTime = (dateStr) => {
            if (!dateStr) return '';
            const diff = Date.now() - new Date(dateStr).getTime();
            const mins = Math.floor(diff / 60000);
            if (mins < 60) return `${mins}m ago`;
            const hrs = Math.floor(mins / 60);
            if (hrs < 24) return `${hrs}h ago`;
            const days = Math.floor(hrs / 24);
            return `${days}d ago`;
        };
        
        // Filtered apps
        const visibleApps = selectedApp === 'all' 
            ? configuredApps 
            : configuredApps.filter(a => a.id === selectedApp);
        
        // === Test Checklist Modal ===
        if (showTestChecklist) {
            const checklist = generateTestChecklist(showTestChecklist);
            const stats = getChecklistStats(checklist);
            const appName = apps[showTestChecklist]?.name || showTestChecklist;
            const rd = releaseData[showTestChecklist];
            const currentVer = rd?.testVer || rd?.prodVer || '?';
            
            return (
                <div className="space-y-6">
                    <div className="flex items-center justify-between">
                        <div>
                            <h1 className="text-2xl font-bold flex items-center gap-2">
                                📋 Release Test Checklist
                            </h1>
                            <p className="text-sm text-slate-400 mt-1">{appName} — v{currentVer}</p>
                        </div>
                        <div className="flex items-center gap-3">
                            <div className="text-right">
                                <div className="text-lg font-bold">{stats.pct}%</div>
                                <div className="text-xs text-slate-400">{stats.done}/{stats.total} checks</div>
                            </div>
                            <button onClick={() => { setShowTestChecklist(null); setChecklistState({}); }}
                                className="px-3 py-1.5 bg-slate-700 hover:bg-slate-600 rounded text-sm">
                                ← Back
                            </button>
                        </div>
                    </div>
                    
                    {/* Progress bar */}
                    <div className="w-full h-3 bg-slate-700 rounded-full overflow-hidden">
                        <div className={`h-full transition-all duration-300 rounded-full ${
                            stats.pct === 100 ? 'bg-green-500' : stats.pct >= 75 ? 'bg-amber-500' : 'bg-blue-500'
                        }`} style={{ width: `${stats.pct}%` }} />
                    </div>
                    
                    <div className="bg-slate-800 rounded-xl border border-slate-700 p-6 space-y-1">
                        {checklist.map(item => {
                            if (item.type === 'header') {
                                return (
                                    <div key={item.id} className="pt-4 pb-2 first:pt-0">
                                        <h3 className="text-sm font-semibold text-slate-300 uppercase tracking-wide">{item.text}</h3>
                                    </div>
                                );
                            }
                            
                            const isSubcheck = item.type === 'subcheck';
                            const isChecked = checklistState[item.id] || false;
                            
                            return (
                                <label key={item.id} className={`flex items-start gap-3 py-1.5 px-2 rounded cursor-pointer hover:bg-slate-700/50 ${
                                    isSubcheck ? 'ml-6' : ''
                                } ${isChecked ? 'opacity-60' : ''}`}>
                                    <input type="checkbox" checked={isChecked} onChange={() => toggleCheck(item.id)}
                                        className="mt-0.5 rounded border-slate-600 bg-slate-700 text-indigo-500 focus:ring-indigo-500" />
                                    <div className="flex-1 min-w-0">
                                        <span className={`text-sm ${isChecked ? 'line-through text-slate-500' : isSubcheck ? 'text-slate-400' : 'text-slate-200'}`}>
                                            {item.text}
                                        </span>
                                        {item.detail && (
                                            <div className="text-xs text-slate-500 mt-0.5">{item.detail}</div>
                                        )}
                                    </div>
                                </label>
                            );
                        })}
                    </div>
                    
                    {stats.pct === 100 && (
                        <div className="bg-green-500/10 border border-green-500/30 rounded-xl p-4 text-center">
                            <div className="text-lg font-bold text-green-400">✅ All checks passed!</div>
                            <p className="text-sm text-green-300 mt-1">This release is ready for promotion to production.</p>
                            <button onClick={() => { setView('smartdeploy'); }}
                                className="mt-3 px-4 py-2 bg-green-600 hover:bg-green-500 rounded-lg text-sm font-medium">
                                🚀 Go to Smart Deploy
                            </button>
                        </div>
                    )}
                </div>
            );
        }
        
        // === Main Release Coordination View ===
        return (
            <div className="space-y-6">
                <div className="flex items-center justify-between flex-wrap gap-4">
                    <div>
                        <h1 className="text-2xl font-bold">🚢 Release Coordination</h1>
                        <p className="text-sm text-slate-400 mt-1">Track readiness, blockers, and test status per app</p>
                    </div>
                    <div className="flex items-center gap-2">
                        <select value={selectedApp} onChange={e => setSelectedApp(e.target.value)}
                            className="bg-slate-700 border border-slate-600 rounded px-3 py-1.5 text-sm">
                            <option value="all">All Apps ({configuredApps.length})</option>
                            {configuredApps.map(a => (
                                <option key={a.id} value={a.id}>{a.icon && a.icon !== 'gs-logo' ? a.icon : '📦'} {a.name}</option>
                            ))}
                        </select>
                    </div>
                </div>
                
                {/* Summary cards */}
                <div className="grid grid-cols-2 md:grid-cols-4 gap-3">
                    {(() => {
                        const allRd = Object.values(releaseData);
                        const readyCount = allRd.filter(r => r.readiness === 'ready').length;
                        const blockedCount = allRd.filter(r => r.readiness === 'blocked').length;
                        const totalDone = allRd.reduce((s, r) => s + r.doneItems, 0);
                        const totalAll = allRd.reduce((s, r) => s + r.totalItems, 0);
                        const staleTotal = allRd.reduce((s, r) => s + (r.staleAll?.length || 0), 0);
                        return (
                            <>
                                <div className="bg-slate-800 rounded-lg border border-slate-700 p-3 text-center">
                                    <div className="text-2xl font-bold text-green-400">{readyCount}</div>
                                    <div className="text-xs text-slate-400">Ready to Ship</div>
                                </div>
                                <div className="bg-slate-800 rounded-lg border border-slate-700 p-3 text-center">
                                    <div className="text-2xl font-bold text-red-400">{blockedCount}</div>
                                    <div className="text-xs text-slate-400">Blocked</div>
                                </div>
                                <div className="bg-slate-800 rounded-lg border border-slate-700 p-3 text-center">
                                    <div className="text-2xl font-bold">{totalAll > 0 ? Math.round((totalDone / totalAll) * 100) : 0}%</div>
                                    <div className="text-xs text-slate-400">Overall Completion</div>
                                </div>
                                <div className="bg-slate-800 rounded-lg border border-slate-700 p-3 text-center">
                                    <div className={`text-2xl font-bold ${staleTotal > 0 ? 'text-amber-400' : 'text-slate-400'}`}>{staleTotal}</div>
                                    <div className="text-xs text-slate-400">Stale Items</div>
                                </div>
                            </>
                        );
                    })()}
                </div>
                
                {/* Per-app release cards */}
                {visibleApps.map(app => {
                    const rd = releaseData[app.id];
                    if (!rd) return null;
                    
                    return (
                        <div key={app.id} className="bg-slate-800 rounded-xl border border-slate-700 overflow-hidden">
                            {/* App header */}
                            <div className="p-4 border-b border-slate-700">
                                <div className="flex items-center justify-between flex-wrap gap-2">
                                    <div className="flex items-center gap-3">
                                        <span className="text-xl">{app.icon && app.icon !== 'gs-logo' ? app.icon : '📦'}</span>
                                        <div>
                                            <h2 className="font-semibold text-lg">{app.name}</h2>
                                            <div className="flex items-center gap-3 text-xs text-slate-400 mt-0.5">
                                                {rd.testVer && <span>Test: v{rd.testVer}</span>}
                                                {rd.prodVer && <span>Prod: v{rd.prodVer}</span>}
                                                {rd.testVer && rd.prodVer && rd.testVer !== rd.prodVer && (
                                                    <span className="text-amber-400">⚠ Test ahead of Prod</span>
                                                )}
                                            </div>
                                        </div>
                                    </div>
                                    <div className="flex items-center gap-2">
                                        <ReadinessBadge readiness={rd.readiness} />
                                        <button onClick={() => setShowTestChecklist(app.id)}
                                            className="px-3 py-1.5 bg-indigo-600 hover:bg-indigo-500 rounded text-xs font-medium">
                                            📋 Test Checklist
                                        </button>
                                    </div>
                                </div>
                            </div>
                            
                            <div className="p-4 space-y-4">
                                {/* Pipeline bar */}
                                <div>
                                    <div className="flex items-center justify-between mb-1">
                                        <span className="text-xs text-slate-400">Pipeline</span>
                                        <span className="text-xs text-slate-400">{rd.completionPct}% complete</span>
                                    </div>
                                    <MiniPipelineBar pipeline={rd.pipeline} />
                                    <div className="flex items-center gap-4 mt-1.5 text-xs text-slate-500">
                                        {rd.pipeline.idea > 0 && <span>💡 {rd.pipeline.idea} idea{rd.pipeline.idea > 1 ? 's' : ''}</span>}
                                        {rd.pipeline.ready > 0 && <span>📋 {rd.pipeline.ready} ready</span>}
                                        {rd.pipeline['in-progress'] > 0 && <span>🔨 {rd.pipeline['in-progress']} WIP</span>}
                                        {rd.pipeline.review > 0 && <span>👁 {rd.pipeline.review} review</span>}
                                        {rd.pipeline.done > 0 && <span>✅ {rd.pipeline.done} done</span>}
                                    </div>
                                </div>
                                
                                {/* Blockers */}
                                {rd.blockers.length > 0 && (
                                    <div className="bg-red-500/10 border border-red-500/20 rounded-lg p-3">
                                        <h4 className="text-xs font-semibold text-red-400 mb-1">Blockers</h4>
                                        <ul className="space-y-0.5">
                                            {rd.blockers.map((b, i) => (
                                                <li key={i} className="text-xs text-red-300">• {b}</li>
                                            ))}
                                        </ul>
                                    </div>
                                )}
                                
                                {/* Milestone breakdown (expandable) */}
                                {Object.keys(rd.milestones).length > 0 && (
                                    <details className="group">
                                        <summary className="text-xs text-slate-400 cursor-pointer hover:text-slate-300">
                                            ▸ Milestones ({Object.keys(rd.milestones).length})
                                        </summary>
                                        <div className="mt-2 space-y-2">
                                            {Object.entries(rd.milestones)
                                                .sort((a, b) => {
                                                    const order = { production: 0, beta: 1, alpha: 2, prototype: 3, unassigned: 4 };
                                                    return (order[a[0]] ?? 5) - (order[b[0]] ?? 5);
                                                })
                                                .map(([ms, msData]) => (
                                                    <div key={ms} className="bg-slate-700/50 rounded-lg p-3">
                                                        <div className="flex items-center justify-between mb-1">
                                                            <span className="text-xs font-medium capitalize">{ms}</span>
                                                            <span className="text-xs text-slate-400">{msData.done}/{msData.total} done</span>
                                                        </div>
                                                        <div className="w-full h-1.5 bg-slate-700 rounded-full overflow-hidden">
                                                            <div className="h-full bg-green-500 rounded-full" 
                                                                style={{ width: `${msData.total > 0 ? (msData.done / msData.total) * 100 : 0}%` }} />
                                                        </div>
                                                        {msData.stale.length > 0 && (
                                                            <div className="text-xs text-amber-400 mt-1">⚠ {msData.stale.length} stale</div>
                                                        )}
                                                    </div>
                                                ))
                                            }
                                        </div>
                                    </details>
                                )}
                                
                                {/* Recent deploys */}
                                {rd.recentDeploys.length > 0 && (
                                    <details className="group">
                                        <summary className="text-xs text-slate-400 cursor-pointer hover:text-slate-300">
                                            ▸ Recent Deploys ({rd.recentDeploys.length})
                                        </summary>
                                        <div className="mt-2 space-y-1">
                                            {rd.recentDeploys.map((d, i) => (
                                                <div key={i} className="flex items-center justify-between text-xs py-1 px-2 bg-slate-700/30 rounded">
                                                    <span>v{d.version || '?'} → {d.target || d.environment || '?'}</span>
                                                    <span className="text-slate-500">{relTime(d.timestamp || d.date)}</span>
                                                </div>
                                            ))}
                                        </div>
                                    </details>
                                )}
                                
                                {/* Go/No-Go summary */}
                                {rd.readiness === 'ready' && (
                                    <div className="bg-green-500/10 border border-green-500/20 rounded-lg p-3 flex items-center justify-between">
                                        <span className="text-sm text-green-400">All {rd.totalItems} items complete. Ready to ship.</span>
                                        <button onClick={() => setView('smartdeploy')}
                                            className="px-3 py-1 bg-green-600 hover:bg-green-500 rounded text-xs font-medium">
                                            🚀 Deploy
                                        </button>
                                    </div>
                                )}
                                
                                {rd.readiness === 'almost' && (
                                    <div className="bg-amber-500/10 border border-amber-500/20 rounded-lg p-3">
                                        <span className="text-sm text-amber-400">{rd.completionPct}% complete — {rd.totalItems - rd.doneItems} item{rd.totalItems - rd.doneItems > 1 ? 's' : ''} remaining.</span>
                                    </div>
                                )}
                            </div>
                        </div>
                    );
                })}
                
                {visibleApps.length === 0 && (
                    <div className="bg-slate-800 rounded-xl border border-slate-700 p-12 text-center text-slate-400">
                        No configured apps found. Set up apps with repos in the Configure section.
                    </div>
                )}
            </div>
        );
    }
    
    // =========================================================================
    // ISSUES VIEW - Full Issue Tracking & Release Management
    // =========================================================================
    
    function IssuesView({ apps, deployments, showAlert, showConfirm, showPrompt, setView, globalWorkItems }) {
        const [issues, setIssues] = React.useState([]);
        const [releases, setReleases] = React.useState([]);
        const [userReports, setUserReports] = React.useState([]);
        const [userReportsExpanded, setUserReportsExpanded] = React.useState(true);
        const [firebaseUser, setFirebaseUser] = React.useState(null);
        const [loading, setLoading] = React.useState(true);
        const [showNewIssue, setShowNewIssue] = React.useState(false);
        const [selectedIssue, setSelectedIssue] = React.useState(null);
        const [selectedUserReport, setSelectedUserReport] = React.useState(null);
        const [filter, setFilter] = React.useState('open'); // 'all', 'open', 'fixed', 'verified', 'closed'
        const [appFilter, setAppFilter] = React.useState('all');
        
        const configuredApps = Object.values(apps).filter(a => a.testRepo || a.prodRepo);
        
        // Listen for Firebase auth
        React.useEffect(() => {
            if (!firebaseAuth) return;
            
            let unsubIssues = () => {};
            let unsubReleases = () => {};
            let unsubReports = () => {};
            
            const unsubscribe = firebaseAuth.onAuthStateChanged((u) => {
                setFirebaseUser(u);
                if (u) {
                    // Use service listeners
                    setLoading(true);
                    unsubIssues = IssueService.listen(u.uid, (list) => {
                        setIssues(list);
                        setLoading(false);
                    });
                    unsubReleases = ReleaseService.listen(u.uid, setReleases);
                    unsubReports = UserReportService.listen(setUserReports);
                }
            });
            return () => {
                unsubscribe();
                unsubIssues();
                unsubReleases();
                unsubReports();
            };
        }, []);
        
        // Generate next issue ID
        const getNextIssueId = () => IssueService.getNextId(issues);
        
        // Create new issue
        const createIssue = async (issueData) => {
            if (!firebaseUser) return;
            const id = getNextIssueId();
            await IssueService.create(firebaseUser.uid, { ...issueData, id });
            setShowNewIssue(false);
        };
        
        // Update issue status
        const updateIssueStatus = async (issueId, newStatus, extraData = {}) => {
            if (!firebaseUser) return;
            await IssueService.updateStatus(firebaseUser.uid, issueId, newStatus, extraData);
        };
        
        // Link issue to version (when deploying fix)
        const linkIssueToVersion = async (issueId, version, app) => {
            if (!firebaseUser) return;
            await IssueService.linkToVersion(firebaseUser.uid, [issueId], version, app);
        };
        
        // Generate "Copy for Claude" text
        const copyForClaude = (issue) => {
            const text = `## Issue ${issue.id}: ${issue.title}

**App:** ${issue.app}
**Severity:** ${issue.severity}
**Status:** ${issue.status}

### Description
${issue.description}

### Steps to Reproduce
${issue.stepsToReproduce?.map((s, i) => `${i + 1}. ${s}`).join('\n') || 'N/A'}

### Expected Behavior
${issue.expected || 'N/A'}

### Actual Behavior
${issue.actual || 'N/A'}

---
When you fix this, please note: "Fixes ${issue.id}" in the code or deploy notes.`;
            
            navigator.clipboard.writeText(text);
        };
        
        // Promote issue to work item
        const promoteToWorkItem = async (issue) => {
            if (!firebaseUser) {
                showAlert('Sign in to Firebase to create work items', 'error');
                return;
            }
            
            // Check if already promoted
            const existingWI = (globalWorkItems || []).find(wi => 
                wi.context?.relatedItems?.includes(issue.id) || 
                wi.tags?.includes(`from-${issue.id}`)
            );
            if (existingWI) {
                const proceed = await showConfirm(`Issue ${issue.id} was already promoted to ${existingWI.id}. Create another work item anyway?`);
                if (!proceed) return;
            }
            
            // Generate next work item ID
            const existingIds = (globalWorkItems || []).map(i => parseInt(i.id?.replace('WI-', '') || '0'));
            const nextNum = Math.max(0, ...existingIds) + 1;
            const newId = `WI-${String(nextNum).padStart(3, '0')}`;
            
            // Map severity to priority
            const priorityMap = { 'critical': 'core', 'major': 'core', 'minor': 'nice-to-have', 'cosmetic': 'nice-to-have' };
            
            const workItemData = {
                id: newId,
                appId: issue.app,
                title: issue.title,
                description: [
                    issue.description || '',
                    issue.stepsToReproduce?.length ? '\n**Steps to Reproduce:**\n' + issue.stepsToReproduce.map((s, i) => `${i + 1}. ${s}`).join('\n') : '',
                    issue.expected ? `\n**Expected:** ${issue.expected}` : '',
                    issue.actual ? `\n**Actual:** ${issue.actual}` : ''
                ].filter(Boolean).join('\n'),
                type: 'bugfix',
                priority: priorityMap[issue.severity] || 'core',
                status: 'ready',
                effort: issue.severity === 'critical' || issue.severity === 'major' ? 'session' : 'quick',
                source: 'promoted',
                tags: ['promoted', `from-${issue.id}`],
                context: {
                    filesAffected: [],
                    sections: [],
                    dependencies: [],
                    notes: `Promoted from issue ${issue.id} (${issue.severity})`,
                    relatedItems: [issue.id]
                }
            };
            
            try {
                await WorkItemService.create(firebaseUser.uid, workItemData);
                
                // Update the issue to note it was promoted
                await IssueService.update(firebaseUser.uid, issue.id, {
                    promotedTo: newId,
                    promotedAt: new Date().toISOString()
                });
                
                showAlert(`Promoted ${issue.id} → ${newId} in Backlog`, 'success');
            } catch (e) {
                showAlert(`Error promoting issue: ${e.message}`, 'error');
            }
        };
        
        // Get issues ready for release (fixed in TEST, not yet in PROD)
        const getIssuesForRelease = (app) => {
            return issues.filter(i => 
                i.app === app && 
                (i.status === 'fixed' || i.status === 'verified') &&
                !i.releasedToProd
            );
        };
        
        // Generate release notes
        const generateReleaseNotes = (app) => {
            const releaseIssues = getIssuesForRelease(app);
            const appInfo = configuredApps.find(a => a.id === app);
            const version = appInfo?.currentTestVersion || '?.?.?';
            
            const notes = `# ${appInfo?.name || app} v${version} Release Notes

## What's New

${releaseIssues.map(i => `- **${i.id}**: ${i.title}`).join('\n') || 'No tracked issues in this release.'}

## Details

${releaseIssues.map(i => `### ${i.id}: ${i.title}
${i.description}
`).join('\n')}

---
Released: ${new Date().toLocaleDateString()}
`;
            return notes;
        };
        
        // Mark issues as released to PROD
        const markReleasedToProd = async (app) => {
            if (!firebaseUser) return;
            
            const releaseIssues = getIssuesForRelease(app);
            const appInfo = configuredApps.find(a => a.id === app);
            const version = appInfo?.currentTestVersion;
            
            // Update each issue via IssueService
            const issueIds = releaseIssues.map(i => i.id);
            await IssueService.markReleasedToProd(firebaseUser.uid, issueIds, version);
            
            // Create release record via ReleaseService
            await ReleaseService.create(firebaseUser.uid, {
                app,
                version,
                deployedAt: new Date().toISOString(),
                issues: issueIds,
                environment: 'prod'
            });
            
            // Copy release notes
            navigator.clipboard.writeText(generateReleaseNotes(app));
            showAlert('Release notes copied to clipboard!', 'Copied');
        };
        
        // Convert user report to tracked issue
        const convertToTrackedIssue = async (report) => {
            if (!firebaseUser) return;
            
            const id = getNextIssueId();
            const issue = {
                id,
                title: report.title || report.description?.substring(0, 50) || 'User reported issue',
                description: report.description || '',
                app: report.section || 'gameshelf',
                severity: report.severity || 'medium',
                createdBy: 'user-report',
                originalReport: {
                    firebaseKey: report.firebaseKey,
                    type: report.type,
                    section: report.section,
                    userAgent: report.userAgent,
                    appVersion: report.appVersion,
                    timestamp: report.timestamp,
                    screenshot: report.screenshot
                },
                stepsToReproduce: [],
                expected: '',
                actual: report.description || ''
            };
            
            await IssueService.create(firebaseUser.uid, issue);
            
            // Mark original report as converted
            if (firebaseDb) {
                await firebaseDb.ref(`reported-issues/${report.firebaseKey}`).update({
                    convertedToIssue: id,
                    convertedAt: new Date().toISOString()
                });
            }
            
            setSelectedUserReport(null);
        };
        
        // Dismiss user report (archive without tracking)
        const dismissUserReport = async (report) => {
            if (!firebaseDb) return;
            
            await firebaseDb.ref(`reported-issues/${report.firebaseKey}`).update({
                dismissed: true,
                dismissedAt: new Date().toISOString()
            });
        };
        
        // Delete user report permanently
        const deleteUserReport = async (report) => {
            if (!firebaseDb) return;
            const confirmed = await showConfirm('Permanently delete this report?', 'Confirm Delete');
            if (!confirmed) return;
            
            await firebaseDb.ref(`reported-issues/${report.firebaseKey}`).remove();
        };
        
        // Get active (non-dismissed, non-converted) user reports
        const activeUserReports = userReports.filter(r => !r.dismissed && !r.convertedToIssue);
        
        // Filter issues
        const filteredIssues = issues.filter(i => {
            if (filter !== 'all' && i.status !== filter) return false;
            if (appFilter !== 'all' && i.app !== appFilter) return false;
            return true;
        });
        
        // Status badge
        const StatusBadge = ({ status }) => {
            const colors = {
                open: 'bg-red-900/50 text-red-300 border-red-700',
                'in-progress': 'bg-yellow-900/50 text-yellow-300 border-yellow-700',
                fixed: 'bg-blue-900/50 text-blue-300 border-blue-700',
                verified: 'bg-green-900/50 text-green-300 border-green-700',
                closed: 'bg-slate-700 text-slate-400 border-slate-600'
            };
            return (
                <span className={`px-2 py-0.5 rounded border text-xs ${colors[status] || colors.open}`}>
                    {status}
                </span>
            );
        };
        
        // Severity badge
        const SeverityBadge = ({ severity }) => {
            const colors = {
                critical: 'text-red-400',
                high: 'text-orange-400',
                medium: 'text-yellow-400',
                low: 'text-slate-400'
            };
            const icons = { critical: '🔴', high: '🟠', medium: '🟡', low: '⚪' };
            return <span className={colors[severity]}>{icons[severity]} {severity}</span>;
        };
        
        if (!firebaseUser) {
            return (
                <div className="bg-amber-900/30 border border-amber-700 rounded-xl p-6 text-center">
                    <div className="text-amber-400 mb-2">⚠️ Sign in Required</div>
                    <div className="text-sm text-slate-400">Go to the Firebase tab to sign in and enable issue tracking.</div>
                </div>
            );
        }
        
        return (
            <div className="space-y-6">
                {/* Header & Stats */}
                <div className="flex items-center justify-between">
                    <div>
                        <h2 className="text-xl font-bold">🐛 Issue Tracker</h2>
                        <div className="text-sm text-slate-400">
                            {issues.filter(i => i.status === 'open').length} open • 
                            {issues.filter(i => i.status === 'fixed').length} fixed • 
                            {issues.filter(i => i.status === 'verified').length} verified
                            {activeUserReports.length > 0 && (
                                <span className="text-orange-400"> • {activeUserReports.length} user reports</span>
                            )}
                        </div>
                    </div>
                    <button
                        onClick={() => setShowNewIssue(true)}
                        className="px-4 py-2 bg-red-600 hover:bg-red-500 rounded-lg flex items-center gap-2">
                        + New Issue
                    </button>
                </div>
                
                {/* Filters */}
                <div className="flex gap-2 flex-wrap">
                    {['all', 'open', 'in-progress', 'fixed', 'verified', 'closed'].map(f => (
                        <button
                            key={f}
                            onClick={() => setFilter(f)}
                            className={`px-3 py-1 rounded text-sm ${filter === f ? 'bg-indigo-600' : 'bg-slate-700 hover:bg-slate-600'}`}>
                            {f}
                        </button>
                    ))}
                    <select
                        value={appFilter}
                        onChange={e => setAppFilter(e.target.value)}
                        className="px-3 py-1 rounded text-sm bg-slate-700 border-none">
                        <option value="all">All Apps</option>
                        {configuredApps.map(app => (
                            <option key={app.id} value={app.id}>{app.name}</option>
                        ))}
                    </select>
                </div>
                
                {/* User-Reported Issues Section */}
                {activeUserReports.length > 0 && (
                    <div className="bg-orange-900/30 border border-orange-700 rounded-xl overflow-hidden">
                        <button 
                            onClick={() => setUserReportsExpanded(!userReportsExpanded)}
                            className="w-full p-4 flex items-center justify-between hover:bg-orange-900/20 transition-colors"
                        >
                            <div className="flex items-center gap-3">
                                <span className="text-2xl">📬</span>
                                <div className="text-left">
                                    <div className="font-semibold text-orange-300">
                                        {activeUserReports.length} User Report{activeUserReports.length !== 1 ? 's' : ''} Pending
                                    </div>
                                    <div className="text-sm text-slate-400">
                                        Submitted from Game Shelf app
                                    </div>
                                </div>
                            </div>
                            <span className="text-xl">{userReportsExpanded ? '▼' : '▶'}</span>
                        </button>
                        
                        {userReportsExpanded && (
                            <div className="border-t border-orange-800 p-4 space-y-3">
                                {activeUserReports.slice(0, 10).map(report => (
                                    <div key={report.firebaseKey} className="bg-slate-800 rounded-lg p-4 border border-slate-700">
                                        <div className="flex items-start justify-between gap-4">
                                            <div className="flex-1 min-w-0">
                                                <div className="flex items-center gap-2 mb-1 flex-wrap">
                                                    <span className={`px-2 py-0.5 rounded text-xs ${
                                                        report.type === 'bug' ? 'bg-red-900/50 text-red-300' :
                                                        report.type === 'feature' ? 'bg-blue-900/50 text-blue-300' :
                                                        report.type === 'ux' ? 'bg-purple-900/50 text-purple-300' :
                                                        'bg-slate-700 text-slate-300'
                                                    }`}>
                                                        {report.type === 'bug' && '🐛'}
                                                        {report.type === 'feature' && '💡'}
                                                        {report.type === 'ux' && '🎨'}
                                                        {report.type === 'other' && '📝'}
                                                        {' '}{report.type || 'report'}
                                                    </span>
                                                    {report.section && (
                                                        <span className="px-2 py-0.5 rounded text-xs bg-slate-700 text-slate-300">
                                                            📍 {report.section}
                                                        </span>
                                                    )}
                                                    {report.severity && (
                                                        <span className={`px-2 py-0.5 rounded text-xs ${
                                                            report.severity === 'critical' ? 'bg-red-900 text-red-200' :
                                                            report.severity === 'major' ? 'bg-orange-900 text-orange-200' :
                                                            report.severity === 'minor' ? 'bg-yellow-900 text-yellow-200' :
                                                            'bg-slate-700 text-slate-300'
                                                        }`}>
                                                            {report.severity}
                                                        </span>
                                                    )}
                                                    {report.appVersion && (
                                                        <span className="text-xs text-slate-500">
                                                            v{report.appVersion}
                                                        </span>
                                                    )}
                                                </div>
                                                <div className="font-medium truncate">
                                                    {report.title || report.description?.substring(0, 60) || 'No description'}
                                                </div>
                                                {report.description && report.title && (
                                                    <div className="text-sm text-slate-400 mt-1 line-clamp-2">
                                                        {report.description}
                                                    </div>
                                                )}
                                                <div className="text-xs text-slate-500 mt-2">
                                                    📅 {new Date(report.timestamp || report.createdAt).toLocaleString()}
                                                </div>
                                            </div>
                                            <div className="flex flex-col gap-1">
                                                <button
                                                    onClick={() => setSelectedUserReport(report)}
                                                    className="px-3 py-1.5 bg-slate-700 hover:bg-slate-600 rounded text-xs whitespace-nowrap"
                                                >
                                                    👁️ View
                                                </button>
                                                <button
                                                    onClick={() => convertToTrackedIssue(report)}
                                                    className="px-3 py-1.5 bg-indigo-600 hover:bg-indigo-500 rounded text-xs whitespace-nowrap"
                                                >
                                                    ➕ Track
                                                </button>
                                                <button
                                                    onClick={() => dismissUserReport(report)}
                                                    className="px-3 py-1.5 bg-slate-800 hover:bg-slate-700 rounded text-xs text-slate-400 whitespace-nowrap"
                                                >
                                                    ✕ Dismiss
                                                </button>
                                            </div>
                                        </div>
                                        {report.screenshot && (
                                            <div className="mt-3 pt-3 border-t border-slate-700">
                                                <img 
                                                    src={report.screenshot} 
                                                    alt="Screenshot" 
                                                    className="max-h-32 rounded cursor-pointer hover:opacity-80"
                                                    onClick={() => window.open(report.screenshot, '_blank')}
                                                />
                                            </div>
                                        )}
                                    </div>
                                ))}
                                {activeUserReports.length > 10 && (
                                    <div className="text-center text-sm text-slate-400">
                                        + {activeUserReports.length - 10} more reports
                                    </div>
                                )}
                            </div>
                        )}
                    </div>
                )}
                
                {/* User Report Detail Modal */}
                {selectedUserReport && (
                    <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50 p-4" onClick={() => setSelectedUserReport(null)}>
                        <div className="bg-slate-800 rounded-xl border border-slate-600 w-full max-w-2xl max-h-[90vh] overflow-y-auto" onClick={e => e.stopPropagation()}>
                            <div className="p-6 border-b border-slate-700 flex items-center justify-between">
                                <h3 className="text-lg font-semibold">📬 User Report</h3>
                                <button onClick={() => setSelectedUserReport(null)} className="text-slate-400 hover:text-white">✕</button>
                            </div>
                            <div className="p-6 space-y-4">
                                <div className="flex flex-wrap gap-2">
                                    <span className={`px-3 py-1 rounded ${
                                        selectedUserReport.type === 'bug' ? 'bg-red-900/50 text-red-300' :
                                        selectedUserReport.type === 'feature' ? 'bg-blue-900/50 text-blue-300' :
                                        'bg-slate-700'
                                    }`}>
                                        {selectedUserReport.type || 'report'}
                                    </span>
                                    {selectedUserReport.section && (
                                        <span className="px-3 py-1 rounded bg-slate-700">📍 {selectedUserReport.section}</span>
                                    )}
                                    {selectedUserReport.severity && (
                                        <span className="px-3 py-1 rounded bg-slate-700">{selectedUserReport.severity}</span>
                                    )}
                                </div>
                                
                                {selectedUserReport.title && (
                                    <div>
                                        <div className="text-sm text-slate-400 mb-1">Title</div>
                                        <div className="font-medium">{selectedUserReport.title}</div>
                                    </div>
                                )}
                                
                                <div>
                                    <div className="text-sm text-slate-400 mb-1">Description</div>
                                    <div className="bg-slate-900 rounded p-3 whitespace-pre-wrap">
                                        {selectedUserReport.description || 'No description provided'}
                                    </div>
                                </div>
                                
                                {selectedUserReport.screenshot && (
                                    <div>
                                        <div className="text-sm text-slate-400 mb-1">Screenshot</div>
                                        <img 
                                            src={selectedUserReport.screenshot} 
                                            alt="Screenshot" 
                                            className="max-w-full rounded cursor-pointer"
                                            onClick={() => window.open(selectedUserReport.screenshot, '_blank')}
                                        />
                                    </div>
                                )}
                                
                                <div className="grid grid-cols-2 gap-4 text-sm">
                                    <div>
                                        <div className="text-slate-400">Submitted</div>
                                        <div>{new Date(selectedUserReport.timestamp || selectedUserReport.createdAt).toLocaleString()}</div>
                                    </div>
                                    <div>
                                        <div className="text-slate-400">App Version</div>
                                        <div>{selectedUserReport.appVersion || 'Unknown'}</div>
                                    </div>
                                </div>
                                
                                {selectedUserReport.userAgent && (
                                    <div>
                                        <div className="text-sm text-slate-400 mb-1">Device/Browser</div>
                                        <div className="text-xs bg-slate-900 rounded p-2 font-mono break-all">
                                            {selectedUserReport.userAgent}
                                        </div>
                                    </div>
                                )}
                            </div>
                            <div className="p-6 border-t border-slate-700 flex gap-3">
                                <button
                                    onClick={() => convertToTrackedIssue(selectedUserReport)}
                                    className="flex-1 px-4 py-2 bg-indigo-600 hover:bg-indigo-500 rounded-lg"
                                >
                                    ➕ Convert to Tracked Issue
                                </button>
                                <button
                                    onClick={() => { dismissUserReport(selectedUserReport); setSelectedUserReport(null); }}
                                    className="px-4 py-2 bg-slate-700 hover:bg-slate-600 rounded-lg"
                                >
                                    Dismiss
                                </button>
                                <button
                                    onClick={() => { deleteUserReport(selectedUserReport); setSelectedUserReport(null); }}
                                    className="px-4 py-2 bg-red-900 hover:bg-red-800 rounded-lg"
                                >
                                    🗑️
                                </button>
                            </div>
                        </div>
                    </div>
                )}
                
                {/* Release Ready Banner */}
                {configuredApps.map(app => {
                    const ready = getIssuesForRelease(app.id);
                    if (ready.length === 0) return null;
                    return (
                        <div key={app.id} className="bg-green-900/30 border border-green-700 rounded-xl p-4 flex items-center justify-between">
                            <div>
                                <div className="font-medium text-green-300 flex items-center gap-1">
                                    <AppIcon icon={app.icon} size={18} /> {app.name}: {ready.length} issue{ready.length !== 1 ? 's' : ''} ready for PROD
                                </div>
                                <div className="text-sm text-slate-400">
                                    {ready.map(i => i.id).join(', ')}
                                </div>
                            </div>
                            <div className="flex gap-2">
                                <button
                                    onClick={() => navigator.clipboard.writeText(generateReleaseNotes(app.id))}
                                    className="px-3 py-1.5 bg-slate-700 hover:bg-slate-600 rounded text-sm">
                                    📋 Copy Notes
                                </button>
                                <button
                                    onClick={() => markReleasedToProd(app.id)}
                                    className="px-3 py-1.5 bg-green-600 hover:bg-green-500 rounded text-sm">
                                    🚀 Mark Released
                                </button>
                            </div>
                        </div>
                    );
                })}
                
                {/* Issues List */}
                <div className="space-y-3">
                    {loading ? (
                        <div className="text-center text-slate-400 py-8">Loading issues...</div>
                    ) : filteredIssues.length === 0 ? (
                        <div className="text-center text-slate-400 py-8">No issues found</div>
                    ) : (
                        filteredIssues.map(issue => (
                            <div
                                key={issue.id}
                                className="bg-slate-800 border border-slate-700 rounded-lg p-4 hover:border-slate-600 transition-colors">
                                <div className="flex items-start justify-between gap-4">
                                    <div className="flex-1">
                                        <div className="flex items-center gap-2 mb-1">
                                            <span className="font-mono text-sm text-indigo-400">{issue.id}</span>
                                            <StatusBadge status={issue.status} />
                                            <SeverityBadge severity={issue.severity} />
                                        </div>
                                        <div className="font-medium">{issue.title}</div>
                                        <div className="text-sm text-slate-400 mt-1">
                                            {issue.app && <span className="mr-3">📱 {configuredApps.find(a => a.id === issue.app)?.name || issue.app}</span>}
                                            <span>📅 {new Date(issue.createdAt).toLocaleDateString()}</span>
                                            {issue.fixedInVersion && <span className="ml-3 text-blue-400">🔧 Fixed in v{issue.fixedInVersion}</span>}
                                            {issue.promotedTo && <span className="ml-3 text-emerald-400">📋 → {issue.promotedTo}</span>}
                                        </div>
                                    </div>
                                    <div className="flex gap-1">
                                        <button
                                            onClick={() => promoteToWorkItem(issue)}
                                            className="px-2 py-1 bg-emerald-700 hover:bg-emerald-600 rounded text-xs"
                                            title="Promote to Work Item">
                                            📋
                                        </button>
                                        <button
                                            onClick={() => copyForClaude(issue)}
                                            className="px-2 py-1 bg-purple-600 hover:bg-purple-500 rounded text-xs"
                                            title="Copy for Claude">
                                            🤖
                                        </button>
                                        <button
                                            onClick={() => setSelectedIssue(issue)}
                                            className="px-2 py-1 bg-slate-700 hover:bg-slate-600 rounded text-xs">
                                            Edit
                                        </button>
                                    </div>
                                </div>
                                
                                {/* Quick status buttons */}
                                <div className="flex gap-2 mt-3 pt-3 border-t border-slate-700">
                                    {issue.status === 'open' && (
                                        <button
                                            onClick={() => updateIssueStatus(issue.id, 'in-progress')}
                                            className="px-2 py-1 bg-yellow-700 hover:bg-yellow-600 rounded text-xs">
                                            Start Working
                                        </button>
                                    )}
                                    {(issue.status === 'open' || issue.status === 'in-progress') && (
                                        <button
                                            onClick={async () => {
                                                const version = await showPrompt('Fixed in version:', '', 'Enter Version');
                                                if (version) linkIssueToVersion(issue.id, version, issue.app);
                                            }}
                                            className="px-2 py-1 bg-blue-700 hover:bg-blue-600 rounded text-xs">
                                            Mark Fixed
                                        </button>
                                    )}
                                    {issue.status === 'fixed' && (
                                        <button
                                            onClick={() => updateIssueStatus(issue.id, 'verified')}
                                            className="px-2 py-1 bg-green-700 hover:bg-green-600 rounded text-xs">
                                            ✓ Verify Fixed
                                        </button>
                                    )}
                                    {!issue.promotedTo && (issue.status === 'open' || issue.status === 'in-progress') && (
                                        <button
                                            onClick={() => promoteToWorkItem(issue)}
                                            className="px-2 py-1 bg-emerald-700 hover:bg-emerald-600 rounded text-xs ml-auto">
                                            📋 Promote to Work Item
                                        </button>
                                    )}
                                </div>
                            </div>
                        ))
                    )}
                </div>
                
                {/* Recent Releases */}
                {releases.length > 0 && (
                    <div className="bg-slate-800 rounded-xl border border-slate-700 p-6">
                        <h3 className="text-lg font-semibold mb-4">📦 Recent Releases</h3>
                        <div className="space-y-2">
                            {releases.slice(0, 5).map(rel => (
                                <div key={rel.id} className="flex items-center justify-between p-3 bg-slate-700/50 rounded-lg">
                                    <div>
                                        <span className="font-medium">{configuredApps.find(a => a.id === rel.app)?.name || rel.app}</span>
                                        <span className="ml-2 font-mono text-green-400">v{rel.version}</span>
                                        <span className="ml-2 text-xs text-slate-400">→ {rel.environment?.toUpperCase()}</span>
                                    </div>
                                    <div className="text-sm text-slate-400">
                                        {rel.issues?.length || 0} issues • {new Date(rel.deployedAt).toLocaleDateString()}
                                    </div>
                                </div>
                            ))}
                        </div>
                    </div>
                )}
                
                {/* Test Plan Integration */}
                {firebaseUser && (
                    <div className="bg-purple-900/30 border border-purple-700 rounded-xl p-6">
                        <h3 className="text-lg font-semibold mb-4 flex items-center gap-2 text-purple-300">
                            🧪 Test Plan Integration
                        </h3>
                        <p className="text-sm text-slate-400 mb-4">
                            The Test Plan app can automatically push issues here when tests fail.
                        </p>
                        
                        <div className="space-y-3">
                            <div className="p-3 bg-slate-800 rounded-lg">
                                <div className="text-xs text-slate-500 mb-1">Firebase Path:</div>
                                <code className="text-sm text-purple-300 break-all">
                                    command-center/{firebaseUser.uid}/issues/
                                </code>
                            </div>
                            
                            <details className="bg-slate-800 rounded-lg">
                                <summary className="p-3 cursor-pointer text-sm font-medium">
                                    📋 Test Plan Integration Code
                                </summary>
                                <pre className="p-3 text-xs overflow-auto border-t border-slate-700 bg-slate-900">
{`// Add to Test Plan - Push issue when test fails
const pushIssueToCommandCenter = async (testResult) => {
  const uid = '${firebaseUser.uid}';
  const issueId = 'ISS-' + String(Date.now()).slice(-6);
  
  await firebase.database()
    .ref(\`command-center/\${uid}/issues/\${issueId}\`)
    .set({
      id: issueId,
      title: testResult.testName + ' failed',
      description: testResult.error || 'Test failed',
      app: testResult.appId, // 'gameshelf', 'quotle', etc
      severity: testResult.critical ? 'high' : 'medium',
      status: 'open',
      createdAt: new Date().toISOString(),
      createdBy: 'test-plan',
      stepsToReproduce: testResult.steps || [],
      expected: testResult.expected,
      actual: testResult.actual,
      testId: testResult.testId
    });
};`}
                                </pre>
                            </details>
                            
                            <div className="flex gap-2">
                                <a href="https://stewartdavidp-ship-it.github.io/gameshelf-testplan/"
                                   target="_blank"
                                   className="flex-1 px-4 py-2 bg-indigo-600 hover:bg-indigo-500 rounded-lg text-center text-sm">
                                    📋 Open Test Plan
                                </a>
                                <a href="https://stewartdavidp-ship-it.github.io/gameshelf-testplan/issue-tracker.html"
                                   target="_blank"
                                   className="flex-1 px-4 py-2 bg-slate-700 hover:bg-slate-600 rounded-lg text-center text-sm">
                                    🐛 Legacy Tracker
                                </a>
                            </div>
                        </div>
                    </div>
                )}
                
                {/* New Issue Modal */}
                {showNewIssue && (
                    <NewIssueModal
                        apps={configuredApps}
                        onSave={createIssue}
                        onCancel={() => setShowNewIssue(false)}
                    />
                )}
                
                {/* Edit Issue Modal */}
                {selectedIssue && (
                    <EditIssueModal
                        issue={selectedIssue}
                        apps={configuredApps}
                        onSave={async (updated) => {
                            if (firebaseUser) {
                                await IssueService.update(firebaseUser.uid, updated.id, updated);
                            }
                            setSelectedIssue(null);
                        }}
                        onCancel={() => setSelectedIssue(null)}
                    />
                )}
            </div>
        );
    }
    
    // New Issue Modal
    function NewIssueModal({ apps, onSave, onCancel }) {
        const [title, setTitle] = React.useState('');
        const [description, setDescription] = React.useState('');
        const [app, setApp] = React.useState(apps[0]?.id || '');
        const [severity, setSeverity] = React.useState('medium');
        const [stepsText, setStepsText] = React.useState('');
        const [expected, setExpected] = React.useState('');
        const [actual, setActual] = React.useState('');
        
        const handleSubmit = () => {
            if (!title.trim()) return;
            onSave({
                title: title.trim(),
                description: description.trim(),
                app,
                severity,
                stepsToReproduce: stepsText.split('\n').filter(s => s.trim()),
                expected: expected.trim(),
                actual: actual.trim()
            });
        };
        
        return (
            <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
                <div className="bg-slate-800 rounded-xl border border-slate-700 w-full max-w-2xl max-h-[90vh] overflow-y-auto">
                    <div className="p-6 border-b border-slate-700">
                        <h3 className="text-lg font-semibold">New Issue</h3>
                    </div>
                    <div className="p-6 space-y-4">
                        <div>
                            <label className="block text-sm text-slate-400 mb-1">Title *</label>
                            <input
                                value={title}
                                onChange={e => setTitle(e.target.value)}
                                className="w-full p-2 bg-slate-900 border border-slate-600 rounded"
                                placeholder="Brief description of the issue"
                            />
                        </div>
                        <div className="grid grid-cols-2 gap-4">
                            <div>
                                <label className="block text-sm text-slate-400 mb-1">App</label>
                                <select
                                    value={app}
                                    onChange={e => setApp(e.target.value)}
                                    className="w-full p-2 bg-slate-900 border border-slate-600 rounded">
                                    {apps.map(a => (
                                        <option key={a.id} value={a.id}>{a.name}</option>
                                    ))}
                                </select>
                            </div>
                            <div>
                                <label className="block text-sm text-slate-400 mb-1">Severity</label>
                                <select
                                    value={severity}
                                    onChange={e => setSeverity(e.target.value)}
                                    className="w-full p-2 bg-slate-900 border border-slate-600 rounded">
                                    <option value="critical">🔴 Critical</option>
                                    <option value="high">🟠 High</option>
                                    <option value="medium">🟡 Medium</option>
                                    <option value="low">⚪ Low</option>
                                </select>
                            </div>
                        </div>
                        <div>
                            <label className="block text-sm text-slate-400 mb-1">Description</label>
                            <textarea
                                value={description}
                                onChange={e => setDescription(e.target.value)}
                                className="w-full p-2 bg-slate-900 border border-slate-600 rounded h-20"
                                placeholder="Detailed description"
                            />
                        </div>
                        <div>
                            <label className="block text-sm text-slate-400 mb-1">Steps to Reproduce (one per line)</label>
                            <textarea
                                value={stepsText}
                                onChange={e => setStepsText(e.target.value)}
                                className="w-full p-2 bg-slate-900 border border-slate-600 rounded h-20 font-mono text-sm"
                                placeholder="1. Go to...&#10;2. Click on...&#10;3. Observe..."
                            />
                        </div>
                        <div className="grid grid-cols-2 gap-4">
                            <div>
                                <label className="block text-sm text-slate-400 mb-1">Expected</label>
                                <textarea
                                    value={expected}
                                    onChange={e => setExpected(e.target.value)}
                                    className="w-full p-2 bg-slate-900 border border-slate-600 rounded h-16"
                                />
                            </div>
                            <div>
                                <label className="block text-sm text-slate-400 mb-1">Actual</label>
                                <textarea
                                    value={actual}
                                    onChange={e => setActual(e.target.value)}
                                    className="w-full p-2 bg-slate-900 border border-slate-600 rounded h-16"
                                />
                            </div>
                        </div>
                    </div>
                    <div className="p-6 border-t border-slate-700 flex justify-end gap-3">
                        <button onClick={onCancel} className="px-4 py-2 bg-slate-700 hover:bg-slate-600 rounded">
                            Cancel
                        </button>
                        <button onClick={handleSubmit} className="px-4 py-2 bg-red-600 hover:bg-red-500 rounded">
                            Create Issue
                        </button>
                    </div>
                </div>
            </div>
        );
    }
    
    // Edit Issue Modal
    function EditIssueModal({ issue, apps, onSave, onCancel }) {
        const [title, setTitle] = React.useState(issue.title || '');
        const [description, setDescription] = React.useState(issue.description || '');
        const [app, setApp] = React.useState(issue.app || apps[0]?.id || '');
        const [severity, setSeverity] = React.useState(issue.severity || 'medium');
        const [stepsText, setStepsText] = React.useState(issue.stepsToReproduce?.join('\n') || '');
        const [expected, setExpected] = React.useState(issue.expected || '');
        const [actual, setActual] = React.useState(issue.actual || '');
        
        const handleSubmit = () => {
            onSave({
                ...issue,
                title: title.trim(),
                description: description.trim(),
                app,
                severity,
                stepsToReproduce: stepsText.split('\n').filter(s => s.trim()),
                expected: expected.trim(),
                actual: actual.trim()
            });
        };
        
        return (
            <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
                <div className="bg-slate-800 rounded-xl border border-slate-700 w-full max-w-2xl max-h-[90vh] overflow-y-auto">
                    <div className="p-6 border-b border-slate-700">
                        <h3 className="text-lg font-semibold">Edit {issue.id}</h3>
                    </div>
                    <div className="p-6 space-y-4">
                        <div>
                            <label className="block text-sm text-slate-400 mb-1">Title</label>
                            <input
                                value={title}
                                onChange={e => setTitle(e.target.value)}
                                className="w-full p-2 bg-slate-900 border border-slate-600 rounded"
                            />
                        </div>
                        <div className="grid grid-cols-2 gap-4">
                            <div>
                                <label className="block text-sm text-slate-400 mb-1">App</label>
                                <select
                                    value={app}
                                    onChange={e => setApp(e.target.value)}
                                    className="w-full p-2 bg-slate-900 border border-slate-600 rounded">
                                    {apps.map(a => (
                                        <option key={a.id} value={a.id}>{a.name}</option>
                                    ))}
                                </select>
                            </div>
                            <div>
                                <label className="block text-sm text-slate-400 mb-1">Severity</label>
                                <select
                                    value={severity}
                                    onChange={e => setSeverity(e.target.value)}
                                    className="w-full p-2 bg-slate-900 border border-slate-600 rounded">
                                    <option value="critical">🔴 Critical</option>
                                    <option value="high">🟠 High</option>
                                    <option value="medium">🟡 Medium</option>
                                    <option value="low">⚪ Low</option>
                                </select>
                            </div>
                        </div>
                        <div>
                            <label className="block text-sm text-slate-400 mb-1">Description</label>
                            <textarea
                                value={description}
                                onChange={e => setDescription(e.target.value)}
                                className="w-full p-2 bg-slate-900 border border-slate-600 rounded h-20"
                            />
                        </div>
                        <div>
                            <label className="block text-sm text-slate-400 mb-1">Steps to Reproduce</label>
                            <textarea
                                value={stepsText}
                                onChange={e => setStepsText(e.target.value)}
                                className="w-full p-2 bg-slate-900 border border-slate-600 rounded h-20 font-mono text-sm"
                            />
                        </div>
                        <div className="grid grid-cols-2 gap-4">
                            <div>
                                <label className="block text-sm text-slate-400 mb-1">Expected</label>
                                <textarea
                                    value={expected}
                                    onChange={e => setExpected(e.target.value)}
                                    className="w-full p-2 bg-slate-900 border border-slate-600 rounded h-16"
                                />
                            </div>
                            <div>
                                <label className="block text-sm text-slate-400 mb-1">Actual</label>
                                <textarea
                                    value={actual}
                                    onChange={e => setActual(e.target.value)}
                                    className="w-full p-2 bg-slate-900 border border-slate-600 rounded h-16"
                                />
                            </div>
                        </div>
                    </div>
                    <div className="p-6 border-t border-slate-700 flex justify-end gap-3">
                        <button onClick={onCancel} className="px-4 py-2 bg-slate-700 hover:bg-slate-600 rounded">
                            Cancel
                        </button>
                        <button onClick={handleSubmit} className="px-4 py-2 bg-indigo-600 hover:bg-indigo-500 rounded">
                            Save Changes
                        </button>
                    </div>
                </div>
            </div>
        );
    }

    // =========================================================================
    // CONFIG VIEW (v7.0.0) - Dynamic Environment & App Configuration
    // =========================================================================
    
    function ConfigView({ config, onConfigChange, showAlert, showConfirm, github, availableRepos, onRefreshRepos }) {
        const [activeTab, setActiveTab] = React.useState('environments');
        const [editingApp, setEditingApp] = React.useState(null);
        const [newAppForm, setNewAppForm] = React.useState(null);
        const [creatingRepo, setCreatingRepo] = React.useState(null); // { appId, env }
        const [repoCreationStatus, setRepoCreationStatus] = React.useState({});
        
        // Internal tools that don't need DEV/BETA repos
        const internalTools = ['testplan', 'command-center'];
        const gameApps = Object.values(config.apps).filter(app => !internalTools.includes(app.id));
        
        // Get GitHub username from available repos
        const githubOwner = availableRepos[0]?.owner || 'stewartdavidp-ship-it';
        
        const updateConfig = (newConfig) => {
            onConfigChange(newConfig);
        };
        
        // Environment Management
        const toggleEnv = (envId) => {
            const newConfig = ConfigManager.toggleEnvironment({ ...config }, envId);
            updateConfig(newConfig);
        };
        
        // App Management
        const saveApp = (appData) => {
            let newConfig = { ...config, apps: { ...config.apps } };
            if (editingApp) {
                newConfig = ConfigManager.updateApp(newConfig, editingApp.id, appData);
            } else {
                newConfig = ConfigManager.addApp(newConfig, appData);
            }
            updateConfig(newConfig);
            setEditingApp(null);
            setNewAppForm(null);
        };
        
        const deleteApp = async (appId) => {
            const confirmed = await showConfirm(`Delete "${config.apps[appId]?.name}"? This cannot be undone.`, 'Delete App');
            if (confirmed) {
                const newConfig = ConfigManager.removeApp({ ...config, apps: { ...config.apps } }, appId);
                updateConfig(newConfig);
            }
        };
        
        // Create a new repository for an app environment
        const createRepoForApp = async (appId, env) => {
            if (!github) {
                await showAlert('Configure GitHub token first', 'GitHub Required');
                return;
            }
            
            const app = config.apps[appId];
            if (!app) return;
            
            // Generate repo name based on patterns
            const repoPatterns = app.repoPatterns[env] || [];
            const suggestedName = repoPatterns[0] || `${appId}${env}`;
            
            // Check if repo already exists
            const exists = await github.repoExists(githubOwner, suggestedName);
            if (exists) {
                const useExisting = await showConfirm(
                    `Repository "${suggestedName}" already exists.\n\nAssign it to ${app.name} ${env.toUpperCase()}?`,
                    'Repository Exists'
                );
                if (useExisting) {
                    // Update config with existing repo
                    const newConfig = { ...config, apps: { ...config.apps } };
                    newConfig.apps[appId] = {
                        ...newConfig.apps[appId],
                        repos: { ...newConfig.apps[appId].repos, [env]: `${githubOwner}/${suggestedName}` }
                    };
                    updateConfig(newConfig);
                    setRepoCreationStatus(prev => ({ ...prev, [`${appId}-${env}`]: 'assigned' }));
                }
                return;
            }
            
            // Confirm creation
            const confirmed = await showConfirm(
                `Create new repository?\n\n` +
                `Name: ${suggestedName}\n` +
                `For: ${app.name} (${env.toUpperCase()})\n` +
                `URL: https://${githubOwner}.github.io/${suggestedName}/\n\n` +
                `This will create a public repo with GitHub Pages enabled.`,
                `Create ${env.toUpperCase()} Repository`
            );
            
            if (!confirmed) return;
            
            setCreatingRepo({ appId, env });
            setRepoCreationStatus(prev => ({ ...prev, [`${appId}-${env}`]: 'creating' }));
            
            try {
                // Create the repository
                const description = `${app.name} - ${env.toUpperCase()} environment`;
                const result = await github.createRepo(suggestedName, description, false);
                
                setRepoCreationStatus(prev => ({ ...prev, [`${appId}-${env}`]: 'enabling-pages' }));
                
                // Wait a moment for GitHub to initialize the repo
                await new Promise(r => setTimeout(r, 2000));
                
                // Enable GitHub Pages
                try {
                    await github.enablePages(result.fullName);
                } catch (e) {
                    console.log('Pages may need manual enabling:', e);
                }
                
                // Update config with new repo
                const newConfig = { ...config, apps: { ...config.apps } };
                newConfig.apps[appId] = {
                    ...newConfig.apps[appId],
                    repos: { ...newConfig.apps[appId].repos, [env]: result.fullName }
                };
                updateConfig(newConfig);
                
                // Refresh repo list
                if (onRefreshRepos) onRefreshRepos();
                
                setRepoCreationStatus(prev => ({ ...prev, [`${appId}-${env}`]: 'complete' }));
                await showAlert(
                    `Repository created successfully!\n\n` +
                    `${result.fullName}\n` +
                    `${result.pagesUrl}`,
                    '✅ Repository Created'
                );
                
            } catch (error) {
                console.error('Failed to create repo:', error);
                setRepoCreationStatus(prev => ({ ...prev, [`${appId}-${env}`]: 'error' }));
                await showAlert(`Failed to create repository: ${error.message}`, 'Error');
            } finally {
                setCreatingRepo(null);
            }
        };
        
        // Get repo status for an app/env
        const getRepoStatus = (appId, env) => {
            const app = config.apps[appId];
            const repo = app?.repos?.[env];
            const statusKey = `${appId}-${env}`;
            
            if (repoCreationStatus[statusKey]) {
                return repoCreationStatus[statusKey];
            }
            if (repo) {
                return 'configured';
            }
            return 'not-created';
        };
        
        const envColors = config.environments.colors;
        const activeEnvs = config.environments.active;
        
        return (
            <div className="space-y-6">
                <div className="flex items-center justify-between">
                    <h2 className="text-xl font-bold flex items-center gap-2">
                        ⚙️ Configuration
                    </h2>
                    <div className="text-xs text-slate-500">Config v{config.version}</div>
                </div>
                
                {/* Tab Navigation */}
                <div className="flex gap-2 border-b border-slate-700 pb-2">
                    {[
                        { id: 'environments', label: '🌍 Environments' },
                        { id: 'repos', label: '🗄️ Repositories' },
                        { id: 'detection', label: '🔍 Detection' }
                    ].map(tab => (
                        <button
                            key={tab.id}
                            onClick={() => setActiveTab(tab.id)}
                            className={`px-4 py-2 rounded-t-lg font-medium transition-colors ${
                                activeTab === tab.id 
                                    ? 'bg-slate-700 text-white' 
                                    : 'text-slate-400 hover:text-white hover:bg-slate-800'
                            }`}
                        >
                            {tab.label}
                        </button>
                    ))}
                </div>
                
                {/* Environments Tab */}
                {activeTab === 'environments' && (
                    <div className="space-y-6">
                        <div className="bg-slate-800 rounded-xl p-6 border border-slate-700">
                            <h3 className="font-semibold mb-4">Deployment Tiers</h3>
                            <p className="text-sm text-slate-400 mb-4">
                                Enable the environments you use. Files deploy through active tiers in order.
                            </p>
                            
                            <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
                                {config.environments.available.map(env => {
                                    const isActive = activeEnvs.includes(env);
                                    const colors = envColors[env];
                                    return (
                                        <button
                                            key={env}
                                            onClick={() => toggleEnv(env)}
                                            className={`p-4 rounded-xl border-2 transition-all ${
                                                isActive 
                                                    ? `${colors.bg} ${colors.border} text-white` 
                                                    : 'bg-slate-900 border-slate-600 text-slate-400 hover:border-slate-500'
                                            }`}
                                        >
                                            <div className="text-2xl mb-2">
                                                {config.environments.icons[env]}
                                            </div>
                                            <div className="font-bold uppercase">{config.environments.labels[env]}</div>
                                            <div className="text-xs mt-1 opacity-75">
                                                {isActive ? '✓ Active' : 'Disabled'}
                                            </div>
                                        </button>
                                    );
                                })}
                            </div>
                            
                            <div className="mt-6 p-4 bg-slate-900 rounded-lg">
                                <div className="text-sm font-medium mb-2">Current Flow:</div>
                                <div className="flex items-center gap-2 flex-wrap">
                                    {activeEnvs.map((env, idx) => (
                                        <React.Fragment key={env}>
                                            <span className={`px-3 py-1 rounded-full text-sm font-medium ${envColors[env].bg}`}>
                                                {config.environments.labels[env]}
                                            </span>
                                            {idx < activeEnvs.length - 1 && (
                                                <span className="text-slate-500">→</span>
                                            )}
                                        </React.Fragment>
                                    ))}
                                </div>
                            </div>
                        </div>
                        
                        <div className="bg-amber-900/30 border border-amber-700 rounded-xl p-4">
                            <div className="flex items-start gap-3">
                                <Icons.AlertTriangle className="text-amber-400 mt-0.5" />
                                <div>
                                    <div className="font-medium text-amber-300">Environment Changes</div>
                                    <div className="text-sm text-slate-300 mt-1">
                                        Adding DEV creates a rapid-build tier before TEST. Adding BETA creates a feature-flag tier after PROD.
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                )}
                
                {/* Repositories Tab */}
                {activeTab === 'repos' && (
                    <div className="space-y-6">
                        <div className="bg-slate-800 rounded-xl p-6 border border-slate-700">
                            <h3 className="font-semibold mb-2">Repository Management</h3>
                            <p className="text-sm text-slate-400 mb-4">
                                Create and manage GitHub repositories for each app environment. 
                                DEV is for rapid iteration, BETA is for feature-flagged production testing.
                            </p>
                            
                            {!github && (
                                <div className="bg-amber-900/30 border border-amber-700 rounded-lg p-4 mb-4">
                                    <div className="text-amber-300 font-medium">⚠️ GitHub Token Required</div>
                                    <div className="text-sm text-slate-300 mt-1">
                                        Configure your GitHub token in Settings to create repositories.
                                    </div>
                                </div>
                            )}
                            
                            <div className="space-y-4">
                                {gameApps.map(app => (
                                    <div key={app.id} className="bg-slate-900 rounded-xl p-4 border border-slate-700">
                                        <div className="flex items-center gap-3 mb-4">
                                            <AppIcon icon={app.icon} size={28} />
                                            <div>
                                                <div className="font-semibold">{app.name}</div>
                                                <div className="text-xs text-slate-400">
                                                    {app.hasServiceWorker ? 'PWA' : 'Web App'}
                                                </div>
                                            </div>
                                        </div>
                                        
                                        <div className="grid grid-cols-2 md:grid-cols-4 gap-3">
                                            {['dev', 'test', 'prod', 'beta'].map(env => {
                                                const isActive = activeEnvs.includes(env);
                                                const repo = app.repos?.[env];
                                                const status = getRepoStatus(app.id, env);
                                                const colors = envColors[env];
                                                const isCreating = creatingRepo?.appId === app.id && creatingRepo?.env === env;
                                                
                                                return (
                                                    <div 
                                                        key={env} 
                                                        className={`p-3 rounded-lg border ${
                                                            isActive ? colors.border : 'border-slate-700 opacity-50'
                                                        } ${isActive ? 'bg-slate-800' : 'bg-slate-900'}`}
                                                    >
                                                        <div className={`text-xs font-medium mb-2 ${isActive ? colors.text : 'text-slate-500'}`}>
                                                            {config.environments.labels[env]}
                                                            {!isActive && ' (disabled)'}
                                                        </div>
                                                        
                                                        {repo ? (
                                                            <div>
                                                                <div className="text-xs font-mono text-green-400 truncate" title={repo}>
                                                                    ✓ {repo.split('/')[1]}
                                                                </div>
                                                                <a 
                                                                    href={`https://github.com/${repo}`}
                                                                    target="_blank"
                                                                    className="text-xs text-slate-400 hover:text-white"
                                                                >
                                                                    View →
                                                                </a>
                                                            </div>
                                                        ) : isActive ? (
                                                            <button
                                                                onClick={() => createRepoForApp(app.id, env)}
                                                                disabled={!github || isCreating}
                                                                className={`w-full px-2 py-1.5 rounded text-xs font-medium transition-colors ${
                                                                    isCreating 
                                                                        ? 'bg-slate-700 text-slate-400 cursor-wait'
                                                                        : github
                                                                            ? `${colors.bg} hover:opacity-90 text-white`
                                                                            : 'bg-slate-700 text-slate-500 cursor-not-allowed'
                                                                }`}
                                                            >
                                                                {isCreating ? (
                                                                    status === 'enabling-pages' ? '⏳ Enabling Pages...' : '⏳ Creating...'
                                                                ) : (
                                                                    <>+ Create Repo</>
                                                                )}
                                                            </button>
                                                        ) : (
                                                            <div className="text-xs text-slate-500 italic">
                                                                Enable {env.toUpperCase()} first
                                                            </div>
                                                        )}
                                                    </div>
                                                );
                                            })}
                                        </div>
                                    </div>
                                ))}
                            </div>
                        </div>
                        
                        <div className="bg-slate-800 rounded-xl p-6 border border-slate-700">
                            <h3 className="font-semibold mb-2">Internal Tools</h3>
                            <p className="text-sm text-slate-400 mb-4">
                                These tools only use TEST and PROD environments.
                            </p>
                            
                            <div className="space-y-3">
                                {Object.values(config.apps)
                                    .filter(app => internalTools.includes(app.id))
                                    .map(app => (
                                        <div key={app.id} className="flex items-center justify-between p-3 bg-slate-900 rounded-lg">
                                            <div className="flex items-center gap-3">
                                                <AppIcon icon={app.icon} size={24} />
                                                <span className="font-medium">{app.name}</span>
                                            </div>
                                            <div className="flex gap-2">
                                                {['test', 'prod'].map(env => {
                                                    const repo = app.repos?.[env];
                                                    return repo ? (
                                                        <span key={env} className="text-xs px-2 py-1 bg-slate-800 rounded text-slate-400">
                                                            {env.toUpperCase()}: {repo.split('/')[1]}
                                                        </span>
                                                    ) : (
                                                        <span key={env} className="text-xs px-2 py-1 bg-slate-800 rounded text-slate-500">
                                                            {env.toUpperCase()}: —
                                                        </span>
                                                    );
                                                })}
                                            </div>
                                        </div>
                                    ))}
                            </div>
                        </div>
                    </div>
                )}
                
                {/* Detection Tab */}
                {activeTab === 'detection' && (
                    <div className="space-y-4">
                        <div className="bg-slate-800 rounded-xl p-6 border border-slate-700">
                            <h3 className="font-semibold mb-2">Content Detection Patterns</h3>
                            <p className="text-sm text-slate-400 mb-4">
                                Regex patterns (case-insensitive) used to auto-detect which app a file belongs to.
                            </p>
                            
                            <div className="space-y-4">
                                {Object.values(config.apps).map(app => (
                                    <div key={app.id} className="p-4 bg-slate-900 rounded-lg">
                                        <div className="flex items-center gap-2 mb-2">
                                            <AppIcon icon={app.icon} size={20} />
                                            <span className="font-medium">{app.name}</span>
                                        </div>
                                        <div className="flex flex-wrap gap-2">
                                            {app.detectionPatterns.map((pattern, idx) => (
                                                <code key={idx} className="px-2 py-1 bg-slate-800 rounded text-xs text-green-400">
                                                    {pattern}
                                                </code>
                                            ))}
                                        </div>
                                    </div>
                                ))}
                            </div>
                        </div>
                        
                        <div className="bg-slate-800 rounded-xl p-6 border border-slate-700">
                            <h3 className="font-semibold mb-2">Repo Name Patterns</h3>
                            <p className="text-sm text-slate-400 mb-4">
                                Patterns for auto-suggesting apps based on GitHub repo names.
                            </p>
                            
                            <div className="overflow-x-auto">
                                <table className="w-full text-sm">
                                    <thead>
                                        <tr className="text-left text-slate-400 border-b border-slate-700">
                                            <th className="pb-2 pr-4">App</th>
                                            {activeEnvs.map(env => (
                                                <th key={env} className={`pb-2 pr-4 ${envColors[env].text}`}>
                                                    {config.environments.labels[env]}
                                                </th>
                                            ))}
                                        </tr>
                                    </thead>
                                    <tbody>
                                        {Object.values(config.apps).map(app => (
                                            <tr key={app.id} className="border-b border-slate-800">
                                                <td className="py-2 pr-4 font-medium">
                                                    <span className="flex items-center gap-2">
                                                        <AppIcon icon={app.icon} size={16} />
                                                        {app.name}
                                                    </span>
                                                </td>
                                                {activeEnvs.map(env => (
                                                    <td key={env} className="py-2 pr-4">
                                                        <div className="flex flex-wrap gap-1">
                                                            {(app.repoPatterns[env] || []).map((p, i) => (
                                                                <code key={i} className="px-1 bg-slate-800 rounded text-xs">
                                                                    {p}
                                                                </code>
                                                            ))}
                                                        </div>
                                                    </td>
                                                ))}
                                            </tr>
                                        ))}
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                )}
            </div>
        );
    }
    
    // App Edit Modal Component
    function AppEditModal({ app, isNew, environments, envLabels, projects, availableRepos, allApps, onSave, onCancel }) {
        const [form, setForm] = React.useState({
            id: app.id || '',
            name: app.name || '',
            icon: app.icon || '📦',
            project: app.project || 'other',
            subPath: app.subPath || '',
            targetPath: app.targetPath || 'index.html',
            swPath: app.swPath || '',
            hasServiceWorker: app.hasServiceWorker || false,
            repos: app.repos || {},
            detectionPatterns: (app.detectionPatterns || []).join('\n'),
            repoPatterns: Object.fromEntries(
                environments.map(env => [env, (app.repoPatterns?.[env] || []).join(', ')])
            ),
            // v8.20.0: Lifecycle fields
            lifecycle: {
                category: app.lifecycle?.category || null,
                currentMaturity: app.lifecycle?.currentMaturity || null,
                maturityTarget: app.lifecycle?.maturityTarget || null,
                problemStatement: app.lifecycle?.problemStatement || '',
                targetAudience: app.lifecycle?.targetAudience || '',
                userGoal: app.lifecycle?.userGoal || '',
                successMetric: app.lifecycle?.successMetric || ''
            }
        });
        
        const [activeTab, setActiveTab] = React.useState('general'); // 'general' or 'lifecycle'
        const [repoMode, setRepoMode] = React.useState('dropdown'); // 'dropdown' or 'manual'
        const [patternsManuallyEdited, setPatternsManuallyEdited] = React.useState(!isNew);
        const [showEmojiPicker, setShowEmojiPicker] = React.useState(false);
        
        // Common emoji options for apps grouped by category
        const emojiOptions = [
            { label: 'Tools', emojis: ['🔧', '🛠️', '⚙️', '🔨', '🪛', '🏗️', '🔩'] },
            { label: 'Games', emojis: ['🎮', '🎲', '🃏', '♟️', '🎯', '🏆', '🎪'] },
            { label: 'Objects', emojis: ['📦', '📋', '📊', '📁', '💾', '🗂️', '📝'] },
            { label: 'Symbols', emojis: ['🚀', '⚡', '🔥', '💡', '🧪', '🎨', '🌟'] },
            { label: 'Combo', emojis: ['🪜🔧', '🪜🛠️', '🏗️🪜', '⚙️🪜'] }
        ];
        
        // Generate detection patterns from app name
        const generatePatterns = (name) => {
            if (!name.trim()) return '';
            const trimmed = name.trim();
            const lower = trimmed.toLowerCase();
            const noSpaces = trimmed.replace(/\s+/g, '');
            const kebab = lower.replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, '');
            const underscored = lower.replace(/[^a-z0-9]+/g, '_').toUpperCase();
            
            const patterns = new Set();
            patterns.add(`<title>${trimmed}`);
            if (kebab !== lower) patterns.add(kebab);
            if (noSpaces !== trimmed) patterns.add(noSpaces);
            patterns.add(underscored);
            return [...patterns].join('\n');
        };
        
        // Handle name changes - auto-generate ID and detection patterns
        const handleNameChange = (newName) => {
            const updates = { name: newName };
            
            // Auto-generate ID for new apps
            if (isNew) {
                updates.id = newName.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, '');
            }
            
            // Auto-generate detection patterns for new apps (unless manually edited)
            if (isNew && !patternsManuallyEdited) {
                updates.detectionPatterns = generatePatterns(newName);
            }
            
            setForm(prev => ({ ...prev, ...updates }));
        };
        
        // Build list of repos already assigned to other apps (for context)
        const assignedRepos = React.useMemo(() => {
            const map = {};
            if (allApps) {
                Object.values(allApps).forEach(a => {
                    if (a.id === app.id) return; // skip current app
                    environments.forEach(env => {
                        const repo = a.repos?.[env];
                        if (repo) {
                            if (!map[repo]) map[repo] = [];
                            map[repo].push(`${a.name} ${envLabels[env]}`);
                        }
                    });
                });
            }
            return map;
        }, [allApps, app.id, environments, envLabels]);
        
        // Group repos: shared repos (used by multiple apps via subPath) vs dedicated
        const repoOptions = React.useMemo(() => {
            if (!availableRepos?.length) return [];
            return availableRepos.map(r => ({
                ...r,
                assignedTo: assignedRepos[r.fullName] || [],
                isShared: (assignedRepos[r.fullName] || []).length > 0
            })).sort((a, b) => {
                // Sort: shared repos first (likely candidates for subPath apps), then alpha
                if (a.isShared && !b.isShared) return -1;
                if (!a.isShared && b.isShared) return 1;
                return a.name.localeCompare(b.name);
            });
        }, [availableRepos, assignedRepos]);
        
        const handleSave = () => {
            const effectiveId = form.id || form.name.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, '');
            
            // Build repo patterns from selected repos
            const repoPatterns = {};
            environments.forEach(env => {
                if (repoMode === 'dropdown') {
                    // In dropdown mode, derive patterns from selected repo
                    const selectedRepo = form.repos[env];
                    if (selectedRepo) {
                        const repoName = selectedRepo.split('/').pop();
                        repoPatterns[env] = [repoName];
                    } else {
                        repoPatterns[env] = [];
                    }
                } else {
                    // Manual mode - parse comma-separated
                    repoPatterns[env] = form.repoPatterns[env]?.split(',').map(s => s.trim()).filter(Boolean) || [];
                }
            });
            
            const data = {
                ...form,
                id: effectiveId,
                detectionPatterns: form.detectionPatterns.split('\n').filter(p => p.trim()),
                repoPatterns,
                // v8.20.0: Include lifecycle data
                lifecycle: form.lifecycle
            };
            onSave(data);
        };
        
        return (
            <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
                <div className="bg-slate-800 rounded-xl border border-slate-600 w-full max-w-2xl max-h-[90vh] overflow-y-auto">
                    <div className="p-6 border-b border-slate-700">
                        <h3 className="text-lg font-bold">{isNew ? 'Add New App' : `Edit ${app.name}`}</h3>
                        {/* v8.20.0: Tab navigation */}
                        <div className="flex gap-1 mt-3">
                            <button 
                                onClick={() => setActiveTab('general')}
                                className={`px-3 py-1.5 rounded text-sm font-medium ${activeTab === 'general' ? 'bg-indigo-600 text-white' : 'bg-slate-700 text-slate-300 hover:bg-slate-600'}`}
                            >
                                ⚙️ General
                            </button>
                            <button 
                                onClick={() => setActiveTab('lifecycle')}
                                className={`px-3 py-1.5 rounded text-sm font-medium ${activeTab === 'lifecycle' ? 'bg-indigo-600 text-white' : 'bg-slate-700 text-slate-300 hover:bg-slate-600'}`}
                            >
                                📊 Lifecycle
                            </button>
                        </div>
                    </div>
                    
                    {activeTab === 'general' && <div className="p-6 space-y-4">
                        <div className="grid grid-cols-2 gap-4">
                            <div>
                                <label className="block text-sm font-medium mb-1">App Name</label>
                                <input 
                                    type="text"
                                    value={form.name}
                                    onChange={e => handleNameChange(e.target.value)}
                                    className="w-full p-2 bg-slate-900 border border-slate-600 rounded"
                                    placeholder="My App"
                                />
                            </div>
                            <div>
                                <label className="block text-sm font-medium mb-1">Icon (emoji)</label>
                                <div className="relative">
                                    <div className="flex gap-2">
                                        <input 
                                            type="text"
                                            value={form.icon}
                                            onChange={e => setForm({ ...form, icon: e.target.value })}
                                            className="w-full p-2 bg-slate-900 border border-slate-600 rounded"
                                        />
                                        <button 
                                            type="button"
                                            onClick={() => setShowEmojiPicker(!showEmojiPicker)}
                                            className={`px-3 py-2 rounded border text-sm whitespace-nowrap ${showEmojiPicker ? 'bg-indigo-600 border-indigo-500 text-white' : 'bg-slate-700 border-slate-600 hover:bg-slate-600 text-slate-300'}`}
                                        >
                                            😀 Pick
                                        </button>
                                    </div>
                                    {showEmojiPicker && (
                                        <div className="absolute right-0 top-full mt-1 bg-slate-800 border border-slate-600 rounded-lg shadow-xl z-50 p-3 w-72">
                                            {emojiOptions.map(group => (
                                                <div key={group.label} className="mb-2">
                                                    <div className="text-xs text-slate-500 mb-1">{group.label}</div>
                                                    <div className="flex flex-wrap gap-1">
                                                        {group.emojis.map(emoji => (
                                                            <button
                                                                key={emoji}
                                                                type="button"
                                                                onClick={() => { setForm({ ...form, icon: emoji }); setShowEmojiPicker(false); }}
                                                                className={`w-9 h-9 rounded hover:bg-slate-700 text-lg flex items-center justify-center ${form.icon === emoji ? 'bg-indigo-600/30 ring-1 ring-indigo-500' : ''}`}
                                                            >
                                                                {emoji}
                                                            </button>
                                                        ))}
                                                    </div>
                                                </div>
                                            ))}
                                        </div>
                                    )}
                                </div>
                            </div>
                        </div>
                        <div>
                            <label className="block text-sm font-medium mb-1">Project</label>
                            <select value={form.project} onChange={e => setForm({ ...form, project: e.target.value })}
                                className="w-full p-2 bg-slate-900 border border-slate-600 rounded">
                                {Object.values(projects || SEED_PROJECTS).sort((a, b) => (a.order || 99) - (b.order || 99)).map(p => (
                                    <option key={p.id} value={p.id}>{p.icon === 'gs-logo' ? '🎮' : p.icon} {p.name}</option>
                                ))}
                            </select>
                        </div>
                        
                        <div>
                            <label className="block text-sm font-medium mb-1">Sub Path</label>
                            <input 
                                type="text"
                                value={form.subPath}
                                onChange={e => setForm({ ...form, subPath: e.target.value })}
                                className="w-full p-2 bg-slate-900 border border-slate-600 rounded font-mono text-sm"
                                placeholder="e.g. rungs, rungs/builder (leave empty for repo root)"
                            />
                            <div className="text-xs text-slate-500 mt-1">Directory within the repo where app files live. Supports nested paths.</div>
                        </div>
                        
                        <div className="grid grid-cols-2 gap-4">
                            <div>
                                <label className="block text-sm font-medium mb-1">Target Path</label>
                                <input 
                                    type="text"
                                    value={form.targetPath}
                                    onChange={e => setForm({ ...form, targetPath: e.target.value })}
                                    className="w-full p-2 bg-slate-900 border border-slate-600 rounded"
                                    placeholder="index.html"
                                />
                            </div>
                            <div>
                                <label className="block text-sm font-medium mb-1">Service Worker Path</label>
                                <input 
                                    type="text"
                                    value={form.swPath}
                                    onChange={e => setForm({ ...form, swPath: e.target.value })}
                                    className="w-full p-2 bg-slate-900 border border-slate-600 rounded"
                                    placeholder="sw.js (leave empty if none)"
                                />
                            </div>
                        </div>
                        
                        <div>
                            <label className="flex items-center gap-2">
                                <input 
                                    type="checkbox"
                                    checked={form.hasServiceWorker}
                                    onChange={e => setForm({ ...form, hasServiceWorker: e.target.checked })}
                                    className="rounded"
                                />
                                <span className="text-sm">Has Service Worker (PWA)</span>
                            </label>
                        </div>
                        
                        <div>
                            <label className="block text-sm font-medium mb-1">
                                Detection Patterns (one per line, regex)
                                {isNew && !patternsManuallyEdited && form.name.trim() && (
                                    <span className="text-xs text-indigo-400 ml-2">✨ auto-generated from name</span>
                                )}
                            </label>
                            <textarea 
                                value={form.detectionPatterns}
                                onChange={e => { setPatternsManuallyEdited(true); setForm({ ...form, detectionPatterns: e.target.value }); }}
                                className="w-full p-2 bg-slate-900 border border-slate-600 rounded font-mono text-sm"
                                rows={4}
                                placeholder="<title>my app&#10;myapp-container"
                            />
                        </div>
                        
                        {/* Repository Assignment */}
                        <div>
                            <div className="flex items-center justify-between mb-2">
                                <label className="block text-sm font-medium">Repository Assignment</label>
                                <button 
                                    onClick={() => setRepoMode(repoMode === 'dropdown' ? 'manual' : 'dropdown')}
                                    className="text-xs text-indigo-400 hover:text-indigo-300"
                                >
                                    {repoMode === 'dropdown' ? '✏️ Manual entry' : '📋 Select from repos'}
                                </button>
                            </div>
                            
                            {repoMode === 'dropdown' ? (
                                <div className="grid grid-cols-2 gap-3">
                                    {environments.map(env => (
                                        <div key={env}>
                                            <label className="block text-xs text-slate-400 mb-1">{envLabels[env]}</label>
                                            <select
                                                value={form.repos[env] || ''}
                                                onChange={e => setForm({
                                                    ...form,
                                                    repos: { ...form.repos, [env]: e.target.value },
                                                    repoPatterns: { 
                                                        ...form.repoPatterns, 
                                                        [env]: e.target.value ? e.target.value.split('/').pop() : '' 
                                                    }
                                                })}
                                                className="w-full p-2 bg-slate-900 border border-slate-600 rounded text-sm"
                                            >
                                                <option value="">— None —</option>
                                                {repoOptions.length > 0 && (() => {
                                                    const shared = repoOptions.filter(r => r.isShared);
                                                    const unassigned = repoOptions.filter(r => !r.isShared);
                                                    return (
                                                        <>
                                                            {shared.length > 0 && (
                                                                <optgroup label="Shared Repos (used by other apps)">
                                                                    {shared.map(r => (
                                                                        <option key={r.fullName} value={r.fullName}>
                                                                            {r.name} — {r.assignedTo.join(', ')}
                                                                        </option>
                                                                    ))}
                                                                </optgroup>
                                                            )}
                                                            {unassigned.length > 0 && (
                                                                <optgroup label="Available Repos">
                                                                    {unassigned.map(r => (
                                                                        <option key={r.fullName} value={r.fullName}>{r.name}</option>
                                                                    ))}
                                                                </optgroup>
                                                            )}
                                                        </>
                                                    );
                                                })()}
                                            </select>
                                            {form.repos[env] && form.subPath && (
                                                <div className="text-xs text-slate-500 mt-1 font-mono">
                                                    → {form.subPath}/{form.targetPath || 'index.html'}
                                                </div>
                                            )}
                                        </div>
                                    ))}
                                </div>
                            ) : (
                                <div>
                                    <div className="text-xs text-slate-500 mb-2">Enter repo name patterns for auto-mapping (comma-separated)</div>
                                    <div className="grid grid-cols-2 gap-3">
                                        {environments.map(env => (
                                            <div key={env}>
                                                <label className="block text-xs text-slate-400 mb-1">{envLabels[env]}</label>
                                                <input 
                                                    type="text"
                                                    value={form.repoPatterns[env] || ''}
                                                    onChange={e => setForm({ 
                                                        ...form, 
                                                        repoPatterns: { ...form.repoPatterns, [env]: e.target.value }
                                                    })}
                                                    className="w-full p-2 bg-slate-900 border border-slate-600 rounded text-sm"
                                                    placeholder={`myapp-${env}, myapp${env}`}
                                                />
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            )}
                        </div>
                    </div>}
                    
                    {/* v8.20.0: Lifecycle Tab */}
                    {activeTab === 'lifecycle' && <div className="p-6 space-y-4">
                        <div className="grid grid-cols-2 gap-4">
                            <div>
                                <label className="block text-sm font-medium mb-1">Category</label>
                                <select
                                    value={form.lifecycle.category || ''}
                                    onChange={e => setForm({ ...form, lifecycle: { ...form.lifecycle, category: e.target.value || null }})}
                                    className="w-full p-2 bg-slate-900 border border-slate-600 rounded"
                                >
                                    <option value="">Not set</option>
                                    <option value="game">🎮 Game</option>
                                    <option value="tool">🔧 Tool</option>
                                    <option value="dashboard">📊 Dashboard</option>
                                    <option value="content">📄 Content</option>
                                    <option value="admin">⚙️ Admin</option>
                                </select>
                            </div>
                            <div>
                                <label className="block text-sm font-medium mb-1">Current Maturity</label>
                                <select
                                    value={form.lifecycle.currentMaturity || ''}
                                    onChange={e => setForm({ ...form, lifecycle: { ...form.lifecycle, currentMaturity: e.target.value || null }})}
                                    className="w-full p-2 bg-slate-900 border border-slate-600 rounded"
                                >
                                    <option value="">Not set</option>
                                    <option value="prototype">🧪 Prototype</option>
                                    <option value="alpha">🔬 Alpha</option>
                                    <option value="beta">🔧 Beta</option>
                                    <option value="production">🚀 Production</option>
                                </select>
                            </div>
                        </div>
                        
                        <div>
                            <label className="block text-sm font-medium mb-1">Maturity Target</label>
                            <select
                                value={form.lifecycle.maturityTarget || ''}
                                onChange={e => setForm({ ...form, lifecycle: { ...form.lifecycle, maturityTarget: e.target.value || null }})}
                                className="w-full p-2 bg-slate-900 border border-slate-600 rounded"
                            >
                                <option value="">Not set</option>
                                <option value="prototype">🧪 Prototype</option>
                                <option value="alpha">🔬 Alpha</option>
                                <option value="beta">🔧 Beta</option>
                                <option value="production">🚀 Production</option>
                            </select>
                        </div>
                        
                        <div>
                            <label className="block text-sm font-medium mb-1">Problem Statement</label>
                            <textarea
                                value={form.lifecycle.problemStatement}
                                onChange={e => setForm({ ...form, lifecycle: { ...form.lifecycle, problemStatement: e.target.value }})}
                                className="w-full p-2 bg-slate-900 border border-slate-600 rounded text-sm"
                                rows="2"
                                placeholder="What problem does this app solve?"
                            />
                        </div>
                        
                        <div className="grid grid-cols-2 gap-4">
                            <div>
                                <label className="block text-sm font-medium mb-1">Target Audience</label>
                                <input
                                    type="text"
                                    value={form.lifecycle.targetAudience}
                                    onChange={e => setForm({ ...form, lifecycle: { ...form.lifecycle, targetAudience: e.target.value }})}
                                    className="w-full p-2 bg-slate-900 border border-slate-600 rounded text-sm"
                                    placeholder="Who is this for?"
                                />
                            </div>
                            <div>
                                <label className="block text-sm font-medium mb-1">User Goal</label>
                                <input
                                    type="text"
                                    value={form.lifecycle.userGoal}
                                    onChange={e => setForm({ ...form, lifecycle: { ...form.lifecycle, userGoal: e.target.value }})}
                                    className="w-full p-2 bg-slate-900 border border-slate-600 rounded text-sm"
                                    placeholder="What should users accomplish?"
                                />
                            </div>
                        </div>
                        
                        <div>
                            <label className="block text-sm font-medium mb-1">Success Metric</label>
                            <input
                                type="text"
                                value={form.lifecycle.successMetric}
                                onChange={e => setForm({ ...form, lifecycle: { ...form.lifecycle, successMetric: e.target.value }})}
                                className="w-full p-2 bg-slate-900 border border-slate-600 rounded text-sm"
                                placeholder="How do we measure success?"
                            />
                        </div>
                        
                        {form.lifecycle.currentMaturity && form.lifecycle.maturityTarget && (
                            <div className="bg-slate-900/50 rounded-lg p-3 border border-slate-700">
                                <div className="text-sm font-medium mb-2">Maturity Progress</div>
                                <div className="flex items-center gap-2 text-sm">
                                    {['prototype', 'alpha', 'beta', 'production'].map((m, i) => {
                                        const milestones = ['prototype', 'alpha', 'beta', 'production'];
                                        const currentIdx = milestones.indexOf(form.lifecycle.currentMaturity);
                                        const targetIdx = milestones.indexOf(form.lifecycle.maturityTarget);
                                        const icons = { prototype: '🧪', alpha: '🔬', beta: '🔧', production: '🚀' };
                                        const isComplete = i <= currentIdx;
                                        const isCurrent = i === currentIdx;
                                        const isTarget = i === targetIdx;
                                        const isInRange = i <= targetIdx;
                                        return React.createElement(React.Fragment, { key: m },
                                            i > 0 && React.createElement('div', { className: `flex-1 h-0.5 ${isComplete ? 'bg-emerald-500' : isInRange ? 'bg-slate-600' : 'bg-slate-800'}` }),
                                            React.createElement('div', { 
                                                className: `flex flex-col items-center ${isComplete ? 'text-emerald-400' : isInRange ? 'text-slate-400' : 'text-slate-600'}`,
                                                title: m.charAt(0).toUpperCase() + m.slice(1)
                                            },
                                                React.createElement('span', { className: 'text-base' }, icons[m]),
                                                React.createElement('span', { className: `text-xs mt-0.5 ${isCurrent ? 'font-bold underline' : ''} ${isTarget ? 'font-bold' : ''}` }, 
                                                    m.charAt(0).toUpperCase() + m.slice(1).substring(0, 4) + (isTarget ? ' ★' : '')
                                                )
                                            )
                                        );
                                    })}
                                </div>
                            </div>
                        )}
                    </div>}
                    
                    <div className="p-6 border-t border-slate-700 flex justify-end gap-3">
                        <button 
                            onClick={onCancel}
                            className="px-4 py-2 bg-slate-700 hover:bg-slate-600 rounded"
                        >
                            Cancel
                        </button>
                        <button 
                            onClick={handleSave}
                            className="px-4 py-2 bg-indigo-600 hover:bg-indigo-500 rounded"
                        >
                            {isNew ? 'Add App' : 'Save Changes'}
                        </button>
                    </div>
                </div>
            </div>
        );
    }

    // =========================================================================
    // ARCHIVE VIEW - gs-active Management for Claude Sessions
    // =========================================================================
    
    // gs-active repo configuration
    const GS_ACTIVE_REPO = 'stewartdavidp-ship-it/gs-active';
    const GS_ACTIVE_APPS = ['gameshelf', 'quotle', 'rungs', 'slate', 'wordboxing', 'command-center', 'testplan', 'firebase-functions'];
    
    function ArchiveView({ apps, config, github, showAlert, showConfirm, showPrompt, globalIssues, sessionLog, deployments }) {
        const [activeTab, setActiveTab] = React.useState('upload'); // 'upload', 'download', 'briefing'
        const [archiveFiles, setArchiveFiles] = React.useState([]); // Parsed files from uploaded zip
        const [archiveContext, setArchiveContext] = React.useState(null); // CONTEXT.md content
        const [archiveStandards, setArchiveStandards] = React.useState(null); // STANDARDS.md content
        const [validationResults, setValidationResults] = React.useState(null); // Version comparison results
        const [loading, setLoading] = React.useState(false);
        const [uploadProgress, setUploadProgress] = React.useState('');
        const [repoFiles, setRepoFiles] = React.useState(null); // Files from gs-active repo
        const [repoLoading, setRepoLoading] = React.useState(false);
        const [briefingText, setBriefingText] = React.useState('');
        
        // Get deployed versions for all apps
        const getDeployedVersions = async () => {
            if (!github) return {};
            const versions = {};
            
            for (const [appId, app] of Object.entries(apps)) {
                versions[appId] = { test: null, prod: null };
                // Use effectiveSubPath with fallback to defaults (localStorage may have empty string)
                const effectiveSubPath = app.subPath || '';
                const indexPath = effectiveSubPath ? `${effectiveSubPath}/index.html` : 'index.html';
                
                if (app.testRepo) {
                    try {
                        const fileData = await github.getFileContent(app.testRepo, indexPath);
                        if (fileData) {
                            versions[appId].test = extractVersionFromHTML(fileData.textContent);
                        }
                    } catch (e) { console.log(`Could not fetch ${appId} test version from ${indexPath}`); }
                }
                
                if (app.prodRepo) {
                    try {
                        const fileData = await github.getFileContent(app.prodRepo, indexPath);
                        if (fileData) {
                            versions[appId].prod = extractVersionFromHTML(fileData.textContent);
                        }
                    } catch (e) { console.log(`Could not fetch ${appId} prod version from ${indexPath}`); }
                }
            }
            
            return versions;
        };
        
        // Handle zip file upload
        const handleZipUpload = async (e) => {
            const file = e.target.files?.[0];
            if (!file) return;
            
            setLoading(true);
            setUploadProgress('Reading zip file...');
            setArchiveFiles([]);
            setValidationResults(null);
            
            try {
                const zip = await JSZip.loadAsync(file);
                const files = [];
                
                setUploadProgress('Extracting files...');
                
                // Extract all files
                for (const [path, zipEntry] of Object.entries(zip.files)) {
                    if (zipEntry.dir) continue;
                    
                    // Detect if file is binary
                    const isBinary = /\.(png|jpg|jpeg|gif|ico|woff|woff2|ttf|eot|svg)$/i.test(path);
                    
                    let content;
                    let base64Content = null;
                    
                    if (isBinary) {
                        // Read binary files as base64
                        base64Content = await zipEntry.async('base64');
                        content = `[Binary file: ${path}]`; // Placeholder for display
                    } else {
                        content = await zipEntry.async('string');
                    }
                    
                    const relativePath = path.replace(/^gs-active\//, '');
                    
                    // Extract version from HTML files
                    let version = null;
                    if (path.endsWith('.html')) {
                        version = extractVersionFromHTML(content);
                    }
                    
                    // Detect app from path
                    const pathParts = relativePath.split('/');
                    const appFolder = pathParts[0];
                    
                    files.push({
                        path: relativePath,
                        fullPath: path,
                        appFolder,
                        content,
                        base64Content,
                        isBinary,
                        version,
                        size: isBinary ? (base64Content?.length || 0) : content.length,
                        isHtml: path.endsWith('.html'),
                        isMarkdown: path.endsWith('.md'),
                        isJson: path.endsWith('.json'),
                        isJs: path.endsWith('.js')
                    });
                    
                    // Capture special files
                    if (relativePath === 'CONTEXT.md') {
                        setArchiveContext(content);
                    } else if (relativePath === 'STANDARDS.md') {
                        setArchiveStandards(content);
                    }
                }
                
                setArchiveFiles(files);
                setUploadProgress('Validating versions...');
                
                // Validate against deployed versions
                const deployedVersions = await getDeployedVersions();
                const validation = [];
                
                // Map app folders to app IDs
                const folderToAppId = {
                    'gameshelf': 'gameshelf',
                    'quotle': 'quotle', 
                    'rungs': 'rungs',
                    'slate': 'slate',
                    'wordboxing': 'wordboxing',
                    'command-center': 'command-center',
                    'testplan': 'testplan'
                };
                
                // Check each app folder
                const appFolders = [...new Set(files.map(f => f.appFolder))];
                
                for (const folder of appFolders) {
                    const appId = folderToAppId[folder];
                    const indexFile = files.find(f => f.appFolder === folder && f.path.endsWith('index.html'));
                    
                    if (!indexFile || !appId) continue;
                    
                    const archiveVersion = indexFile.version;
                    const deployed = deployedVersions[appId] || {};
                    
                    let status = 'unknown';
                    let message = '';
                    
                    if (!archiveVersion) {
                        status = 'warning';
                        message = 'No version found in archive';
                    } else if (deployed.prod && archiveVersion === deployed.prod) {
                        status = 'match';
                        message = `v${archiveVersion} matches PROD`;
                    } else if (deployed.test && archiveVersion === deployed.test) {
                        status = 'match-test';
                        message = `v${archiveVersion} matches TEST`;
                    } else if (deployed.prod && archiveVersion !== deployed.prod) {
                        status = 'mismatch';
                        message = `Archive v${archiveVersion} ≠ PROD v${deployed.prod}`;
                    } else if (!deployed.prod && !deployed.test) {
                        status = 'no-deploy';
                        message = `v${archiveVersion} (no deployed version found)`;
                    } else {
                        status = 'newer';
                        message = `v${archiveVersion} (PROD: ${deployed.prod || 'none'}, TEST: ${deployed.test || 'none'})`;
                    }
                    
                    validation.push({
                        folder,
                        appId,
                        appName: apps[appId]?.name || folder,
                        archiveVersion,
                        deployedProd: deployed.prod,
                        deployedTest: deployed.test,
                        status,
                        message
                    });
                }
                
                // Check for apps deployed but not in archive
                for (const [appId, app] of Object.entries(apps)) {
                    const folder = Object.entries(folderToAppId).find(([f, id]) => id === appId)?.[0];
                    if (!folder) continue;
                    
                    const inArchive = validation.some(v => v.appId === appId);
                    if (!inArchive && (app.testRepo || app.prodRepo)) {
                        const deployed = deployedVersions[appId] || {};
                        if (deployed.prod || deployed.test) {
                            validation.push({
                                folder,
                                appId,
                                appName: app.name,
                                archiveVersion: null,
                                deployedProd: deployed.prod,
                                deployedTest: deployed.test,
                                status: 'missing',
                                message: `Not in archive (PROD: ${deployed.prod || 'none'})`
                            });
                        }
                    }
                }
                
                setValidationResults(validation);
                setUploadProgress('');
                
            } catch (err) {
                console.error('Error processing zip:', err);
                await showAlert(`Error processing zip: ${err.message}`, 'Upload Error');
            } finally {
                setLoading(false);
            }
        };
        
        // Push archive to gs-active repo
        const pushToRepo = async () => {
            if (!github || archiveFiles.length === 0) return;
            
            const confirmed = await showConfirm(
                `Push ${archiveFiles.length} files to gs-active repo?\n\n` +
                `This will update the archive in GitHub.`,
                'Push to gs-active'
            );
            
            if (!confirmed) return;
            
            setLoading(true);
            setUploadProgress('Checking repository...');
            
            try {
                // Check if repo exists
                const [owner, repoName] = GS_ACTIVE_REPO.split('/');
                const exists = await github.repoExists(owner, repoName);
                
                if (!exists) {
                    setUploadProgress('Creating gs-active repository...');
                    await github.createRepo('gs-active', 'Game Shelf development archive for Claude sessions', false);
                    await new Promise(r => setTimeout(r, 2000)); // Wait for repo creation
                }
                
                // Push each file
                let pushed = 0;
                for (const file of archiveFiles) {
                    setUploadProgress(`Pushing ${file.path} (${++pushed}/${archiveFiles.length})...`);
                    
                    // Get current file SHA if it exists
                    let sha = null;
                    try {
                        const existing = await github.getFile(GS_ACTIVE_REPO, file.path);
                        if (existing) sha = existing.sha;
                    } catch (e) { /* File doesn't exist yet */ }
                    
                    // Handle binary vs text files differently
                    if (file.isBinary && file.base64Content) {
                        // Binary file - use base64 content directly
                        const [owner, repoName] = GS_ACTIVE_REPO.split('/');
                        const body = {
                            message: `Update ${file.path} - ${new Date().toISOString().split('T')[0]}`,
                            content: file.base64Content,
                            committer: { name: 'Command Center', email: 'deploy@gameshelf.app' }
                        };
                        if (sha) body.sha = sha;
                        await github.request(`/repos/${owner}/${repoName}/contents/${file.path}`, { 
                            method: 'PUT', 
                            body: JSON.stringify(body) 
                        });
                    } else {
                        // Text file - use normal method
                        await github.createOrUpdateFile(
                            GS_ACTIVE_REPO,
                            file.path,
                            file.content,
                            `Update ${file.path} - ${new Date().toISOString().split('T')[0]}`,
                            sha
                        );
                    }
                }
                
                setUploadProgress('');
                await showAlert(`Successfully pushed ${archiveFiles.length} files to gs-active!`, '✅ Archive Updated');
                
            } catch (err) {
                console.error('Error pushing to repo:', err);
                await showAlert(`Error: ${err.message}`, 'Push Failed');
            } finally {
                setLoading(false);
            }
        };
        
        // Load files from gs-active repo - returns the files array
        const loadFromRepo = async () => {
            if (!github) return [];
            
            setRepoLoading(true);
            
            try {
                const files = [];
                
                // Get root contents
                const root = await github.listRepoContents(GS_ACTIVE_REPO);
                
                for (const item of root) {
                    if (item.type === 'file') {
                        files.push({ path: item.path, type: 'file', sha: item.sha, size: item.size });
                    } else if (item.type === 'dir') {
                        // Get directory contents
                        const dirContents = await github.listRepoContents(GS_ACTIVE_REPO, item.path);
                        for (const subItem of dirContents) {
                            if (subItem.type === 'file') {
                                files.push({ path: subItem.path, type: 'file', sha: subItem.sha, size: subItem.size, folder: item.path });
                            } else if (subItem.type === 'dir') {
                                // Go one more level (for icons folders, etc)
                                const subDirContents = await github.listRepoContents(GS_ACTIVE_REPO, subItem.path);
                                for (const deepItem of subDirContents) {
                                    if (deepItem.type === 'file') {
                                        files.push({ path: deepItem.path, type: 'file', sha: deepItem.sha, size: deepItem.size, folder: item.path });
                                    }
                                }
                            }
                        }
                    }
                }
                
                setRepoFiles(files);
                return files;
                
            } catch (err) {
                console.error('Error loading repo:', err);
                if (err.message?.includes('Not Found')) {
                    await showAlert('gs-active repo not found. Upload an archive first to create it.', 'Repository Not Found');
                } else {
                    await showAlert(`Error: ${err.message}`, 'Load Failed');
                }
                return [];
            } finally {
                setRepoLoading(false);
            }
        };
        
        // Download gs-active as zip
        const downloadAsZip = async () => {
            if (!github) return;
            
            setLoading(true);
            setUploadProgress('Fetching file list from repository...');
            
            try {
                const zip = new JSZip();
                const gsActive = zip.folder('gs-active');
                
                // Always fetch fresh file list
                const filesToFetch = await loadFromRepo();
                
                if (filesToFetch.length === 0) {
                    await showAlert('No files found in gs-active repository.', 'Empty Repository');
                    setLoading(false);
                    return;
                }
                
                let fetched = 0;
                
                for (const file of filesToFetch) {
                    setUploadProgress(`Downloading ${file.path} (${++fetched}/${filesToFetch.length})...`);
                    
                    try {
                        const fileData = await github.getFile(GS_ACTIVE_REPO, file.path);
                        if (fileData) {
                            // Determine if binary or text
                            const isBinary = file.path.match(/\.(png|jpg|jpeg|gif|ico|woff|woff2|ttf|eot|svg)$/i);
                            
                            // Check if content is available (GitHub Contents API has 1MB limit)
                            // For files >1MB, content will be empty but download_url is provided
                            if (!fileData.content && fileData.download_url) {
                                console.log(`Large file detected (>1MB): ${file.path}, using download_url`);
                                const response = await fetch(fileData.download_url);
                                if (isBinary) {
                                    const blob = await response.blob();
                                    gsActive.file(file.path, blob);
                                } else {
                                    const text = await response.text();
                                    gsActive.file(file.path, text);
                                }
                            } else if (fileData.content) {
                                if (isBinary) {
                                    // Binary files - content is already base64
                                    gsActive.file(file.path, fileData.content.replace(/[\r\n\s]/g, ''), { base64: true });
                                } else {
                                    // Text files - decode from base64
                                    const content = decodeURIComponent(escape(atob(fileData.content.replace(/[\r\n\s]/g, ''))));
                                    gsActive.file(file.path, content);
                                }
                            } else {
                                console.warn(`No content or download_url for ${file.path}`);
                            }
                        }
                    } catch (e) {
                        console.error(`Error fetching ${file.path}:`, e);
                    }
                }
                
                setUploadProgress('Creating zip file...');
                
                const blob = await zip.generateAsync({ type: 'blob' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `gs-active-${new Date().toISOString().split('T')[0]}.zip`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                setUploadProgress('');
                await showAlert(`Downloaded ${filesToFetch.length} files!`, '✅ Download Complete');
                
            } catch (err) {
                console.error('Error downloading:', err);
                await showAlert(`Error: ${err.message}`, 'Download Failed');
            } finally {
                setLoading(false);
            }
        };
        
        // Generate Claude briefing
        const generateBriefing = async () => {
            setLoading(true);
            setUploadProgress('Generating briefing...');
            
            try {
                const deployedVersions = await getDeployedVersions();
                const today = new Date().toISOString().split('T')[0];
                const dayOfWeek = new Date().toLocaleDateString('en-US', { weekday: 'long' });
                
                let briefing = `# Claude Session Briefing - ${dayOfWeek}, ${today}\n\n`;
                briefing += `Generated by Command Center v${document.querySelector('meta[name="version"]')?.content || '?'}\n\n`;
                briefing += `---\n\n`;
                
                // Deployed Versions
                briefing += `## 📊 Deployed Versions\n\n`;
                briefing += `| App | TEST | PROD | Status |\n`;
                briefing += `|-----|------|------|--------|\n`;
                
                let hasVersions = false;
                for (const [appId, app] of Object.entries(apps)) {
                    if (!app.testRepo && !app.prodRepo) continue;
                    hasVersions = true;
                    const v = deployedVersions[appId] || {};
                    const status = v.test === v.prod ? '✓ Synced' : (v.test && v.prod ? '⚠️ Differ' : '—');
                    briefing += `| ${app.name} | ${v.test || '—'} | ${v.prod || '—'} | ${status} |\n`;
                }
                
                if (!hasVersions) {
                    briefing += `| (No configured apps) | — | — | — |\n`;
                }
                
                briefing += `\n`;
                
                // Open Issues
                const openIssues = globalIssues?.filter(i => i.status === 'open' || i.status === 'in-progress') || [];
                briefing += `## 🐛 Open Issues (${openIssues.length})\n\n`;
                if (openIssues.length > 0) {
                    for (const issue of openIssues.slice(0, 10)) {
                        const priorityIcon = issue.priority === 'high' ? '🔴' : issue.priority === 'low' ? '🟢' : '🟡';
                        briefing += `- ${priorityIcon} **${issue.id}**: ${issue.title} (${issue.app || 'General'})\n`;
                    }
                    if (openIssues.length > 10) {
                        briefing += `- _...and ${openIssues.length - 10} more_\n`;
                    }
                } else {
                    briefing += `_No open issues - great job!_\n`;
                }
                briefing += `\n`;
                
                // Recent Deployments
                const recentDeploys = deployments?.filter(d => d.status === 'success').slice(0, 5) || [];
                briefing += `## 🚀 Recent Deployments\n\n`;
                if (recentDeploys.length > 0) {
                    for (const d of recentDeploys) {
                        const time = d.startedAt ? new Date(d.startedAt).toLocaleString() : 'Unknown';
                        const targetIcon = d.target === 'prod' ? '🟢' : '🔵';
                        briefing += `- ${targetIcon} **${d.appName}** v${d.version || '?'} → ${d.target?.toUpperCase() || '?'} (${time})\n`;
                    }
                } else {
                    briefing += `_No recent deployments_\n`;
                }
                briefing += `\n`;
                
                // Session Notes (if any)
                if (sessionLog?.notes && sessionLog.notes.trim()) {
                    briefing += `## 📝 Session Notes\n\n`;
                    briefing += sessionLog.notes + `\n\n`;
                }
                
                // Current Session Log
                if (sessionLog?.currentSession) {
                    briefing += `## 🎯 Current Session\n\n`;
                    briefing += `**Goal:** ${sessionLog.currentSession.goal || 'Not specified'}\n\n`;
                    if (sessionLog.currentSession.completed?.length > 0) {
                        briefing += `**Completed:**\n`;
                        for (const item of sessionLog.currentSession.completed) {
                            briefing += `- ✅ ${item}\n`;
                        }
                        briefing += `\n`;
                    }
                    if (sessionLog.currentSession.pending?.length > 0) {
                        briefing += `**Pending:**\n`;
                        for (const item of sessionLog.currentSession.pending) {
                            briefing += `- ⏳ ${item}\n`;
                        }
                        briefing += `\n`;
                    }
                }
                
                // Include archive info if we have it
                if (archiveContext) {
                    briefing += `## 📦 Archive CONTEXT.md (Summary)\n\n`;
                    // Extract just the first section or key info
                    const contextLines = archiveContext.split('\n').slice(0, 30);
                    briefing += contextLines.join('\n') + '\n\n';
                    if (archiveContext.split('\n').length > 30) {
                        briefing += `_[Truncated - see full CONTEXT.md in gs-active]_\n\n`;
                    }
                }
                
                // GitHub URLs
                briefing += `## 🔗 Quick Links\n\n`;
                briefing += `| App | TEST | PROD |\n`;
                briefing += `|-----|------|------|\n`;
                
                for (const [appId, app] of Object.entries(apps)) {
                    if (!app.testRepo && !app.prodRepo) continue;
                    const testUrl = app.testRepo ? `[Link](https://${app.testRepo.split('/')[0]}.github.io/${app.testRepo.split('/')[1]}/)` : '—';
                    const prodUrl = app.prodRepo ? `[Link](https://${app.prodRepo.split('/')[0]}.github.io/${app.prodRepo.split('/')[1]}/)` : '—';
                    briefing += `| ${app.name} | ${testUrl} | ${prodUrl} |\n`;
                }
                
                briefing += `\n---\n\n`;
                briefing += `## 🚀 Getting Started\n\n`;
                briefing += `1. Download **gs-active.zip** from the Archive → Download tab\n`;
                briefing += `2. Upload the zip to Claude\n`;
                briefing += `3. Say: "Please review skills and the gs-active file"\n\n`;
                briefing += `_Or paste this briefing for a quick overview without the full archive._\n`;
                
                setBriefingText(briefing);
                setUploadProgress('');
                
            } catch (err) {
                console.error('Error generating briefing:', err);
                await showAlert(`Error: ${err.message}`, 'Briefing Failed');
            } finally {
                setLoading(false);
            }
        };
        
        // Copy briefing to clipboard
        const copyBriefing = async () => {
            try {
                await navigator.clipboard.writeText(briefingText);
                await showAlert('Briefing copied to clipboard!', '✅ Copied');
            } catch (err) {
                await showAlert('Failed to copy to clipboard', 'Error');
            }
        };
        
        // Status badge component
        const StatusBadge = ({ status }) => {
            const styles = {
                'match': 'bg-green-600 text-green-100',
                'match-test': 'bg-blue-600 text-blue-100',
                'mismatch': 'bg-red-600 text-red-100',
                'newer': 'bg-amber-600 text-amber-100',
                'missing': 'bg-red-800 text-red-200',
                'warning': 'bg-amber-600 text-amber-100',
                'no-deploy': 'bg-slate-600 text-slate-300',
                'unknown': 'bg-slate-600 text-slate-300'
            };
            
            const labels = {
                'match': '✓ PROD Match',
                'match-test': '✓ TEST Match',
                'mismatch': '✗ Mismatch',
                'newer': '↑ Newer',
                'missing': '✗ Missing',
                'warning': '⚠ Warning',
                'no-deploy': '— Not Deployed',
                'unknown': '? Unknown'
            };
            
            return (
                <span className={`px-2 py-0.5 rounded text-xs font-medium ${styles[status] || styles.unknown}`}>
                    {labels[status] || status}
                </span>
            );
        };
        
        return (
            <div className="space-y-6">
                <div className="flex items-center justify-between">
                    <h2 className="text-xl font-bold flex items-center gap-2">
                        📦 Archive Manager
                    </h2>
                    <div className="text-sm text-slate-400">
                        gs-active repo: <span className="text-indigo-400">{GS_ACTIVE_REPO}</span>
                    </div>
                </div>
                
                {/* Tab Navigation */}
                <div className="flex gap-2 border-b border-slate-700 pb-2">
                    {[
                        { id: 'upload', label: '⬆️ Upload Archive', icon: 'Upload' },
                        { id: 'download', label: '⬇️ Download Archive', icon: 'Download' },
                        { id: 'briefing', label: '📋 Claude Briefing', icon: 'File' }
                    ].map(tab => (
                        <button
                            key={tab.id}
                            onClick={() => setActiveTab(tab.id)}
                            className={`px-4 py-2 rounded-t-lg font-medium transition-colors ${
                                activeTab === tab.id 
                                    ? 'bg-slate-700 text-white' 
                                    : 'text-slate-400 hover:text-white hover:bg-slate-800'
                            }`}
                        >
                            {tab.label}
                        </button>
                    ))}
                </div>
                
                {/* Loading indicator */}
                {loading && (
                    <div className="p-4 bg-indigo-900/30 border border-indigo-700 rounded-lg flex items-center gap-3">
                        <div className="animate-spin w-5 h-5 border-2 border-indigo-500 border-t-transparent rounded-full"></div>
                        <span>{uploadProgress || 'Processing...'}</span>
                    </div>
                )}
                
                {/* Upload Tab */}
                {activeTab === 'upload' && (
                    <div className="space-y-6">
                        {/* Upload Zone */}
                        <div className="border-2 border-dashed border-slate-600 rounded-lg p-8 text-center hover:border-indigo-500 transition-colors">
                            <input
                                type="file"
                                accept=".zip"
                                onChange={handleZipUpload}
                                className="hidden"
                                id="archive-upload"
                            />
                            <label htmlFor="archive-upload" className="cursor-pointer">
                                <Icons.Upload />
                                <div className="mt-2 text-lg">Drop gs-active.zip here or click to upload</div>
                                <div className="text-sm text-slate-400 mt-1">End of session: Upload to validate and push to GitHub</div>
                            </label>
                        </div>
                        
                        {/* Validation Results */}
                        {validationResults && (
                            <div className="bg-slate-800 rounded-lg p-4">
                                <h3 className="text-lg font-semibold mb-4 flex items-center gap-2">
                                    <Icons.Check /> Version Validation
                                </h3>
                                
                                <div className="space-y-2">
                                    {validationResults.map((v, i) => (
                                        <div key={i} className="flex items-center justify-between p-3 bg-slate-900 rounded">
                                            <div className="flex items-center gap-3">
                                                <AppIcon icon={apps[v.appId]?.icon} size={20} />
                                                <span className="font-medium">{v.appName}</span>
                                                {v.archiveVersion && (
                                                    <span className="text-sm text-slate-400">v{v.archiveVersion}</span>
                                                )}
                                            </div>
                                            <div className="flex items-center gap-3">
                                                <span className="text-sm text-slate-400">{v.message}</span>
                                                <StatusBadge status={v.status} />
                                            </div>
                                        </div>
                                    ))}
                                </div>
                                
                                {/* Summary */}
                                <div className="mt-4 pt-4 border-t border-slate-700 flex justify-between items-center">
                                    <div className="text-sm text-slate-400">
                                        {archiveFiles.length} files in archive • 
                                        {validationResults.filter(v => v.status === 'match' || v.status === 'match-test').length} matching • 
                                        {validationResults.filter(v => v.status === 'mismatch' || v.status === 'missing').length} issues
                                    </div>
                                    
                                    <button
                                        onClick={pushToRepo}
                                        disabled={loading || !github}
                                        className="px-4 py-2 bg-indigo-600 hover:bg-indigo-500 disabled:bg-slate-700 disabled:text-slate-500 rounded font-medium flex items-center gap-2"
                                    >
                                        <Icons.Rocket /> Push to gs-active
                                    </button>
                                </div>
                            </div>
                        )}
                        
                        {/* Archive Contents */}
                        {archiveFiles.length > 0 && (
                            <div className="bg-slate-800 rounded-lg p-4">
                                <h3 className="text-lg font-semibold mb-4">Archive Contents ({archiveFiles.length} files)</h3>
                                
                                <div className="max-h-64 overflow-y-auto space-y-1 text-sm font-mono">
                                    {archiveFiles.map((f, i) => (
                                        <div key={i} className="flex items-center gap-2 py-1 px-2 hover:bg-slate-700 rounded">
                                            {f.isBinary && <span className="text-purple-400">🖼️</span>}
                                            {!f.isBinary && f.isHtml && <span className="text-orange-400">📄</span>}
                                            {!f.isBinary && f.isJs && <span className="text-yellow-400">📜</span>}
                                            {!f.isBinary && f.isJson && <span className="text-green-400">📋</span>}
                                            {!f.isBinary && f.isMarkdown && <span className="text-blue-400">📝</span>}
                                            {!f.isBinary && !f.isHtml && !f.isJs && !f.isJson && !f.isMarkdown && <span>📁</span>}
                                            <span className="text-slate-300">{f.path}</span>
                                            {f.isBinary && <span className="text-purple-400 text-xs">(binary)</span>}
                                            {f.version && <span className="text-indigo-400 ml-auto">v{f.version}</span>}
                                            <span className="text-slate-500 text-xs">{(f.size / 1024).toFixed(1)}KB</span>
                                        </div>
                                    ))}
                                </div>
                            </div>
                        )}
                        
                        {/* CONTEXT.md Preview */}
                        {archiveContext && (
                            <div className="bg-slate-800 rounded-lg p-4">
                                <h3 className="text-lg font-semibold mb-2">📄 CONTEXT.md</h3>
                                <pre className="text-sm text-slate-300 whitespace-pre-wrap max-h-48 overflow-y-auto bg-slate-900 p-3 rounded">
                                    {archiveContext.substring(0, 2000)}
                                    {archiveContext.length > 2000 && '...\n(truncated)'}
                                </pre>
                            </div>
                        )}
                    </div>
                )}
                
                {/* Download Tab */}
                {activeTab === 'download' && (
                    <div className="space-y-6">
                        <div className="bg-slate-800 rounded-lg p-6">
                            <h3 className="text-lg font-semibold mb-4">Download gs-active from GitHub</h3>
                            <p className="text-slate-400 mb-4">
                                Start of session: Download the latest archive to provide to Claude.
                            </p>
                            
                            <div className="flex gap-3">
                                <button
                                    onClick={loadFromRepo}
                                    disabled={repoLoading || !github}
                                    className="px-4 py-2 bg-slate-700 hover:bg-slate-600 disabled:bg-slate-800 rounded flex items-center gap-2"
                                >
                                    <Icons.Refresh /> Refresh File List
                                </button>
                                
                                <button
                                    onClick={downloadAsZip}
                                    disabled={loading || !github}
                                    className="px-4 py-2 bg-indigo-600 hover:bg-indigo-500 disabled:bg-slate-700 rounded font-medium flex items-center gap-2"
                                >
                                    <Icons.Download /> Download gs-active.zip
                                </button>
                            </div>
                        </div>
                        
                        {/* Repo file list */}
                        {repoFiles && (
                            <div className="bg-slate-800 rounded-lg p-4">
                                <h3 className="text-lg font-semibold mb-4">Files in gs-active repo ({repoFiles.length})</h3>
                                
                                <div className="max-h-64 overflow-y-auto space-y-1 text-sm font-mono">
                                    {repoFiles.map((f, i) => (
                                        <div key={i} className="flex items-center gap-2 py-1 px-2 hover:bg-slate-700 rounded">
                                            <Icons.File />
                                            <span className="text-slate-300">{f.path}</span>
                                            <span className="text-slate-500 text-xs ml-auto">{(f.size / 1024).toFixed(1)}KB</span>
                                        </div>
                                    ))}
                                </div>
                            </div>
                        )}
                        
                        {repoFiles === null && !repoLoading && (
                            <div className="text-center text-slate-400 py-8">
                                Click "Refresh File List" to see available files
                            </div>
                        )}
                    </div>
                )}
                
                {/* Briefing Tab */}
                {activeTab === 'briefing' && (
                    <div className="space-y-6">
                        <div className="bg-slate-800 rounded-lg p-6">
                            <h3 className="text-lg font-semibold mb-4">Generate Claude Briefing</h3>
                            <p className="text-slate-400 mb-4">
                                Create a markdown summary of current project state for quick Claude onboarding.
                            </p>
                            
                            <button
                                onClick={generateBriefing}
                                disabled={loading || !github}
                                className="px-4 py-2 bg-indigo-600 hover:bg-indigo-500 disabled:bg-slate-700 rounded font-medium flex items-center gap-2"
                            >
                                <Icons.Zap /> Generate Briefing
                            </button>
                        </div>
                        
                        {briefingText && (
                            <div className="bg-slate-800 rounded-lg p-4">
                                <div className="flex justify-between items-center mb-4">
                                    <h3 className="text-lg font-semibold">📋 Session Briefing</h3>
                                    <button
                                        onClick={copyBriefing}
                                        className="px-3 py-1 bg-slate-700 hover:bg-slate-600 rounded text-sm flex items-center gap-1"
                                    >
                                        <Icons.Copy /> Copy
                                    </button>
                                </div>
                                
                                <pre className="text-sm text-slate-300 whitespace-pre-wrap max-h-96 overflow-y-auto bg-slate-900 p-4 rounded font-mono">
                                    {briefingText}
                                </pre>
                            </div>
                        )}
                    </div>
                )}
                
                {/* Help Text */}
                <div className="bg-slate-800/50 rounded-lg p-4 text-sm text-slate-400">
                    <h4 className="font-medium text-slate-300 mb-2">📖 Workflow</h4>
                    <ul className="space-y-1 list-disc list-inside">
                        <li><strong>End of Session:</strong> Upload gs-active.zip → Validate versions → Push to GitHub</li>
                        <li><strong>Start of Session:</strong> Download gs-active.zip → Upload to Claude → Or copy briefing for quick start</li>
                        <li>The gs-active repo serves as the single source of truth between Claude sessions</li>
                    </ul>
                </div>
            </div>
        );
    }

    // =========================================================================
    // SETTINGS VIEW
    // =========================================================================
    
    // =========================================================================
    // PROJECTS TAB (v8.8.0) — Replaces Apps tab in Configure
    // =========================================================================
    function ProjectsTab({ config, updateConfig, activeEnvs, envColors, github, githubOwner, availableRepos, showAlert, showConfirm, onRefreshRepos, deployments, globalWorkItems, firebaseUid, globalStreams }) {
        const [expandedProject, setExpandedProject] = React.useState(null);
        const [editingApp, setEditingApp] = React.useState(null);
        const [editingProject, setEditingProject] = React.useState(null);
        const [newProjectForm, setNewProjectForm] = React.useState(null);
        const [newAppForm, setNewAppForm] = React.useState(null);
        const [prepApp, setPrepApp] = React.useState(null);
        
        const formatDate = (ts) => {
            if (!ts) return '—';
            const d = new Date(ts);
            return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
        };
        
        // Save project (create or update)
        const saveProject = (projectData) => {
            let newConfig = { ...config, projects: { ...(config.projects || {}) } };
            if (editingProject) {
                newConfig = ConfigManager.updateProject(newConfig, editingProject.id, projectData);
            } else {
                newConfig = ConfigManager.addProject(newConfig, projectData);
            }
            updateConfig(newConfig);
            setEditingProject(null);
            setNewProjectForm(null);
        };
        
        // Delete project
        const deleteProject = async (projectId) => {
            const appCount = ConfigManager.getProjectAppCount(config, projectId);
            const msg = appCount > 0 
                ? `Delete "${config.projects[projectId]?.name}"? Its ${appCount} app${appCount !== 1 ? 's' : ''} will be moved to Other.`
                : `Delete "${config.projects[projectId]?.name}"?`;
            const confirmed = await showConfirm(msg, 'Delete Project');
            if (!confirmed) return;
            const newConfig = ConfigManager.removeProject({ ...config, projects: { ...config.projects }, apps: { ...config.apps } }, projectId);
            updateConfig(newConfig);
            setEditingProject(null);
        };
        
        // Build project data with computed attributes
        const projectsData = React.useMemo(() => {
            const projectDefs = config.projects || SEED_PROJECTS;
            const projectMap = {};
            
            // First, create entries for all defined projects (even those with no apps yet)
            Object.values(projectDefs).forEach(projDef => {
                projectMap[projDef.id] = {
                    ...projDef,
                    state: projDef.state || 'active',
                    apps: [],
                    allRepos: new Set(),
                    createdAt: null,
                    updatedAt: null
                };
            });
            
            // Then assign apps to their projects
            Object.values(config.apps).forEach(app => {
                const projId = app.project || 'other';
                if (!projectMap[projId]) {
                    // App references a project not in config — show it under 'other'
                    if (!projectMap['other']) {
                        const otherDef = projectDefs['other'] || { id: 'other', name: 'Other', icon: '📦', color: 'slate', order: 99 };
                        projectMap['other'] = { ...otherDef, state: 'active', apps: [], allRepos: new Set(), createdAt: null, updatedAt: null };
                    }
                    projectMap['other'].apps.push(app);
                } else {
                    projectMap[projId].apps.push(app);
                }
                const p = projectMap[projId] || projectMap['other'];
                // Collect repos
                Object.values(app.repos || {}).forEach(r => { if (r) p.allRepos.add(r); });
                // Track dates from app versions
                if (app.createdAt && (!p.createdAt || app.createdAt < p.createdAt)) p.createdAt = app.createdAt;
                if (app.updatedAt && (!p.updatedAt || app.updatedAt > p.updatedAt)) p.updatedAt = app.updatedAt;
            });
            
            return Object.values(projectMap)
                .sort((a, b) => (a.order || 99) - (b.order || 99))
                .map(p => {
                    // Determine deployment structure
                    const hasTest = p.apps.some(a => a.repos?.test);
                    const repoArr = [...p.allRepos];
                    const structure = repoArr.length <= 1 ? 'single' : hasTest ? 'dual' : 'multi';
                    return { ...p, allRepos: repoArr, structure };
                });
        }, [config.apps, config.projects]);
        
        // Get deployment structure label
        const getStructureLabel = (s) => {
            if (s === 'single') return { label: 'Single Repo', icon: '📦', color: 'text-slate-400' };
            if (s === 'dual') return { label: 'Dual Repo (Test → Prod)', icon: '🔀', color: 'text-blue-400' };
            return { label: 'Multi Repo', icon: '🗂️', color: 'text-purple-400' };
        };
        
        // Get app deployment structure
        const getAppStructure = (app) => {
            if (app.repos?.test && app.repos?.prod) return 'dual';
            return 'single';
        };
        
        // Save app edits
        const saveApp = (appData) => {
            const newConfig = { ...config, apps: { ...config.apps } };
            const id = appData.id || appData.name.toLowerCase().replace(/\s+/g, '-');
            newConfig.apps[id] = {
                ...(config.apps[id] || {}),
                ...appData,
                id,
                detectionPatterns: typeof appData.detectionPatterns === 'string' 
                    ? appData.detectionPatterns.split('\n').filter(p => p.trim()) 
                    : (appData.detectionPatterns || []),
                repoPatterns: typeof appData.repoPatterns === 'object' && !Array.isArray(appData.repoPatterns)
                    ? Object.fromEntries(Object.entries(appData.repoPatterns).map(([k, v]) => [k, typeof v === 'string' ? v.split(',').map(s => s.trim()).filter(Boolean) : v]))
                    : (appData.repoPatterns || {}),
                updatedAt: Date.now(),
                createdAt: config.apps[id]?.createdAt || Date.now()
            };
            updateConfig(newConfig);
            setEditingApp(null);
            setNewAppForm(null);
        };
        
        const deleteApp = async (appId) => {
            const confirmed = await showConfirm(`Delete ${config.apps[appId]?.name || appId}?`, 'Delete App');
            if (!confirmed) return;
            const newConfig = { ...config, apps: { ...config.apps } };
            delete newConfig.apps[appId];
            updateConfig(newConfig);
        };
        
        // Toggle project state
        const toggleProjectState = (projId) => {
            const newConfig = { ...config, projects: { ...config.projects } };
            if (newConfig.projects[projId]) {
                newConfig.projects[projId] = { ...newConfig.projects[projId], state: newConfig.projects[projId].state === 'hidden' ? 'active' : 'hidden' };
                updateConfig(newConfig);
            }
        };
        
        
        // Stats
        const totalApps = Object.keys(config.apps).length;
        const totalProjects = projectsData.length;
        
        return (
            <div className="space-y-4">
                {/* Header */}
                <div className="flex justify-between items-center">
                    <div className="text-sm text-slate-400">
                        {totalProjects} project{totalProjects !== 1 ? 's' : ''} · {totalApps} app{totalApps !== 1 ? 's' : ''}
                    </div>
                    <div className="flex gap-2">
                        <button onClick={() => setNewProjectForm(true)}
                            className="flex items-center gap-2 px-4 py-2 bg-slate-700 hover:bg-slate-600 rounded-lg text-sm">
                            <Icons.Plus /> New Project
                        </button>
                        <button onClick={() => setNewAppForm({ name: '', icon: '📦', targetPath: 'index.html', project: 'other' })}
                            className="flex items-center gap-2 px-4 py-2 bg-indigo-600 hover:bg-indigo-500 rounded-lg text-sm">
                            <Icons.Plus /> Add App
                        </button>
                    </div>
                </div>
                
                {/* Project Cards */}
                {projectsData.map(proj => {
                    const colors = getProjectColor(proj.color);
                    const structInfo = getStructureLabel(proj.structure);
                    const isExpanded = expandedProject === proj.id;
                    const projState = proj.state || 'active';
                    const isHidden = projState === 'hidden';
                    
                    return (
                        <div key={proj.id} className={`rounded-xl border overflow-hidden transition-all ${isHidden ? 'border-slate-700/50 opacity-60' : colors.border}`}>
                            {/* Project Header */}
                            <div className={`p-4 cursor-pointer transition-colors ${isExpanded ? colors.bg : 'hover:bg-white/5'}`}
                                onClick={() => setExpandedProject(isExpanded ? null : proj.id)}>
                                <div className="flex items-center gap-3">
                                    <span className={`transform transition-transform text-sm ${isExpanded ? 'rotate-90' : ''}`}>▶</span>
                                    <AppIcon icon={proj.icon} size={28} />
                                    <div className="flex-1 min-w-0">
                                        <div className="flex items-center gap-2">
                                            <span className={`font-semibold ${colors.text}`}>{proj.name}</span>
                                            <span className={`text-xs px-2 py-0.5 rounded-full ${isHidden ? 'bg-slate-700 text-slate-500' : 'bg-slate-700/50 text-slate-400'}`}>
                                                {projState}
                                            </span>
                                        </div>
                                        {proj.description && <div className="text-xs text-slate-500 mt-0.5">{proj.description}</div>}
                                    </div>
                                    
                                    {/* Compact attributes */}
                                    <div className="flex items-center gap-3 text-xs text-slate-400">
                                        <div className="flex items-center gap-1" title="Deployment Structure">
                                            <span>{structInfo.icon}</span>
                                            <span className={structInfo.color}>{structInfo.label}</span>
                                        </div>
                                        <span className="text-slate-600">|</span>
                                        <span>{proj.apps.length} app{proj.apps.length !== 1 ? 's' : ''}</span>
                                        <span className="text-slate-600">|</span>
                                        <span>{proj.allRepos.length} repo{proj.allRepos.length !== 1 ? 's' : ''}</span>
                                    </div>
                                    
                                    {/* Edit project button */}
                                    <button onClick={(e) => { e.stopPropagation(); setEditingProject(proj); }}
                                        className="p-1.5 rounded hover:bg-white/10 text-slate-500 hover:text-slate-300 transition-colors"
                                        title="Edit project">
                                        ✏️
                                    </button>
                                </div>
                            </div>
                            
                            {/* Expanded Project Detail */}
                            {isExpanded && (
                                <div className="border-t border-slate-700/50">
                                    {/* Project Attributes */}
                                    <div className="p-4 bg-slate-800/50 grid grid-cols-2 md:grid-cols-5 gap-4 text-xs">
                                        <div>
                                            <div className="text-slate-500 uppercase tracking-wide mb-1">State</div>
                                            <button onClick={(e) => { e.stopPropagation(); toggleProjectState(proj.id); }}
                                                className={`px-2 py-1 rounded text-xs font-medium ${isHidden ? 'bg-slate-700 text-slate-400 hover:bg-slate-600' : 'bg-green-900/30 text-green-400 hover:bg-green-900/50'}`}>
                                                {projState === 'hidden' ? '👁️ Show' : '🟢 Active'}
                                            </button>
                                        </div>
                                        <div>
                                            <div className="text-slate-500 uppercase tracking-wide mb-1">Structure</div>
                                            <div className={`font-medium ${structInfo.color}`}>{structInfo.icon} {structInfo.label}</div>
                                        </div>
                                        <div>
                                            <div className="text-slate-500 uppercase tracking-wide mb-1">Repositories</div>
                                            <div className="space-y-0.5">
                                                {proj.allRepos.length > 0 ? proj.allRepos.map(r => (
                                                    <div key={r} className="font-mono text-slate-300 truncate">{r.split('/')[1]}</div>
                                                )) : <span className="text-slate-500 italic">None assigned</span>}
                                            </div>
                                        </div>
                                        <div>
                                            <div className="text-slate-500 uppercase tracking-wide mb-1">Created</div>
                                            <div className="text-slate-300">{formatDate(proj.createdAt)}</div>
                                        </div>
                                        <div>
                                            <div className="text-slate-500 uppercase tracking-wide mb-1">Last Updated</div>
                                            <div className="text-slate-300">{formatDate(proj.updatedAt)}</div>
                                        </div>
                                    </div>
                                    
                                    {/* Apps Table */}
                                    <div className="p-4">
                                        <div className="flex items-center justify-between mb-3">
                                            <div className="text-sm font-semibold text-slate-300">Apps ({proj.apps.length})</div>
                                            <button onClick={() => setNewAppForm({ name: '', icon: '📦', targetPath: 'index.html', project: proj.id })}
                                                className="text-xs px-3 py-1 bg-slate-700 hover:bg-slate-600 rounded flex items-center gap-1">
                                                <Icons.Plus className="w-3 h-3" /> Add App to {proj.name}
                                            </button>
                                        </div>
                                        
                                        {/* Table Header */}
                                        <div className="grid grid-cols-12 gap-2 px-3 py-2 text-xs text-slate-500 uppercase tracking-wide border-b border-slate-700">
                                            <div className="col-span-3">App</div>
                                            <div className="col-span-1">Structure</div>
                                            <div className="col-span-3">Repos</div>
                                            <div className="col-span-2">Version</div>
                                            <div className="col-span-1">Created</div>
                                            <div className="col-span-1">Updated</div>
                                            <div className="col-span-1"></div>
                                        </div>
                                        
                                        {/* App Rows */}
                                        {proj.apps.sort((a, b) => a.name.localeCompare(b.name)).map(app => {
                                            const appStruct = getAppStructure(app);
                                            const appStructInfo = getStructureLabel(appStruct);
                                            const latestVersion = app.versions?.prod || app.versions?.test || '';
                                            const testVersion = app.versions?.test || '';
                                            const prodVersion = app.versions?.prod || '';
                                            
                                            return (
                                                <div key={app.id} className="grid grid-cols-12 gap-2 px-3 py-3 text-sm border-b border-slate-800 hover:bg-slate-800/50 items-center">
                                                    {/* App Name */}
                                                    <div className="col-span-3 flex items-center gap-2 min-w-0">
                                                        <AppIcon icon={app.icon} size={20} />
                                                        <div className="min-w-0">
                                                            <div className="font-medium truncate">{app.name}</div>
                                                            <div className="text-xs text-slate-500 flex items-center gap-1">
                                                                {app.hasServiceWorker && <span className="text-purple-400" title="PWA">📱</span>}
                                                                {app.appType === 'internal' && <span className="text-amber-400" title="Internal">🔒</span>}
                                                                <span className="font-mono">{app.targetPath}</span>
                                                                {app.subPath && <span className="text-slate-600">/{app.subPath}/</span>}
                                                            </div>
                                                        </div>
                                                    </div>
                                                    
                                                    {/* Structure */}
                                                    <div className="col-span-1">
                                                        <span className={`text-xs ${appStructInfo.color}`}>
                                                            {appStructInfo.icon} {appStruct === 'dual' ? 'Dual' : 'Single'}
                                                        </span>
                                                    </div>
                                                    
                                                    {/* Repos */}
                                                    <div className="col-span-3 text-xs font-mono min-w-0 space-y-0.5">
                                                        {app.repos?.test && (
                                                            <div className="flex items-center gap-1 truncate">
                                                                <span className="text-blue-400 w-8 shrink-0">TEST</span>
                                                                <span className="text-slate-400 truncate">{app.repos.test.split('/')[1]}</span>
                                                            </div>
                                                        )}
                                                        {app.repos?.prod && (
                                                            <div className="flex items-center gap-1 truncate">
                                                                <span className="text-green-400 w-8 shrink-0">PROD</span>
                                                                <span className="text-slate-400 truncate">{app.repos.prod.split('/')[1]}</span>
                                                            </div>
                                                        )}
                                                        {!app.repos?.test && !app.repos?.prod && <span className="text-slate-600 italic">No repos</span>}
                                                    </div>
                                                    
                                                    {/* Versions */}
                                                    <div className="col-span-2 text-xs space-y-0.5">
                                                        {testVersion && (
                                                            <div className="flex items-center gap-1">
                                                                <span className="bg-blue-900/40 text-blue-300 px-1.5 py-0.5 rounded">T: v{testVersion}</span>
                                                            </div>
                                                        )}
                                                        {prodVersion && (
                                                            <div className="flex items-center gap-1">
                                                                <span className="bg-green-900/40 text-green-300 px-1.5 py-0.5 rounded">P: v{prodVersion}</span>
                                                            </div>
                                                        )}
                                                        {!testVersion && !prodVersion && <span className="text-slate-600">—</span>}
                                                    </div>
                                                    
                                                    {/* Created */}
                                                    <div className="col-span-1 text-xs text-slate-500">
                                                        {formatDate(app.createdAt)}
                                                    </div>
                                                    
                                                    {/* Updated */}
                                                    <div className="col-span-1 text-xs text-slate-400">
                                                        {formatDate(app.updatedAt)}
                                                    </div>
                                                    
                                                    {/* Actions */}
                                                    <div className="col-span-1 flex gap-1 justify-end">
                                                        <button onClick={() => setPrepApp(app)}
                                                            className="p-1.5 text-slate-500 hover:text-purple-400 hover:bg-slate-700 rounded" title="Claude Prep">
                                                            🤖
                                                        </button>
                                                        <button onClick={() => setEditingApp(app)}
                                                            className="p-1.5 text-slate-500 hover:text-white hover:bg-slate-700 rounded" title="Edit">
                                                            <Icons.Edit className="w-3.5 h-3.5" />
                                                        </button>
                                                        <button onClick={() => deleteApp(app.id)}
                                                            className="p-1.5 text-slate-500 hover:text-red-400 hover:bg-slate-700 rounded" title="Delete">
                                                            <Icons.Trash className="w-3.5 h-3.5" />
                                                        </button>
                                                    </div>
                                                </div>
                                            );
                                        })}
                                    </div>
                                </div>
                            )}
                        </div>
                    );
                })}
                
                {/* Add/Edit App Modal */}
                {(newAppForm || editingApp) && (
                    <AppEditModal 
                        app={editingApp || newAppForm}
                        isNew={!editingApp}
                        environments={activeEnvs}
                        envLabels={config.environments.labels}
                        projects={config.projects}
                        availableRepos={availableRepos}
                        allApps={config.apps}
                        onSave={saveApp}
                        onCancel={() => { setEditingApp(null); setNewAppForm(null); }}
                    />
                )}
                
                {/* Add/Edit Project Modal */}
                {(newProjectForm || editingProject) && (
                    <ProjectEditModal
                        project={editingProject || null}
                        isNew={!editingProject}
                        appCount={editingProject ? ConfigManager.getProjectAppCount(config, editingProject.id) : 0}
                        onSave={saveProject}
                        onDelete={deleteProject}
                        onCancel={() => { setEditingProject(null); setNewProjectForm(null); }}
                    />
                )}
                
                {/* Claude Prep Modal */}
                {prepApp && (
                    <ClaudePrepModal
                        app={prepApp}
                        config={config}
                        github={github}
                        githubOwner={githubOwner}
                        deployments={deployments || []}
                        onClose={() => setPrepApp(null)}
                        showAlert={showAlert}
                        globalWorkItems={globalWorkItems}
                        firebaseUid={firebaseUid}
                        globalStreams={globalStreams}
                    />
                )}
            </div>
        );
    }

    // =========================================================================
    // PROJECT EDIT MODAL (v8.12.0)
    // =========================================================================
    function ProjectEditModal({ project, isNew, onSave, onDelete, onCancel, appCount }) {
        const [form, setForm] = React.useState({
            id: project?.id || '',
            name: project?.name || '',
            icon: project?.icon || '📦',
            color: project?.color || 'slate',
            description: project?.description || '',
            order: project?.order ?? 50
        });
        
        const [autoId, setAutoId] = React.useState(isNew);
        
        // Auto-generate ID from name for new projects
        React.useEffect(() => {
            if (autoId && isNew) {
                setForm(prev => ({ ...prev, id: prev.name.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, '') }));
            }
        }, [form.name, autoId, isNew]);
        
        const handleSave = () => {
            if (!form.name.trim()) return;
            if (!form.id.trim()) return;
            const { _showPicker, ...saveData } = form;
            onSave({
                ...saveData,
                order: parseInt(form.order) || 50
            });
        };
        
        const colorKeys = Object.keys(PROJECT_COLORS);
        const isOther = project?.id === 'other';
        
        return (
            <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50" onClick={onCancel}>
                <div className="bg-slate-800 rounded-xl border border-slate-600 p-6 w-full max-w-lg" onClick={e => e.stopPropagation()}>
                    <h3 className="text-lg font-semibold mb-4">{isNew ? '✨ New Project' : `Edit ${project.name}`}</h3>
                    
                    <div className="space-y-4">
                        {/* Name */}
                        <div>
                            <label className="block text-sm font-medium mb-1">Project Name</label>
                            <input type="text" value={form.name}
                                onChange={e => setForm({ ...form, name: e.target.value })}
                                className="w-full p-2 bg-slate-900 border border-slate-600 rounded focus:border-indigo-500 focus:outline-none"
                                placeholder="My Project" autoFocus />
                        </div>
                        
                        {/* ID */}
                        <div>
                            <label className="block text-sm font-medium mb-1">
                                Project ID
                                {isNew && <span className="text-xs text-slate-500 ml-2">(auto-generated from name)</span>}
                            </label>
                            <input type="text" value={form.id}
                                onChange={e => { setForm({ ...form, id: e.target.value }); setAutoId(false); }}
                                disabled={!isNew}
                                className={`w-full p-2 bg-slate-900 border border-slate-600 rounded font-mono text-sm ${!isNew ? 'opacity-60' : 'focus:border-indigo-500 focus:outline-none'}`}
                                placeholder="my-project" />
                        </div>
                        
                        {/* Icon + Order */}
                        <div className="grid grid-cols-2 gap-4">
                            <div>
                                <label className="block text-sm font-medium mb-1">Icon</label>
                                <div className="flex gap-2">
                                    <input type="text" value={form.icon}
                                        onChange={e => setForm({ ...form, icon: e.target.value })}
                                        className="flex-1 p-2 bg-slate-900 border border-slate-600 rounded focus:border-indigo-500 focus:outline-none"
                                        placeholder="📦 or gs-logo" />
                                    <button type="button" onClick={() => setForm(prev => ({ ...prev, _showPicker: !prev._showPicker }))}
                                        className="px-3 py-2 bg-slate-700 hover:bg-slate-600 rounded text-sm">
                                        😀 Pick
                                    </button>
                                </div>
                                {form._showPicker && (
                                    <div className="mt-2 p-2 bg-slate-900 border border-slate-600 rounded-lg max-h-36 overflow-y-auto">
                                        <div className="flex flex-wrap gap-1">
                                            {['📦','📋','📊','📁','💾','🗂️','📝','🎮','🎲','🃏','♟️','🎯','🏆','🎪','🔧','🛠️','⚙️','🔨','🪛','🏗️','🔩','🚀','⚡','🔥','💡','🧪','🎨','🌟','🪜','💻','📱','🖥️','⌨️','🖱️','💿','📡','🔌','🔋','📸','🎵','🎬','📚','✏️','🖊️','📌','🗃️','📈','📉','🧮','🔬','🔭','💰','🏦','🛒','🏠','🌍','✈️','🚗','⛵','🎓','🏥','⚖️','🎛️','🤖','👾','🕹️','🧩','🪄','✨'].map(emoji => (
                                                <button key={emoji} type="button"
                                                    onClick={() => setForm(prev => ({ ...prev, icon: emoji, _showPicker: false }))}
                                                    className={`w-8 h-8 flex items-center justify-center rounded hover:bg-slate-700 text-lg ${form.icon === emoji ? 'bg-indigo-600 ring-1 ring-indigo-400' : ''}`}>
                                                    {emoji}
                                                </button>
                                            ))}
                                        </div>
                                    </div>
                                )}
                                <div className="text-xs text-slate-500 mt-1">Emoji or "gs-logo" for Game Shelf icon</div>
                            </div>
                            <div>
                                <label className="block text-sm font-medium mb-1">Sort Order</label>
                                <input type="number" value={form.order}
                                    onChange={e => setForm({ ...form, order: e.target.value })}
                                    className="w-full p-2 bg-slate-900 border border-slate-600 rounded focus:border-indigo-500 focus:outline-none"
                                    min="1" max="99" />
                            </div>
                        </div>
                        
                        {/* Color Picker */}
                        <div>
                            <label className="block text-sm font-medium mb-2">Color Theme</label>
                            <div className="flex gap-2 flex-wrap">
                                {colorKeys.map(c => {
                                    const colors = PROJECT_COLORS[c];
                                    return (
                                        <button key={c}
                                            onClick={() => setForm({ ...form, color: c })}
                                            className={`px-3 py-1.5 rounded-lg text-sm capitalize transition-all ${colors.bg} ${colors.text} border ${form.color === c ? `${colors.border} ring-2 ring-offset-1 ring-offset-slate-800 ring-${c}-500` : 'border-transparent hover:border-slate-600'}`}>
                                            {c}
                                        </button>
                                    );
                                })}
                            </div>
                        </div>
                        
                        {/* Description */}
                        <div>
                            <label className="block text-sm font-medium mb-1">Description</label>
                            <input type="text" value={form.description}
                                onChange={e => setForm({ ...form, description: e.target.value })}
                                className="w-full p-2 bg-slate-900 border border-slate-600 rounded focus:border-indigo-500 focus:outline-none"
                                placeholder="What this project is about" />
                        </div>
                    </div>
                    
                    {/* Actions */}
                    <div className="flex justify-between mt-6">
                        <div>
                            {!isNew && !isOther && onDelete && (
                                <button onClick={() => onDelete(project.id)}
                                    className="px-4 py-2 text-red-400 hover:bg-red-900/30 rounded-lg text-sm">
                                    🗑️ Delete {appCount > 0 ? `(${appCount} app${appCount !== 1 ? 's' : ''} → Other)` : ''}
                                </button>
                            )}
                        </div>
                        <div className="flex gap-2">
                            <button onClick={onCancel} className="px-4 py-2 bg-slate-700 hover:bg-slate-600 rounded-lg text-sm">Cancel</button>
                            <button onClick={handleSave} disabled={!form.name.trim() || !form.id.trim()}
                                className="px-4 py-2 bg-indigo-600 hover:bg-indigo-500 disabled:opacity-50 disabled:cursor-not-allowed rounded-lg text-sm">
                                {isNew ? 'Create Project' : 'Save Changes'}
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        );
    }


    // =========================================================================
    // CLAUDE PREP MODAL (v8.13.0)
    // =========================================================================
    
    // Standard doc filenames for the Claude Prep package convention
    const CLAUDE_PREP_DOCS = ['CONTEXT.md', 'PROJECT_PLAN.md', 'CHANGELOG.md', 'RELEASE_NOTES.txt', 'ARCHITECTURE.md', 'CLAUDE-PREP-STANDARD.md', 'CLAUDE_INSTRUCTIONS.md'];
    
    // File action classification: deploy to GitHub Pages or push to source repo
    const DOC_FILE_EXTENSIONS = /\.(md|txt)$/i;
    const DEPLOY_FILE_EXTENSIONS = /\.(html|js|json|css|xml|svg|yml|yaml)$/i;
    
    function classifyFileAction(fileName) {
        // Known doc files always push to repo
        if (CLAUDE_PREP_DOCS.includes(fileName)) return 'push-doc';
        if (fileName === 'SESSION_BRIEF.md') return 'skip'; // Auto-generated, don't push
        // .md and .txt files → push to repo
        if (DOC_FILE_EXTENSIONS.test(fileName)) return 'push-doc';
        // Everything else → deploy to GitHub Pages
        return 'deploy';
    }
    
    // Required docs for a full doc set (per CLAUDE-PREP-STANDARD)
    const REQUIRED_DOCS = ['CONTEXT.md', 'PROJECT_PLAN.md', 'CHANGELOG.md', 'RELEASE_NOTES.txt'];
    
    // =========================================================================
    // UNIFIED PACKAGE VALIDATION (v8.36.0)
    // Selection-driven: runs on selected files to determine intent and issues.
    // Replaces: validateDocPackage, post-extraction showAlerts, deploy-time confirms
    // =========================================================================

    function getValidationIntent(selectedFiles) {
        const deployFiles = selectedFiles.filter(f => f.fileAction === 'deploy');
        const docFiles = selectedFiles.filter(f => f.fileAction === 'push-doc');

        if (selectedFiles.length === 0) return 'none';
        if (deployFiles.length === 0 && docFiles.length > 0) return 'docs-only';
        if (deployFiles.length === 1 && docFiles.length === 0) return 'quick-deploy';

        const hasHtml = deployFiles.some(f => f.name === 'index.html');
        const hasSw = deployFiles.some(f => f.name === 'sw.js');
        const hasManifest = deployFiles.some(f => f.name === 'manifest.json');
        const hasIcons = deployFiles.some(f => f.targetPath?.startsWith('icons/'));
        const pwaFileCount = [hasHtml, hasSw, hasManifest, hasIcons].filter(Boolean).length;

        const isPackage = pwaFileCount >= 3 || (deployFiles.length >= 2 && docFiles.length >= 2);

        if (isPackage && docFiles.length > 0) return 'full-package';
        if (isPackage) return 'deploy-package';
        return 'targeted-update';
    }

    function validatePackage(selectedFiles, stagedFiles, appConfig, deployedVersion) {
        const intent = getValidationIntent(selectedFiles);
        if (intent === 'none' || intent === 'docs-only') return null;

        const deployFiles = selectedFiles.filter(f => f.fileAction === 'deploy');
        const docFiles = selectedFiles.filter(f => f.fileAction === 'push-doc');
        const indexFile = deployFiles.find(f => f.name === 'index.html' || f.targetPath === 'index.html');
        const swFile = deployFiles.find(f => f.name === 'sw.js');
        // For quick-deploy (single file), use that file's version even if not named index.html
        const deployVersion = indexFile?.version || (deployFiles.length === 1 ? deployFiles[0]?.version : null) || null;
        const isPWA = appConfig?.hasServiceWorker === true;

        const issues = [];

        // --- Version not incremented (applies to ALL deploy intents, not just packages) ---
        if (intent !== 'none' && intent !== 'docs-only' && deployVersion && deployedVersion) {
            if (!isNewerVersion(deployVersion, deployedVersion)) {
                const isDowngrade = compareVersions(deployVersion, deployedVersion) < 0;
                const suggestedBump = bumpVersion(deployedVersion, 'patch');
                const hasDocsSelected = docFiles.length > 0;
                issues.push({
                    id: 'version-not-incremented',
                    severity: isDowngrade ? 'error' : 'warning',
                    category: 'versions',
                    title: isDowngrade ? 'Version downgrade detected' : 'Version not incremented',
                    detail: isDowngrade 
                        ? `v${deployVersion} is OLDER than deployed v${deployedVersion} on ${appConfig?.name || 'target'}`
                        : `v${deployVersion} is already on ${appConfig?.name || 'target'}`,
                    fix: `Bump to v${suggestedBump}`,
                    action: hasDocsSelected ? null : {
                        type: 'bump-version',
                        from: deployVersion,
                        suggested: suggestedBump
                    },
                    useClaudePrompt: hasDocsSelected
                });
            }
        }

        // --- Version mismatch: index.html vs sw.js ---
        if (intent !== 'quick-deploy' && indexFile && swFile) {
            if (indexFile.version && swFile.version && indexFile.version !== swFile.version) {
                issues.push({
                    id: 'version-mismatch',
                    severity: 'error',
                    category: 'versions',
                    title: 'Version mismatch: index.html vs sw.js',
                    detail: `index.html: v${indexFile.version}, sw.js: v${swFile.version}`,
                    fix: `Update sw.js CACHE_VERSION to v${indexFile.version}`
                });
            }
        }

        // --- PWA completeness (check against STAGED files, not selected) ---
        if ((intent === 'deploy-package' || intent === 'full-package') && isPWA) {
            const allStagedDeploy = stagedFiles.filter(f => f.fileAction === 'deploy');
            const missing = [];
            if (!allStagedDeploy.some(f => f.name === 'sw.js')) missing.push('sw.js');
            if (!allStagedDeploy.some(f => f.name === 'manifest.json')) missing.push('manifest.json');
            if (!allStagedDeploy.some(f => f.targetPath?.startsWith('icons/'))) missing.push('icons/');

            for (const m of missing) {
                issues.push({
                    id: `pwa-missing-${m.replace(/[/.]/g, '')}`,
                    severity: m === 'icons/' ? 'warning' : 'error',
                    category: 'pwa',
                    title: `Missing: ${m}`,
                    detail: `PWA package needs ${m}`,
                    fix: `Include ${m} in deployment package`
                });
            }
        }

        // --- Missing docs (full-package only, check against STAGED) ---
        if (intent === 'full-package') {
            const stagedDocNames = new Set(
                stagedFiles.filter(f => f.fileAction === 'push-doc').map(f => f.name)
            );
            for (const required of REQUIRED_DOCS) {
                if (!stagedDocNames.has(required)) {
                    issues.push({
                        id: `docs-missing-${required.toLowerCase().replace(/\./g, '')}`,
                        severity: 'warning',
                        category: 'docs',
                        title: `Missing: ${required}`,
                        detail: `Full package should include ${required}`,
                        fix: `Create ${required} following CLAUDE-PREP-STANDARD`
                    });
                }
            }
        }

        // --- Doc version alignment (on selected docs) ---
        // Use the effective target version: if a bump is needed, docs should match the bumped version
        const needsBump = issues.some(i => i.id === 'version-not-incremented');
        const effectiveVersion = needsBump ? bumpVersion(deployedVersion || deployVersion, 'patch') : deployVersion;
        if (effectiveVersion && docFiles.length > 0) {
            const contextFile = docFiles.find(f => f.name === 'CONTEXT.md');
            if (contextFile?.content) {
                const match = contextFile.content.match(/\*\*v([^\s*]+)\*\*/);
                if (match && match[1] !== effectiveVersion) {
                    issues.push({
                        id: 'docs-context-version', severity: 'warning', category: 'docs',
                        title: 'CONTEXT.md version mismatch',
                        detail: `CONTEXT.md: v${match[1]}, deploy: v${effectiveVersion}`,
                        fix: `Update CONTEXT.md header to v${effectiveVersion}`
                    });
                }
            }

            const changelogFile = docFiles.find(f => f.name === 'CHANGELOG.md');
            if (changelogFile?.content) {
                const match = changelogFile.content.match(/## \[([^\]]+)\]/);
                if (match && match[1] !== effectiveVersion) {
                    issues.push({
                        id: 'docs-changelog-version', severity: 'warning', category: 'docs',
                        title: 'CHANGELOG.md version mismatch',
                        detail: `CHANGELOG.md: [${match[1]}], deploy: v${effectiveVersion}`,
                        fix: `Add CHANGELOG.md entry for v${effectiveVersion}`
                    });
                }
            }

            const rnFile = docFiles.find(f => f.name === 'RELEASE_NOTES.txt');
            if (rnFile?.content) {
                const match = rnFile.content.match(/v?(\d+\.\d+[\d.]*)\s*[—–-]/);
                if (match && match[1] !== effectiveVersion) {
                    issues.push({
                        id: 'docs-releasenotes-version', severity: 'warning', category: 'docs',
                        title: 'RELEASE_NOTES.txt version mismatch',
                        detail: `RELEASE_NOTES.txt: v${match[1]}, deploy: v${effectiveVersion}`,
                        fix: `Add RELEASE_NOTES.txt entry for v${effectiveVersion}`
                    });
                }
            }
        }

        // --- Docs not included (info — deploy-package only) ---
        if (intent === 'deploy-package' && deployVersion) {
            issues.push({
                id: 'docs-not-included',
                severity: 'info',
                category: 'docs',
                title: 'Docs not included',
                detail: `Repo docs will be out of sync after deploying v${deployVersion}`,
                fix: null
            });
        }

        // --- Build result ---
        if (issues.length === 0) return null;

        const hasErrors = issues.some(i => i.severity === 'error');
        const hasWarnings = issues.some(i => i.severity === 'warning');
        const severity = hasErrors ? 'error' : hasWarnings ? 'warning' : 'info';

        const errorCount = issues.filter(i => i.severity === 'error').length;
        const warnCount = issues.filter(i => i.severity === 'warning').length;
        const infoCount = issues.filter(i => i.severity === 'info').length;

        const summaryParts = [];
        if (errorCount) summaryParts.push(`${errorCount} error${errorCount !== 1 ? 's' : ''}`);
        if (warnCount) summaryParts.push(`${warnCount} warning${warnCount !== 1 ? 's' : ''}`);
        if (infoCount) summaryParts.push(`${infoCount} info`);

        const needsClaudePrompt = issues.some(i =>
            i.useClaudePrompt ||
            i.category === 'pwa' ||
            (i.category === 'docs' && i.id !== 'docs-not-included') ||
            i.id === 'version-mismatch'
        );

        return {
            issues,
            intent,
            severity,
            summary: summaryParts.join(', '),
            claudePrompt: needsClaudePrompt
                ? generateClaudeFixPrompt(issues, deployVersion, deployedVersion, appConfig)
                : null,
            deployVersion
        };
    }

    function generateClaudeFixPrompt(issues, deployVersion, deployedVersion, appConfig) {
        const lines = [];
        lines.push('Please fix the following issues in my deployment package:\n');

        const notIncremented = issues.find(i => i.id === 'version-not-incremented');
        if (notIncremented) {
            const suggested = bumpVersion(deployedVersion || deployVersion, 'patch');
            const isDowngrade = deployVersion && deployedVersion && compareVersions(deployVersion, deployedVersion) < 0;
            lines.push('Version not incremented:');
            lines.push(`• Code is v${deployVersion} — ${isDowngrade ? `OLDER than deployed v${deployedVersion}` : 'same as deployed'}`);
            lines.push(`• Bump to v${suggested} (or appropriate version)`);
            lines.push(`• Update <meta name="version"> in index.html`);
            if (appConfig?.hasServiceWorker) {
                lines.push('• Update sw.js CACHE_VERSION to match');
            }
            lines.push('');
        }

        const mismatch = issues.find(i => i.id === 'version-mismatch');
        if (mismatch) {
            lines.push('Version mismatch:');
            lines.push(`• ${mismatch.detail}`);
            lines.push(`• ${mismatch.fix}`);
            lines.push('');
        }

        const pwaIssues = issues.filter(i => i.category === 'pwa');
        if (pwaIssues.length > 0) {
            const missingFiles = pwaIssues.map(i => i.title.replace('Missing: ', ''));
            lines.push('PWA package incomplete:');
            lines.push(`• Missing: ${missingFiles.join(', ')}`);
            lines.push('• Include all PWA files in the deployment package');
            lines.push('');
        }

        const missingDocs = issues.filter(i => i.id.startsWith('docs-missing'));
        if (missingDocs.length > 0) {
            const names = missingDocs.map(i => i.title.replace('Missing: ', ''));
            lines.push(`Missing docs: ${names.join(', ')}`);
            lines.push('Please create these following CLAUDE-PREP-STANDARD.');
            lines.push('');
        }

        const docVersions = issues.filter(i =>
            i.category === 'docs' &&
            !i.id.startsWith('docs-missing') &&
            i.id !== 'docs-not-included'
        );
        if (docVersions.length > 0) {
            lines.push('Doc version updates:');
            for (const issue of docVersions) {
                lines.push(`• ${issue.detail}`);
            }
            const targetV = notIncremented
                ? bumpVersion(deployedVersion || deployVersion, 'patch')
                : deployVersion;
            lines.push(`Please update all docs to reference v${targetV}.`);
            lines.push('');
        }

        const promptVersion = notIncremented
            ? bumpVersion(deployedVersion || deployVersion, 'patch')
            : deployVersion;
        if (promptVersion) lines.push(`Current version: v${promptVersion}`);
        if (appConfig?.name) lines.push(`App: ${appConfig.name}`);

        return lines.join('\n');
    }
    
    // Detect config ↔ code drift when deploying CC itself.
    // Parses CC_SEED_MANIFEST from staged HTML and compares against running config.
    function detectConfigDrift(stagedContent, runningConfig) {
        if (!stagedContent || !runningConfig) return null;
        
        // Extract CC_SEED_MANIFEST from staged HTML
        const manifestMatch = stagedContent.match(/\/\* CC_SEED_MANIFEST_START \*\/\s*[\n\r]?\s*const CC_SEED_MANIFEST = (\{[\s\S]*?\});\s*[\n\r]?\s*\/\* CC_SEED_MANIFEST_END \*\//);
        if (!manifestMatch) return null;
        
        let manifest;
        try {
            manifest = JSON.parse(manifestMatch[1]);
        } catch (e) {
            return { parseError: true, drifts: [], claudePrompt: 'Failed to parse CC_SEED_MANIFEST from staged code.' };
        }
        
        const drifts = [];
        
        // 1. Check gs-app-id matches a running app
        const gsAppIdMatch = stagedContent.match(/<meta\s+name=["']gs-app-id["']\s+content=["']([^"']+)["']/i);
        const codeAppId = gsAppIdMatch?.[1];
        if (codeAppId && !runningConfig.apps[codeAppId]) {
            drifts.push({
                type: 'identity', severity: 'error',
                field: 'gs-app-id',
                codeValue: codeAppId, configValue: '(no app with this id)',
                detail: `Code has gs-app-id="${codeAppId}" but no app with that id exists in config`
            });
        }
        
        // 2. Check project drift
        if (manifest.projects) {
            for (const [projId, codeProjData] of Object.entries(manifest.projects)) {
                const configProj = runningConfig.projects?.[projId];
                if (!configProj) {
                    drifts.push({
                        type: 'project', severity: 'warn',
                        field: `projects.${projId}`,
                        codeValue: codeProjData.name, configValue: '(missing)',
                        detail: `Code seeds project "${codeProjData.name}" (${projId}) but it doesn't exist in config`
                    });
                } else if (codeProjData.name !== configProj.name) {
                    drifts.push({
                        type: 'project', severity: 'warn',
                        field: `projects.${projId}.name`,
                        codeValue: codeProjData.name, configValue: configProj.name,
                        detail: `Project ${projId} name: code="${codeProjData.name}", config="${configProj.name}"`
                    });
                }
            }
            // Projects in config but not in code seeds
            for (const projId of Object.keys(runningConfig.projects || {})) {
                if (!manifest.projects[projId]) {
                    drifts.push({
                        type: 'project', severity: 'info',
                        field: `projects.${projId}`,
                        codeValue: '(not in seeds)', configValue: runningConfig.projects[projId].name,
                        detail: `Config has project "${runningConfig.projects[projId].name}" (${projId}) — not in code seeds, fresh install won't have it`
                    });
                }
            }
        }
        
        // 3. Check app drift — key identity fields
        if (manifest.apps) {
            const compareFields = ['name', 'project', 'icon', 'subPath', 'appType', 'hasServiceWorker'];
            
            for (const [appId, codeApp] of Object.entries(manifest.apps)) {
                const configApp = runningConfig.apps?.[appId];
                if (!configApp) {
                    drifts.push({
                        type: 'app', severity: 'warn',
                        field: `apps.${appId}`,
                        codeValue: codeApp.name, configValue: '(missing)',
                        detail: `Code seeds app "${codeApp.name}" (${appId}) but it doesn't exist in config`
                    });
                    continue;
                }
                for (const field of compareFields) {
                    const codeNorm = String(codeApp[field] ?? '');
                    const configNorm = String(configApp[field] ?? '');
                    if (codeNorm !== configNorm) {
                        drifts.push({
                            type: 'app',
                            severity: field === 'project' || field === 'name' ? 'warn' : 'info',
                            field: `apps.${appId}.${field}`,
                            codeValue: codeNorm || '(empty)', configValue: configNorm || '(empty)',
                            detail: `${configApp.name || appId} ${field}: code="${codeNorm || '(empty)'}", config="${configNorm || '(empty)'}"`
                        });
                    }
                }
            }
            // Apps in config but not in code seeds
            for (const appId of Object.keys(runningConfig.apps || {})) {
                if (!manifest.apps[appId]) {
                    drifts.push({
                        type: 'app', severity: 'info',
                        field: `apps.${appId}`,
                        codeValue: '(not in seeds)', configValue: runningConfig.apps[appId].name,
                        detail: `Config has app "${runningConfig.apps[appId].name}" (${appId}) — not in code seeds, fresh install won't have it`
                    });
                }
            }
        }
        
        if (drifts.length === 0) return null;
        
        // Generate Claude fix prompt
        const errors = drifts.filter(d => d.severity === 'error');
        const warns = drifts.filter(d => d.severity === 'warn');
        const infos = drifts.filter(d => d.severity === 'info');
        
        const lines = ['Please fix the following config ↔ code drift in Command Center:\n'];
        if (errors.length > 0) {
            lines.push('🔴 Critical:');
            errors.forEach(d => lines.push(`• ${d.detail}`));
            lines.push('');
        }
        if (warns.length > 0) {
            lines.push('⚠️ Mismatches (fresh installs get wrong defaults):');
            warns.forEach(d => lines.push(`• ${d.detail}`));
            lines.push('');
        }
        if (infos.length > 0) {
            lines.push('ℹ️ Config-only (not in code seeds — optional to add):');
            infos.forEach(d => lines.push(`• ${d.detail}`));
            lines.push('');
        }
        lines.push('Update CC_SEED_MANIFEST, SEED_PROJECTS, and DEFAULT_APP_DEFINITIONS to match.');
        
        return {
            drifts,
            errorCount: errors.length,
            warnCount: warns.length,
            infoCount: infos.length,
            claudePrompt: lines.join('\n')
        };
    }
    
    function getDocsPath(app) {
        // Standalone repos (no subPath): docs at root
        // Consolidated repos (has subPath): docs at {subPath}/docs/
        const subPath = app.subPath || '';
        if (!subPath) return '';
        return `${subPath}/docs`;
    }
    
    // Generate SESSION_BRIEF.md content from CC data
    function generateSessionBrief(app, config, deployments, options) {
        return SessionBriefGenerator.generate(app, config, deployments, options || {});
    }
    
    // Generate skeleton CONTEXT.md for bootstrapping
    function generateSkeletonContext(app, config) {
        const projectDef = config.projects?.[app.project] || {};
        const repos = Object.entries(app.repos || {}).filter(([,v]) => v);
        const repoStr = repos.map(([k,v]) => `- **${k.toUpperCase()}:** ${v}`).join('\n');
        
        return `# ${app.name} — CONTEXT.md

> **Read this first** at the start of every session.

## Current Version

**v${app.versions?.prod || app.versions?.test || '0.0.0'}**

## What ${app.name} Is

*TODO: Describe what this app does and who it's for.*

## Architecture

- **Single-file HTML app**: All CSS/JS inline in ${app.targetPath || 'index.html'}
- **Framework**: *TODO: React via CDN / vanilla JS / etc.*
- **Data**: *TODO: Firebase RTDB / localStorage / none*
- **PWA**: ${app.hasServiceWorker ? 'Yes — sw.js + manifest.json' : 'No'}
- **Deploy target**: *TODO: URL*

## Key Technical Details

### Meta Tags (Required)
\`\`\`html
<meta name="version" content="X.X.X">
<meta name="gs-app-id" content="${app.id}">
\`\`\`

### Data Schema
*TODO: Key data structures, Firebase paths, localStorage keys*

### Key Components / Functions
*TODO: Map of major components or functions*

## Deployment

${repoStr || '- *No repos configured*'}
- **SubPath:** ${app.subPath || '(root)'}
- **Structure:** ${repos.length > 1 ? 'Dual (Test → Prod)' : 'Single repo'}
- **PWA Package:** ${app.hasServiceWorker ? 'Yes — include sw.js, manifest.json, icons/' : 'No — single HTML file'}
- **Detection patterns:** ${(app.detectionPatterns || []).join(', ')}

## Conventions

*TODO: App-specific rules, CSS patterns, state management*

## Recent Changes

*TODO: Updated each session*
`;
    }
    
    // Generate skeleton PROJECT_PLAN.md
    function generateSkeletonPlan(app) {
        return `# ${app.name} — Project Plan

## Mission

*TODO: What this app exists to do.*

## Completed Features

*TODO: List completed features.*

## In Progress

*TODO: What's actively being worked on.*

## Planned Features

### Near Term
*TODO: Next priorities.*

### Medium Term
*TODO: Roadmap items.*

## Architecture Decisions

*TODO: Why key technical choices were made.*

## Open Questions

*TODO: Unresolved decisions.*
`;
    }
    
    // Generate skeleton CHANGELOG.md
    function generateSkeletonChangelog(app) {
        const ver = app.versions?.prod || app.versions?.test || '0.0.0';
        return `# ${app.name} — Changelog

## [${ver}] - ${new Date().toISOString().split('T')[0]}

### Added
- Initial changelog created by Claude Prep

*Use format: Added / Changed / Fixed / Removed per version.*
`;
    }
    
    function ClaudePrepModal({ app, config, github, githubOwner, deployments, onClose, showAlert, globalWorkItems, firebaseUid, globalStreams }) {
        // === Wizard State (v8.37.0: 3-step Session Wizard) ===
        const [wizardStep, setWizardStep] = React.useState(1); // 1: Work Items, 2: Session Type + Context, 3: Generate
        const [phase, setPhase] = React.useState('wizard'); // wizard | building | done | error
        const [sessionType, setSessionType] = React.useState(null);
        const [selectedWorkItems, setSelectedWorkItems] = React.useState([]);
        const [status, setStatus] = React.useState('idle');
        const [log, setLog] = React.useState([]);
        const [progress, setProgress] = React.useState({ current: 0, total: 0 });
        const [result, setResult] = React.useState(null);
        const [uploadMode, setUploadMode] = React.useState(false);
        const [uploadFiles, setUploadFiles] = React.useState([]);
        const [uploading, setUploading] = React.useState(false);
        const [uploadLog, setUploadLog] = React.useState([]);
        const [sessionRecord, setSessionRecord] = React.useState(null);
        
        // Get work items for this app
        const [streamFilter, setStreamFilter] = React.useState('all'); // Phase 5.2: stream filter for work items
        
        const appStreams = React.useMemo(() => {
            return (globalStreams || []).filter(s => s.appId === app.id);
        }, [globalStreams, app.id]);
        
        const appWorkItems = React.useMemo(() => {
            if (!globalWorkItems) return [];
            let items = globalWorkItems.filter(wi => wi.appId === app.id && (wi.status === 'ready' || wi.status === 'in-progress'));
            if (streamFilter !== 'all') {
                items = items.filter(wi => streamFilter === 'unassigned' ? !wi.streamId : wi.streamId === streamFilter);
            }
            return items;
        }, [globalWorkItems, app.id, streamFilter]);
        
        // Auto-suggest session type when a work item is selected
        const handleWorkItemToggle = (wi) => {
            setSelectedWorkItems(prev => {
                const exists = prev.find(w => w.id === wi.id);
                const next = exists ? prev.filter(w => w.id !== wi.id) : [...prev, wi];
                if (next.length > 0 && !sessionType) {
                    setSessionType(SessionBriefGenerator.suggestFromWorkItem(next[0]));
                }
                return next;
            });
        };
        
        const typeInfo = sessionType ? SESSION_TYPES[sessionType] : null;
        const suggestedEngine = typeInfo ? EngineRegistryService.get(typeInfo.suggestedEngine) : null;
        const defaultEngine = EngineRegistryService.getDefault();
        const activeEngine = suggestedEngine || defaultEngine;
        
        const addLog = (msg, type = 'info') => {
            setLog(prev => [...prev, { msg, type, time: new Date().toLocaleTimeString() }]);
        };
        
        // Wizard navigation
        const canProceed = (step) => {
            if (step === 1) return true; // Can always proceed from step 1 (general session is fine)
            if (step === 2) return true; // Session type is optional
            return false;
        };
        
        const goNext = () => setWizardStep(prev => Math.min(prev + 1, 3));
        const goBack = () => setWizardStep(prev => Math.max(prev - 1, 1));
        
        // Quick Skip: jump to building immediately
        const quickBuild = () => {
            setSessionType(null);
            setSelectedWorkItems([]);
            startPrep();
        };
        
        const startPrep = async () => {
            if (!github) {
                await showAlert('GitHub token not configured. Go to Settings to add one.');
                return;
            }
            
            setPhase('building');
            setStatus('fetching');
            setLog([]);
            
            try {
                const zip = new JSZip();
                const appFolder = zip.folder(app.id);
                const files = [];
                const missingDocs = [];
                
                const repo = app.repos?.prod || app.repos?.test;
                if (!repo) {
                    addLog('\u274c No repo configured for this app', 'error');
                    setStatus('error');
                    setPhase('error');
                    return;
                }
                
                addLog(`\ud83d\udcc2 Using repo: ${repo}`);
                const subPath = app.subPath || '';
                const docsPath = getDocsPath(app);
                const strategy = typeInfo?.contextStrategy || null;
                
                // === Fetch source files (session-type-aware) ===
                const includeSource = strategy ? strategy.includeSource : true;
                
                if (includeSource) {
                    addLog('\ud83d\udce5 Fetching source files...');
                    const targetPath = subPath 
                        ? `${subPath}/${app.targetPath || 'index.html'}`
                        : (app.targetPath || 'index.html');
                    
                    setProgress({ current: 1, total: 8 });
                    const mainFile = await github.getFileContent(repo, targetPath);
                    if (mainFile?.textContent) {
                        appFolder.file(app.targetPath || 'index.html', mainFile.textContent);
                        const mainName = app.targetPath || 'index.html';
                        files.push({ name: mainName, size: mainFile.textContent.length, tokens: TokenRegistryService.estimateTokens(mainFile.textContent, mainName) });
                        addLog(`\u2705 ${mainName} (${(mainFile.textContent.length / 1024).toFixed(0)}KB)`);
                    } else {
                        addLog(`\u26a0\ufe0f Could not fetch ${targetPath}`, 'warn');
                    }
                    
                    if (app.hasServiceWorker) {
                        setProgress({ current: 2, total: 8 });
                        const swPath = subPath ? `${subPath}/sw.js` : 'sw.js';
                        const swFile = await github.getFileContent(repo, swPath);
                        if (swFile?.textContent) {
                            appFolder.file('sw.js', swFile.textContent);
                            files.push({ name: 'sw.js', size: swFile.textContent.length, tokens: TokenRegistryService.estimateTokens(swFile.textContent, 'sw.js') });
                            addLog(`\u2705 sw.js (${(swFile.textContent.length / 1024).toFixed(0)}KB)`);
                        } else {
                            addLog('\u26a0\ufe0f sw.js not found (PWA app)', 'warn');
                        }
                        
                        setProgress({ current: 3, total: 8 });
                        const manifestPath = subPath ? `${subPath}/manifest.json` : 'manifest.json';
                        const manifestFile = await github.getFileContent(repo, manifestPath);
                        if (manifestFile?.textContent) {
                            appFolder.file('manifest.json', manifestFile.textContent);
                            files.push({ name: 'manifest.json', size: manifestFile.textContent.length, tokens: TokenRegistryService.estimateTokens(manifestFile.textContent, 'manifest.json') });
                            addLog(`\u2705 manifest.json`);
                        }
                    }
                } else {
                    addLog('\u23ed\ufe0f Skipping source files (not needed for this session type)');
                }
                
                // === Fetch doc files (session-type-aware filtering) ===
                addLog('\ud83d\udcc4 Looking for project docs...');
                setProgress({ current: 4, total: 8 });
                
                const skipSet = new Set(strategy?.skipWhenTight || []);
                const alwaysSet = new Set(strategy?.alwaysInclude || []);
                const preferSet = new Set(strategy?.preferInclude || []);
                
                let docsFound = 0;
                for (const docName of CLAUDE_PREP_DOCS) {
                    if (strategy && !alwaysSet.has(docName) && !preferSet.has(docName) && skipSet.has(docName)) {
                        addLog(`\u23ed\ufe0f Skipping ${docName} (session type: ${typeInfo?.label || 'N/A'})`, 'info');
                        continue;
                    }
                    
                    const paths = docsPath 
                        ? [`${docsPath}/${docName}`, `${subPath}/${docName}`, docName]
                        : [docName];
                    
                    let found = false;
                    for (const tryPath of paths) {
                        const docFile = await github.getFileContent(repo, tryPath);
                        if (docFile?.textContent) {
                            appFolder.file(docName, docFile.textContent);
                            files.push({ name: docName, size: docFile.textContent.length, tokens: TokenRegistryService.estimateTokens(docFile.textContent, docName) });
                            addLog(`\u2705 ${docName} (from ${tryPath})`);
                            docsFound++;
                            found = true;
                            break;
                        }
                    }
                    if (!found && docName !== 'ARCHITECTURE.md' && docName !== 'CLAUDE_INSTRUCTIONS.md' && docName !== 'CLAUDE-PREP-STANDARD.md') {
                        missingDocs.push(docName);
                    }
                }
                
                // === Bootstrap missing docs ===
                if (missingDocs.length > 0) {
                    addLog(`\ud83d\udcdd Generating ${missingDocs.length} missing doc${missingDocs.length > 1 ? 's' : ''}...`, 'warn');
                    setProgress({ current: 6, total: 8 });
                    
                    for (const docName of missingDocs) {
                        let content = '';
                        if (docName === 'CONTEXT.md') content = generateSkeletonContext(app, config);
                        else if (docName === 'PROJECT_PLAN.md') content = generateSkeletonPlan(app);
                        else if (docName === 'CHANGELOG.md') content = generateSkeletonChangelog(app);
                        else if (docName === 'RELEASE_NOTES.txt') content = `${app.name} - Release Notes\n${'='.repeat(app.name.length + 18)}\n\nv${app.versions?.prod || app.versions?.test || '0.0.0'}\n- Initial release notes created by Claude Prep\n`;
                        if (content) {
                            appFolder.file(docName, content);
                            files.push({ name: docName, size: content.length, generated: true, tokens: TokenRegistryService.estimateTokens(content, docName) });
                            addLog(`\ud83d\udcdd Generated skeleton: ${docName}`, 'warn');
                        }
                    }
                }
                
                // === Generate CLAUDE_INSTRUCTIONS.md from scope (if not in repo) ===
                const hasClaudeInstructions = files.some(f => f.name === 'CLAUDE_INSTRUCTIONS.md');
                if (!hasClaudeInstructions && firebaseDb && firebaseAuth?.currentUser) {
                    try {
                        const scopeSnap = await firebaseDb.ref(`command-center/${firebaseAuth.currentUser.uid}/appScopes/${app.id}`).once('value');
                        const scopeData = scopeSnap.val();
                        if (scopeData) {
                            const instructions = generateClaudeInstructions(app, scopeData, config);
                            if (instructions) {
                                appFolder.file('CLAUDE_INSTRUCTIONS.md', instructions);
                                files.push({ name: 'CLAUDE_INSTRUCTIONS.md', size: instructions.length, generated: true, tokens: TokenRegistryService.estimateTokens(instructions, 'CLAUDE_INSTRUCTIONS.md') });
                                addLog('\ud83c\udfaf Generated CLAUDE_INSTRUCTIONS.md from project scope');
                            }
                        }
                    } catch (e) {
                        addLog('\u26a0\ufe0f Could not generate CLAUDE_INSTRUCTIONS.md: ' + e.message, 'warn');
                    }
                }
                
                // === Scan for extra docs ===
                addLog('\ud83d\udd0d Scanning for extra reference docs...');
                setProgress({ current: 6, total: 9 });
                
                const alreadyFetched = new Set([...CLAUDE_PREP_DOCS, ...files.map(f => f.name), 'SESSION_BRIEF.md']);
                const scanPath = subPath || '';
                
                try {
                    const repoContents = await github.listRepoContents(repo, scanPath);
                    const extraMdFiles = repoContents.filter(f => 
                        f.type === 'file' && 
                        (f.name.endsWith('.md') || f.name.endsWith('.txt')) &&
                        !alreadyFetched.has(f.name) &&
                        f.name !== 'README.md' && f.name !== 'LICENSE' && f.name !== 'LICENSE.md'
                    );
                    
                    for (const extra of extraMdFiles) {
                        const filePath = scanPath ? `${scanPath}/${extra.name}` : extra.name;
                        const extraFile = await github.getFileContent(repo, filePath);
                        if (extraFile?.textContent) {
                            appFolder.file(extra.name, extraFile.textContent);
                            files.push({ name: extra.name, size: extraFile.textContent.length, tokens: TokenRegistryService.estimateTokens(extraFile.textContent, extra.name) });
                            addLog(`\u2705 ${extra.name} (extra reference doc)`);
                        }
                    }
                    if (extraMdFiles.length === 0) addLog('\u2139\ufe0f No extra reference docs found');
                } catch (e) {
                    addLog('\u26a0\ufe0f Could not scan for extra docs: ' + e.message, 'warn');
                }
                
                // === Generate SESSION_BRIEF.md ===
                addLog('\ud83d\udccb Generating session brief...');
                setProgress({ current: 8, total: 9 });
                
                if (sessionType) addLog(`\ud83c\udfaf Session type: ${SESSION_TYPES[sessionType]?.icon || ''} ${SESSION_TYPES[sessionType]?.label || sessionType}`);
                if (selectedWorkItems.length > 0) addLog(`\ud83d\udccb Targeting ${selectedWorkItems.length} work item${selectedWorkItems.length > 1 ? 's' : ''}: ${selectedWorkItems.map(wi => wi.id).join(', ')}`);
                
                const brief = generateSessionBrief(app, config, deployments, {
                    sessionType: sessionType || null,
                    targetWorkItems: selectedWorkItems.length > 0 ? selectedWorkItems : null,
                    allWorkItems: globalWorkItems || [],
                    streams: globalStreams || []  // Phase 5.2: stream context
                });
                const manifest = '\n## Files in This Package\n| File | Size | Tokens | Source |\n|------|------|--------|--------|\n' +
                    files.map(f => `| ${f.name} | ${(f.size / 1024).toFixed(1)}KB | ${TokenRegistryService.formatTokens(f.tokens || 0)} | ${f.generated ? '\u26a1 Generated skeleton' : '\ud83d\udcc2 From repo'} |`).join('\n') + '\n';
                const fullBrief = brief + manifest;
                appFolder.file('SESSION_BRIEF.md', fullBrief);
                files.push({ name: 'SESSION_BRIEF.md', size: fullBrief.length, tokens: TokenRegistryService.estimateTokens(fullBrief, 'SESSION_BRIEF.md') });
                
                // === Build zip ===
                addLog('\ud83d\udce6 Building zip...');
                setProgress({ current: 9, total: 9 });
                
                const ver = app.versions?.prod || app.versions?.test || '0.0.0';
                const filename = `${app.id}-project-v${ver}.zip`;
                const blob = await zip.generateAsync({ type: 'blob', compression: 'DEFLATE', compressionOptions: { level: 6 } });
                const blobUrl = URL.createObjectURL(blob);
                const totalSize = files.reduce((sum, f) => sum + f.size, 0);
                
                addLog(`\ud83c\udf89 Package ready: ${filename} (${(blob.size / 1024).toFixed(0)}KB compressed)`, 'success');
                if (missingDocs.length > 0) addLog(`\u26a0\ufe0f ${missingDocs.length} doc${missingDocs.length > 1 ? 's were' : ' was'} generated as skeleton${missingDocs.length > 1 ? 's' : ''} \u2014 flesh out during the session`, 'warn');
                
                const totalTokens = files.reduce((sum, f) => sum + (f.tokens || 0), 0);
                const budget = EngineRegistryService.checkBudget(totalTokens);
                
                addLog(`\ud83d\udcca Token estimate: ${TokenRegistryService.formatTokens(totalTokens)} (${budget.percentUsed}% of ${budget.engine.name} budget)`, budget.fits ? 'success' : 'warn');
                
                // === Phase 2.2: Work item auto-transition to in-progress ===
                if (firebaseUid && selectedWorkItems.length > 0) {
                    for (const wi of selectedWorkItems) {
                        if (wi.status === 'ready') {
                            try {
                                await WorkItemService.updateStatus(firebaseUid, wi.id, 'in-progress');
                                addLog(`\u27a1\ufe0f ${wi.id} \u2192 in-progress`, 'success');
                            } catch (e) {
                                addLog(`\u26a0\ufe0f Could not transition ${wi.id}: ${e.message}`, 'warn');
                            }
                        }
                    }
                }
                
                // === Phase 2.2: Create session record via SessionService ===
                let newSession = null;
                if (firebaseUid) {
                    try {
                        newSession = await SessionService.create(firebaseUid, {
                            appId: app.id,
                            type: sessionType || 'build',
                            workItemId: selectedWorkItems.length > 0 ? selectedWorkItems.map(wi => wi.id).join(',') : null,
                            engineId: typeInfo?.suggestedEngine || 'claude-sonnet-4.5',
                            packageTokens: totalTokens,
                            packageFiles: files.map(f => f.name)
                        });
                        if (newSession) {
                            setSessionRecord(newSession);
                            addLog(`\ud83d\udcdd Session ${newSession.id} recorded`, 'success');
                            // Phase 3.4: Log session creation
                            const actor = config?.ownerName || 'Owner';
                            ActivityLogService.logSessionCreate(firebaseUid, actor, app.name, sessionType || 'build', newSession.id).catch(() => {});
                        }
                    } catch (e) {
                        addLog(`\u26a0\ufe0f Could not create session record: ${e.message}`, 'warn');
                    }
                }
                
                setResult({ blobUrl, filename, fileCount: files.length, totalSize, missingDocs, files, totalTokens, budget, sessionType });
                setStatus('done');
                setPhase('done');
                
            } catch (e) {
                addLog(`\u274c Error: ${e.message}`, 'error');
                setStatus('error');
                setPhase('error');
            }
        };
        
        // Cleanup blob URL on unmount
        React.useEffect(() => {
            return () => { if (result?.blobUrl) URL.revokeObjectURL(result.blobUrl); };
        }, [result]);
        
        const download = () => {
            if (!result) return;
            const a = document.createElement('a');
            a.href = result.blobUrl;
            a.download = result.filename;
            a.click();
        };
        
        // === Doc Upload Functions (preserved from Phase 2.1) ===
        const ALLOWED_DOC_NAMES = ['CONTEXT.md', 'PROJECT_PLAN.md', 'CHANGELOG.md', 'RELEASE_NOTES.txt', 'ARCHITECTURE.md', 'DATA_MODEL.md', 'UX_LAYERS.md', 'VOICE_OPTIMIZATION.md', 'QUOTE_MIGRATION.md'];
        
        const handleDocDrop = async (e) => {
            e.preventDefault();
            e.stopPropagation();
            const files = Array.from(e.dataTransfer?.files || e.target?.files || []);
            if (files.length === 0) return;
            const repo = app.repos?.prod || app.repos?.test;
            if (!repo) return;
            const subPath = app.subPath || '';
            let docFiles = [];
            for (const file of files) {
                if (file.name.endsWith('.zip')) {
                    try {
                        const zipData = await file.arrayBuffer();
                        const zip = await JSZip.loadAsync(zipData);
                        for (const [path, entry] of Object.entries(zip.files)) {
                            if (entry.dir) continue;
                            const name = path.split('/').pop();
                            if (name.endsWith('.md') || name.endsWith('.txt')) {
                                const content = await entry.async('string');
                                docFiles.push({ name, content });
                            }
                        }
                    } catch (err) { await showAlert('Failed to read zip: ' + err.message); return; }
                } else if (file.name.endsWith('.md') || file.name.endsWith('.txt')) {
                    const content = await file.text();
                    docFiles.push({ name: file.name, content });
                }
            }
            if (docFiles.length === 0) { await showAlert('No .md or .txt doc files found.'); return; }
            const deduped = {};
            for (const f of docFiles) { deduped[f.name] = f; }
            docFiles = Object.values(deduped);
            const parsed = [];
            for (const doc of docFiles) {
                const docsPathLocal = getDocsPath(app);
                const paths = docsPathLocal
                    ? [`${docsPathLocal}/${doc.name}`, `${subPath}/${doc.name}`, doc.name]
                    : subPath ? [`${subPath}/${doc.name}`, doc.name] : [doc.name];
                let existingSha = null;
                let targetPath = paths[0];
                for (const tryPath of paths) {
                    try {
                        const existing = await github.getFile(repo, tryPath);
                        if (existing) { existingSha = existing.sha; targetPath = tryPath; break; }
                    } catch (e) { /* not found */ }
                }
                if (!existingSha && !subPath) targetPath = doc.name;
                else if (!existingSha && subPath) targetPath = docsPathLocal ? `${docsPathLocal}/${doc.name}` : `${subPath}/${doc.name}`;
                parsed.push({ name: doc.name, content: doc.content, size: doc.content.length, existing: !!existingSha, sha: existingSha, targetPath });
            }
            setUploadFiles(parsed);
        };
        
        const pushDocsToRepo = async () => {
            if (!github || uploadFiles.length === 0) return;
            const repo = app.repos?.prod || app.repos?.test;
            if (!repo) return;
            setUploading(true);
            setUploadLog([]);
            for (const doc of uploadFiles) {
                try {
                    const action = doc.existing ? 'Updating' : 'Creating';
                    setUploadLog(prev => [...prev, { msg: `\ud83d\udce4 ${action} ${doc.targetPath}...`, type: 'info' }]);
                    await github.createOrUpdateFile(repo, doc.targetPath, doc.content, `${doc.existing ? 'Update' : 'Add'} ${doc.name} via Command Center`, doc.sha);
                    setUploadLog(prev => [...prev, { msg: `\u2705 ${doc.name} pushed to ${doc.targetPath}`, type: 'success' }]);
                } catch (e) {
                    setUploadLog(prev => [...prev, { msg: `\u274c Failed to push ${doc.name}: ${e.message}`, type: 'error' }]);
                }
            }
            setUploading(false);
            setUploadLog(prev => [...prev, { msg: '\ud83c\udf89 Done! Docs are now in the repo.', type: 'success' }]);
        };
        
        const logColors = { info: 'text-slate-400', success: 'text-green-400', warn: 'text-amber-400', error: 'text-red-400' };
        
        // === Wizard Step Labels ===
        const WIZARD_STEPS = [
            { num: 1, label: 'Work Items', icon: '\ud83d\udccb' },
            { num: 2, label: 'Session Type', icon: '\ud83c\udfaf' },
            { num: 3, label: 'Generate', icon: '\ud83d\udce6' }
        ];
        
        // === RENDER ===
        return (
            <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50" onClick={onClose}>
                <div className="bg-slate-800 rounded-xl border border-slate-600 w-full max-w-xl mx-4 max-h-[85vh] flex flex-col" onClick={e => e.stopPropagation()}>
                    {/* Header */}
                    <div className="flex items-center justify-between p-4 border-b border-slate-700">
                        <div className="flex items-center gap-3">
                            <span className="text-2xl">\ud83e\udd16</span>
                            <div>
                                <h2 className="text-lg font-semibold">Claude Session Wizard</h2>
                                <div className="text-sm text-slate-400 flex items-center gap-2">
                                    <AppIcon icon={app.icon} size={16} />
                                    {app.name}
                                    {app.versions?.prod && <span className="text-xs bg-green-900/40 text-green-300 px-1.5 rounded">v{app.versions.prod}</span>}
                                </div>
                            </div>
                        </div>
                        <button onClick={onClose} className="text-slate-400 hover:text-white text-xl px-2">\u2715</button>
                    </div>
                    
                    {/* === Wizard Step Indicator === */}
                    {phase === 'wizard' && (
                        <div className="flex items-center gap-1 px-4 pt-3 pb-1">
                            {WIZARD_STEPS.map((s, i) => (
                                <React.Fragment key={s.num}>
                                    <button 
                                        onClick={() => s.num < wizardStep && setWizardStep(s.num)}
                                        className={`flex items-center gap-1.5 px-2.5 py-1.5 rounded-full text-xs font-medium transition-all ${
                                            wizardStep === s.num 
                                                ? 'bg-purple-600/30 text-purple-200 border border-purple-500' 
                                                : wizardStep > s.num 
                                                    ? 'bg-green-900/20 text-green-400 border border-green-800 cursor-pointer hover:bg-green-900/30'
                                                    : 'bg-slate-700/30 text-slate-500 border border-slate-700'
                                        }`}>
                                        <span>{wizardStep > s.num ? '\u2713' : s.icon}</span>
                                        <span className="hidden sm:inline">{s.label}</span>
                                        <span className="sm:hidden">{s.num}</span>
                                    </button>
                                    {i < WIZARD_STEPS.length - 1 && (
                                        <div className={`flex-1 h-px ${wizardStep > s.num ? 'bg-green-700' : 'bg-slate-700'}`} />
                                    )}
                                </React.Fragment>
                            ))}
                        </div>
                    )}
                    
                    {/* === STEP 1: Work Items === */}
                    {phase === 'wizard' && wizardStep === 1 && (
                        appWorkItems.length === 0 ? (
                            /* Quick Build Bypass: 0 work items → one-screen summary */
                            <div className="flex-1 overflow-y-auto p-5 min-h-0 space-y-4">
                                <div className="text-sm font-medium text-slate-300 mb-1">Quick Build</div>
                                <div className="text-xs text-slate-500 mb-3">No open work items — this will generate a general session package.</div>
                                
                                <div className="bg-slate-900/50 rounded-lg p-4 space-y-3 text-xs">
                                    <div className="flex items-center justify-between">
                                        <span className="text-slate-500">App</span>
                                        <span className="text-slate-300 flex items-center gap-1.5"><AppIcon icon={app.icon} size={14} /> {app.name}</span>
                                    </div>
                                    <div className="flex items-center justify-between">
                                        <span className="text-slate-500">Session Type</span>
                                        <span className="text-slate-300">General (no targeted items)</span>
                                    </div>
                                    <div className="flex items-center justify-between">
                                        <span className="text-slate-500">Engine</span>
                                        <span className="text-slate-300">{activeEngine?.name || 'Default'}</span>
                                    </div>
                                    <div className="flex items-center justify-between">
                                        <span className="text-slate-500">Source Files</span>
                                        <span className="text-slate-300">Included</span>
                                    </div>
                                </div>
                                
                                <div className="bg-green-900/15 border border-green-800/30 rounded-lg p-3 text-xs text-green-300 flex items-center gap-2">
                                    <span className="text-green-400">\u2713</span>
                                    <span>Package fits — Claude will see everything needed.</span>
                                </div>
                                
                                <div className="pt-2">
                                    <button onClick={quickBuild}
                                        className="w-full py-3 bg-purple-600 hover:bg-purple-500 rounded-lg font-medium text-sm flex items-center justify-center gap-2 transition-colors">
                                        \ud83d\udce6 Generate Package
                                    </button>
                                </div>
                            </div>
                        ) : (
                        <div className="flex-1 overflow-y-auto p-5 min-h-0 space-y-4">
                            <div className="text-sm font-medium text-slate-300 mb-1">What are you working on?</div>
                            <div className="text-xs text-slate-500 mb-3">Build a Claude briefing package. Select work items to focus on, or skip for a general session.</div>
                            
                            {/* Stream filter (Phase 5.2) */}
                            {appStreams.length > 0 && (
                                <div className="flex items-center gap-2 mb-2">
                                    <span className="text-xs text-slate-500">Stream:</span>
                                    <select value={streamFilter} onChange={e => setStreamFilter(e.target.value)}
                                        className="bg-slate-700 border border-slate-600 rounded px-2 py-1 text-xs">
                                        <option value="all">All streams</option>
                                        {appStreams.map(s => (
                                            <option key={s.id} value={s.id}>🔀 {s.name}</option>
                                        ))}
                                        <option value="unassigned">📋 Unassigned</option>
                                    </select>
                                </div>
                            )}
                            
                            {appWorkItems.length > 0 ? (
                                <div className="space-y-1.5 max-h-64 overflow-y-auto">
                                    {appWorkItems.map(wi => {
                                        const isSelected = selectedWorkItems.some(w => w.id === wi.id);
                                        const typeColors = { feature: 'text-blue-400', bugfix: 'text-red-400', enhancement: 'text-green-400', chore: 'text-slate-400', research: 'text-amber-400' };
                                        return (
                                            <button key={wi.id}
                                                onClick={() => handleWorkItemToggle(wi)}
                                                className={`w-full text-left px-3 py-2.5 rounded-lg text-xs flex items-center gap-2 transition-all border ${
                                                    isSelected 
                                                        ? 'bg-purple-600/20 border-purple-500/50 text-slate-200' 
                                                        : 'bg-slate-700/30 border-transparent text-slate-400 hover:bg-slate-700/50'
                                                }`}>
                                                <span className={`w-4 h-4 flex items-center justify-center rounded border ${
                                                    isSelected ? 'bg-purple-600 border-purple-500 text-white' : 'border-slate-600'
                                                }`}>
                                                    {isSelected && '\u2713'}
                                                </span>
                                                <span className="font-mono text-slate-500">{wi.id}</span>
                                                <span className={typeColors[wi.type] || 'text-slate-400'}>{wi.type}</span>
                                                <span className="flex-1 truncate text-slate-300">{wi.title}</span>
                                                <span className={`px-1.5 py-0.5 rounded text-[10px] ${
                                                    wi.status === 'in-progress' ? 'bg-blue-900/30 text-blue-300' : 'bg-slate-700 text-slate-400'
                                                }`}>{wi.status}</span>
                                            </button>
                                        );
                                    })}
                                </div>
                            ) : (
                                <div className="bg-slate-900/30 rounded-lg p-4 text-center text-sm text-slate-500">
                                    No open work items for this app.
                                    <div className="text-xs mt-1 text-slate-600">This will be a general session.</div>
                                </div>
                            )}
                            
                            {selectedWorkItems.length > 0 && (
                                <div className="bg-purple-900/20 border border-purple-800/50 rounded-lg p-3 text-xs text-purple-300">
                                    \ud83d\udccb {selectedWorkItems.length} item{selectedWorkItems.length > 1 ? 's' : ''} selected
                                    {selectedWorkItems.filter(wi => wi.status === 'ready').length > 0 && (
                                        <span className="text-purple-400 ml-2">
                                            \u2192 {selectedWorkItems.filter(wi => wi.status === 'ready').length} will transition to in-progress
                                        </span>
                                    )}
                                </div>
                            )}
                        </div>
                        )
                    )}
                    
                    {/* === STEP 2: Session Type + Context Preview === */}
                    {phase === 'wizard' && wizardStep === 2 && (
                        <div className="flex-1 overflow-y-auto p-5 min-h-0 space-y-4">
                            <div className="text-sm font-medium text-slate-300 mb-1">Session Type</div>
                            <div className="text-xs text-slate-500 mb-3">
                                {selectedWorkItems.length > 0 && sessionType 
                                    ? `Auto-suggested from work item type. This determines how Claude approaches the work and what context it receives.` 
                                    : 'Choose what kind of work you\'ll be doing. This shapes Claude\'s approach and the files included.'}
                            </div>
                            
                            <div className="grid grid-cols-4 gap-1.5">
                                {SessionBriefGenerator.getAll().map(t => (
                                    <button key={t.id}
                                        onClick={() => setSessionType(sessionType === t.id ? null : t.id)}
                                        className={`py-2.5 px-1.5 rounded-lg text-center text-xs transition-all border ${
                                            sessionType === t.id 
                                                ? 'bg-purple-600/30 border-purple-500 text-purple-200' 
                                                : 'bg-slate-700/50 border-slate-600/50 text-slate-400 hover:bg-slate-700 hover:text-slate-300'
                                        }`}>
                                        <div className="text-lg mb-0.5">{t.icon}</div>
                                        <div>{t.label}</div>
                                    </button>
                                ))}
                            </div>
                            
                            {typeInfo && (
                                <div className="bg-slate-900/50 rounded-lg p-3 text-xs space-y-2">
                                    <div className="text-slate-300">{typeInfo.description}</div>
                                    {suggestedEngine && (
                                        <div className="text-slate-500">Suggested engine: <span className="text-slate-400">{suggestedEngine.name}</span></div>
                                    )}
                                    <div className="text-slate-400 italic text-[11px]">"{typeInfo.roleFrame}"</div>
                                    <div className="space-y-0.5 mt-1">
                                        {typeInfo.scopeRules.map((rule, i) => (
                                            <div key={i} className="text-slate-500 flex items-start gap-1.5">
                                                <span className="text-slate-600 mt-0.5">\u2022</span> {rule}
                                            </div>
                                        ))}
                                    </div>
                                    <div className="pt-2 border-t border-slate-800">
                                        <div className="text-slate-500 font-medium mb-1">Delivery requirements:</div>
                                        {typeInfo.deliveryRequirements.map((req, i) => (
                                            <div key={i} className="text-slate-500 flex items-start gap-1.5">
                                                <span className="text-green-700 mt-0.5">\u2713</span> {req}
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            )}
                            
                            {/* Context confidence indicator (replaces old Step 3) */}
                            <div className="bg-green-900/15 border border-green-800/30 rounded-lg p-3 text-xs text-green-300 flex items-center gap-2">
                                <span className="text-green-400">\u2713</span>
                                <span>Package fits — Claude will see everything needed for this session.</span>
                            </div>
                            
                            {/* Collapsible: What Claude will see */}
                            <details className="group">
                                <summary className="text-xs text-slate-500 cursor-pointer hover:text-slate-300 transition-colors select-none flex items-center gap-1">
                                    <span className="text-[10px] group-open:rotate-90 transition-transform inline-block">\u25b6</span>
                                    What Claude will see
                                </summary>
                                <div className="mt-2 space-y-2">
                                    {typeInfo ? (
                                        <div className="space-y-1">
                                            {typeInfo.contextStrategy.includeSource && (
                                                <div className="flex items-center gap-2 px-3 py-1.5 bg-green-900/20 rounded text-xs">
                                                    <span className="text-green-400">\u2713</span>
                                                    <span className="text-green-300 font-mono">{app.targetPath || 'index.html'}</span>
                                                    <span className="text-green-600 ml-auto">source</span>
                                                </div>
                                            )}
                                            {!typeInfo.contextStrategy.includeSource && (
                                                <div className="flex items-center gap-2 px-3 py-1.5 bg-slate-800 rounded text-xs">
                                                    <span className="text-slate-600">\u2212</span>
                                                    <span className="text-slate-500 font-mono line-through">{app.targetPath || 'index.html'}</span>
                                                    <span className="text-amber-600 ml-auto">skipped</span>
                                                </div>
                                            )}
                                            {typeInfo.contextStrategy.alwaysInclude.map(f => (
                                                <div key={f} className="flex items-center gap-2 px-3 py-1.5 bg-green-900/20 rounded text-xs">
                                                    <span className="text-green-400">\u2713</span>
                                                    <span className="text-green-300 font-mono">{f}</span>
                                                    <span className="text-green-600 ml-auto">always</span>
                                                </div>
                                            ))}
                                            {typeInfo.contextStrategy.preferInclude.map(f => (
                                                <div key={f} className="flex items-center gap-2 px-3 py-1.5 bg-slate-700/50 rounded text-xs">
                                                    <span className="text-slate-400">+</span>
                                                    <span className="text-slate-300 font-mono">{f}</span>
                                                    <span className="text-slate-500 ml-auto">preferred</span>
                                                </div>
                                            ))}
                                            {typeInfo.contextStrategy.skipWhenTight.map(f => (
                                                <div key={f} className="flex items-center gap-2 px-3 py-1.5 bg-slate-800 rounded text-xs">
                                                    <span className="text-slate-600">\u2212</span>
                                                    <span className="text-slate-500 font-mono">{f}</span>
                                                    <span className="text-slate-600 ml-auto">skipped</span>
                                                </div>
                                            ))}
                                            <div className="text-xs text-slate-500 mt-2">
                                                + SESSION_BRIEF.md (auto-generated) + any extra .md/.txt files found in repo
                                            </div>
                                        </div>
                                    ) : (
                                        <div className="bg-slate-900/30 rounded-lg p-3 text-xs text-slate-500">
                                            All standard docs + source files will be included. Select a session type above to optimize file selection.
                                        </div>
                                    )}
                                </div>
                            </details>
                            
                            {/* Work item context note */}
                            {selectedWorkItems.length > 0 && (
                                <div className="bg-purple-900/15 border border-purple-800/30 rounded-lg p-3 text-xs text-purple-300">
                                    \ud83d\udccb Session brief will include acceptance criteria, files affected, and dependencies for {selectedWorkItems.length} targeted work item{selectedWorkItems.length > 1 ? 's' : ''}.
                                </div>
                            )}
                        </div>
                    )}
                    
                    {/* === STEP 3: Generate (summary before building) === */}
                    {phase === 'wizard' && wizardStep === 3 && (
                        <div className="flex-1 overflow-y-auto p-5 min-h-0 space-y-4">
                            <div className="text-sm font-medium text-slate-300 mb-1">Ready to Generate</div>
                            <div className="text-xs text-slate-500 mb-3">Generate a zip package with source, docs, and a session brief to upload to Claude.</div>
                            
                            {/* Summary */}
                            <div className="bg-slate-900/50 rounded-lg p-4 space-y-3 text-xs">
                                <div className="flex items-center justify-between">
                                    <span className="text-slate-500">Session Type</span>
                                    <span className="text-slate-300">{typeInfo ? `${typeInfo.icon} ${typeInfo.label}` : 'General (no type)'}</span>
                                </div>
                                <div className="flex items-center justify-between">
                                    <span className="text-slate-500">Work Items</span>
                                    <span className="text-slate-300">{selectedWorkItems.length > 0 ? selectedWorkItems.map(wi => wi.id).join(', ') : 'None (general session)'}</span>
                                </div>
                                <div className="flex items-center justify-between">
                                    <span className="text-slate-500">Engine</span>
                                    <span className="text-slate-300">{activeEngine?.name || 'Default'}</span>
                                </div>
                                <div className="flex items-center justify-between">
                                    <span className="text-slate-500">Source Files</span>
                                    <span className="text-slate-300">{typeInfo?.contextStrategy?.includeSource === false ? 'Excluded' : 'Included'}</span>
                                </div>
                                {selectedWorkItems.filter(wi => wi.status === 'ready').length > 0 && (
                                    <div className="pt-2 border-t border-slate-700 text-purple-300">
                                        \u27a1\ufe0f {selectedWorkItems.filter(wi => wi.status === 'ready').length} work item{selectedWorkItems.filter(wi => wi.status === 'ready').length > 1 ? 's' : ''} will transition to <strong>in-progress</strong>
                                    </div>
                                )}
                            </div>
                        </div>
                    )}
                    
                    {/* === Wizard Footer (navigation) === */}
                    {phase === 'wizard' && (
                        <div className="p-4 border-t border-slate-700 space-y-2">
                            <div className="flex gap-2">
                                {wizardStep > 1 && (
                                    <button onClick={goBack}
                                        className="px-4 py-2.5 bg-slate-700 hover:bg-slate-600 rounded-lg text-sm transition-colors">
                                        \u2190 Back
                                    </button>
                                )}
                                {wizardStep < 3 && (
                                    <button onClick={goNext}
                                        className="flex-1 py-2.5 bg-purple-600 hover:bg-purple-500 rounded-lg font-medium text-sm transition-colors">
                                        Next \u2192
                                    </button>
                                )}
                                {wizardStep === 3 && (
                                    <button onClick={startPrep}
                                        className="flex-1 py-2.5 bg-purple-600 hover:bg-purple-500 rounded-lg font-medium text-sm flex items-center justify-center gap-2 transition-colors">
                                        \ud83d\udce6 Generate Package{sessionType ? ` (${SESSION_TYPES[sessionType].icon} ${SESSION_TYPES[sessionType].label})` : ''}
                                    </button>
                                )}
                            </div>
                            {wizardStep === 1 && (
                                <button onClick={quickBuild}
                                    className="w-full py-2 text-sm text-slate-500 hover:text-slate-300 transition-colors">
                                    Skip wizard \u2014 Quick package
                                </button>
                            )}
                        </div>
                    )}
                    
                    {/* === Building/Done/Error Phase (same as before) === */}
                    {(phase === 'building' || phase === 'done' || phase === 'error') && (
                        <React.Fragment>
                    
                    {status === 'fetching' && progress.total > 0 && (
                        <div className="px-5 pt-3">
                            <div className="h-1.5 bg-slate-700 rounded-full overflow-hidden">
                                <div className="h-full bg-purple-500 rounded-full transition-all duration-300"
                                    style={{ width: `${(progress.current / progress.total) * 100}%` }} />
                            </div>
                        </div>
                    )}
                    
                    <div className="flex-1 overflow-y-auto p-5 min-h-0">
                        <div className="space-y-1 font-mono text-xs">
                            {log.map((entry, i) => (
                                <div key={i} className={logColors[entry.type] || 'text-slate-400'}>
                                    <span className="text-slate-600 mr-2">{entry.time}</span>
                                    {entry.msg}
                                </div>
                            ))}
                            {status === 'fetching' && (
                                <div className="text-purple-400 animate-pulse">\u23f3 Working...</div>
                            )}
                        </div>
                    </div>
                    
                    <div className="p-5 border-t border-slate-700">
                        {status === 'done' && result && (
                            <div className="space-y-3">
                                <div className="flex items-center gap-4 text-sm flex-wrap">
                                    <div className="flex items-center gap-1.5 text-slate-300"><span>\ud83d\udce6</span> {result.fileCount} files</div>
                                    <div className="flex items-center gap-1.5 text-slate-300"><span>\ud83d\udcbe</span> {(result.totalSize / 1024).toFixed(0)}KB</div>
                                    <div className="flex items-center gap-1.5 text-slate-300"><span>\ud83e\uddee</span> {TokenRegistryService.formatTokens(result.totalTokens)} tokens</div>
                                    {result.missingDocs.length > 0 && (
                                        <div className="flex items-center gap-1.5 text-amber-400"><span>\u26a1</span> {result.missingDocs.length} skeleton{result.missingDocs.length > 1 ? 's' : ''}</div>
                                    )}
                                    {sessionRecord && (
                                        <div className="flex items-center gap-1.5 text-green-400"><span>\ud83d\udcdd</span> {sessionRecord.id}</div>
                                    )}
                                </div>
                                
                                {result.budget && (() => {
                                    const b = result.budget;
                                    const pct = Math.min(b.percentUsed, 100);
                                    const barColor = b.percentUsed <= 50 ? 'bg-green-500' : b.percentUsed <= 75 ? 'bg-emerald-500' : b.percentUsed <= 90 ? 'bg-amber-500' : b.fits ? 'bg-orange-500' : 'bg-red-500';
                                    const textColor = b.fits ? 'text-slate-400' : 'text-red-400';
                                    return (
                                        <div className="bg-slate-900 rounded-lg p-3">
                                            <div className="flex items-center justify-between text-xs mb-1.5">
                                                <span className="text-slate-400 font-medium">{b.engine.name}</span>
                                                <span className={textColor}>{TokenRegistryService.formatTokens(b.tokenCount)} / {TokenRegistryService.formatTokens(b.usableLimit)} usable ({b.percentUsed}%)</span>
                                            </div>
                                            <div className="h-2.5 bg-slate-700 rounded-full overflow-hidden">
                                                <div className={`h-full rounded-full transition-all duration-500 ${barColor}`} style={{ width: `${pct}%` }} />
                                            </div>
                                            <div className="flex justify-between text-[10px] text-slate-600 mt-1">
                                                <span>0</span>
                                                <span>{TokenRegistryService.formatTokens(b.limit)} total ({TokenRegistryService.formatTokens(b.usableLimit)} usable \u00b7 20% reserved)</span>
                                            </div>
                                            {!b.fits && b.recommendations.length > 0 && (
                                                <div className="mt-2.5 pt-2.5 border-t border-slate-700">
                                                    <div className="text-xs text-red-400 font-medium mb-1.5">\u26a0\ufe0f Over budget by {TokenRegistryService.formatTokens(b.overBy)} tokens</div>
                                                    <div className="space-y-1">{b.recommendations.map((rec, i) => (
                                                        <div key={i} className="flex items-start gap-2 text-xs">
                                                            <span className="text-slate-500 mt-0.5">\u2022</span>
                                                            <div><span className="text-slate-300">{rec.label}</span>{rec.savings && <span className="text-green-500 ml-1">({rec.savings})</span>}{rec.cost && <span className="text-amber-500 ml-1">({rec.cost})</span>}</div>
                                                        </div>
                                                    ))}</div>
                                                </div>
                                            )}
                                        </div>
                                    );
                                })()}
                                
                                {result.files && result.files.length > 0 && (
                                    <details className="group">
                                        <summary className="text-xs text-slate-500 cursor-pointer hover:text-slate-300 select-none">\ud83d\udccb File manifest ({result.files.length} files)</summary>
                                        <div className="mt-2 bg-slate-900 rounded-lg overflow-hidden">
                                            <table className="w-full text-xs">
                                                <thead><tr className="text-slate-500 border-b border-slate-700">
                                                    <th className="text-left py-1.5 px-2 font-medium">File</th>
                                                    <th className="text-right py-1.5 px-2 font-medium">Size</th>
                                                    <th className="text-right py-1.5 px-2 font-medium">Tokens</th>
                                                    <th className="text-right py-1.5 px-2 font-medium">%</th>
                                                </tr></thead>
                                                <tbody>{[...result.files].sort((a, b) => (b.tokens || 0) - (a.tokens || 0)).map((f, i) => {
                                                    const pctOfTotal = result.totalTokens ? Math.round(((f.tokens || 0) / result.totalTokens) * 100) : 0;
                                                    return (<tr key={i} className="border-b border-slate-800 hover:bg-slate-800/50">
                                                        <td className="py-1 px-2 font-mono text-slate-300">{f.generated ? '\u26a1 ' : ''}{f.name}</td>
                                                        <td className="py-1 px-2 text-right text-slate-500">{(f.size / 1024).toFixed(1)}KB</td>
                                                        <td className="py-1 px-2 text-right text-slate-400">{TokenRegistryService.formatTokens(f.tokens || 0)}</td>
                                                        <td className="py-1 px-2 text-right"><span className={pctOfTotal > 50 ? 'text-amber-400' : pctOfTotal > 25 ? 'text-slate-300' : 'text-slate-500'}>{pctOfTotal}%</span></td>
                                                    </tr>);
                                                })}</tbody>
                                                <tfoot><tr className="border-t border-slate-600 font-medium">
                                                    <td className="py-1.5 px-2 text-slate-300">Total</td>
                                                    <td className="py-1.5 px-2 text-right text-slate-400">{(result.totalSize / 1024).toFixed(0)}KB</td>
                                                    <td className="py-1.5 px-2 text-right text-slate-300">{TokenRegistryService.formatTokens(result.totalTokens)}</td>
                                                    <td className="py-1.5 px-2 text-right text-slate-500">100%</td>
                                                </tr></tfoot>
                                            </table>
                                        </div>
                                    </details>
                                )}
                                
                                <button onClick={download} className="w-full py-3 bg-purple-600 hover:bg-purple-500 rounded-lg font-medium flex items-center justify-center gap-2 transition-colors">
                                    \u2b07\ufe0f Download {result.filename}
                                </button>
                                
                                {result.missingDocs.length > 0 && (
                                    <div className="text-xs text-amber-400/80 bg-amber-900/20 rounded-lg p-3">
                                        <strong>Skeleton docs generated:</strong> {result.missingDocs.join(', ')}. 
                                        These are templates \u2014 flesh them out during your first session with this app, 
                                        then commit the docs to the repo so future preps pull the real versions.
                                    </div>
                                )}
                                
                                {!uploadMode && uploadFiles.length === 0 && (
                                    <button onClick={() => setUploadMode(true)}
                                        className="w-full py-2 rounded-lg text-sm flex items-center justify-center gap-2 transition-colors bg-slate-700 hover:bg-slate-600 text-slate-300">
                                        \ud83d\udcc4 Push Docs to Repo
                                    </button>
                                )}
                            </div>
                        )}
                        
                        {(uploadMode || uploadFiles.length > 0) && (
                            <div className="space-y-3 mt-3">
                                {uploadFiles.length === 0 && (
                                    <div>
                                        <div onDrop={handleDocDrop} onDragOver={e => { e.preventDefault(); e.stopPropagation(); }}
                                            onClick={() => { const input = document.createElement('input'); input.type = 'file'; input.multiple = true; input.accept = '.md,.txt,.zip'; input.onchange = handleDocDrop; input.click(); }}
                                            className="border-2 border-dashed border-slate-600 hover:border-indigo-500 rounded-lg p-4 text-center cursor-pointer transition-colors">
                                            <div className="text-slate-400 text-sm">\ud83d\udcc4 Drop doc files or a project zip here</div>
                                            <div className="text-xs text-slate-500 mt-1">Accepts .md, .txt files or .zip packages</div>
                                        </div>
                                        <button onClick={() => setUploadMode(false)} className="w-full mt-2 py-1.5 text-xs text-slate-500 hover:text-slate-300">Cancel</button>
                                    </div>
                                )}
                                {uploadFiles.length > 0 && (
                                    <div className="space-y-2">
                                        <div className="flex items-center justify-between">
                                            <div className="text-xs text-slate-400 font-medium">Files to push:</div>
                                            <button onClick={() => { setUploadFiles([]); setUploadLog([]); }} className="text-xs text-slate-500 hover:text-red-400">\u2715 Clear</button>
                                        </div>
                                        {uploadFiles.map((f, i) => (
                                            <div key={i} className="flex items-center justify-between bg-slate-900 rounded px-3 py-2 text-sm">
                                                <div className="flex items-center gap-2">
                                                    <span>{f.existing ? '\ud83d\udd04' : '\ud83c\udd95'}</span>
                                                    <span className="font-mono text-slate-300">{f.name}</span>
                                                    <span className="text-xs text-slate-500">({(f.size / 1024).toFixed(1)}KB)</span>
                                                </div>
                                                <div className="text-xs text-slate-500 font-mono">{f.targetPath}</div>
                                            </div>
                                        ))}
                                        {!uploading && uploadLog.length === 0 && (
                                            <button onClick={pushDocsToRepo} className="w-full py-2.5 rounded-lg font-medium flex items-center justify-center gap-2 transition-colors bg-green-600 hover:bg-green-500 text-white">
                                                \ud83d\ude80 Push {uploadFiles.length} file{uploadFiles.length > 1 ? 's' : ''} to {app.repos?.prod?.split('/').pop() || 'repo'}
                                            </button>
                                        )}
                                        {uploading && (
                                            <div className="w-full py-2.5 rounded-lg font-medium flex items-center justify-center gap-2 bg-slate-700 text-amber-400 animate-pulse">\u23f3 Pushing files to repo...</div>
                                        )}
                                    </div>
                                )}
                                {uploadLog.length > 0 && (
                                    <div className="space-y-2">
                                        <div className="bg-slate-900 rounded-lg p-3 space-y-1 font-mono text-xs max-h-40 overflow-y-auto">
                                            {uploadLog.map((entry, i) => (<div key={i} className={logColors[entry.type] || 'text-slate-400'}>{entry.msg}</div>))}
                                        </div>
                                        {!uploading && uploadLog.some(e => e.type === 'success' && e.msg.includes('Done')) && (
                                            <div className="bg-green-900/30 border border-green-700 rounded-lg p-3 text-center">
                                                <div className="text-green-400 font-medium">\u2705 All docs pushed to repo</div>
                                                <div className="text-xs text-green-500 mt-1">Next Claude Prep will pull these docs automatically</div>
                                            </div>
                                        )}
                                        {!uploading && uploadLog.some(e => e.type === 'error') && !uploadLog.some(e => e.msg.includes('Done')) && (
                                            <div className="bg-red-900/30 border border-red-700 rounded-lg p-3 text-center">
                                                <div className="text-red-400 font-medium">\u26a0\ufe0f Some files failed to push</div>
                                                <button onClick={() => setUploadLog([])} className="text-xs text-slate-400 hover:text-white mt-1">Retry</button>
                                            </div>
                                        )}
                                    </div>
                                )}
                            </div>
                        )}
                        
                        {status === 'error' && (
                            <div className="flex gap-2">
                                <button onClick={() => { setPhase('wizard'); setWizardStep(4); setStatus('idle'); }} className="flex-1 py-2 bg-slate-700 hover:bg-slate-600 rounded-lg text-sm">\u2190 Back</button>
                                <button onClick={startPrep} className="flex-1 py-2 bg-slate-700 hover:bg-slate-600 rounded-lg text-sm">\ud83d\udd04 Retry</button>
                                <button onClick={onClose} className="flex-1 py-2 bg-slate-700 hover:bg-slate-600 rounded-lg text-sm">Close</button>
                            </div>
                        )}
                    </div>
                    
                    </React.Fragment>
                    )}
                </div>
            </div>
        );
    }

    // =========================================================================
    // SETUP NEW APP VIEW (v8.7.7)
    // =========================================================================
    function SetupNewAppView({ apps, github, config, updateConfig, showAlert, showConfirm, onRefreshRepos, githubOwner, firebaseUid }) {
        const [step, setStep] = React.useState(1);
        const [appData, setAppData] = React.useState({
            name: '',
            id: '',
            description: '',
            structure: 'prod-only',  // 'prod-only' or 'test-prod'
            isPWA: false,
            appType: 'other',  // 'public', 'internal', 'other'
            project: '',  // v8.8.0: Project grouping
            icon: '📦',
            hasAdmin: false,
            adminSubPath: 'admin',
            customDomain: ''
        });
        const [scopeData, setScopeData] = React.useState(null); // v8.23.0: Project scope
        const [skipScope, setSkipScope] = React.useState(false); // v8.23.0: Quick setup option
        const [showScopeInline, setShowScopeInline] = React.useState(false); // v8.23.0: Inline scope modal
        const [repoStatus, setRepoStatus] = React.useState({ checking: false, prodExists: null, testExists: null });
        const [creating, setCreating] = React.useState(false);
        const [creationLog, setCreationLog] = React.useState([]);
        const [promptGenerated, setPromptGenerated] = React.useState('');
        const [workItemsCreated, setWorkItemsCreated] = React.useState([]); // v8.28.0: Track created work items
        const [reviewData, setReviewData] = React.useState(null); // v8.28.0: Review summary for Step 5
        const [activeDocTab, setActiveDocTab] = React.useState('instructions'); // v8.29.0: Doc viewer tab

        const addLog = (msg, type = 'info') => setCreationLog(prev => [...prev, { msg, type, time: new Date().toLocaleTimeString() }]);

        // Auto-generate ID from name
        const handleNameChange = (name) => {
            const id = name.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/-+$/, '');
            setAppData(prev => ({ ...prev, name, id }));
        };

        // Get repo names
        const prodRepoName = appData.id || 'my-app';
        const testRepoName = `${prodRepoName}-test`;

        // Step 1: Check repos
        const checkRepos = async () => {
            if (!github || !githubOwner) { await showAlert('Configure GitHub token first'); return; }
            setRepoStatus({ checking: true, prodExists: null, testExists: null });
            try {
                const prodExists = await github.repoExists(githubOwner, prodRepoName);
                let testExists = null;
                if (appData.structure === 'test-prod') {
                    testExists = await github.repoExists(githubOwner, testRepoName);
                }
                setRepoStatus({ checking: false, prodExists, testExists });
            } catch (e) {
                setRepoStatus({ checking: false, prodExists: null, testExists: null });
                await showAlert('Error checking repos: ' + e.message);
            }
        };

        // Step 2: Create repos + configure
        const setupApp = async () => {
            if (!github || !githubOwner) return;
            setCreating(true);
            setCreationLog([]);

            try {
                // Create prod repo if needed
                let prodFullName = `${githubOwner}/${prodRepoName}`;
                if (!repoStatus.prodExists) {
                    addLog(`Creating repository: ${prodRepoName}...`);
                    const result = await github.createRepo(prodRepoName, appData.description, false);
                    prodFullName = result.fullName;
                    addLog(`✅ Repository created: ${prodFullName}`, 'success');

                    await new Promise(r => setTimeout(r, 2000));
                    addLog('Enabling GitHub Pages...');
                    try { await github.enablePages(prodFullName); addLog('✅ GitHub Pages enabled', 'success'); }
                    catch (e) { addLog('⚠️ Pages may need manual enabling', 'warn'); }
                } else {
                    addLog(`✅ Prod repo exists: ${prodFullName}`, 'success');
                }

                // Create test repo if needed
                let testFullName = '';
                if (appData.structure === 'test-prod') {
                    testFullName = `${githubOwner}/${testRepoName}`;
                    if (!repoStatus.testExists) {
                        addLog(`Creating test repository: ${testRepoName}...`);
                        const result = await github.createRepo(testRepoName, `${appData.description} (Test)`, false);
                        testFullName = result.fullName;
                        addLog(`✅ Test repository created: ${testFullName}`, 'success');
                        await new Promise(r => setTimeout(r, 2000));
                        try { await github.enablePages(testFullName); addLog('✅ Test Pages enabled', 'success'); }
                        catch (e) { addLog('⚠️ Test Pages may need manual enabling', 'warn'); }
                    } else {
                        addLog(`✅ Test repo exists: ${testFullName}`, 'success');
                    }
                }

                // Seed initial index.html with meta tags for detection
                addLog('Seeding initial files...');
                const initialHTML = generateInitialHTML(appData);
                try {
                    // Check if index.html already exists
                    try {
                        await github.request(`/repos/${prodFullName}/contents/index.html`);
                        addLog('index.html already exists, skipping seed', 'info');
                    } catch {
                        await github.createOrUpdateFile(prodFullName, 'index.html', initialHTML, `Initial setup: ${appData.name}`);
                        addLog('✅ Seeded index.html with app meta tags', 'success');
                    }
                } catch (e) {
                    addLog(`⚠️ Could not seed index.html: ${e.message}`, 'warn');
                }

                // Create admin directory if requested
                if (appData.hasAdmin) {
                    const adminHTML = generateAdminHTML(appData);
                    try {
                        try {
                            await github.request(`/repos/${prodFullName}/contents/${appData.adminSubPath}/index.html`);
                            addLog(`${appData.adminSubPath}/index.html already exists, skipping`, 'info');
                        } catch {
                            await github.createOrUpdateFile(prodFullName, `${appData.adminSubPath}/index.html`, adminHTML, `Initial setup: ${appData.name} Admin`);
                            addLog(`✅ Seeded ${appData.adminSubPath}/index.html`, 'success');
                        }
                    } catch (e) {
                        addLog(`⚠️ Could not seed admin: ${e.message}`, 'warn');
                    }
                }

                // Add app to Command Center config
                addLog('Adding to Command Center configuration...');
                const newAppDef = {
                    id: appData.id,
                    name: appData.name,
                    icon: appData.icon,
                    appType: appData.appType,
                    project: appData.project || appData.id,  // v8.8.0: Use selected project or create new one from app id
                    targetPath: 'index.html',
                    swPath: appData.isPWA ? 'sw.js' : '',
                    hasServiceWorker: appData.isPWA,
                    subPath: '',
                    repos: appData.structure === 'test-prod'
                        ? { test: testFullName, prod: prodFullName }
                        : { prod: prodFullName },
                    versions: appData.structure === 'test-prod'
                        ? { test: '', prod: '' }
                        : { prod: '' },
                    repoPatterns: appData.structure === 'test-prod'
                        ? { test: [testRepoName], prod: [prodRepoName] }
                        : { prod: [prodRepoName] },
                    detectionPatterns: [`gs-app-id.*${appData.id}`, `<title>.*${appData.name}`]
                };

                // Also add admin as a separate app entry if requested
                const newConfig = { ...config, apps: { ...config.apps } };
                newConfig.apps[appData.id] = {
                    ...newAppDef,
                    repos: { ...newAppDef.repos }
                };

                if (appData.hasAdmin) {
                    newConfig.apps[`${appData.id}-admin`] = {
                        id: `${appData.id}-admin`,
                        name: `${appData.name} Admin`,
                        icon: appData.icon + '🔧',
                        appType: appData.appType === 'public' ? 'internal' : appData.appType,
                        project: appData.project || appData.id,
                        targetPath: 'index.html',
                        swPath: '',
                        hasServiceWorker: false,
                        subPath: appData.adminSubPath,
                        repos: { prod: prodFullName },
                        versions: { prod: '' },
                        repoPatterns: { prod: [prodRepoName] },
                        detectionPatterns: [`gs-app-id.*${appData.id}-admin`]
                    };
                }

                updateConfig(newConfig);
                addLog('✅ App added to Command Center', 'success');

                // v8.28.0: Store lifecycle metadata with scope if available
                if (scopeData) {
                    const lifecycleData = {
                        currentMaturity: 'seed',
                        complexity: scopeData.v1Features?.length > 5 ? 'medium' : 'simple',
                        scope: {
                            description: scopeData.description || '',
                            category: scopeData.category || '',
                            categoryAnswers: scopeData.categoryAnswers || {},
                            v1Features: scopeData.v1Features || [],
                            futureFeatures: scopeData.futureFeatures || [],
                            keyDecisions: scopeData.keyDecisions || [],
                            startingStandards: scopeData.startingStandards || [],
                            scopedAt: new Date().toISOString(),
                            source: 'manual'
                        }
                    };
                    // Update the config with lifecycle data on the app
                    const configWithLifecycle = { ...newConfig, apps: { ...newConfig.apps } };
                    configWithLifecycle.apps[appData.id] = {
                        ...configWithLifecycle.apps[appData.id],
                        lifecycle: lifecycleData
                    };
                    updateConfig(configWithLifecycle);
                    addLog('📋 Lifecycle metadata stored with project scope', 'success');
                }

                // v8.28.0: Auto-create work items from scope
                let createdItems = [];
                const ownerName = config?.ownerName || 'Owner';
                if (scopeData && firebaseUid) {
                    const itemsToCreate = [];
                    let nextNum = 1;
                    const padId = (n) => `WI-${String(n).padStart(3, '0')}`;

                    // V1 features → work items (status: ready, source: scoped)
                    (scopeData.v1Features || []).forEach(f => {
                        itemsToCreate.push({
                            id: padId(nextNum++),
                            appId: appData.id,
                            title: f.title,
                            description: f.description || '',
                            type: 'feature',
                            priority: f.priority || 'core',
                            status: 'ready',
                            effort: f.effort || 'session',
                            source: 'scoped',
                            createdBy: ownerName,
                            tags: ['v1', scopeData.category || '']
                        });
                    });

                    // Future features → work items (status: idea, source: scoped)
                    (scopeData.futureFeatures || []).forEach(f => {
                        itemsToCreate.push({
                            id: padId(nextNum++),
                            appId: appData.id,
                            title: f.title,
                            description: f.description || '',
                            type: 'feature',
                            priority: 'nice-to-have',
                            status: 'idea',
                            effort: f.effort || 'session',
                            source: 'scoped',
                            createdBy: ownerName,
                            tags: ['future']
                        });
                    });

                    // Key decisions → work items (type: research, status: ready, source: scoped)
                    (scopeData.keyDecisions || []).filter(d => !d.resolved).forEach(d => {
                        itemsToCreate.push({
                            id: padId(nextNum++),
                            appId: appData.id,
                            title: d.title,
                            description: d.description || '',
                            type: 'research',
                            priority: 'core',
                            status: 'ready',
                            effort: 'quick',
                            source: 'scoped',
                            createdBy: ownerName,
                            tags: ['decision']
                        });
                    });

                    if (itemsToCreate.length > 0) {
                        try {
                            addLog(`Creating ${itemsToCreate.length} work items from scope...`);
                            createdItems = await WorkItemService.createBatch(firebaseUid, itemsToCreate);
                            addLog(`✅ ${createdItems.length} work items created in backlog`, 'success');
                        } catch (e) {
                            addLog(`⚠️ Could not create work items: ${e.message}`, 'warn');
                        }
                    }
                } else if (scopeData && !firebaseUid) {
                    addLog('⚠️ Sign in to Firebase to auto-create work items from scope', 'warn');
                }
                setWorkItemsCreated(createdItems);

                if (onRefreshRepos) {
                    addLog('Refreshing repo list...');
                    await onRefreshRepos();
                    addLog('✅ Repos refreshed', 'success');
                }

                // Generate Claude prompt (use CLAUDE_INSTRUCTIONS.md if scope available)
                let generatedPromptType = 'basic';
                let generatedInstructions = null;
                let generatedContextMd = null;
                let generatedProjectPlanMd = null;
                let generatedChangelogMd = null;
                let generatedReleaseNotes = null;
                
                if (scopeData) {
                    const instructions = generateClaudeInstructions(appData, scopeData, config);
                    if (instructions) {
                        generatedInstructions = instructions;
                        setPromptGenerated(instructions);
                        generatedPromptType = 'instructions';
                        addLog('🎯 Generated CLAUDE_INSTRUCTIONS.md from project scope', 'success');
                    } else {
                        const prompt = generateClaudePrompt(appData, prodFullName, testFullName);
                        setPromptGenerated(prompt);
                        addLog('✅ Claude project prompt generated', 'success');
                    }
                    
                    // v8.29.0: Generate CONTEXT.md and PROJECT_PLAN.md
                    generatedContextMd = generateContextMd(appData, scopeData, config);
                    generatedProjectPlanMd = generateProjectPlanMd(appData, scopeData);
                    addLog('📄 Generated CONTEXT.md and PROJECT_PLAN.md from scope', 'success');
                    
                    // Generate initial CHANGELOG.md and RELEASE_NOTES.txt
                    const today = new Date().toLocaleDateString();
                    generatedChangelogMd = `# ${appData.name} — Changelog\n\nAll notable changes to this project will be documented in this file.\n\n## [0.1.0] - ${today}\n\n### Added\n- Initial seed generated by Command Center\n- App shell with placeholder content\n`;
                    generatedReleaseNotes = `${appData.name} — Release Notes\n${'='.repeat(40)}\n\nv0.1.0 (${today})\n${'─'.repeat(30)}\n- Initial seed generated by Command Center\n- App shell with placeholder content\n`;
                    addLog('📝 Generated CHANGELOG.md and RELEASE_NOTES.txt', 'success');
                    
                } else {
                    const prompt = generateClaudePrompt(appData, prodFullName, testFullName);
                    setPromptGenerated(prompt);
                    addLog('✅ Claude project prompt generated', 'success');
                }
                
                // v8.29.0: Commit generated docs to repo
                let docsCommitted = 0;
                if (scopeData && github) {
                    addLog('📂 Committing generated docs to repository...');
                    const docsToCommit = [];
                    
                    // Determine doc path based on subPath (consolidated vs standalone repo)
                    const docPrefix = appData.subPath ? `${appData.subPath}/docs/` : '';
                    
                    if (generatedPromptType === 'instructions' && generatedInstructions) {
                        docsToCommit.push({ path: `${docPrefix}CLAUDE_INSTRUCTIONS.md`, content: generatedInstructions });
                    }
                    if (generatedContextMd) docsToCommit.push({ path: `${docPrefix}CONTEXT.md`, content: generatedContextMd });
                    if (generatedProjectPlanMd) docsToCommit.push({ path: `${docPrefix}PROJECT_PLAN.md`, content: generatedProjectPlanMd });
                    if (generatedChangelogMd) docsToCommit.push({ path: `${docPrefix}CHANGELOG.md`, content: generatedChangelogMd });
                    if (generatedReleaseNotes) docsToCommit.push({ path: `${docPrefix}RELEASE_NOTES.txt`, content: generatedReleaseNotes });
                    
                    for (const doc of docsToCommit) {
                        try {
                            // Check if file already exists
                            try {
                                await github.request(`/repos/${prodFullName}/contents/${doc.path}`);
                                addLog(`  ⏭️ ${doc.path} already exists, skipping`, 'info');
                            } catch {
                                await github.createOrUpdateFile(prodFullName, doc.path, doc.content, `Add ${doc.path.split('/').pop()} — generated by Command Center setup`);
                                docsCommitted++;
                                addLog(`  ✅ ${doc.path}`, 'success');
                            }
                        } catch (e) {
                            addLog(`  ⚠️ Could not commit ${doc.path}: ${e.message}`, 'warn');
                        }
                    }
                    
                    if (docsCommitted > 0) {
                        addLog(`📂 ${docsCommitted} docs committed to ${prodFullName}`, 'success');
                    }
                }
                
                // v8.29.0: Auto-deploy seed to test environment
                let seedDeployedToTest = false;
                if (appData.structure === 'test-prod' && testFullName && github) {
                    addLog('🚀 Auto-deploying seed to test environment...');
                    try {
                        // Check if test already has index.html
                        try {
                            await github.request(`/repos/${testFullName}/contents/${appData.subPath ? appData.subPath + '/' : ''}index.html`);
                            addLog('  ⏭️ Test already has index.html, skipping seed deploy', 'info');
                        } catch {
                            const testPath = appData.subPath ? `${appData.subPath}/index.html` : 'index.html';
                            const initialHTML = generateInitialHTML(appData);
                            await github.createOrUpdateFile(testFullName, testPath, initialHTML, `Seed deploy: ${appData.name} v0.1.0`);
                            seedDeployedToTest = true;
                            addLog('✅ Seed deployed to test environment', 'success');
                        }
                    } catch (e) {
                        addLog(`⚠️ Could not deploy seed to test: ${e.message}`, 'warn');
                    }
                }

                // v8.29.0: Build review summary (enhanced with doc generation info)
                setReviewData({
                    appName: appData.name,
                    appId: appData.id,
                    repos: {
                        prod: prodFullName,
                        test: appData.structure === 'test-prod' ? testFullName : null
                    },
                    hasScope: !!scopeData,
                    category: scopeData?.category ? (SCOPE_CATEGORIES[scopeData.category]?.icon + ' ' + SCOPE_CATEGORIES[scopeData.category]?.label) : null,
                    v1FeatureCount: scopeData?.v1Features?.length || 0,
                    futureFeatureCount: scopeData?.futureFeatures?.length || 0,
                    standardsCount: scopeData?.startingStandards?.length || 0,
                    workItemsCreated: createdItems.length,
                    promptType: generatedPromptType,
                    hasAdmin: appData.hasAdmin,
                    isPWA: appData.isPWA,
                    lifecycleStored: !!scopeData,
                    docsCommitted,
                    docsGenerated: scopeData ? ['CLAUDE_INSTRUCTIONS.md', 'CONTEXT.md', 'PROJECT_PLAN.md', 'CHANGELOG.md', 'RELEASE_NOTES.txt'] : [],
                    seedDeployedToTest,
                    generatedContextMd,
                    generatedProjectPlanMd,
                    generatedChangelogMd,
                    generatedReleaseNotes
                });

                addLog('🎉 Setup complete!', 'success');

            } catch (e) {
                addLog(`❌ Error: ${e.message}`, 'error');
            } finally {
                setCreating(false);
            }
        };

        // Generate initial HTML with proper meta tags
        const SEED_VERSION = '0.1.0';  // Initial version for new apps — extracted as constant to avoid version scanner false positives
        function generateInitialHTML(app) {
            const pwaHead = app.isPWA ? `\n    <link rel="manifest" href="manifest.json">\n    <meta name="theme-color" content="#0f172a">\n    <link rel="apple-touch-icon" href="icons/icon-192.png">` : '';
            const pwaScript = app.isPWA ? `\n    <scr` + `ipt>\n    if ('serviceWorker' in navigator) {\n        navigator.serviceWorker.register('sw.js').catch(e => console.error('SW:', e));\n    }\n    </scr` + `ipt>` : '';

            return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${app.name}</title>
    <meta name="version" content="${SEED_VERSION}">
    <meta name="gs-app-id" content="${app.id}">
    <meta name="description" content="${app.description}">${pwaHead}
    <style>
        body { margin:0; font-family:system-ui,-apple-system,sans-serif; background:#0f172a; color:#e2e8f0; display:flex; align-items:center; justify-content:center; min-height:100vh; }
        .container { text-align:center; max-width:500px; padding:40px; }
        h1 { font-size:2rem; margin-bottom:8px; }
        p { color:#94a3b8; }
    </style>
</head>
<body>
    <div class="container">
        <h1>${app.icon} ${app.name}</h1>
        <p>${app.description || 'Coming soon'}</p>
        <p style="font-size:0.8rem;color:#475569;margin-top:24px;">v${SEED_VERSION} · Part of the Game Shelf ecosystem</p>
    </div>${pwaScript}
</body>
</html>`;
        }

        function generateAdminHTML(app) {
            return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${app.name} — Admin</title>
    <meta name="version" content="${SEED_VERSION}">
    <meta name="gs-app-id" content="${app.id}-admin">
    <style>
        body { margin:0; font-family:system-ui,-apple-system,sans-serif; background:#0f172a; color:#e2e8f0; display:flex; align-items:center; justify-content:center; min-height:100vh; }
        .container { text-align:center; max-width:500px; padding:40px; }
    </style>
</head>
<body>
    <div class="container">
        <h1>🔧 ${app.name} Admin</h1>
        <p style="color:#94a3b8;">Admin panel placeholder — replace with your admin tool</p>
        <p style="font-size:0.8rem;color:#475569;margin-top:24px;">v${SEED_VERSION}</p>
    </div>
</body>
</html>`;
        }

        // Generate the Claude project prompt
        function generateClaudePrompt(app, prodRepo, testRepo) {
            const isPWA = app.isPWA;
            const hasTest = app.structure === 'test-prod';
            const hasAdmin = app.hasAdmin;

            const deployFilesList = isPWA
                ? `- index.html (main app — single file, all CSS/JS inline)
- sw.js (service worker for offline support)
- manifest.json (PWA manifest with app name, icons, theme)
- icons/ folder (icon-192.png, icon-512.png, icon-maskable-192.png, icon-maskable-512.png, apple-touch-icon.png)
- RELEASE_NOTES.txt (optional changelog)`
                : `- index.html (main app — single file, all CSS/JS inline)
- RELEASE_NOTES.txt (optional changelog)`;

            const adminSection = hasAdmin ? `
## Admin Tool (${app.adminSubPath}/)
- Located at ${app.adminSubPath}/index.html in the same repo
- Has its own gs-app-id: "${app.id}-admin"
- Has its own version meta tag
- Deployed separately via Command Center
` : '';

            const testSection = hasTest ? `
## Test → Prod Workflow
- Test repo: ${testRepo} (deployed at https://${githubOwner}.github.io/${testRepoName}/)
- Prod repo: ${prodRepo} (deployed at https://${githubOwner}.github.io/${prodRepoName}/)
- Always deploy to test first, verify, then promote to prod via Command Center
` : `
## Deployment
- Single prod repo: ${prodRepo}
- Deployed at: https://${githubOwner}.github.io/${prodRepoName}/
${app.customDomain ? `- Custom domain: ${app.customDomain}` : ''}
`;

            return `# ${app.name} — Project Brief

## Overview
${app.description || app.name + ' is a web application.'}

## Technical Requirements

### App Identity (Required for Command Center)
Every HTML file must include these meta tags in <head>:
\`\`\`html
<meta name="version" content="X.Y.Z">
<meta name="gs-app-id" content="${app.id}">
\`\`\`
Version must follow semver (e.g., 1.0.0). Bump on every deploy.

### Architecture
- **Single-file HTML app**: All CSS and JS must be inline in index.html (no external files except CDN libraries)
- **Dark mode by default**: Background #0f172a or similar dark theme
- **Mobile-first responsive design**
${isPWA ? '- **Progressive Web App**: Must include service worker, manifest.json, and app icons' : '- **Standard web app**: No service worker needed'}
- **Firebase integration**: Uses the shared Game Shelf Firebase project (word-boxing-default-rtdb)

### Firebase Config
\`\`\`javascript
const firebaseConfig = {
    apiKey: "AIzaSyBQVwn8vOrFTzLlm2MYIPBwgZV2xR9AuhM",
    authDomain: "word-boxing.firebaseapp.com",
    databaseURL: "https://word-boxing-default-rtdb.firebaseio.com",
    projectId: "word-boxing"
};
\`\`\`
${testSection}
### Deploy Package Structure
The Command Center deploys these files to GitHub Pages:
${deployFilesList}
${adminSection}
### Version Management
- Use \`<meta name="version" content="X.Y.Z">\` in the HTML head
- Command Center reads this to track deployed versions
- Bump the patch version for bug fixes, minor for features, major for breaking changes

## Project Plan

### Phase 1: Foundation
- [ ] Basic UI with app branding and layout
- [ ] Firebase integration (auth if needed, database read/write)
- [ ] Core feature implementation
- [ ] Mobile responsive design

### Phase 2: Polish
- [ ] Error handling and edge cases
- [ ] Loading states and transitions
- [ ] Accessibility basics (semantic HTML, keyboard nav)
${isPWA ? '- [ ] Service worker for offline support\n- [ ] PWA manifest and icons' : ''}

### Phase 3: Launch
- [ ] Test deployment via Command Center
- [ ] Version tracking verified
- [ ] Performance optimization
${hasAdmin ? '- [ ] Admin tool deployment' : ''}

## Current Status
- Version: 0.1.0 (placeholder)
- Status: Initial setup complete
- Repo: ${prodRepo}
${hasTest ? `- Test repo: ${testRepo}` : ''}

## Session Continuity
When starting a new session, provide this document plus any updates to the project plan.
The developer uses Claude for iterative development — each session should:
1. Review this brief and any RELEASE_NOTES.txt
2. Understand what was built previously
3. Continue from where the last session left off
4. Produce deploy-ready files (single HTML with inline CSS/JS)
5. Include updated version meta tags
`;
        }

        // =================== RENDER ===================
        return (
            <div className="max-w-3xl mx-auto">
                <div className="flex items-center gap-3 mb-6">
                    <span className="text-3xl">🆕</span>
                    <div>
                        <h1 className="text-2xl font-bold">Setup New App</h1>
                        <p className="text-slate-400 text-sm">Create repos, configure Command Center, and generate a Claude project brief</p>
                    </div>
                </div>

                {/* Progress */}
                <div className="flex items-center gap-2 mb-8">
                    {[
                        { n: 1, label: 'Define' },
                        { n: 2, label: 'Scope' },
                        { n: 3, label: 'Check Repos' },
                        { n: 4, label: 'Create & Configure' },
                        { n: 5, label: 'Review & Launch' }
                    ].map(s => (
                        <React.Fragment key={s.n}>
                            <div className={`flex items-center gap-2 px-3 py-1.5 rounded-lg text-sm font-medium ${
                                step === s.n ? 'bg-indigo-600 text-white' : step > s.n ? 'bg-green-600/20 text-green-400' : 'bg-slate-800 text-slate-500'
                            }`}>
                                {step > s.n ? '✓' : s.n} {s.label}
                            </div>
                            {s.n < 5 && <div className={`flex-1 h-px ${step > s.n ? 'bg-green-600' : 'bg-slate-700'}`} />}
                        </React.Fragment>
                    ))}
                </div>

                {/* Step 1: Define App */}
                {step === 1 && (
                    <div className="bg-slate-800 rounded-xl p-6 border border-slate-700">
                        <h2 className="text-lg font-semibold mb-4">📝 Define Your App</h2>
                        <div className="space-y-4">
                            <div>
                                <label className="block text-sm text-slate-400 mb-1">App Name <span className="text-red-400">*</span></label>
                                <input value={appData.name} onChange={e => handleNameChange(e.target.value)}
                                    className="w-full px-3 py-2 bg-slate-900 border border-slate-600 rounded-lg text-white focus:border-indigo-500 focus:outline-none"
                                    placeholder="My Awesome App" />
                            </div>
                            <div className="grid grid-cols-2 gap-4">
                                <div>
                                    <label className="block text-sm text-slate-400 mb-1">App ID (auto-generated)</label>
                                    <input value={appData.id} onChange={e => setAppData(prev => ({ ...prev, id: e.target.value }))}
                                        className="w-full px-3 py-2 bg-slate-900 border border-slate-600 rounded-lg text-white font-mono text-sm focus:border-indigo-500 focus:outline-none" />
                                </div>
                                <div>
                                    <label className="block text-sm text-slate-400 mb-1">Icon (emoji)</label>
                                    <input value={appData.icon} onChange={e => setAppData(prev => ({ ...prev, icon: e.target.value }))}
                                        className="w-full px-3 py-2 bg-slate-900 border border-slate-600 rounded-lg text-white text-center text-2xl focus:border-indigo-500 focus:outline-none" />
                                </div>
                            </div>
                            <div>
                                <label className="block text-sm text-slate-400 mb-1">Description</label>
                                <textarea value={appData.description} onChange={e => setAppData(prev => ({ ...prev, description: e.target.value }))}
                                    className="w-full px-3 py-2 bg-slate-900 border border-slate-600 rounded-lg text-white focus:border-indigo-500 focus:outline-none resize-none"
                                    rows={2} placeholder="Brief description of what this app does" />
                            </div>
                            <div className="grid grid-cols-2 gap-4">
                                <div>
                                    <label className="block text-sm text-slate-400 mb-2">Deploy Structure</label>
                                    <div className="space-y-2">
                                        {[['prod-only', '🚀 Prod Only', 'Single repo, deploy directly'],
                                          ['test-prod', '🧪→🚀 Test → Prod', 'Two repos, promote test to prod']
                                        ].map(([val, label, desc]) => (
                                            <label key={val} className={`flex items-start gap-3 p-3 rounded-lg border cursor-pointer ${
                                                appData.structure === val ? 'border-indigo-500 bg-indigo-500/10' : 'border-slate-600 hover:border-slate-500'
                                            }`}>
                                                <input type="radio" name="structure" value={val} checked={appData.structure === val}
                                                    onChange={e => setAppData(prev => ({ ...prev, structure: e.target.value }))} className="mt-1" />
                                                <div><div className="text-sm font-medium">{label}</div><div className="text-xs text-slate-500">{desc}</div></div>
                                            </label>
                                        ))}
                                    </div>
                                </div>
                                <div>
                                    <label className="block text-sm text-slate-400 mb-2">App Category</label>
                                    <select value={appData.appType} onChange={e => setAppData(prev => ({ ...prev, appType: e.target.value }))}
                                        className="w-full px-3 py-2 bg-slate-900 border border-slate-600 rounded-lg text-white focus:border-indigo-500 focus:outline-none mb-3">
                                        <option value="public">Public App</option>
                                        <option value="internal">Internal Tool</option>
                                        <option value="other">Other Project</option>
                                    </select>
                                    <label className="block text-sm text-slate-400 mb-2">Project</label>
                                    <select value={appData.project} onChange={e => setAppData(prev => ({ ...prev, project: e.target.value }))}
                                        className="w-full px-3 py-2 bg-slate-900 border border-slate-600 rounded-lg text-white focus:border-indigo-500 focus:outline-none mb-3">
                                        <option value="">— Select a project —</option>
                                        {Object.values(config.projects || SEED_PROJECTS).filter(p => p.id !== 'other').sort((a, b) => (a.order || 99) - (b.order || 99)).map(p => (
                                            <option key={p.id} value={p.id}>{p.icon === 'gs-logo' ? '🎮' : p.icon} {p.name}</option>
                                        ))}
                                        <option value="other">Other</option>
                                    </select>
                                    <label className="flex items-center gap-3 p-3 rounded-lg border border-slate-600 cursor-pointer hover:border-slate-500">
                                        <input type="checkbox" checked={appData.isPWA} onChange={e => setAppData(prev => ({ ...prev, isPWA: e.target.checked }))} />
                                        <div><div className="text-sm font-medium">📱 Progressive Web App</div><div className="text-xs text-slate-500">SW, manifest, icons</div></div>
                                    </label>
                                </div>
                            </div>
                            <div className="grid grid-cols-2 gap-4">
                                <label className="flex items-center gap-3 p-3 rounded-lg border border-slate-600 cursor-pointer hover:border-slate-500">
                                    <input type="checkbox" checked={appData.hasAdmin} onChange={e => setAppData(prev => ({ ...prev, hasAdmin: e.target.checked }))} />
                                    <div><div className="text-sm font-medium">🔧 Admin Panel</div><div className="text-xs text-slate-500">Separate page in subdirectory</div></div>
                                </label>
                                {appData.hasAdmin && (
                                    <div>
                                        <label className="block text-sm text-slate-400 mb-1">Admin Path</label>
                                        <input value={appData.adminSubPath} onChange={e => setAppData(prev => ({ ...prev, adminSubPath: e.target.value }))}
                                            className="w-full px-3 py-2 bg-slate-900 border border-slate-600 rounded-lg text-white font-mono text-sm focus:border-indigo-500 focus:outline-none"
                                            placeholder="admin" />
                                    </div>
                                )}
                            </div>
                            <div>
                                <label className="block text-sm text-slate-400 mb-1">Custom Domain (optional)</label>
                                <input value={appData.customDomain} onChange={e => setAppData(prev => ({ ...prev, customDomain: e.target.value }))}
                                    className="w-full px-3 py-2 bg-slate-900 border border-slate-600 rounded-lg text-white focus:border-indigo-500 focus:outline-none"
                                    placeholder="myapp.com" />
                            </div>
                        </div>

                        {/* Preview */}
                        {appData.name && (
                            <div className="mt-6 p-4 bg-slate-900 rounded-lg border border-slate-700">
                                <div className="text-xs text-slate-500 uppercase tracking-wide mb-2">Preview</div>
                                <div className="flex items-center gap-2 mb-2">
                                    <span className="text-xl">{appData.icon}</span>
                                    <span className="font-semibold">{appData.name}</span>
                                    <span className="text-xs px-2 py-0.5 bg-slate-700 rounded">{appData.appType}</span>
                                    {appData.isPWA && <span className="text-xs px-2 py-0.5 bg-purple-600/30 text-purple-300 rounded">PWA</span>}
                                </div>
                                <div className="text-sm text-slate-400 space-y-1">
                                    <div>Prod repo: <code className="text-indigo-400">{githubOwner}/{prodRepoName}</code></div>
                                    {appData.structure === 'test-prod' && <div>Test repo: <code className="text-yellow-400">{githubOwner}/{testRepoName}</code></div>}
                                    {appData.hasAdmin && <div>Admin path: <code className="text-green-400">/{appData.adminSubPath}/index.html</code></div>}
                                    {appData.customDomain && <div>Domain: <code className="text-cyan-400">{appData.customDomain}</code></div>}
                                    <div>gs-app-id: <code className="text-slate-300">{appData.id}</code></div>
                                </div>
                            </div>
                        )}

                        <div className="mt-6 flex justify-end">
                            <button onClick={() => { if (!appData.name) return; setStep(2); }}
                                disabled={!appData.name}
                                className="px-6 py-2 bg-indigo-600 hover:bg-indigo-500 disabled:bg-slate-700 disabled:text-slate-500 rounded-lg font-medium transition-colors">
                                Next: Scope →
                            </button>
                        </div>
                    </div>
                )}

                {/* Step 2: Scope (v8.23.0) */}
                {step === 2 && (
                    <div className="bg-slate-800 rounded-xl p-6 border border-slate-700">
                        <h2 className="text-lg font-semibold mb-4">🎯 Project Scope</h2>
                        <p className="text-sm text-slate-400 mb-4">
                            Define what this app does and how it should be built. This generates work items and starting standards for Claude.
                        </p>
                        
                        {!skipScope && !scopeData ? (
                            <div className="space-y-4">
                                <button onClick={() => {
                                        // Create a temporary app object for the scope modal
                                        const tempApp = { id: appData.id, name: appData.name, icon: appData.icon, lifecycle: {} };
                                        // Open inline scope flow
                                        setShowScopeInline(true);
                                    }}
                                    className="w-full p-6 bg-indigo-600/10 border-2 border-dashed border-indigo-500/50 rounded-xl hover:bg-indigo-600/20 transition-colors text-center">
                                    <div className="text-3xl mb-2">🎯</div>
                                    <div className="font-medium">Start Scoping Flow</div>
                                    <div className="text-xs text-slate-400 mt-1">Category-driven questions → features → standards (~2 min)</div>
                                </button>
                                <button onClick={() => { setSkipScope(true); }}
                                    className="w-full p-3 text-slate-400 hover:text-white text-sm transition-colors">
                                    Skip scope — I'll add details later
                                </button>
                            </div>
                        ) : scopeData ? (
                            <div className="space-y-3">
                                <div className="bg-green-900/20 border border-green-700/50 rounded-lg p-4">
                                    <div className="flex items-center gap-2 mb-2">
                                        <span className="text-green-400">✅</span>
                                        <span className="font-medium text-green-300">Scope captured</span>
                                    </div>
                                    <div className="text-sm text-slate-300 grid grid-cols-3 gap-3">
                                        <div><span className="text-slate-500">Category:</span> {SCOPE_CATEGORIES[scopeData.category]?.icon} {SCOPE_CATEGORIES[scopeData.category]?.label}</div>
                                        <div><span className="text-slate-500">Features:</span> {scopeData.v1Features?.length || 0} V1</div>
                                        <div><span className="text-slate-500">Standards:</span> {scopeData.startingStandards?.length || 0}</div>
                                    </div>
                                </div>
                                <button onClick={() => { setScopeData(null); setSkipScope(false); }}
                                    className="text-xs text-slate-400 hover:text-white">Edit scope</button>
                            </div>
                        ) : (
                            <div className="bg-slate-700/30 rounded-lg p-4 text-center text-sm text-slate-400">
                                <p>Scope skipped — you can add one later from the Backlog view.</p>
                                <button onClick={() => setSkipScope(false)} className="mt-2 text-xs text-indigo-400 hover:text-indigo-300">
                                    Actually, let me scope this
                                </button>
                            </div>
                        )}
                        
                        <div className="mt-6 flex justify-between">
                            <button onClick={() => setStep(1)} className="px-4 py-2 text-slate-400 hover:text-white transition-colors">← Back</button>
                            <button onClick={() => { setStep(3); checkRepos(); }}
                                disabled={!skipScope && !scopeData}
                                className="px-6 py-2 bg-indigo-600 hover:bg-indigo-500 disabled:bg-slate-700 disabled:text-slate-500 rounded-lg font-medium transition-colors">
                                Next: Check Repos →
                            </button>
                        </div>
                        
                        {/* Inline Scope Modal */}
                        {showScopeInline && (
                            <ProjectScopeModal
                                app={{ id: appData.id, name: appData.name, icon: appData.icon, lifecycle: {} }}
                                apps={apps}
                                onSave={(scope) => { setScopeData(scope); setShowScopeInline(false); }}
                                onCancel={() => setShowScopeInline(false)}
                                showAlert={showAlert}
                                config={config}
                            />
                        )}
                    </div>
                )}

                {/* Step 3: Repo Check */}
                {step === 3 && (
                    <div className="bg-slate-800 rounded-xl p-6 border border-slate-700">
                        <h2 className="text-lg font-semibold mb-4">🔍 Repository Check</h2>
                        {repoStatus.checking ? (
                            <div className="text-center py-8 text-slate-400"><span className="animate-spin inline-block mr-2">⏳</span> Checking repositories...</div>
                        ) : (
                            <div className="space-y-3">
                                <div className={`p-4 rounded-lg border ${repoStatus.prodExists ? 'border-yellow-600 bg-yellow-600/10' : 'border-green-600 bg-green-600/10'}`}>
                                    <div className="flex items-center gap-2">
                                        <span>{repoStatus.prodExists ? '📂' : '✨'}</span>
                                        <span className="font-medium">{githubOwner}/{prodRepoName}</span>
                                        <span className={`text-xs px-2 py-0.5 rounded ${repoStatus.prodExists ? 'bg-yellow-600/30 text-yellow-300' : 'bg-green-600/30 text-green-300'}`}>
                                            {repoStatus.prodExists ? 'Already exists — will assign' : 'Will create'}
                                        </span>
                                    </div>
                                </div>
                                {appData.structure === 'test-prod' && (
                                    <div className={`p-4 rounded-lg border ${repoStatus.testExists ? 'border-yellow-600 bg-yellow-600/10' : 'border-green-600 bg-green-600/10'}`}>
                                        <div className="flex items-center gap-2">
                                            <span>{repoStatus.testExists ? '📂' : '✨'}</span>
                                            <span className="font-medium">{githubOwner}/{testRepoName}</span>
                                            <span className={`text-xs px-2 py-0.5 rounded ${repoStatus.testExists ? 'bg-yellow-600/30 text-yellow-300' : 'bg-green-600/30 text-green-300'}`}>
                                                {repoStatus.testExists ? 'Already exists — will assign' : 'Will create'}
                                            </span>
                                        </div>
                                    </div>
                                )}
                            </div>
                        )}
                        <div className="mt-6 flex justify-between">
                            <button onClick={() => setStep(2)} className="px-4 py-2 text-slate-400 hover:text-white transition-colors">← Back</button>
                            <button onClick={() => setStep(4)} disabled={repoStatus.checking}
                                className="px-6 py-2 bg-indigo-600 hover:bg-indigo-500 disabled:bg-slate-700 rounded-lg font-medium transition-colors">
                                Next: Create & Configure →
                            </button>
                        </div>
                    </div>
                )}

                {/* Step 4: Create & Configure */}
                {step === 4 && (
                    <div className="bg-slate-800 rounded-xl p-6 border border-slate-700">
                        <h2 className="text-lg font-semibold mb-4">⚡ Create & Configure</h2>
                        {creationLog.length === 0 && !creating ? (
                            <div>
                                <p className="text-slate-400 mb-4">Ready to set up <strong className="text-white">{appData.name}</strong>. This will:</p>
                                <ul className="space-y-2 text-sm text-slate-300 mb-6">
                                    {!repoStatus.prodExists && <li>✨ Create <code className="text-indigo-400">{prodRepoName}</code> repository</li>}
                                    {appData.structure === 'test-prod' && !repoStatus.testExists && <li>✨ Create <code className="text-yellow-400">{testRepoName}</code> repository</li>}
                                    <li>📄 Seed index.html with app meta tags (version + gs-app-id)</li>
                                    {appData.hasAdmin && <li>🔧 Seed {appData.adminSubPath}/index.html</li>}
                                    <li>⚙️ Add app to Command Center configuration</li>
                                    <li>🌐 Enable GitHub Pages</li>
                                    <li>🤖 Generate Claude project prompt</li>
                                </ul>
                                <div className="flex justify-between">
                                    <button onClick={() => setStep(2)} className="px-4 py-2 text-slate-400 hover:text-white transition-colors">← Back</button>
                                    <button onClick={setupApp} className="px-6 py-2 bg-green-600 hover:bg-green-500 rounded-lg font-medium transition-colors">
                                        🚀 Set Up Everything
                                    </button>
                                </div>
                            </div>
                        ) : (
                            <div>
                                <div className="bg-slate-900 rounded-lg p-4 max-h-64 overflow-y-auto space-y-1 font-mono text-sm">
                                    {creationLog.map((log, i) => (
                                        <div key={i} className={`${
                                            log.type === 'success' ? 'text-green-400' : log.type === 'error' ? 'text-red-400' : log.type === 'warn' ? 'text-yellow-400' : 'text-slate-400'
                                        }`}>
                                            <span className="text-slate-600 mr-2">{log.time}</span>{log.msg}
                                        </div>
                                    ))}
                                    {creating && <div className="text-slate-500"><span className="animate-spin inline-block">⏳</span> Working...</div>}
                                </div>
                                {!creating && promptGenerated && (
                                    <div className="mt-4 flex justify-end">
                                        <button onClick={() => setStep(5)} className="px-6 py-2 bg-indigo-600 hover:bg-indigo-500 rounded-lg font-medium transition-colors">
                                            View Claude Prompt →
                                        </button>
                                    </div>
                                )}
                            </div>
                        )}
                    </div>
                )}

                {/* Step 5: Review & Launch (v8.29.0 — Phase 3.2 enhanced) */}
                {step === 5 && (
                    <div className="bg-slate-800 rounded-xl p-6 border border-slate-700 space-y-6">
                        <div>
                            <h2 className="text-lg font-semibold mb-1">🚀 Review & Launch</h2>
                            <p className="text-slate-400 text-sm">Everything has been set up. Review what was created and grab your Claude instructions.</p>
                        </div>

                        {/* Setup Summary */}
                        {reviewData && (
                            <div className="grid grid-cols-2 gap-3">
                                <div className="bg-slate-900/60 rounded-lg p-3 border border-slate-700">
                                    <div className="text-xs text-slate-500 uppercase tracking-wide mb-1">App</div>
                                    <div className="font-medium">{appData.icon} {reviewData.appName}</div>
                                    <div className="text-xs text-slate-400 mt-1 font-mono">{reviewData.appId}</div>
                                </div>
                                <div className="bg-slate-900/60 rounded-lg p-3 border border-slate-700">
                                    <div className="text-xs text-slate-500 uppercase tracking-wide mb-1">Repositories</div>
                                    <div className="text-sm font-mono text-slate-300 truncate">{reviewData.repos?.prod}</div>
                                    {reviewData.repos?.test && <div className="text-xs font-mono text-slate-400 mt-1 truncate">{reviewData.repos.test}</div>}
                                </div>
                                {reviewData.hasScope && (
                                    <div className="bg-slate-900/60 rounded-lg p-3 border border-slate-700">
                                        <div className="text-xs text-slate-500 uppercase tracking-wide mb-1">Scope</div>
                                        <div className="text-sm">{reviewData.category || 'Scoped'}</div>
                                        <div className="text-xs text-slate-400 mt-1">
                                            {reviewData.v1FeatureCount} V1 features · {reviewData.standardsCount} standards
                                        </div>
                                    </div>
                                )}
                                <div className="bg-slate-900/60 rounded-lg p-3 border border-slate-700">
                                    <div className="text-xs text-slate-500 uppercase tracking-wide mb-1">Generated Artifacts</div>
                                    <div className="text-sm space-y-0.5">
                                        {reviewData.workItemsCreated > 0 && (
                                            <div className="text-green-400">✅ {reviewData.workItemsCreated} work items</div>
                                        )}
                                        {reviewData.docsGenerated?.length > 0 && (
                                            <div className="text-green-400">✅ {reviewData.docsGenerated.length} docs generated</div>
                                        )}
                                        {reviewData.docsCommitted > 0 && (
                                            <div className="text-green-400">📂 {reviewData.docsCommitted} committed to repo</div>
                                        )}
                                        {reviewData.seedDeployedToTest && (
                                            <div className="text-green-400">🚀 Seed deployed to test</div>
                                        )}
                                        {reviewData.isPWA && <span className="text-xs text-slate-500">PWA</span>}
                                        {reviewData.hasAdmin && <span className="text-xs text-slate-500 ml-1">Admin</span>}
                                    </div>
                                </div>
                            </div>
                        )}

                        {/* Work Items Summary */}
                        {workItemsCreated.length > 0 && (
                            <div className="bg-slate-900/40 rounded-lg p-4 border border-slate-700">
                                <div className="flex items-center justify-between mb-3">
                                    <h3 className="text-sm font-semibold">📋 Work Items Created</h3>
                                    <span className="text-xs text-slate-500">{workItemsCreated.length} items in backlog</span>
                                </div>
                                <div className="space-y-1 max-h-40 overflow-y-auto">
                                    {workItemsCreated.map((wi, i) => (
                                        <div key={i} className="flex items-center gap-2 text-sm py-1">
                                            <span className={`text-xs px-1.5 py-0.5 rounded font-mono ${
                                                wi.status === 'ready' ? 'bg-blue-600/20 text-blue-400' : 'bg-slate-700 text-slate-400'
                                            }`}>{wi.status}</span>
                                            <span className={`text-xs px-1.5 py-0.5 rounded ${
                                                wi.type === 'feature' ? 'bg-purple-600/20 text-purple-400' : 'bg-amber-600/20 text-amber-400'
                                            }`}>{wi.type}</span>
                                            <span className="text-slate-300 truncate">{wi.title}</span>
                                            <span className={`text-xs ml-auto ${
                                                wi.priority === 'core' ? 'text-red-400' : 'text-slate-500'
                                            }`}>{wi.priority}</span>
                                        </div>
                                    ))}
                                </div>
                            </div>
                        )}

                        {/* Generated Docs Viewer (v8.29.0) */}
                        {reviewData?.docsGenerated?.length > 0 && (() => {
                            const docTabs = [
                                { id: 'instructions', label: 'CLAUDE_INSTRUCTIONS', content: promptGenerated },
                                { id: 'context', label: 'CONTEXT.md', content: reviewData.generatedContextMd },
                                { id: 'plan', label: 'PROJECT_PLAN.md', content: reviewData.generatedProjectPlanMd },
                                { id: 'changelog', label: 'CHANGELOG.md', content: reviewData.generatedChangelogMd },
                                { id: 'release', label: 'RELEASE_NOTES.txt', content: reviewData.generatedReleaseNotes }
                            ].filter(t => t.content);
                            const activeContent = docTabs.find(t => t.id === activeDocTab)?.content || docTabs[0]?.content || '';
                            const activeLabel = docTabs.find(t => t.id === activeDocTab)?.label || docTabs[0]?.label || '';
                            
                            return (
                                <div>
                                    <div className="flex items-center justify-between mb-2">
                                        <h3 className="text-sm font-semibold">📄 Generated Project Docs</h3>
                                        <button onClick={() => { navigator.clipboard.writeText(activeContent); showAlert(`Copied ${activeLabel} to clipboard!`, 'Copied'); }}
                                            className="px-3 py-1.5 bg-indigo-600 hover:bg-indigo-500 rounded text-sm font-medium transition-colors">
                                            📋 Copy {activeLabel}
                                        </button>
                                    </div>
                                    <p className="text-slate-400 text-xs mb-2">
                                        {reviewData.docsCommitted > 0 
                                            ? `These docs have been committed to your repo. They'll be included in Claude Prep packages.`
                                            : `These docs were generated but not committed (no GitHub access). Copy and add to your repo manually.`
                                        }
                                    </p>
                                    <div className="flex gap-1 mb-2 overflow-x-auto">
                                        {docTabs.map(tab => (
                                            <button key={tab.id}
                                                onClick={() => setActiveDocTab(tab.id)}
                                                className={`px-2 py-1 rounded text-xs font-medium whitespace-nowrap transition-colors ${
                                                    activeDocTab === tab.id 
                                                        ? 'bg-indigo-600 text-white' 
                                                        : 'bg-slate-700 text-slate-400 hover:text-white'
                                                }`}>
                                                {tab.label}
                                            </button>
                                        ))}
                                    </div>
                                    <pre className="bg-slate-900 rounded-lg p-4 text-sm text-slate-300 max-h-64 overflow-y-auto whitespace-pre-wrap border border-slate-700">
                                        {activeContent}
                                    </pre>
                                </div>
                            );
                        })()}

                        {/* Fallback: Simple prompt viewer if no docs generated */}
                        {(!reviewData?.docsGenerated?.length && promptGenerated) && (
                            <div>
                                <div className="flex items-center justify-between mb-2">
                                    <h3 className="text-sm font-semibold">
                                        🤖 {reviewData?.promptType === 'instructions' ? 'CLAUDE_INSTRUCTIONS.md' : 'Claude Project Prompt'}
                                    </h3>
                                    <button onClick={() => { navigator.clipboard.writeText(promptGenerated); showAlert('Copied to clipboard!', 'Copied'); }}
                                        className="px-3 py-1.5 bg-indigo-600 hover:bg-indigo-500 rounded text-sm font-medium transition-colors">
                                        📋 Copy
                                    </button>
                                </div>
                                <p className="text-slate-400 text-xs mb-2">Copy this into a Claude Project or use as a session starter.</p>
                                <pre className="bg-slate-900 rounded-lg p-4 text-sm text-slate-300 max-h-64 overflow-y-auto whitespace-pre-wrap border border-slate-700">
                                    {promptGenerated}
                                </pre>
                            </div>
                        )}

                        {/* Actions */}
                        <div className="flex justify-between items-center pt-2 border-t border-slate-700">
                            <button onClick={() => { setStep(1); setAppData({ name:'',id:'',description:'',structure:'prod-only',isPWA:false,appType:'other',project:'',icon:'📦',hasAdmin:false,adminSubPath:'admin',customDomain:'' }); setScopeData(null); setSkipScope(false); setCreationLog([]); setPromptGenerated(''); setRepoStatus({checking:false,prodExists:null,testExists:null}); setWorkItemsCreated([]); setReviewData(null); setActiveDocTab('instructions'); }}
                                className="px-4 py-2 text-slate-400 hover:text-white transition-colors">
                                🆕 Setup Another App
                            </button>
                            <div className="text-green-400 text-sm font-medium">✅ Setup Complete</div>
                        </div>
                    </div>
                )}
            </div>
        );
    }

    // =========================================================================
    // FIREBASE ADMIN SETTINGS (v8.9.0)
    // =========================================================================
    
    // =========================================================================
    // DOMAIN REGISTRAR SETTINGS (v8.35.0)
    // =========================================================================
    
    function DomainRegistrarSettings() {
        const [activeProvider, setActiveProvider] = React.useState('porkbun');
        const providers = DomainProviderRegistry.getAll();
        
        return (
            <div className="space-y-4">
                {/* Provider Tabs */}
                <div className="flex gap-2 mb-4">
                    {providers.map(p => (
                        <button key={p.id} onClick={() => setActiveProvider(p.id)}
                            className={`px-4 py-2 rounded-lg text-sm flex items-center gap-2 transition-all ${
                                activeProvider === p.id 
                                    ? 'bg-indigo-600 text-white ring-1 ring-indigo-400' 
                                    : 'bg-slate-700 text-slate-300 hover:bg-slate-600'
                            }`}>
                            <span>{p.icon}</span>
                            <span>{p.name}</span>
                            {p.service.isConfigured() && <span className="text-green-400 text-xs">✓</span>}
                        </button>
                    ))}
                </div>
                
                {/* Active Provider Settings */}
                {providers.filter(p => p.id === activeProvider).map(provider => (
                    <ProviderConfigPanel key={provider.id} provider={provider} />
                ))}
            </div>
        );
    }
    
    function ProviderConfigPanel({ provider }) {
        const [config, setConfig] = React.useState(provider.service.getConfig());
        const [showKeys, setShowKeys] = React.useState(false);
        const [testing, setTesting] = React.useState(false);
        const [testResult, setTestResult] = React.useState(null);
        const [domains, setDomains] = React.useState(null);
        const [loadingDomains, setLoadingDomains] = React.useState(false);
        
        const updateConfig = (field, value) => {
            const updated = { ...config, [field]: value };
            setConfig(updated);
            provider.service.saveConfig(updated);
        };
        
        const handleTest = async () => {
            setTesting(true);
            setTestResult(null);
            try {
                const result = await provider.service.ping();
                const msg = result.yourIp && result.yourIp !== 'N/A' 
                    ? `Connected! Your IP: ${result.yourIp}`
                    : `Connected! ${result.domainCount !== undefined ? `${result.domainCount}+ domains found` : 'API responding'}`;
                setTestResult({ ok: true, msg });
                await handleFetchDomains();
            } catch (e) {
                setTestResult({ ok: false, msg: e.message });
            }
            setTesting(false);
        };
        
        const handleFetchDomains = async () => {
            setLoadingDomains(true);
            try {
                const domainList = await provider.service.listDomains();
                setDomains(domainList);
            } catch (e) {
                console.error(`Failed to fetch domains from ${provider.name}:`, e);
            }
            setLoadingDomains(false);
        };
        
        React.useEffect(() => {
            if (provider.service.isConfigured() && !domains) {
                handleFetchDomains();
            }
        }, [provider.id]);
        
        const allKeysPresent = provider.keyFields.every(f => config[f.key]);
        
        return (
            <div className="space-y-4">
                <p className="text-sm text-slate-400">
                    {provider.setupNote}{' '}
                    <a href={provider.setupUrl} target="_blank" className="text-indigo-400 hover:underline">
                        Get API keys →
                    </a>
                </p>
                
                {/* Key Fields (dynamic per provider) */}
                {provider.keyFields.map(field => (
                    <div key={field.key}>
                        <label className="text-xs text-slate-400 block mb-1.5">{field.label}</label>
                        <input 
                            type={showKeys ? 'text' : 'password'}
                            value={config[field.key] || ''}
                            onChange={e => updateConfig(field.key, e.target.value.trim())}
                            placeholder={field.placeholder}
                            className="w-full p-2 bg-slate-700 border border-slate-600 rounded text-sm font-mono"
                        />
                    </div>
                ))}
                
                {/* Action Buttons */}
                <div className="flex items-center gap-3 flex-wrap">
                    <button onClick={() => setShowKeys(!showKeys)}
                        className="text-xs px-3 py-1.5 bg-slate-700 rounded hover:bg-slate-600">
                        {showKeys ? '🔒 Hide' : '👁️ Show'} Keys
                    </button>
                    <button onClick={handleTest} disabled={testing || !allKeysPresent}
                        className="text-xs px-3 py-1.5 bg-indigo-600 rounded hover:bg-indigo-500 disabled:opacity-40 disabled:hover:bg-indigo-600">
                        {testing ? '⏳ Testing...' : '🔌 Test Connection'}
                    </button>
                    {provider.service.isConfigured() && (
                        <button onClick={handleFetchDomains} disabled={loadingDomains}
                            className="text-xs px-3 py-1.5 bg-slate-700 rounded hover:bg-slate-600 disabled:opacity-40">
                            {loadingDomains ? '⏳ Loading...' : '🔄 Refresh Domains'}
                        </button>
                    )}
                </div>
                
                {testResult && (
                    <div className={`p-3 rounded-lg border text-sm ${testResult.ok ? 'bg-green-900/30 border-green-700 text-green-300' : 'bg-red-900/30 border-red-700 text-red-300'}`}>
                        {testResult.ok ? '✅' : '❌'} {testResult.msg}
                    </div>
                )}
                
                {/* Domain List */}
                {domains && domains.length > 0 && (
                    <div className="mt-4">
                        <div className="text-xs text-slate-400 mb-2">{provider.icon} {provider.name} Domains ({domains.length})</div>
                        <div className="space-y-1.5">
                            {domains.map(d => {
                                const isExpiringSoon = d.expireDate && new Date(d.expireDate) - Date.now() < 60 * 24 * 60 * 60 * 1000;
                                return (
                                    <div key={d.domain} className="flex items-center gap-3 p-2.5 bg-slate-900/50 rounded-lg text-sm">
                                        <span className="text-lg">🌐</span>
                                        <span className="font-mono text-slate-200 flex-1">{d.domain}</span>
                                        <span className={`text-xs px-2 py-0.5 rounded ${
                                            d.status === 'ACTIVE' ? 'bg-green-900/30 text-green-400' : 'bg-amber-900/30 text-amber-400'
                                        }`}>
                                            {d.status || 'unknown'}
                                        </span>
                                        {d.expireDate && (
                                            <span className={`text-xs ${isExpiringSoon ? 'text-amber-400' : 'text-slate-500'}`}>
                                                {isExpiringSoon ? '⚠️ ' : ''}expires {new Date(d.expireDate).toLocaleDateString()}
                                            </span>
                                        )}
                                        <span className={`text-xs ${d.autoRenew ? 'text-green-500' : 'text-slate-600'}`}>
                                            {d.autoRenew ? '🔄 auto' : '⏸️ manual'}
                                        </span>
                                    </div>
                                );
                            })}
                        </div>
                    </div>
                )}
                
                {domains && domains.length === 0 && (
                    <div className="text-sm text-slate-500 p-4 text-center bg-slate-900/50 rounded-lg">
                        No domains found on this {provider.name} account.
                    </div>
                )}
            </div>
        );
    }

    // =========================================================================
    // DOMAINS VIEW — DNS management and domain health (v8.35.0)
    // =========================================================================
    
    function DomainsView({ apps, config, showAlert, showConfirm }) {
        const [domains, setDomains] = React.useState(null);
        const [loading, setLoading] = React.useState(false);
        const [error, setError] = React.useState(null);
        const [selectedDomain, setSelectedDomain] = React.useState(null);
        const [dnsRecords, setDnsRecords] = React.useState(null);
        const [loadingDNS, setLoadingDNS] = React.useState(false);
        const [addingRecord, setAddingRecord] = React.useState(false);
        const [newRecord, setNewRecord] = React.useState({ type: 'A', name: '', content: '', ttl: '600' });
        const [wiringDomain, setWiringDomain] = React.useState(null);
        const [wireLog, setWireLog] = React.useState([]);
        const [wireProgress, setWireProgress] = React.useState(false);
        
        // Get the service for the currently selected domain
        const getServiceForDomain = (domain) => {
            return DomainProviderRegistry.getServiceForDomain(domain, domains || []);
        };
        
        // Load domains from all configured providers
        const fetchDomains = async () => {
            setLoading(true);
            setError(null);
            try {
                const allDomains = await DomainProviderRegistry.getAllDomains();
                setDomains(allDomains);
                if (allDomains.length > 0 && !selectedDomain) {
                    setSelectedDomain(allDomains[0].domain);
                }
            } catch (e) {
                setError(e.message);
            }
            setLoading(false);
        };
        
        // Load DNS records for selected domain
        const fetchDNS = async (domain) => {
            setLoadingDNS(true);
            try {
                const service = getServiceForDomain(domain);
                if (!service) throw new Error('No provider found for this domain');
                const records = await service.listDNSRecords(domain);
                setDnsRecords(records);
            } catch (e) {
                showAlert(`Failed to load DNS: ${e.message}`, 'error');
            }
            setLoadingDNS(false);
        };
        
        // Fetch on mount
        React.useEffect(() => {
            if (DomainProviderRegistry.getConfigured().length > 0) fetchDomains();
        }, []);
        
        // Fetch DNS when domain changes
        React.useEffect(() => {
            if (selectedDomain) fetchDNS(selectedDomain);
        }, [selectedDomain]);
        
        // Add DNS record
        const handleAddRecord = async () => {
            if (!newRecord.type || !newRecord.content) return;
            setAddingRecord(true);
            try {
                const service = getServiceForDomain(selectedDomain);
                if (!service) throw new Error('No provider found for this domain');
                await service.createDNSRecord(
                    selectedDomain, newRecord.type, newRecord.name, 
                    newRecord.content, parseInt(newRecord.ttl) || 600,
                    newRecord.type === 'MX' ? parseInt(newRecord.prio) || 10 : null
                );
                showAlert('DNS record created', 'success');
                setNewRecord({ type: 'A', name: '', content: '', ttl: '600' });
                await fetchDNS(selectedDomain);
            } catch (e) {
                showAlert(`Failed to create record: ${e.message}`, 'error');
            }
            setAddingRecord(false);
        };
        
        // Delete DNS record
        const handleDeleteRecord = async (recordId, recordDesc) => {
            const confirmed = await showConfirm(`Delete ${recordDesc}?`, 'Delete DNS Record');
            if (!confirmed) return;
            try {
                const service = getServiceForDomain(selectedDomain);
                if (!service) throw new Error('No provider found for this domain');
                // GoDaddy needs all records to do a replace-minus-one
                await service.deleteDNSRecord(selectedDomain, recordId, dnsRecords);
                showAlert('Record deleted', 'success');
                await fetchDNS(selectedDomain);
            } catch (e) {
                showAlert(`Failed to delete: ${e.message}`, 'error');
            }
        };
        
        // Wire domain for GitHub Pages
        const handleWireForGitHubPages = async (domain, repo) => {
            setWireProgress(true);
            setWireLog(['🚀 Starting GitHub Pages configuration...']);
            
            try {
                const service = getServiceForDomain(domain);
                if (!service) throw new Error('No provider found for this domain');
                const domainEntry = (domains || []).find(d => d.domain === domain);
                const providerName = domainEntry?.providerName || 'registrar';
                
                // Step 1: Configure DNS at registrar
                setWireLog(prev => [...prev, `📡 Configuring DNS records at ${providerName}...`]);
                const githubUsername = repo.split('/')[0];
                const dnsResult = await service.configureForGitHubPages(domain, githubUsername);
                dnsResult.log.forEach(l => setWireLog(prev => [...prev, `  ${l}`]));
                setWireLog(prev => [...prev, `✅ ${dnsResult.recordsCreated} DNS records created`]);
                
                // Step 2: Create CNAME file in repo
                setWireLog(prev => [...prev, '📄 Committing CNAME file to repo...']);
                const github = new GitHubAPI(localStorage.getItem('cc_github_token'));
                await github.createOrUpdateFile(repo, 'CNAME', domain, `Add custom domain CNAME for ${domain}`);
                setWireLog(prev => [...prev, '✅ CNAME file committed']);
                
                // Step 3: Update GitHub Pages config
                setWireLog(prev => [...prev, '⚙️ Updating GitHub Pages configuration...']);
                await github.updatePagesConfig(repo, domain, false);
                setWireLog(prev => [...prev, '✅ Custom domain set on GitHub Pages']);
                
                setWireLog(prev => [...prev, '', '🎉 Domain configuration complete!', `🌐 ${domain} will be live once DNS propagates (5-30 minutes)`, '🔒 HTTPS will auto-enable after DNS propagation']);
                
                showAlert(`${domain} configured for GitHub Pages! DNS may take 5-30 minutes to propagate.`, 'success');
                
                // Refresh DNS records view
                await fetchDNS(domain);
            } catch (e) {
                setWireLog(prev => [...prev, `❌ Error: ${e.message}`]);
                showAlert(`Wiring failed: ${e.message}`, 'error');
            }
            setWireProgress(false);
        };
        
        // Not configured
        if (DomainProviderRegistry.getConfigured().length === 0) {
            return (
                <div className="max-w-4xl mx-auto">
                    <div className="flex items-center gap-3 mb-6">
                        <span className="text-2xl">🌐</span>
                        <h1 className="text-2xl font-bold">Domains</h1>
                    </div>
                    <div className="bg-slate-800 rounded-xl border border-slate-700 p-8 text-center">
                        <span className="text-4xl block mb-4">🔑</span>
                        <h3 className="text-lg font-semibold mb-2">No Domain Registrars Configured</h3>
                        <p className="text-slate-400 text-sm mb-4">Add API keys for Porkbun, GoDaddy, or both in Settings to manage domains from Command Center.</p>
                        <p className="text-slate-500 text-xs">Configure → Settings → 🌐 Domain Registrar</p>
                    </div>
                </div>
            );
        }
        
        // Record type colors
        const typeColors = {
            A: 'bg-blue-600/20 text-blue-400',
            AAAA: 'bg-cyan-600/20 text-cyan-400',
            CNAME: 'bg-green-600/20 text-green-400',
            MX: 'bg-purple-600/20 text-purple-400',
            TXT: 'bg-amber-600/20 text-amber-400',
            NS: 'bg-slate-600/20 text-slate-400',
            SRV: 'bg-pink-600/20 text-pink-400',
            ALIAS: 'bg-emerald-600/20 text-emerald-400',
            CAA: 'bg-orange-600/20 text-orange-400',
        };
        
        // Check if domain is already wired for GitHub Pages
        const isGitHubPagesWired = (records) => {
            if (!records) return false;
            const ghIPs = PorkbunService.GITHUB_PAGES_IPS; // Same IPs regardless of provider
            const aRecords = records.filter(r => r.type === 'A').map(r => r.content);
            const hasGHIPs = ghIPs.every(ip => aRecords.includes(ip));
            const hasCNAME = records.some(r => r.type === 'CNAME' && r.content.includes('.github.io'));
            return hasGHIPs && hasCNAME;
        };
        
        // Find which apps could use this domain (have repos assigned)
        const getAppsWithRepos = () => {
            return Object.entries(apps)
                .filter(([_, a]) => a.testRepo || a.prodRepo)
                .map(([id, a]) => ({ id, ...a }));
        };
        
        return (
            <div className="max-w-6xl mx-auto">
                <div className="flex items-center justify-between mb-6">
                    <div className="flex items-center gap-3">
                        <span className="text-2xl">🌐</span>
                        <div>
                            <h1 className="text-2xl font-bold">Domains</h1>
                            <p className="text-slate-400 text-sm">DNS management and GitHub Pages domain wiring</p>
                        </div>
                    </div>
                    <button onClick={fetchDomains} disabled={loading}
                        className="px-3 py-1.5 text-sm bg-slate-700 rounded hover:bg-slate-600 disabled:opacity-40">
                        {loading ? '⏳' : '🔄'} Refresh
                    </button>
                </div>
                
                {error && (
                    <div className="bg-red-900/30 border border-red-700 text-red-300 rounded-xl p-4 mb-6 text-sm">
                        ❌ {error}
                    </div>
                )}
                
                {/* Domain Selector */}
                {domains && domains.length > 0 && (
                    <div className="flex gap-2 mb-6 flex-wrap">
                        {domains.map(d => (
                            <button key={d.domain}
                                onClick={() => setSelectedDomain(d.domain)}
                                className={`px-4 py-2 rounded-lg text-sm font-mono transition-all flex items-center gap-2 ${
                                    selectedDomain === d.domain 
                                        ? 'bg-indigo-600 text-white ring-1 ring-indigo-400' 
                                        : 'bg-slate-800 border border-slate-700 text-slate-300 hover:bg-slate-700'
                                }`}>
                                <span>{d.providerIcon || '🌐'}</span>
                                <span>{d.domain}</span>
                            </button>
                        ))}
                    </div>
                )}
                
                {loading && <div className="text-center text-slate-400 py-12">⏳ Loading domains...</div>}
                
                {/* DNS Records Panel */}
                {selectedDomain && !loading && (
                    <div className="space-y-6">
                        {/* Domain Info + Quick Actions */}
                        <div className="bg-slate-800 rounded-xl border border-slate-700 p-5">
                            <div className="flex items-center justify-between mb-4">
                                <h3 className="font-semibold flex items-center gap-2">
                                    📡 DNS Records — <span className="font-mono text-indigo-300">{selectedDomain}</span>
                                </h3>
                                <div className="flex gap-2">
                                    {!isGitHubPagesWired(dnsRecords) && (
                                        <button onClick={() => setWiringDomain(selectedDomain)}
                                            className="text-xs px-3 py-1.5 bg-green-600 rounded hover:bg-green-500 font-medium">
                                            ⚡ Wire for GitHub Pages
                                        </button>
                                    )}
                                    {isGitHubPagesWired(dnsRecords) && (
                                        <span className="text-xs px-3 py-1.5 bg-green-900/30 text-green-400 rounded border border-green-700/30">
                                            ✅ GitHub Pages configured
                                        </span>
                                    )}
                                    <button onClick={() => fetchDNS(selectedDomain)} disabled={loadingDNS}
                                        className="text-xs px-3 py-1.5 bg-slate-700 rounded hover:bg-slate-600 disabled:opacity-40">
                                        {loadingDNS ? '⏳' : '🔄'}
                                    </button>
                                </div>
                            </div>
                            
                            {/* DNS Records Table */}
                            {loadingDNS && <div className="text-center text-slate-400 py-8">⏳ Loading DNS records...</div>}
                            
                            {dnsRecords && !loadingDNS && (
                                <div className="overflow-x-auto">
                                    <table className="w-full text-sm">
                                        <thead>
                                            <tr className="border-b border-slate-700 text-left">
                                                <th className="py-2 px-3 text-slate-400 font-medium w-20">Type</th>
                                                <th className="py-2 px-3 text-slate-400 font-medium">Name</th>
                                                <th className="py-2 px-3 text-slate-400 font-medium">Content</th>
                                                <th className="py-2 px-3 text-slate-400 font-medium w-16">TTL</th>
                                                <th className="py-2 px-3 text-slate-400 font-medium w-16">Prio</th>
                                                <th className="py-2 px-3 text-slate-400 font-medium w-12"></th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            {dnsRecords.map(record => (
                                                <tr key={record.id} className="border-b border-slate-700/50 hover:bg-slate-700/30">
                                                    <td className="py-2 px-3">
                                                        <span className={`text-xs px-2 py-0.5 rounded font-medium ${typeColors[record.type] || 'bg-slate-600/20 text-slate-400'}`}>
                                                            {record.type}
                                                        </span>
                                                    </td>
                                                    <td className="py-2 px-3 font-mono text-slate-300 text-xs">{record.name || '@'}</td>
                                                    <td className="py-2 px-3 font-mono text-slate-200 text-xs break-all max-w-xs">{record.content}</td>
                                                    <td className="py-2 px-3 text-xs text-slate-500">{record.ttl}</td>
                                                    <td className="py-2 px-3 text-xs text-slate-500">{record.prio || '—'}</td>
                                                    <td className="py-2 px-3">
                                                        <button onClick={() => handleDeleteRecord(record.id, `${record.type} ${record.name}`)}
                                                            className="text-red-500 hover:text-red-400 text-xs" title="Delete record">
                                                            🗑️
                                                        </button>
                                                    </td>
                                                </tr>
                                            ))}
                                            {dnsRecords.length === 0 && (
                                                <tr><td colSpan="6" className="py-8 text-center text-slate-500">No DNS records found</td></tr>
                                            )}
                                        </tbody>
                                    </table>
                                </div>
                            )}
                        </div>
                        
                        {/* Add DNS Record */}
                        <div className="bg-slate-800 rounded-xl border border-slate-700 p-5">
                            <h3 className="font-semibold mb-4 flex items-center gap-2">➕ Add DNS Record</h3>
                            <div className="grid grid-cols-2 sm:grid-cols-5 gap-3">
                                <div>
                                    <label className="text-xs text-slate-400 block mb-1">Type</label>
                                    <select value={newRecord.type} onChange={e => setNewRecord({...newRecord, type: e.target.value})}
                                        className="w-full p-2 bg-slate-700 border border-slate-600 rounded text-sm">
                                        {['A', 'AAAA', 'CNAME', 'MX', 'TXT', 'NS', 'SRV', 'CAA', 'ALIAS'].map(t => (
                                            <option key={t} value={t}>{t}</option>
                                        ))}
                                    </select>
                                </div>
                                <div>
                                    <label className="text-xs text-slate-400 block mb-1">Name <span className="text-slate-600">(subdomain)</span></label>
                                    <input value={newRecord.name} onChange={e => setNewRecord({...newRecord, name: e.target.value})}
                                        placeholder="@ or www" className="w-full p-2 bg-slate-700 border border-slate-600 rounded text-sm font-mono" />
                                </div>
                                <div className="sm:col-span-2">
                                    <label className="text-xs text-slate-400 block mb-1">Content</label>
                                    <input value={newRecord.content} onChange={e => setNewRecord({...newRecord, content: e.target.value})}
                                        placeholder="1.2.3.4 or target.example.com" className="w-full p-2 bg-slate-700 border border-slate-600 rounded text-sm font-mono" />
                                </div>
                                <div className="flex items-end gap-2">
                                    <div className="flex-1">
                                        <label className="text-xs text-slate-400 block mb-1">TTL</label>
                                        <input value={newRecord.ttl} onChange={e => setNewRecord({...newRecord, ttl: e.target.value})}
                                            className="w-full p-2 bg-slate-700 border border-slate-600 rounded text-sm font-mono" />
                                    </div>
                                    <button onClick={handleAddRecord} disabled={addingRecord || !newRecord.content}
                                        className="px-4 py-2 bg-indigo-600 rounded text-sm hover:bg-indigo-500 disabled:opacity-40 whitespace-nowrap">
                                        {addingRecord ? '⏳' : '➕'} Add
                                    </button>
                                </div>
                            </div>
                        </div>
                        
                        {/* Wire for GitHub Pages Modal */}
                        {wiringDomain && (
                            <div className="bg-slate-800 rounded-xl border border-indigo-700/50 p-5">
                                <h3 className="font-semibold mb-3 flex items-center gap-2">⚡ Wire {wiringDomain} for GitHub Pages</h3>
                                
                                {!wireProgress && wireLog.length === 0 && (
                                    <div>
                                        <p className="text-sm text-slate-400 mb-4">
                                            This will configure DNS records and GitHub Pages to serve your app from <strong className="text-white">{wiringDomain}</strong>. 
                                            It creates 4 A records + 1 CNAME record, commits a CNAME file, and updates the GitHub Pages settings.
                                        </p>
                                        <div className="mb-4">
                                            <label className="text-xs text-slate-400 block mb-1.5">Select Repository to Wire</label>
                                            <div className="space-y-1.5">
                                                {getAppsWithRepos().map(app => (
                                                    <div key={app.id} className="flex items-center gap-3">
                                                        {app.prodRepo && (
                                                            <button onClick={() => handleWireForGitHubPages(wiringDomain, app.prodRepo)}
                                                                className="flex items-center gap-2 px-3 py-2 bg-slate-900/50 rounded-lg hover:bg-slate-700/50 text-sm border border-slate-700 w-full text-left">
                                                                <AppIcon icon={app.icon} size={16} />
                                                                <span className="font-medium">{app.name}</span>
                                                                <span className="text-xs text-slate-500 font-mono ml-auto">{app.prodRepo}</span>
                                                                <span className="text-xs px-1.5 py-0.5 bg-green-900/30 text-green-400 rounded">prod</span>
                                                            </button>
                                                        )}
                                                    </div>
                                                ))}
                                            </div>
                                        </div>
                                        <button onClick={() => { setWiringDomain(null); setWireLog([]); }}
                                            className="text-xs text-slate-400 hover:text-white">Cancel</button>
                                    </div>
                                )}
                                
                                {/* Wire Progress Log */}
                                {wireLog.length > 0 && (
                                    <div>
                                        <div className="bg-slate-900 rounded-lg p-4 max-h-64 overflow-y-auto font-mono text-xs space-y-1">
                                            {wireLog.map((line, i) => (
                                                <div key={i} className={`${line.startsWith('❌') ? 'text-red-400' : line.startsWith('✅') ? 'text-green-400' : line.startsWith('🎉') ? 'text-yellow-400 font-bold' : 'text-slate-300'}`}>
                                                    {line}
                                                </div>
                                            ))}
                                            {wireProgress && <div className="text-indigo-400 animate-pulse">⏳ Working...</div>}
                                        </div>
                                        {!wireProgress && (
                                            <button onClick={() => { setWiringDomain(null); setWireLog([]); }}
                                                className="mt-3 text-xs px-3 py-1.5 bg-slate-700 rounded hover:bg-slate-600">
                                                ✓ Done
                                            </button>
                                        )}
                                    </div>
                                )}
                            </div>
                        )}
                    </div>
                )}
                
                {!loading && domains && domains.length === 0 && (
                    <div className="bg-slate-800 rounded-xl border border-slate-700 p-8 text-center">
                        <span className="text-4xl block mb-4">🌐</span>
                        <h3 className="text-lg font-semibold mb-2">No Domains Found</h3>
                        <p className="text-slate-400 text-sm">No domains found across your configured registrars. Purchase a domain at your registrar, then manage it here.</p>
                    </div>
                )}
            </div>
        );
    }

    function FirebaseAdminSettings() {
        const [showKeyInput, setShowKeyInput] = React.useState(false);
        const [keyInput, setKeyInput] = React.useState('');
        const [info, setInfo] = React.useState(() => firebaseAdmin.getInfo());
        const [testing, setTesting] = React.useState(false);
        const [testResult, setTestResult] = React.useState(null);
        const [saveResult, setSaveResult] = React.useState(null);
        
        const refreshInfo = () => setInfo(firebaseAdmin.getInfo());
        
        const handleSave = () => {
            setSaveResult(null);
            setTestResult(null);
            const result = firebaseAdmin.saveServiceAccount(keyInput);
            setSaveResult(result);
            if (result.success) {
                setKeyInput('');
                setShowKeyInput(false);
                refreshInfo();
            }
        };
        
        const handleClear = () => {
            firebaseAdmin.clearServiceAccount();
            setSaveResult(null);
            setTestResult(null);
            refreshInfo();
        };
        
        const handleTest = async () => {
            setTesting(true);
            setTestResult(null);
            try {
                const result = await firebaseAdmin.testConnection();
                setTestResult(result);
                refreshInfo();
            } catch (e) {
                setTestResult({ token: false, rules: false, functions: false, errors: [e.message] });
            }
            setTesting(false);
        };
        
        const handleRefreshToken = async () => {
            setTesting(true);
            setTestResult(null);
            try {
                firebaseAdmin.clearToken();
                await firebaseAdmin.getAccessToken();
                refreshInfo();
                setTestResult({ token: true, errors: [], message: 'Token refreshed' });
            } catch (e) {
                setTestResult({ token: false, errors: [e.message] });
            }
            setTesting(false);
        };
        
        const configured = info !== null;
        
        return (
            <div className="space-y-4">
                {/* Status display */}
                {configured ? (
                    <div className="space-y-3">
                        <div className="p-4 bg-slate-900 rounded-lg border border-slate-600">
                            <div className="grid grid-cols-2 gap-3 text-sm">
                                <div>
                                    <div className="text-xs text-slate-500 uppercase tracking-wide mb-1">Service Account</div>
                                    <div className="font-mono text-slate-300 text-xs truncate" title={info.email}>{info.email}</div>
                                </div>
                                <div>
                                    <div className="text-xs text-slate-500 uppercase tracking-wide mb-1">Firebase Project</div>
                                    <div className="font-mono text-slate-300 text-xs">{info.projectId}</div>
                                </div>
                                <div>
                                    <div className="text-xs text-slate-500 uppercase tracking-wide mb-1">Key ID</div>
                                    <div className="font-mono text-slate-300 text-xs">{info.keyId}</div>
                                </div>
                                <div>
                                    <div className="text-xs text-slate-500 uppercase tracking-wide mb-1">OAuth Token</div>
                                    <div className="flex items-center gap-2">
                                        {info.tokenValid ? (
                                            <span className="text-green-400 text-xs flex items-center gap-1">
                                                <span className="inline-block w-2 h-2 rounded-full bg-green-400"></span>
                                                Active — expires {info.tokenExpiry}
                                            </span>
                                        ) : info.tokenCached ? (
                                            <span className="text-amber-400 text-xs flex items-center gap-1">
                                                <span className="inline-block w-2 h-2 rounded-full bg-amber-400"></span>
                                                Expired
                                            </span>
                                        ) : (
                                            <span className="text-slate-500 text-xs flex items-center gap-1">
                                                <span className="inline-block w-2 h-2 rounded-full bg-slate-500"></span>
                                                Not yet requested
                                            </span>
                                        )}
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        {/* Actions */}
                        <div className="flex gap-2 flex-wrap">
                            <button onClick={handleTest} disabled={testing}
                                className="px-4 py-2 bg-indigo-600 hover:bg-indigo-500 rounded text-sm disabled:opacity-50">
                                {testing ? '⏳ Testing...' : '🧪 Test Connection'}
                            </button>
                            <button onClick={handleRefreshToken} disabled={testing}
                                className="px-4 py-2 bg-slate-700 hover:bg-slate-600 rounded text-sm disabled:opacity-50">
                                🔄 Refresh Token
                            </button>
                            <button onClick={() => setShowKeyInput(true)}
                                className="px-4 py-2 bg-slate-700 hover:bg-slate-600 rounded text-sm">
                                🔑 Update Key
                            </button>
                            <button onClick={handleClear}
                                className="px-4 py-2 bg-red-900/50 hover:bg-red-900/70 text-red-400 border border-red-800 rounded text-sm">
                                🗑️ Remove
                            </button>
                        </div>
                    </div>
                ) : (
                    <div className="p-4 bg-slate-900/50 rounded-lg border border-dashed border-slate-600 text-center">
                        <div className="text-slate-400 text-sm mb-3">No service account configured</div>
                        <button onClick={() => setShowKeyInput(true)}
                            className="px-4 py-2 bg-indigo-600 hover:bg-indigo-500 rounded text-sm">
                            🔑 Add Service Account Key
                        </button>
                    </div>
                )}
                
                {/* Key input area */}
                {showKeyInput && (
                    <div className="p-4 bg-slate-900 rounded-lg border border-indigo-500/30">
                        <div className="text-sm text-slate-300 mb-2 font-medium">
                            Paste Service Account JSON Key
                        </div>
                        <p className="text-xs text-slate-500 mb-3">
                            Firebase Console → Project Settings → Service Accounts → Generate New Private Key. 
                            Paste the entire JSON file contents below.
                        </p>
                        <textarea
                            value={keyInput}
                            onChange={e => setKeyInput(e.target.value)}
                            placeholder='{"type": "service_account", "project_id": "...", ...}'
                            className="w-full h-32 bg-slate-800 border border-slate-600 rounded p-3 font-mono text-xs text-slate-300 resize-y"
                            spellCheck="false"
                        />
                        <div className="flex gap-2 mt-3">
                            <button onClick={handleSave} disabled={!keyInput.trim()}
                                className="px-4 py-2 bg-green-600 hover:bg-green-500 rounded text-sm disabled:opacity-50">
                                💾 Save Key
                            </button>
                            <button onClick={() => { setShowKeyInput(false); setKeyInput(''); setSaveResult(null); }}
                                className="px-4 py-2 bg-slate-700 hover:bg-slate-600 rounded text-sm">
                                Cancel
                            </button>
                        </div>
                        
                        {/* Save result */}
                        {saveResult && (
                            <div className={`mt-3 p-3 rounded text-sm ${saveResult.success ? 'bg-green-900/30 border border-green-700 text-green-300' : 'bg-red-900/30 border border-red-700 text-red-300'}`}>
                                {saveResult.success 
                                    ? `✅ Saved — ${saveResult.email} (project: ${saveResult.project})`
                                    : `❌ ${saveResult.error}`
                                }
                            </div>
                        )}
                    </div>
                )}
                
                {/* Test results */}
                {testResult && (
                    <div className="p-4 bg-slate-900 rounded-lg border border-slate-600">
                        <div className="text-sm font-medium text-slate-300 mb-3">Connection Test Results</div>
                        <div className="space-y-2">
                            <div className="flex items-center gap-2 text-sm">
                                <span className={testResult.token ? 'text-green-400' : 'text-red-400'}>
                                    {testResult.token ? '✅' : '❌'}
                                </span>
                                <span>OAuth2 Token</span>
                                <span className="text-slate-500 text-xs">— JWT signing & token exchange</span>
                            </div>
                            <div className="flex items-center gap-2 text-sm">
                                <span className={testResult.rules ? 'text-green-400' : 'text-red-400'}>
                                    {testResult.rules ? '✅' : '❌'}
                                </span>
                                <span>RTDB Rules Access</span>
                                <span className="text-slate-500 text-xs">— read security rules via REST</span>
                            </div>
                            <div className="flex items-center gap-2 text-sm">
                                <span className={testResult.functions ? 'text-green-400' : 'text-red-400'}>
                                    {testResult.functions ? '✅' : '❌'}
                                </span>
                                <span>Cloud Functions API</span>
                                {testResult.functionCount !== undefined && (
                                    <span className="text-slate-500 text-xs">— found {testResult.functionCount} function{testResult.functionCount !== 1 ? 's' : ''}</span>
                                )}
                            </div>
                        </div>
                        {testResult.errors?.length > 0 && (
                            <div className="mt-3 space-y-1">
                                {testResult.errors.map((err, i) => (
                                    <div key={i} className="text-xs text-red-400 bg-red-900/20 px-3 py-1.5 rounded font-mono">{err}</div>
                                ))}
                            </div>
                        )}
                        {testResult.message && (
                            <div className="mt-2 text-xs text-green-400">{testResult.message}</div>
                        )}
                    </div>
                )}
                
                {/* Info about what admin access enables */}
                <div className="text-xs text-slate-500 space-y-1">
                    <div>Admin access enables:</div>
                    <div className="ml-3">• Read & deploy RTDB security rules</div>
                    <div className="ml-3">• List Cloud Functions and their status</div>
                    <div className="ml-3">• View Cloud Logging entries and errors</div>
                    <div className="ml-3">• Admin-level RTDB data access</div>
                </div>
            </div>
        );
    }

    // =========================================================================
    // SETTINGS VIEW
    // =========================================================================
    
    function SettingsView({ token, setToken, settings, setSettings, repoCount, syncStatus, onForceSync, config, onConfigChange }) {
        const [show, setShow] = React.useState(false);
        const [testing, setTesting] = React.useState(false);
        const [result, setResult] = React.useState(null);
        const [storageDiag, setStorageDiag] = React.useState(null);
        const [cleanupResult, setCleanupResult] = React.useState(null);
        
        // Firebase Sync state
        const [syncAction, setSyncAction] = React.useState(null); // 'pushing' | 'pulling' | 'clearing'
        const [syncResult, setSyncResult] = React.useState(null);
        const [dataSize, setDataSize] = React.useState(null);
        const [loadingSize, setLoadingSize] = React.useState(false);
        const [lastSyncTime, setLastSyncTime] = React.useState(null);
        
        // Fetch data size on mount and when sync status changes
        React.useEffect(() => {
            if (FirebaseConfigSync.initialized && syncStatus === 'synced') {
                fetchDataSize();
            }
        }, [syncStatus]);
        
        const fetchDataSize = async () => {
            setLoadingSize(true);
            const size = await FirebaseConfigSync.getDataSize();
            setDataSize(size);
            setLoadingSize(false);
        };
        
        const formatBytes = (bytes) => {
            if (bytes < 1024) return `${bytes} B`;
            if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
            return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
        };
        
        const handlePushAll = async () => {
            setSyncAction('pushing');
            setSyncResult(null);
            try {
                const localConfig = ConfigManager.load();
                const localDeployments = DeployService.load();
                const localRulesHistory = (() => { try { return JSON.parse(localStorage.getItem('cc_rulesHistory') || '[]'); } catch { return []; } })();
                const localSessionLog = SessionLogService.load();
                const localDeletionHistory = (() => { try { return JSON.parse(localStorage.getItem('cc_deletion_history') || '[]'); } catch { return []; } })();
                const localRollbackSnapshots = RollbackService.load();
                
                const ok = await FirebaseConfigSync.pushAll({
                    config: localConfig,
                    deployHistory: localDeployments,
                    rulesHistory: localRulesHistory,
                    sessionLog: localSessionLog,
                    deletionHistory: localDeletionHistory,
                    rollbackSnapshots: localRollbackSnapshots
                });
                
                setSyncResult(ok ? { ok: true, msg: 'All local data pushed to Firebase' } : { ok: false, msg: 'Push failed' });
                setLastSyncTime(Date.now());
                await fetchDataSize();
            } catch (e) {
                setSyncResult({ ok: false, msg: e.message });
            }
            setSyncAction(null);
        };
        
        const handlePullAll = async () => {
            setSyncAction('pulling');
            setSyncResult(null);
            try {
                if (onForceSync) {
                    await onForceSync('pull');
                    setSyncResult({ ok: true, msg: 'Firebase data pulled and overlaid onto local state' });
                    setLastSyncTime(Date.now());
                } else {
                    setSyncResult({ ok: false, msg: 'Force sync not available' });
                }
            } catch (e) {
                setSyncResult({ ok: false, msg: e.message });
            }
            setSyncAction(null);
        };
        
        const handleClearFirebase = async () => {
            if (!window.confirm('Are you sure you want to clear ALL Command Center data from Firebase?\n\nThis cannot be undone. Your local data will remain intact.')) {
                return;
            }
            setSyncAction('clearing');
            setSyncResult(null);
            try {
                const ok = await FirebaseConfigSync.clearAll();
                setSyncResult(ok ? { ok: true, msg: 'All Command Center data cleared from Firebase' } : { ok: false, msg: 'Clear failed' });
                setDataSize({ totalBytes: 0, keys: {} });
            } catch (e) {
                setSyncResult({ ok: false, msg: e.message });
            }
            setSyncAction(null);
        };
        
        // Token expiration tracking (v8.3.3)
        const [tokenExpires, setTokenExpires] = React.useState(() => {
            try { return localStorage.getItem('cc_token_expires') || ''; } catch { return ''; }
        });
        
        const saveTokenWithExpiry = (newToken, days = 90) => {
            setToken(newToken);
            if (newToken) {
                const expires = new Date();
                expires.setDate(expires.getDate() + days);
                const expiresStr = expires.toISOString();
                setTokenExpires(expiresStr);
                try { localStorage.setItem('cc_token_expires', expiresStr); } catch {}
            }
        };
        
        const daysUntilExpiry = tokenExpires ? Math.ceil((new Date(tokenExpires) - new Date()) / (1000 * 60 * 60 * 24)) : null;
        const expiryWarning = daysUntilExpiry !== null && daysUntilExpiry <= 14;
        const expiryDanger = daysUntilExpiry !== null && daysUntilExpiry <= 3;
        
        return (
            <div className="space-y-6">
                {/* Your Name (v8.37.0) */}
                <div className="bg-slate-800 rounded-xl border border-slate-700 p-6">
                    <h2 className="text-lg font-semibold mb-2 flex items-center gap-2">
                        👤 Your Name
                    </h2>
                    <p className="text-sm text-slate-400 mb-3">
                        Used to attribute work items, deploys, and session activity. Leave blank to use "Owner".
                    </p>
                    <input 
                        type="text" 
                        value={config?.ownerName || ''} 
                        onChange={e => {
                            if (onConfigChange) {
                                onConfigChange({ ...config, ownerName: e.target.value });
                            }
                        }}
                        placeholder="e.g. Dave"
                        className="w-full max-w-xs p-2 bg-slate-700 border border-slate-600 rounded text-sm focus:border-indigo-500 focus:outline-none" />
                    {config?.ownerName && (
                        <div className="mt-2 text-xs text-green-400">✓ Records will be attributed to "{config.ownerName}"</div>
                    )}
                </div>
                
                <div className="bg-slate-800 rounded-xl border border-slate-700 p-6">
                    <h2 className="text-lg font-semibold mb-4 flex items-center gap-2">
                        <Icons.GitBranch /> GitHub Token
                    </h2>
                    <div className="flex gap-2 mb-2">
                        <input type={show ? 'text' : 'password'} value={token} onChange={e => setToken(e.target.value)}
                            placeholder="ghp_xxxx" className="flex-1 p-2 bg-slate-700 border border-slate-600 rounded font-mono text-sm" />
                        <button onClick={() => setShow(!show)} className="px-3 bg-slate-700 border border-slate-600 rounded">{show ? '🙈' : '👁️'}</button>
                        <button onClick={async () => {
                            setTesting(true);
                            try { const gh = new GitHubAPI(token); const r = await gh.listRepos(); setResult({ ok: true, count: r.length }); }
                            catch (e) { setResult({ ok: false, error: e.message }); }
                            setTesting(false);
                        }} disabled={testing} className="px-4 bg-indigo-600 rounded">{testing ? '...' : 'Test'}</button>
                    </div>
                    <div className="flex items-center gap-4 mt-3">
                        <a href="https://github.com/settings/tokens/new?scopes=repo" target="_blank" className="text-xs text-indigo-400">Create token →</a>
                        {token && (
                            <button onClick={() => saveTokenWithExpiry(token, 90)} 
                                className="text-xs px-2 py-1 bg-slate-700 border border-slate-600 rounded hover:bg-slate-600">
                                🔄 Reset 90-day timer
                            </button>
                        )}
                    </div>
                    {result && <div className={`mt-2 text-sm ${result.ok ? 'text-green-400' : 'text-red-400'}`}>
                        {result.ok ? `✓ Found ${result.count} repos` : `✗ ${result.error}`}
                    </div>}
                    
                    {/* Token expiration warning */}
                    {token && tokenExpires && (
                        <div className={`mt-3 p-3 rounded-lg border ${
                            expiryDanger ? 'bg-red-900/30 border-red-700 text-red-300' :
                            expiryWarning ? 'bg-amber-900/30 border-amber-700 text-amber-300' :
                            'bg-slate-700/50 border-slate-600 text-slate-300'
                        }`}>
                            <div className="flex items-center gap-2">
                                <span>{expiryDanger ? '🚨' : expiryWarning ? '⚠️' : '🔑'}</span>
                                <span className="text-sm">
                                    {daysUntilExpiry <= 0 
                                        ? <strong>Token may have expired!</strong>
                                        : <>Token expires in <strong>{daysUntilExpiry} days</strong> ({new Date(tokenExpires).toLocaleDateString()})</>
                                    }
                                </span>
                            </div>
                            {(expiryWarning || expiryDanger) && (
                                <div className="mt-2 text-xs">
                                    <a href="https://github.com/settings/tokens" target="_blank" className="text-indigo-400 underline">
                                        Generate a new token →
                                    </a>
                                    {' '}then paste it above and click "Reset 90-day timer"
                                </div>
                            )}
                        </div>
                    )}
                    {token && !tokenExpires && (
                        <div className="mt-3 p-3 rounded-lg border bg-amber-900/30 border-amber-700 text-amber-300">
                            <div className="text-sm">⚠️ Token expiration not set</div>
                            <button onClick={() => saveTokenWithExpiry(token, 90)} 
                                className="mt-2 text-xs px-3 py-1 bg-amber-700 rounded hover:bg-amber-600">
                                Set 90-day expiration from today
                            </button>
                        </div>
                    )}
                </div>
                
                {/* Firebase Admin (v8.9.0) */}
                <div className="bg-slate-800 rounded-xl border border-slate-700 p-6">
                    <h2 className="text-lg font-semibold mb-4 flex items-center gap-2">
                        🔥 Firebase Admin
                    </h2>
                    <p className="text-sm text-slate-400 mb-4">
                        Service account credentials enable admin access to Firebase RTDB rules, Cloud Functions status, and logging. 
                        Generate a key at <a href="https://console.firebase.google.com/project/word-boxing/settings/serviceaccounts/adminsdk" target="_blank" className="text-indigo-400 hover:underline">Firebase Console → Project Settings → Service Accounts</a>.
                    </p>
                    
                    <FirebaseAdminSettings />
                </div>
                
                {/* Domain Registrar (v8.35.0) */}
                <div className="bg-slate-800 rounded-xl border border-slate-700 p-6">
                    <h2 className="text-lg font-semibold mb-4 flex items-center gap-2">
                        🌐 Domain Registrar
                    </h2>
                    <p className="text-sm text-slate-400 mb-4">
                        Connect one or more domain registrars to manage DNS, wire custom domains to GitHub Pages, and monitor domain health from Command Center.
                        You can configure multiple providers — domains from all connected registrars appear together in Monitor → Domains.
                    </p>
                    
                    <DomainRegistrarSettings />
                </div>
                
                {/* Firebase Config Sync (v8.18.0) */}
                <div className="bg-slate-800 rounded-xl border border-slate-700 p-6">
                    <h2 className="text-lg font-semibold mb-4 flex items-center gap-2">
                        ☁️ Firebase Config Sync
                    </h2>
                    <p className="text-sm text-slate-400 mb-4">
                        Non-sensitive CC data (config, deploy history, session log, rules history) is synced to Firebase RTDB at <code className="text-xs bg-slate-700 px-1.5 py-0.5 rounded">command-center/</code>. 
                        Secrets (GitHub PAT, Firebase SA key) stay in localStorage only.
                    </p>
                    
                    {/* Status row */}
                    <div className="grid grid-cols-1 sm:grid-cols-3 gap-3 mb-4">
                        <div className="bg-slate-700/50 rounded-lg p-3">
                            <div className="text-xs text-slate-400 mb-1">Status</div>
                            <div className="text-sm font-medium flex items-center gap-2">
                                {syncStatus === 'synced' && <><span className="text-green-400">☁️</span> Synced</>}
                                {syncStatus === 'syncing' && <><span className="text-yellow-400 animate-pulse">🔄</span> Syncing...</>}
                                {syncStatus === 'offline' && <><span className="text-slate-500">⚡</span> Offline</>}
                                {syncStatus === 'error' && <><span className="text-red-400">⚠️</span> Error</>}
                            </div>
                        </div>
                        <div className="bg-slate-700/50 rounded-lg p-3">
                            <div className="text-xs text-slate-400 mb-1">Firebase Data Size</div>
                            <div className="text-sm font-medium">
                                {loadingSize ? '...' : dataSize ? formatBytes(dataSize.totalBytes) : '—'}
                                {!loadingSize && dataSize && dataSize.totalBytes > 0 && (
                                    <button onClick={fetchDataSize} className="ml-2 text-xs text-slate-400 hover:text-slate-300">🔄</button>
                                )}
                            </div>
                        </div>
                        <div className="bg-slate-700/50 rounded-lg p-3">
                            <div className="text-xs text-slate-400 mb-1">Last Manual Sync</div>
                            <div className="text-sm font-medium">
                                {lastSyncTime ? new Date(lastSyncTime).toLocaleTimeString() : '—'}
                            </div>
                        </div>
                    </div>
                    
                    {/* Data breakdown */}
                    {dataSize && dataSize.keys && Object.keys(dataSize.keys).length > 0 && (
                        <div className="mb-4 bg-slate-700/30 rounded-lg p-3">
                            <div className="text-xs text-slate-400 mb-2">Data Breakdown</div>
                            <div className="grid grid-cols-2 sm:grid-cols-3 gap-2">
                                {Object.entries(dataSize.keys).sort((a, b) => b[1] - a[1]).map(([key, bytes]) => (
                                    <div key={key} className="flex justify-between items-center text-xs">
                                        <span className="text-slate-300">{key}</span>
                                        <span className="text-slate-500 ml-2">{formatBytes(bytes)}</span>
                                    </div>
                                ))}
                            </div>
                        </div>
                    )}
                    
                    {/* Action buttons */}
                    <div className="flex flex-wrap gap-2 mb-3">
                        <button 
                            onClick={handlePushAll}
                            disabled={!!syncAction || !FirebaseConfigSync.initialized}
                            className="px-4 py-2 bg-indigo-600 hover:bg-indigo-500 disabled:opacity-50 disabled:cursor-not-allowed rounded text-sm font-medium transition-colors">
                            {syncAction === 'pushing' ? '⏳ Pushing...' : '⬆️ Push All to Firebase'}
                        </button>
                        <button 
                            onClick={handlePullAll}
                            disabled={!!syncAction || !FirebaseConfigSync.initialized}
                            className="px-4 py-2 bg-emerald-700 hover:bg-emerald-600 disabled:opacity-50 disabled:cursor-not-allowed rounded text-sm font-medium transition-colors">
                            {syncAction === 'pulling' ? '⏳ Pulling...' : '⬇️ Pull All from Firebase'}
                        </button>
                        <button 
                            onClick={handleClearFirebase}
                            disabled={!!syncAction || !FirebaseConfigSync.initialized}
                            className="px-4 py-2 bg-red-900/50 text-red-400 border border-red-700 hover:bg-red-900 disabled:opacity-50 disabled:cursor-not-allowed rounded text-sm font-medium transition-colors">
                            {syncAction === 'clearing' ? '⏳ Clearing...' : '🗑️ Clear Firebase Data'}
                        </button>
                    </div>
                    
                    {!FirebaseConfigSync.initialized && (
                        <div className="text-sm text-amber-400 mb-3">⚠️ Firebase not initialized — sync features unavailable</div>
                    )}
                    
                    {/* Result feedback */}
                    {syncResult && (
                        <div className={`p-3 rounded-lg text-sm ${syncResult.ok ? 'bg-green-900/30 border border-green-700 text-green-400' : 'bg-red-900/30 border border-red-700 text-red-400'}`}>
                            {syncResult.ok ? '✓' : '✗'} {syncResult.msg}
                        </div>
                    )}
                </div>
                
                {/* AI Engines (v8.21.0) */}
                <div className="bg-slate-800 rounded-xl border border-slate-700 p-6">
                    <h2 className="text-lg font-semibold mb-4 flex items-center gap-2">
                        🤖 AI Engines
                    </h2>
                    <p className="text-sm text-slate-400 mb-4">
                        Engine profiles used for context budget calculations in Claude Prep. Set your default engine to match your primary Claude plan.
                    </p>
                    
                    {/* Default Engine Selector */}
                    <div className="mb-4">
                        <label className="text-xs text-slate-400 block mb-1.5">Default Engine</label>
                        <select 
                            value={EngineRegistryService.getDefault()}
                            onChange={e => { EngineRegistryService.setDefault(e.target.value); setSettings(prev => ({...prev, _engineRefresh: Date.now()})); }}
                            className="w-full sm:w-auto p-2 bg-slate-700 border border-slate-600 rounded text-sm"
                        >
                            {EngineRegistryService.getAll().map(e => (
                                <option key={e.id} value={e.id}>{e.name} — {TokenRegistryService.formatTokens(e.contextWindow)} context</option>
                            ))}
                        </select>
                    </div>
                    
                    {/* Engine Comparison Table */}
                    <div className="overflow-x-auto -mx-2 px-2">
                        <table className="w-full text-xs">
                            <thead>
                                <tr className="text-slate-500 border-b border-slate-700">
                                    <th className="text-left py-2 px-2 font-medium">Engine</th>
                                    <th className="text-center py-2 px-1 font-medium">Tier</th>
                                    <th className="text-right py-2 px-2 font-medium">Context</th>
                                    <th className="text-right py-2 px-2 font-medium">Extended</th>
                                    <th className="text-right py-2 px-2 font-medium">~$/Session</th>
                                    <th className="text-center py-2 px-1 font-medium">Projects</th>
                                    <th className="text-center py-2 px-1 font-medium">Skills</th>
                                </tr>
                            </thead>
                            <tbody>
                                {EngineRegistryService.getAll().map(engine => {
                                    const isDefault = engine.id === EngineRegistryService.getDefault();
                                    const tierColors = { fast: 'text-cyan-400 bg-cyan-900/30', balanced: 'text-blue-400 bg-blue-900/30', flagship: 'text-purple-400 bg-purple-900/30' };
                                    return (
                                        <tr key={engine.id} className={`border-b border-slate-800 ${isDefault ? 'bg-indigo-900/20' : 'hover:bg-slate-700/30'}`}>
                                            <td className="py-2 px-2">
                                                <div className="flex items-center gap-1.5">
                                                    {isDefault && <span className="text-indigo-400 text-[10px]">★</span>}
                                                    <span className={`font-medium ${isDefault ? 'text-indigo-300' : 'text-slate-300'}`}>{engine.name}</span>
                                                </div>
                                                <div className="text-[10px] text-slate-500 mt-0.5">{engine.strengths.slice(0, 2).join(', ')}</div>
                                            </td>
                                            <td className="py-2 px-1 text-center">
                                                <span className={`px-1.5 py-0.5 rounded text-[10px] font-medium ${tierColors[engine.tier] || 'text-slate-400'}`}>
                                                    {engine.tier}
                                                </span>
                                            </td>
                                            <td className="py-2 px-2 text-right text-slate-300 font-mono">{TokenRegistryService.formatTokens(engine.contextWindow)}</td>
                                            <td className="py-2 px-2 text-right font-mono">
                                                {engine.contextWindowExtended 
                                                    ? <span className="text-green-400">{TokenRegistryService.formatTokens(engine.contextWindowExtended)}</span>
                                                    : <span className="text-slate-600">—</span>
                                                }
                                            </td>
                                            <td className="py-2 px-2 text-right text-slate-400 font-mono" title={`$${engine.cost.input.toFixed(2)}/$${engine.cost.output.toFixed(2)} per MTok`}>
                                                ~${(EngineRegistryService.estimateSessionCost(50000, 10000, engine.id)?.totalCost || 0).toFixed(2)}
                                            </td>
                                            <td className="py-2 px-1 text-center">{engine.features.projects ? <span className="text-green-400">✓</span> : <span className="text-slate-600">—</span>}</td>
                                            <td className="py-2 px-1 text-center">{engine.features.skills ? <span className="text-green-400">✓</span> : <span className="text-slate-600">—</span>}</td>
                                        </tr>
                                    );
                                })}
                            </tbody>
                        </table>
                    </div>
                    
                    {/* Engine Details (expandable) */}
                    <details className="mt-3">
                        <summary className="text-xs text-slate-500 cursor-pointer hover:text-slate-300 select-none">Session type → engine recommendations</summary>
                        <div className="mt-2 grid grid-cols-2 sm:grid-cols-4 gap-2">
                            {SessionBriefGenerator.getAll().map(t => {
                                const engine = EngineRegistryService.get(t.suggestedEngine);
                                return (
                                    <div key={t.id} className="bg-slate-900 rounded px-2.5 py-1.5" title={t.description}>
                                        <div className="text-[10px] text-slate-500 uppercase flex items-center gap-1">{t.icon} {t.label}</div>
                                        <div className="text-xs text-slate-300">{engine?.name?.split(' ').pop()}</div>
                                    </div>
                                );
                            })}
                        </div>
                    </details>
                </div>
                
                <div className="bg-slate-800 rounded-xl border border-slate-700 p-6">
                    <h2 className="text-lg font-semibold mb-4">Options</h2>
                    <label className="flex items-center gap-3 p-3 bg-slate-700/50 rounded cursor-pointer">
                        <input type="checkbox" checked={settings.createTag} onChange={e => setSettings({ ...settings, createTag: e.target.checked })} />
                        <span>Create Git Tags</span>
                    </label>
                </div>
                
                <div className="bg-slate-800 rounded-xl border border-slate-700 p-6">
                    <h2 className="text-lg font-semibold mb-4">Reset</h2>
                    <div className="space-y-3">
                        <button onClick={() => { 
                            localStorage.removeItem('cc_apps_v6'); 
                            location.reload(); 
                        }}
                            className="px-4 py-2 bg-amber-900/50 text-amber-400 border border-amber-700 rounded mr-3">
                            Reset App Mappings
                        </button>
                        <button onClick={() => { localStorage.clear(); location.reload(); }}
                            className="px-4 py-2 bg-red-900/50 text-red-400 border border-red-700 rounded">
                            Clear All Data
                        </button>
                        <p className="text-xs text-slate-500 mt-2">
                            "Reset App Mappings" keeps your token but resets all app→repo mappings to defaults and re-runs auto-detection.
                        </p>
                    </div>
                </div>
                
                {/* Storage Management */}
                <div className="bg-slate-800 rounded-xl border border-slate-700 p-6">
                    <h2 className="text-lg font-semibold mb-4 flex items-center gap-2">
                        💾 Local Storage
                    </h2>
                    
                    {!storageDiag ? (
                        <button onClick={() => setStorageDiag(StorageManager.getDiagnostics())}
                            className="px-4 py-2 bg-slate-700 rounded hover:bg-slate-600 text-sm">
                            📊 Analyze Storage
                        </button>
                    ) : (
                        <div className="space-y-3">
                            {/* Usage bar */}
                            <div>
                                <div className="flex justify-between text-sm mb-1">
                                    <span>{storageDiag.totalFormatted} / {storageDiag.quotaFormatted}</span>
                                    <span className={storageDiag.percent > 80 ? 'text-red-400' : storageDiag.percent > 60 ? 'text-amber-400' : 'text-green-400'}>
                                        {storageDiag.percent}%
                                    </span>
                                </div>
                                <div className="w-full bg-slate-700 rounded-full h-3">
                                    <div className={`h-3 rounded-full transition-all ${
                                        storageDiag.percent > 80 ? 'bg-red-500' : storageDiag.percent > 60 ? 'bg-amber-500' : 'bg-green-500'
                                    }`} style={{ width: `${Math.min(storageDiag.percent, 100)}%` }} />
                                </div>
                            </div>
                            
                            {/* Breakdown */}
                            <div className="space-y-1 max-h-48 overflow-y-auto">
                                {storageDiag.entries.map(e => (
                                    <div key={e.key} className="flex items-center gap-2 text-xs">
                                        <span className={`w-2 h-2 rounded-full ${e.protected ? 'bg-blue-400' : 'bg-slate-500'}`} />
                                        <span className="flex-1 font-mono truncate text-slate-400">{e.key}</span>
                                        <span className="text-slate-500">{e.sizeFormatted}</span>
                                        <span className="text-slate-600 w-10 text-right">{e.percent}%</span>
                                    </div>
                                ))}
                            </div>
                            <div className="text-xs text-slate-500">
                                <span className="inline-flex items-center gap-1"><span className="w-2 h-2 rounded-full bg-blue-400 inline-block" /> Protected</span>
                                {' · '}
                                <span className="inline-flex items-center gap-1"><span className="w-2 h-2 rounded-full bg-slate-500 inline-block" /> Prunable</span>
                            </div>
                            
                            {/* Actions */}
                            <div className="flex gap-2 pt-2">
                                <button onClick={() => {
                                    const r = StorageManager.cleanup(false);
                                    setCleanupResult(r);
                                    setStorageDiag(StorageManager.getDiagnostics());
                                }} className="px-3 py-1.5 bg-amber-700 rounded hover:bg-amber-600 text-sm">
                                    🧹 Smart Cleanup
                                </button>
                                <button onClick={() => {
                                    const r = StorageManager.cleanup(true);
                                    setCleanupResult(r);
                                    setStorageDiag(StorageManager.getDiagnostics());
                                }} className="px-3 py-1.5 bg-red-700 rounded hover:bg-red-600 text-sm">
                                    🗑️ Aggressive Cleanup
                                </button>
                                <button onClick={() => { setStorageDiag(StorageManager.getDiagnostics()); setCleanupResult(null); }}
                                    className="px-3 py-1.5 bg-slate-700 rounded hover:bg-slate-600 text-sm">
                                    🔄 Refresh
                                </button>
                            </div>
                            
                            {cleanupResult && (
                                <div className="p-3 bg-slate-900 rounded text-xs space-y-1">
                                    <div className="text-green-400">Freed {StorageManager._formatBytes(cleanupResult.freed)}</div>
                                    {cleanupResult.actions.map((a, i) => (
                                        <div key={i} className="text-slate-400">
                                            {a.key}: {a.action} ({StorageManager._formatBytes(a.freed)})
                                        </div>
                                    ))}
                                    {cleanupResult.actions.length === 0 && (
                                        <div className="text-slate-500">Nothing to clean up</div>
                                    )}
                                </div>
                            )}
                        </div>
                    )}
                </div>
            </div>
        );
    }

    // =========================================================================
    // RENDER
    // =========================================================================
    
    try {
        ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    } catch (error) {
        document.getElementById('root').innerHTML = `<div style="padding:20px;background:#7f1d1d;margin:20px;border-radius:10px;">
            <h2>Error</h2><pre>${error.message}</pre>
            <button onclick="localStorage.clear();location.reload();" style="margin-top:10px;padding:10px;cursor:pointer;">Clear & Reload</button>
        </div>`;
    }
    </script>
</body>
</html>
